{
	"translatorID": "e7859c61-54d4-466a-b236-aadcf1f7e83b",
	"label": "Collected notes",
	"description": "exports your notes",
	"creator": "Emiliano heyns",
	"target": "html",
	"displayOptions": {
		"markdown": false
	},
	"minVersion": "4.0.27",
	"maxVersion": "",
	"translatorType": 2,
	"browserSupport": "gcsv",
	"inRepository": false,
	"configOptions": {
		"getCollections": true,
		"hash": "432bb6b8eddb48db6891127da87895785dde5170880f034eb9fd1f86c98d73e8"
	},
	"priority": 100,
	"lastUpdated": "2024-05-17"
}

ZOTERO_CONFIG = {"GUID":"zotero@chnm.gmu.edu","ID":"zotero","CLIENT_NAME":"Zotero","DOMAIN_NAME":"zotero.org","PRODUCER":"Digital Scholar","PRODUCER_URL":"https://digitalscholar.org","REPOSITORY_URL":"https://repo.zotero.org/repo/","BASE_URI":"http://zotero.org/","WWW_BASE_URL":"https://www.zotero.org/","PROXY_AUTH_URL":"https://zoteroproxycheck.s3.amazonaws.com/test","API_URL":"https://api.zotero.org/","STREAMING_URL":"wss://stream.zotero.org/","SERVICES_URL":"https://services.zotero.org/","API_VERSION":3,"CONNECTOR_MIN_VERSION":"5.0.39","PREF_BRANCH":"extensions.zotero.","BOOKMARKLET_ORIGIN":"https://www.zotero.org","BOOKMARKLET_URL":"https://www.zotero.org/bookmarklet/","START_URL":"https://www.zotero.org/start","QUICK_START_URL":"https://www.zotero.org/support/quick_start_guide","PDF_TOOLS_URL":"https://www.zotero.org/download/xpdf/","SUPPORT_URL":"https://www.zotero.org/support/","SYNC_INFO_URL":"https://www.zotero.org/support/sync","TROUBLESHOOTING_URL":"https://www.zotero.org/support/getting_help","FEEDBACK_URL":"https://forums.zotero.org/","CONNECTORS_URL":"https://www.zotero.org/download/connectors","CHANGELOG_URL":"https://www.zotero.org/support/changelog","CREDITS_URL":"https://www.zotero.org/support/credits_and_acknowledgments","LICENSING_URL":"https://www.zotero.org/support/licensing","GET_INVOLVED_URL":"https://www.zotero.org/getinvolved","DICTIONARIES_URL":"https://download.zotero.org/dictionaries/"}

        if (typeof ZOTERO_TRANSLATOR_INFO === 'undefined') var ZOTERO_TRANSLATOR_INFO = {}; // declare if not declared
        Object.assign(ZOTERO_TRANSLATOR_INFO, {"translatorID":"e7859c61-54d4-466a-b236-aadcf1f7e83b","label":"Collected notes","description":"exports your notes","creator":"Emiliano heyns","target":"html","displayOptions":{"markdown":false},"minVersion":"4.0.27","maxVersion":"","translatorType":2,"browserSupport":"gcsv","inRepository":false,"configOptions":{"getCollections":true},"priority":100}); // assign new data

var { doExport } = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/@stdlib/utils-define-property/lib/define_property.js
  var require_define_property = __commonJS({
    "node_modules/@stdlib/utils-define-property/lib/define_property.js"(exports, module) {
      var main = typeof Object.defineProperty === "function" ? Object.defineProperty : null;
      module.exports = main;
    }
  });

  // node_modules/@stdlib/utils-define-property/lib/has_define_property_support.js
  var require_has_define_property_support = __commonJS({
    "node_modules/@stdlib/utils-define-property/lib/has_define_property_support.js"(exports, module) {
      var defineProperty = require_define_property();
      function hasDefinePropertySupport() {
        try {
          defineProperty({}, "x", {});
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = hasDefinePropertySupport;
    }
  });

  // node_modules/@stdlib/utils-define-property/lib/builtin.js
  var require_builtin = __commonJS({
    "node_modules/@stdlib/utils-define-property/lib/builtin.js"(exports, module) {
      var defineProperty = Object.defineProperty;
      module.exports = defineProperty;
    }
  });

  // node_modules/@stdlib/string-base-format-interpolate/lib/is_number.js
  var require_is_number = __commonJS({
    "node_modules/@stdlib/string-base-format-interpolate/lib/is_number.js"(exports, module) {
      function isNumber2(value) {
        return typeof value === "number";
      }
      module.exports = isNumber2;
    }
  });

  // node_modules/@stdlib/string-base-format-interpolate/lib/zero_pad.js
  var require_zero_pad = __commonJS({
    "node_modules/@stdlib/string-base-format-interpolate/lib/zero_pad.js"(exports, module) {
      function startsWithMinus(str) {
        return str[0] === "-";
      }
      function zeros(n) {
        var out = "";
        var i;
        for (i = 0; i < n; i++) {
          out += "0";
        }
        return out;
      }
      function zeroPad(str, width, right) {
        var negative = false;
        var pad = width - str.length;
        if (pad < 0) {
          return str;
        }
        if (startsWithMinus(str)) {
          negative = true;
          str = str.substr(1);
        }
        str = right ? str + zeros(pad) : zeros(pad) + str;
        if (negative) {
          str = "-" + str;
        }
        return str;
      }
      module.exports = zeroPad;
    }
  });

  // node_modules/@stdlib/string-base-format-interpolate/lib/format_integer.js
  var require_format_integer = __commonJS({
    "node_modules/@stdlib/string-base-format-interpolate/lib/format_integer.js"(exports, module) {
      var isNumber2 = require_is_number();
      var zeroPad = require_zero_pad();
      var lowercase = String.prototype.toLowerCase;
      var uppercase = String.prototype.toUpperCase;
      function formatInteger(token) {
        var base;
        var out;
        var i;
        switch (token.specifier) {
          case "b":
            base = 2;
            break;
          case "o":
            base = 8;
            break;
          case "x":
          case "X":
            base = 16;
            break;
          case "d":
          case "i":
          case "u":
          default:
            base = 10;
            break;
        }
        out = token.arg;
        i = parseInt(out, 10);
        if (!isFinite(i)) {
          if (!isNumber2(out)) {
            throw new Error("invalid integer. Value: " + out);
          }
          i = 0;
        }
        if (i < 0 && (token.specifier === "u" || base !== 10)) {
          i = 4294967295 + i + 1;
        }
        if (i < 0) {
          out = (-i).toString(base);
          if (token.precision) {
            out = zeroPad(out, token.precision, token.padRight);
          }
          out = "-" + out;
        } else {
          out = i.toString(base);
          if (!i && !token.precision) {
            out = "";
          } else if (token.precision) {
            out = zeroPad(out, token.precision, token.padRight);
          }
          if (token.sign) {
            out = token.sign + out;
          }
        }
        if (base === 16) {
          if (token.alternate) {
            out = "0x" + out;
          }
          out = token.specifier === uppercase.call(token.specifier) ? uppercase.call(out) : lowercase.call(out);
        }
        if (base === 8) {
          if (token.alternate && out.charAt(0) !== "0") {
            out = "0" + out;
          }
        }
        return out;
      }
      module.exports = formatInteger;
    }
  });

  // node_modules/@stdlib/string-base-format-interpolate/lib/is_string.js
  var require_is_string = __commonJS({
    "node_modules/@stdlib/string-base-format-interpolate/lib/is_string.js"(exports, module) {
      function isString(value) {
        return typeof value === "string";
      }
      module.exports = isString;
    }
  });

  // node_modules/@stdlib/string-base-format-interpolate/lib/format_double.js
  var require_format_double = __commonJS({
    "node_modules/@stdlib/string-base-format-interpolate/lib/format_double.js"(exports, module) {
      var isNumber2 = require_is_number();
      var abs = Math.abs;
      var lowercase = String.prototype.toLowerCase;
      var uppercase = String.prototype.toUpperCase;
      var replace = String.prototype.replace;
      var RE_EXP_POS_DIGITS = /e\+(\d)$/;
      var RE_EXP_NEG_DIGITS = /e-(\d)$/;
      var RE_ONLY_DIGITS = /^(\d+)$/;
      var RE_DIGITS_BEFORE_EXP = /^(\d+)e/;
      var RE_TRAILING_PERIOD_ZERO = /\.0$/;
      var RE_PERIOD_ZERO_EXP = /\.0*e/;
      var RE_ZERO_BEFORE_EXP = /(\..*[^0])0*e/;
      function formatDouble(token) {
        var digits;
        var out;
        var f = parseFloat(token.arg);
        if (!isFinite(f)) {
          if (!isNumber2(token.arg)) {
            throw new Error("invalid floating-point number. Value: " + out);
          }
          f = token.arg;
        }
        switch (token.specifier) {
          case "e":
          case "E":
            out = f.toExponential(token.precision);
            break;
          case "f":
          case "F":
            out = f.toFixed(token.precision);
            break;
          case "g":
          case "G":
            if (abs(f) < 1e-4) {
              digits = token.precision;
              if (digits > 0) {
                digits -= 1;
              }
              out = f.toExponential(digits);
            } else {
              out = f.toPrecision(token.precision);
            }
            if (!token.alternate) {
              out = replace.call(out, RE_ZERO_BEFORE_EXP, "$1e");
              out = replace.call(out, RE_PERIOD_ZERO_EXP, "e");
              out = replace.call(out, RE_TRAILING_PERIOD_ZERO, "");
            }
            break;
          default:
            throw new Error("invalid double notation. Value: " + token.specifier);
        }
        out = replace.call(out, RE_EXP_POS_DIGITS, "e+0$1");
        out = replace.call(out, RE_EXP_NEG_DIGITS, "e-0$1");
        if (token.alternate) {
          out = replace.call(out, RE_ONLY_DIGITS, "$1.");
          out = replace.call(out, RE_DIGITS_BEFORE_EXP, "$1.e");
        }
        if (f >= 0 && token.sign) {
          out = token.sign + out;
        }
        out = token.specifier === uppercase.call(token.specifier) ? uppercase.call(out) : lowercase.call(out);
        return out;
      }
      module.exports = formatDouble;
    }
  });

  // node_modules/@stdlib/string-base-format-interpolate/lib/space_pad.js
  var require_space_pad = __commonJS({
    "node_modules/@stdlib/string-base-format-interpolate/lib/space_pad.js"(exports, module) {
      function spaces(n) {
        var out = "";
        var i;
        for (i = 0; i < n; i++) {
          out += " ";
        }
        return out;
      }
      function spacePad(str, width, right) {
        var pad = width - str.length;
        if (pad < 0) {
          return str;
        }
        str = right ? str + spaces(pad) : spaces(pad) + str;
        return str;
      }
      module.exports = spacePad;
    }
  });

  // node_modules/@stdlib/string-base-format-interpolate/lib/main.js
  var require_main = __commonJS({
    "node_modules/@stdlib/string-base-format-interpolate/lib/main.js"(exports, module) {
      var formatInteger = require_format_integer();
      var isString = require_is_string();
      var formatDouble = require_format_double();
      var spacePad = require_space_pad();
      var zeroPad = require_zero_pad();
      var fromCharCode = String.fromCharCode;
      var isnan = isNaN;
      var isArray = Array.isArray;
      function initialize(token) {
        var out = {};
        out.specifier = token.specifier;
        out.precision = token.precision === void 0 ? 1 : token.precision;
        out.width = token.width;
        out.flags = token.flags || "";
        out.mapping = token.mapping;
        return out;
      }
      function formatInterpolate(tokens) {
        var hasPeriod;
        var flags;
        var token;
        var flag;
        var num;
        var out;
        var pos;
        var i;
        var j;
        if (!isArray(tokens)) {
          throw new TypeError("invalid argument. First argument must be an array. Value: `" + tokens + "`.");
        }
        out = "";
        pos = 1;
        for (i = 0; i < tokens.length; i++) {
          token = tokens[i];
          if (isString(token)) {
            out += token;
          } else {
            hasPeriod = token.precision !== void 0;
            token = initialize(token);
            if (!token.specifier) {
              throw new TypeError("invalid argument. Token is missing `specifier` property. Index: `" + i + "`. Value: `" + token + "`.");
            }
            if (token.mapping) {
              pos = token.mapping;
            }
            flags = token.flags;
            for (j = 0; j < flags.length; j++) {
              flag = flags.charAt(j);
              switch (flag) {
                case " ":
                  token.sign = " ";
                  break;
                case "+":
                  token.sign = "+";
                  break;
                case "-":
                  token.padRight = true;
                  token.padZeros = false;
                  break;
                case "0":
                  token.padZeros = flags.indexOf("-") < 0;
                  break;
                case "#":
                  token.alternate = true;
                  break;
                default:
                  throw new Error("invalid flag: " + flag);
              }
            }
            if (token.width === "*") {
              token.width = parseInt(arguments[pos], 10);
              pos += 1;
              if (isnan(token.width)) {
                throw new TypeError("the argument for * width at position " + pos + " is not a number. Value: `" + token.width + "`.");
              }
              if (token.width < 0) {
                token.padRight = true;
                token.width = -token.width;
              }
            }
            if (hasPeriod) {
              if (token.precision === "*") {
                token.precision = parseInt(arguments[pos], 10);
                pos += 1;
                if (isnan(token.precision)) {
                  throw new TypeError("the argument for * precision at position " + pos + " is not a number. Value: `" + token.precision + "`.");
                }
                if (token.precision < 0) {
                  token.precision = 1;
                  hasPeriod = false;
                }
              }
            }
            token.arg = arguments[pos];
            switch (token.specifier) {
              case "b":
              case "o":
              case "x":
              case "X":
              case "d":
              case "i":
              case "u":
                if (hasPeriod) {
                  token.padZeros = false;
                }
                token.arg = formatInteger(token);
                break;
              case "s":
                token.maxWidth = hasPeriod ? token.precision : -1;
                break;
              case "c":
                if (!isnan(token.arg)) {
                  num = parseInt(token.arg, 10);
                  if (num < 0 || num > 127) {
                    throw new Error("invalid character code. Value: " + token.arg);
                  }
                  token.arg = isnan(num) ? String(token.arg) : fromCharCode(num);
                }
                break;
              case "e":
              case "E":
              case "f":
              case "F":
              case "g":
              case "G":
                if (!hasPeriod) {
                  token.precision = 6;
                }
                token.arg = formatDouble(token);
                break;
              default:
                throw new Error("invalid specifier: " + token.specifier);
            }
            if (token.maxWidth >= 0 && token.arg.length > token.maxWidth) {
              token.arg = token.arg.substring(0, token.maxWidth);
            }
            if (token.padZeros) {
              token.arg = zeroPad(token.arg, token.width || token.precision, token.padRight);
            } else if (token.width) {
              token.arg = spacePad(token.arg, token.width, token.padRight);
            }
            out += token.arg || "";
            pos += 1;
          }
        }
        return out;
      }
      module.exports = formatInterpolate;
    }
  });

  // node_modules/@stdlib/string-base-format-interpolate/lib/index.js
  var require_lib = __commonJS({
    "node_modules/@stdlib/string-base-format-interpolate/lib/index.js"(exports, module) {
      var main = require_main();
      module.exports = main;
    }
  });

  // node_modules/@stdlib/string-base-format-tokenize/lib/main.js
  var require_main2 = __commonJS({
    "node_modules/@stdlib/string-base-format-tokenize/lib/main.js"(exports, module) {
      var RE = /%(?:([1-9]\d*)\$)?([0 +\-#]*)(\*|\d+)?(?:(\.)(\*|\d+)?)?[hlL]?([%A-Za-z])/g;
      function parse(match) {
        var token = {
          "mapping": match[1] ? parseInt(match[1], 10) : void 0,
          "flags": match[2],
          "width": match[3],
          "precision": match[5],
          "specifier": match[6]
        };
        if (match[4] === "." && match[5] === void 0) {
          token.precision = "1";
        }
        return token;
      }
      function formatTokenize(str) {
        var content;
        var tokens;
        var match;
        var prev;
        tokens = [];
        prev = 0;
        match = RE.exec(str);
        while (match) {
          content = str.slice(prev, RE.lastIndex - match[0].length);
          if (content.length) {
            tokens.push(content);
          }
          tokens.push(parse(match));
          prev = RE.lastIndex;
          match = RE.exec(str);
        }
        content = str.slice(prev);
        if (content.length) {
          tokens.push(content);
        }
        return tokens;
      }
      module.exports = formatTokenize;
    }
  });

  // node_modules/@stdlib/string-base-format-tokenize/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/@stdlib/string-base-format-tokenize/lib/index.js"(exports, module) {
      var main = require_main2();
      module.exports = main;
    }
  });

  // node_modules/@stdlib/string-format/lib/is_string.js
  var require_is_string2 = __commonJS({
    "node_modules/@stdlib/string-format/lib/is_string.js"(exports, module) {
      function isString(value) {
        return typeof value === "string";
      }
      module.exports = isString;
    }
  });

  // node_modules/@stdlib/string-format/lib/main.js
  var require_main3 = __commonJS({
    "node_modules/@stdlib/string-format/lib/main.js"(exports, module) {
      var interpolate = require_lib();
      var tokenize = require_lib2();
      var isString = require_is_string2();
      function format(str) {
        var args;
        var i;
        if (!isString(str)) {
          throw new TypeError(format("invalid argument. First argument must be a string. Value: `%s`.", str));
        }
        args = [tokenize(str)];
        for (i = 1; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        return interpolate.apply(null, args);
      }
      module.exports = format;
    }
  });

  // node_modules/@stdlib/string-format/lib/index.js
  var require_lib3 = __commonJS({
    "node_modules/@stdlib/string-format/lib/index.js"(exports, module) {
      var main = require_main3();
      module.exports = main;
    }
  });

  // node_modules/@stdlib/utils-define-property/lib/polyfill.js
  var require_polyfill = __commonJS({
    "node_modules/@stdlib/utils-define-property/lib/polyfill.js"(exports, module) {
      var format = require_lib3();
      var objectProtoype = Object.prototype;
      var toStr = objectProtoype.toString;
      var defineGetter = objectProtoype.__defineGetter__;
      var defineSetter = objectProtoype.__defineSetter__;
      var lookupGetter = objectProtoype.__lookupGetter__;
      var lookupSetter = objectProtoype.__lookupSetter__;
      function defineProperty(obj, prop, descriptor) {
        var prototype;
        var hasValue;
        var hasGet;
        var hasSet;
        if (typeof obj !== "object" || obj === null || toStr.call(obj) === "[object Array]") {
          throw new TypeError(format("invalid argument. First argument must be an object. Value: `%s`.", obj));
        }
        if (typeof descriptor !== "object" || descriptor === null || toStr.call(descriptor) === "[object Array]") {
          throw new TypeError(format("invalid argument. Property descriptor must be an object. Value: `%s`.", descriptor));
        }
        hasValue = "value" in descriptor;
        if (hasValue) {
          if (lookupGetter.call(obj, prop) || lookupSetter.call(obj, prop)) {
            prototype = obj.__proto__;
            obj.__proto__ = objectProtoype;
            delete obj[prop];
            obj[prop] = descriptor.value;
            obj.__proto__ = prototype;
          } else {
            obj[prop] = descriptor.value;
          }
        }
        hasGet = "get" in descriptor;
        hasSet = "set" in descriptor;
        if (hasValue && (hasGet || hasSet)) {
          throw new Error("invalid argument. Cannot specify one or more accessors and a value or writable attribute in the property descriptor.");
        }
        if (hasGet && defineGetter) {
          defineGetter.call(obj, prop, descriptor.get);
        }
        if (hasSet && defineSetter) {
          defineSetter.call(obj, prop, descriptor.set);
        }
        return obj;
      }
      module.exports = defineProperty;
    }
  });

  // node_modules/@stdlib/utils-define-property/lib/index.js
  var require_lib4 = __commonJS({
    "node_modules/@stdlib/utils-define-property/lib/index.js"(exports, module) {
      var hasDefinePropertySupport = require_has_define_property_support();
      var builtin = require_builtin();
      var polyfill = require_polyfill();
      var defineProperty;
      if (hasDefinePropertySupport()) {
        defineProperty = builtin;
      } else {
        defineProperty = polyfill;
      }
      module.exports = defineProperty;
    }
  });

  // node_modules/@stdlib/utils-define-nonenumerable-read-only-property/lib/main.js
  var require_main4 = __commonJS({
    "node_modules/@stdlib/utils-define-nonenumerable-read-only-property/lib/main.js"(exports, module) {
      var defineProperty = require_lib4();
      function setNonEnumerableReadOnly(obj, prop, value) {
        defineProperty(obj, prop, {
          "configurable": false,
          "enumerable": false,
          "writable": false,
          "value": value
        });
      }
      module.exports = setNonEnumerableReadOnly;
    }
  });

  // node_modules/@stdlib/utils-define-nonenumerable-read-only-property/lib/index.js
  var require_lib5 = __commonJS({
    "node_modules/@stdlib/utils-define-nonenumerable-read-only-property/lib/index.js"(exports, module) {
      var main = require_main4();
      module.exports = main;
    }
  });

  // node_modules/@stdlib/assert-is-string/lib/primitive.js
  var require_primitive = __commonJS({
    "node_modules/@stdlib/assert-is-string/lib/primitive.js"(exports, module) {
      function isString(value) {
        return typeof value === "string";
      }
      module.exports = isString;
    }
  });

  // node_modules/@stdlib/assert-has-symbol-support/lib/main.js
  var require_main5 = __commonJS({
    "node_modules/@stdlib/assert-has-symbol-support/lib/main.js"(exports, module) {
      function hasSymbolSupport() {
        return typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
      }
      module.exports = hasSymbolSupport;
    }
  });

  // node_modules/@stdlib/assert-has-symbol-support/lib/index.js
  var require_lib6 = __commonJS({
    "node_modules/@stdlib/assert-has-symbol-support/lib/index.js"(exports, module) {
      var main = require_main5();
      module.exports = main;
    }
  });

  // node_modules/@stdlib/assert-has-tostringtag-support/lib/main.js
  var require_main6 = __commonJS({
    "node_modules/@stdlib/assert-has-tostringtag-support/lib/main.js"(exports, module) {
      var hasSymbols = require_lib6();
      var FLG = hasSymbols();
      function hasToStringTagSupport() {
        return FLG && typeof Symbol.toStringTag === "symbol";
      }
      module.exports = hasToStringTagSupport;
    }
  });

  // node_modules/@stdlib/assert-has-tostringtag-support/lib/index.js
  var require_lib7 = __commonJS({
    "node_modules/@stdlib/assert-has-tostringtag-support/lib/index.js"(exports, module) {
      var main = require_main6();
      module.exports = main;
    }
  });

  // node_modules/@stdlib/utils-native-class/lib/tostring.js
  var require_tostring = __commonJS({
    "node_modules/@stdlib/utils-native-class/lib/tostring.js"(exports, module) {
      var toStr = Object.prototype.toString;
      module.exports = toStr;
    }
  });

  // node_modules/@stdlib/utils-native-class/lib/main.js
  var require_main7 = __commonJS({
    "node_modules/@stdlib/utils-native-class/lib/main.js"(exports, module) {
      var toStr = require_tostring();
      function nativeClass(v) {
        return toStr.call(v);
      }
      module.exports = nativeClass;
    }
  });

  // node_modules/@stdlib/assert-has-own-property/lib/main.js
  var require_main8 = __commonJS({
    "node_modules/@stdlib/assert-has-own-property/lib/main.js"(exports, module) {
      var has = Object.prototype.hasOwnProperty;
      function hasOwnProp(value, property) {
        if (value === void 0 || value === null) {
          return false;
        }
        return has.call(value, property);
      }
      module.exports = hasOwnProp;
    }
  });

  // node_modules/@stdlib/assert-has-own-property/lib/index.js
  var require_lib8 = __commonJS({
    "node_modules/@stdlib/assert-has-own-property/lib/index.js"(exports, module) {
      var main = require_main8();
      module.exports = main;
    }
  });

  // node_modules/@stdlib/symbol-ctor/lib/main.js
  var require_main9 = __commonJS({
    "node_modules/@stdlib/symbol-ctor/lib/main.js"(exports, module) {
      var Sym = typeof Symbol === "function" ? Symbol : void 0;
      module.exports = Sym;
    }
  });

  // node_modules/@stdlib/symbol-ctor/lib/index.js
  var require_lib9 = __commonJS({
    "node_modules/@stdlib/symbol-ctor/lib/index.js"(exports, module) {
      var main = require_main9();
      module.exports = main;
    }
  });

  // node_modules/@stdlib/utils-native-class/lib/tostringtag.js
  var require_tostringtag = __commonJS({
    "node_modules/@stdlib/utils-native-class/lib/tostringtag.js"(exports, module) {
      var Symbol2 = require_lib9();
      var toStrTag = typeof Symbol2 === "function" ? Symbol2.toStringTag : "";
      module.exports = toStrTag;
    }
  });

  // node_modules/@stdlib/utils-native-class/lib/polyfill.js
  var require_polyfill2 = __commonJS({
    "node_modules/@stdlib/utils-native-class/lib/polyfill.js"(exports, module) {
      var hasOwnProp = require_lib8();
      var toStringTag = require_tostringtag();
      var toStr = require_tostring();
      function nativeClass(v) {
        var isOwn;
        var tag;
        var out;
        if (v === null || v === void 0) {
          return toStr.call(v);
        }
        tag = v[toStringTag];
        isOwn = hasOwnProp(v, toStringTag);
        try {
          v[toStringTag] = void 0;
        } catch (err) {
          return toStr.call(v);
        }
        out = toStr.call(v);
        if (isOwn) {
          v[toStringTag] = tag;
        } else {
          delete v[toStringTag];
        }
        return out;
      }
      module.exports = nativeClass;
    }
  });

  // node_modules/@stdlib/utils-native-class/lib/index.js
  var require_lib10 = __commonJS({
    "node_modules/@stdlib/utils-native-class/lib/index.js"(exports, module) {
      var hasToStringTag = require_lib7();
      var builtin = require_main7();
      var polyfill = require_polyfill2();
      var main;
      if (hasToStringTag()) {
        main = polyfill;
      } else {
        main = builtin;
      }
      module.exports = main;
    }
  });

  // node_modules/@stdlib/assert-is-string/lib/valueof.js
  var require_valueof = __commonJS({
    "node_modules/@stdlib/assert-is-string/lib/valueof.js"(exports, module) {
      var valueOf = String.prototype.valueOf;
      module.exports = valueOf;
    }
  });

  // node_modules/@stdlib/assert-is-string/lib/try2valueof.js
  var require_try2valueof = __commonJS({
    "node_modules/@stdlib/assert-is-string/lib/try2valueof.js"(exports, module) {
      var valueOf = require_valueof();
      function test(value) {
        try {
          valueOf.call(value);
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = test;
    }
  });

  // node_modules/@stdlib/assert-is-string/lib/object.js
  var require_object = __commonJS({
    "node_modules/@stdlib/assert-is-string/lib/object.js"(exports, module) {
      var hasToStringTag = require_lib7();
      var nativeClass = require_lib10();
      var test = require_try2valueof();
      var FLG = hasToStringTag();
      function isString(value) {
        if (typeof value === "object") {
          if (value instanceof String) {
            return true;
          }
          if (FLG) {
            return test(value);
          }
          return nativeClass(value) === "[object String]";
        }
        return false;
      }
      module.exports = isString;
    }
  });

  // node_modules/@stdlib/assert-is-string/lib/main.js
  var require_main10 = __commonJS({
    "node_modules/@stdlib/assert-is-string/lib/main.js"(exports, module) {
      var isPrimitive = require_primitive();
      var isObject = require_object();
      function isString(value) {
        return isPrimitive(value) || isObject(value);
      }
      module.exports = isString;
    }
  });

  // node_modules/@stdlib/assert-is-string/lib/index.js
  var require_lib11 = __commonJS({
    "node_modules/@stdlib/assert-is-string/lib/index.js"(exports, module) {
      var setReadOnly = require_lib5();
      var main = require_main10();
      var isPrimitive = require_primitive();
      var isObject = require_object();
      setReadOnly(main, "isPrimitive", isPrimitive);
      setReadOnly(main, "isObject", isObject);
      module.exports = main;
    }
  });

  // node_modules/@stdlib/utils-escape-regexp-string/lib/main.js
  var require_main11 = __commonJS({
    "node_modules/@stdlib/utils-escape-regexp-string/lib/main.js"(exports, module) {
      var isString = require_lib11().isPrimitive;
      var format = require_lib3();
      var RE_CHARS = /[-\/\\^$*+?.()|[\]{}]/g;
      function rescape2(str) {
        var len;
        var s;
        var i;
        if (!isString(str)) {
          throw new TypeError(format("invalid argument. Must provide a regular expression string. Value: `%s`.", str));
        }
        if (str[0] === "/") {
          len = str.length;
          for (i = len - 1; i >= 0; i--) {
            if (str[i] === "/") {
              break;
            }
          }
        }
        if (i === void 0 || i <= 0) {
          return str.replace(RE_CHARS, "\\$&");
        }
        s = str.substring(1, i);
        s = s.replace(RE_CHARS, "\\$&");
        str = str[0] + s + str.substring(i);
        return str;
      }
      module.exports = rescape2;
    }
  });

  // node_modules/@stdlib/utils-escape-regexp-string/lib/index.js
  var require_lib12 = __commonJS({
    "node_modules/@stdlib/utils-escape-regexp-string/lib/index.js"(exports, module) {
      var main = require_main11();
      module.exports = main;
    }
  });

  // node_modules/html-to-md/dist/index.js
  var require_dist = __commonJS({
    "node_modules/html-to-md/dist/index.js"(exports, module) {
      !function(t, e) {
        "object" === typeof exports && "object" === typeof module ? module.exports = e() : "function" === typeof define && define.amd ? define([], e) : "object" === typeof exports ? exports.html2md = e() : t.html2md = e();
      }(exports, function() {
        return function(t) {
          var e = {};
          function r(n) {
            if (e[n]) return e[n].exports;
            var o = e[n] = { i: n, l: false, exports: {} };
            return t[n].call(o.exports, o, o.exports, r), o.l = true, o.exports;
          }
          return r.m = t, r.c = e, r.d = function(t2, e2, n) {
            r.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: n });
          }, r.r = function(t2) {
            "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
          }, r.t = function(t2, e2) {
            if (1 & e2 && (t2 = r(t2)), 8 & e2) return t2;
            if (4 & e2 && "object" === typeof t2 && t2 && t2.__esModule) return t2;
            var n = /* @__PURE__ */ Object.create(null);
            if (r.r(n), Object.defineProperty(n, "default", { enumerable: true, value: t2 }), 2 & e2 && "string" != typeof t2) for (var o in t2) r.d(n, o, function(e3) {
              return t2[e3];
            }.bind(null, o));
            return n;
          }, r.n = function(t2) {
            var e2 = t2 && t2.__esModule ? function() {
              return t2.default;
            } : function() {
              return t2;
            };
            return r.d(e2, "a", e2), e2;
          }, r.o = function(t2, e2) {
            return Object.prototype.hasOwnProperty.call(t2, e2);
          }, r.p = "", r(r.s = 45);
        }([function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true });
          var n = r(1), o = r(12), i = r(6), a = r(7), c = r(2), u = function() {
            function t2(t3, e2, r2) {
              var o2 = void 0 === r2 ? {} : r2, i2 = o2.keepSpace, a2 = void 0 !== i2 && i2, c2 = o2.prevTagName, u2 = void 0 === c2 ? "" : c2, s = o2.nextTagName, p = void 0 === s ? "" : s, l = o2.prevTagStr, f = void 0 === l ? "" : l, h = o2.nextTagStr, d = void 0 === h ? "" : h, _ = o2.parentTag, y = void 0 === _ ? "" : _, v = o2.isFirstSubTag, g = void 0 === v || v, b = o2.calcLeading, O = void 0 !== b && b, m = o2.leadingSpace, S = void 0 === m ? "" : m, T = o2.layer, x = void 0 === T ? 1 : T, j = o2.noWrap, w = void 0 !== j && j, P = o2.prevHasEndSpace, M = void 0 !== P && P, E = o2.prevHasStartSpace, N = void 0 !== E && E, C = o2.match, L = void 0 === C ? null : C, k = o2.indentSpace, A = void 0 === k ? "" : k, H = o2.language, W = void 0 === H ? "" : H, V = o2.count, R = void 0 === V ? 1 : V, I = o2.tableColumnCount, D = void 0 === I ? 0 : I, U = o2.noExtraLine, B = void 0 !== U && U, q = o2.inTable, F = void 0 !== q && q;
              if (this.tagName = e2, this.rawStr = t3, this.parentTag = y, this.prevTagName = u2, this.nextTagName = p, this.prevTagStr = f, this.nextTagStr = d, this.isFirstSubTag = g, this.calcLeading = O, this.leadingSpace = S, this.layer = x, this.noWrap = w, this.match = L, this.indentSpace = A, this.language = W, this.count = R, this.inTable = F, this.tableColumnCount = D, this.noExtraLine = B, this.prevHasEndSpace = M, this.prevHasStartSpace = N, this.hasStartSpace = false, this.hasEndSpace = false, this.keepSpace = a2, !this.__detectStr__(t3, this.tagName)) return this.attrs = {}, void (this.innerHTML = "");
              var G = this.__fetchTagAttrAndInnerHTML__(t3), $2 = G.attr, J = G.innerHTML;
              J.startsWith(" ") && (0, n.isSpacePassingTag)(e2) && (this.hasStartSpace = true), J.endsWith(" ") && (0, n.isSpacePassingTag)(e2) && (this.hasEndSpace = true), this.attrs = $2, this.innerHTML = J;
            }
            return t2.prototype.__detectStr__ = function(t3, e2) {
              if ("<" !== t3[0]) return "Not a valid tag, current tag name: ".concat(this.tagName, ", tag content: ").concat(t3), false;
              for (var r2 = "", n2 = false, o2 = 1; o2 < t3.length && ">" !== t3[o2]; o2++) !n2 && /(\s|\/)/.test(t3[o2]) && (n2 = true), n2 || (r2 += t3[o2]);
              return r2 === e2;
            }, t2.prototype.__fetchTagAttrAndInnerHTML__ = function(t3) {
              for (var e2 = "", r2 = 1; r2 < t3.length && ">" !== t3[r2]; r2++) e2 += t3[r2];
              for (var o2 = t3.slice(r2 + 1), i2 = "", a2 = -1, c2 = o2.length - 1; c2 >= 0; c2--) if ((i2 = o2[c2] + i2).startsWith("</")) {
                i2.startsWith("</" + this.tagName + ">") && (a2 = c2);
                break;
              }
              -1 === a2 && (0, n.isSelfClosing)(this.tagName) && this.tagName;
              var u2 = (0, n.getTagAttributes)(e2);
              return this.tagName && delete u2[this.tagName], { attr: u2, innerHTML: o2.slice(0, a2) };
            }, t2.prototype.__onlyLeadingSpace__ = function(t3) {
              t3 = t3.trim();
              for (var e2 = 0; e2 < t3.length; e2++) if (t3[e2] !== i.SINGLE) return false;
              return true;
            }, t2.prototype.__isEmpty__ = function(t3) {
              return !this.keepSpace && ("" === t3 && "td" !== this.tagName || this.calcLeading && this.__onlyLeadingSpace__(t3));
            }, t2.prototype.getValidSubTagName = function(t3) {
              return t3;
            }, t2.prototype.beforeParse = function() {
              var t3 = c.default.get().tagListener;
              if (t3) {
                var e2 = t3(this.tagName, { parentTag: this.parentTag, prevTagName: this.prevTagName, nextTagName: this.nextTagName, isFirstSubTag: this.isFirstSubTag, attrs: this.attrs, innerHTML: this.innerHTML, language: this.language, match: this.match, isSelfClosing: false }), r2 = e2.attrs, n2 = e2.language, o2 = e2.match;
                this.attrs = r2, "string" === typeof n2 && (this.language = n2), "undefined" !== typeof o2 && (this.match = o2);
              }
              return "";
            }, t2.prototype.parseValidSubTag = function(t3, e2, r2) {
              var o2 = new ((0, n.getTagConstructor)(e2))(t3, e2, r2);
              return [o2.exec(), o2];
            }, t2.prototype.parseOnlyString = function(t3, e2, r2) {
              var n2 = new o.default(t3, e2, r2);
              return [n2.exec(), n2];
            }, t2.prototype.afterParsed = function(t3) {
              return t3;
            }, t2.prototype.slim = function(t3) {
              return this.keepSpace ? t3 : t3.trim();
            }, t2.prototype.beforeMergeSpace = function(t3) {
              return t3;
            }, t2.prototype.mergeSpace = function(t3, e2, r2) {
              return this.keepSpace && "pre" !== this.tagName ? t3.endsWith("\n") ? t3 : t3 + r2.replace(/\n+/g, "\n") : e2 + t3 + r2;
            }, t2.prototype.afterMergeSpace = function(t3) {
              return t3;
            }, t2.prototype.beforeReturn = function(t3) {
              return (0, n.isSpacePassingTag)(this.prevTagName) && (0, n.isSpacePassingTag)(this.tagName) && this.hasStartSpace && !/^\s+/.test(t3) && !/\s+$/.test(this.prevTagStr) ? " " + t3 : t3;
            }, t2.prototype.exec = function(t3, e2) {
              void 0 === t3 && (t3 = ""), void 0 === e2 && (e2 = "");
              for (var r2 = this.beforeParse(), o2 = (0, n.generateGetNextValidTag)(this.innerHTML), i2 = o2(), c2 = i2[0], u2 = i2[1], s = null, p = false, l = false; "" !== u2; ) {
                var f, h = o2(), d = h[0], _ = h[1], y = { parentTag: this.tagName, nextTagName: d, nextTagStr: _, prevTagName: s, prevTagStr: r2, prevHasEndSpace: l, prevHasStartSpace: p, leadingSpace: this.leadingSpace, layer: this.layer, keepSpace: this.keepSpace, inTable: this.inTable, calcLeading: ("li" === this.tagName || "ol" === this.tagName || "ul" === this.tagName) && this.calcLeading }, v = void 0, g = void 0;
                if (null != c2) v = (f = this.parseValidSubTag(u2, c2, y))[0], g = f[1];
                else v = (f = this.parseOnlyString(u2, c2, y))[0], g = f[1];
                l = (null === g || void 0 === g ? void 0 : g.hasEndSpace) || false, p = (null === g || void 0 === g ? void 0 : g.hasStartSpace) || false;
                var b = this.getValidSubTagName(c2);
                c2 = d, u2 = _, null == b && this.__isEmpty__(v) || (!this.keepSpace && (0, a.default)(s) && (0, a.default)(b) && (r2 = r2.replace(/\n+$/, "\n"), v = v.replace(/^\n+/, "\n")), s = b, this.isFirstSubTag = false, r2 += v);
              }
              return r2 = this.afterParsed(r2), r2 = this.slim(r2), this.__isEmpty__(r2) ? "" : (r2 = this.beforeMergeSpace(r2), !this.noExtraLine && (0, a.default)(this.tagName) && this.prevTagName && !r2.startsWith("\n") && !(0, a.default)(this.prevTagName) && this.parentTag && (t3 = "\n\n"), r2 = this.mergeSpace(r2, t3, e2), this.noWrap && !this.keepSpace && (r2 = r2.replace(/\s+/g, " ")), r2 = this.afterMergeSpace(r2), r2 = this.beforeReturn(r2));
            }, t2;
          }();
          e.default = u;
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.shouldRenderRawInside = e.isSpacePassingTag = e.isIndependentTag = e.clearComment = e.getLanguage = e.getTableAlign = e.getTagAttributes = e.isSelfClosing = e.generateGetNextValidTag = e.getTagConstructor = e.getRealTagName = e.unescapeStr = e.extraEscape = void 0;
          var n = r(46);
          Object.defineProperty(e, "extraEscape", { enumerable: true, get: function() {
            return n.extraEscape;
          } }), Object.defineProperty(e, "unescapeStr", { enumerable: true, get: function() {
            return n.unescapeStr;
          } });
          var o = r(47);
          e.generateGetNextValidTag = o.default;
          var i = r(48);
          e.getTagConstructor = i.default;
          var a = r(11);
          e.isSelfClosing = a.default;
          var c = r(51);
          e.getTagAttributes = c.default;
          var u = r(52);
          e.getLanguage = u.default;
          var s = r(53);
          e.clearComment = s.default;
          var p = r(13);
          e.getRealTagName = p.default;
          var l = r(7);
          e.isIndependentTag = l.default;
          var f = r(54);
          e.isSpacePassingTag = f.default;
          var h = r(55);
          e.getTableAlign = h.default;
          var d = r(56);
          e.shouldRenderRawInside = d.default;
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true });
          var n = function() {
            function t2(t3) {
              var e2 = void 0 === t3 ? {} : t3, r2 = e2.skipTags, n2 = void 0 === r2 ? [] : r2, o2 = e2.emptyTags, i2 = void 0 === o2 ? [] : o2, a = e2.ignoreTags, c = void 0 === a ? [] : a, u = e2.aliasTags, s = void 0 === u ? {} : u, p = e2.renderCustomTags, l = void 0 === p || p, f = e2.tagListener, h = void 0 === f ? function(t4, e3) {
                return e3;
              } : f;
              this.options = { skipTags: n2, emptyTags: i2, ignoreTags: c, aliasTags: s, renderCustomTags: l, tagListener: h };
            }
            return t2.prototype.get = function() {
              return this.options;
            }, t2.prototype.clear = function() {
              this.options = {};
            }, t2.prototype.set = function(t3, e2) {
              var r2 = this;
              t3 && "[object Object]" === Object.prototype.toString.call(t3) && Object.keys(t3).forEach(function(n2) {
                e2 ? r2.options[n2] = t3[n2] : function(t4, e3, r3) {
                  if (!(r3 in t4)) return void (t4[r3] = e3[r3]);
                  var n3 = Array.isArray(t4[r3]), o2 = "[object Object]" === Object.prototype.toString.call(t4[r3]);
                  t4[r3] = n3 ? t4[r3].concat(e3[r3]) : o2 ? Object.assign(t4[r3], e3[r3]) : e3[r3];
                }(r2.options, t3, n2);
              });
            }, t2.prototype.reset = function() {
              this.options = JSON.parse(JSON.stringify(o)), this.options.tagListener = function(t3, e2) {
                return e2;
              };
            }, t2;
          }();
          var o = { ignoreTags: ["", "style", "head", "!doctype", "form", "svg", "noscript", "script", "meta"], skipTags: ["div", "html", "body", "nav", "section", "footer", "main", "aside", "article", "header"], emptyTags: [], aliasTags: { figure: "p", dl: "p", dd: "p", dt: "p", figcaption: "p" }, renderCustomTags: true }, i = new n();
          i.reset(), e.default = i;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2) {
              void 0 === r2 && (r2 = "h1");
              var n2 = t2.call(this, e3, r2) || this;
              return n2.match = "#", n2;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function(t3) {
              return this.match + " " + t3;
            }, e2.prototype.exec = function(e3, r2) {
              return e3 || (e3 = "\n"), r2 || (r2 = "\n"), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(0).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true });
          var n = r(1), o = r(2), i = function() {
            function t2(t3, e2, r2) {
              var n2 = void 0 === r2 ? {} : r2, o2 = n2.parentTag, i2 = void 0 === o2 ? "" : o2, a = n2.leadingSpace, c = void 0 === a ? "" : a, u = n2.layer, s = void 0 === u ? 1 : u, p = n2.isFirstSubTag, l = void 0 !== p && p, f = n2.inTable, h = void 0 !== f && f, d = n2.match, _ = void 0 === d ? null : d, y = n2.prevTagName, v = void 0 === y ? "" : y, g = n2.nextTagName, b = void 0 === g ? "" : g;
              if (this.tagName = e2, this.rawStr = t3, this.parentTag = i2, this.isFirstSubTag = l, this.prevTagName = v, this.nextTagName = b, this.leadingSpace = c, this.layer = s, this.innerHTML = "", this.match = _, this.inTable = h, this.__detectStr__(t3, this.tagName)) {
                var O = this.__fetchTagAttr__(t3).attr;
                this.attrs = O;
              } else this.attrs = {};
            }
            return t2.prototype.__detectStr__ = function(t3, e2) {
              if ("<" !== t3[0]) return "Not a valid tag, current tag name: ".concat(this.tagName, ", tag content: ").concat(t3), false;
              for (var r2 = "", n2 = false, o2 = 1; o2 < t3.length && ">" !== t3[o2]; o2++) !n2 && /(\s|\/)/.test(t3[o2]) && (n2 = true), n2 || (r2 += t3[o2]);
              return r2 === e2;
            }, t2.prototype.__fetchTagAttr__ = function(t3) {
              for (var e2 = "", r2 = 1; r2 < t3.length && ">" !== t3[r2]; r2++) e2 += t3[r2];
              return { attr: (0, n.getTagAttributes)(e2) };
            }, t2.prototype.beforeParse = function() {
              var t3 = o.default.get().tagListener;
              if (t3) {
                var e2 = t3(this.tagName, { parentTag: this.parentTag, prevTagName: this.prevTagName, nextTagName: this.nextTagName, isFirstSubTag: this.isFirstSubTag, attrs: this.attrs, innerHTML: this.innerHTML, match: this.match, isSelfClosing: true }), r2 = e2.attrs, n2 = e2.match;
                this.attrs = r2, this.match = n2;
              }
              return "";
            }, t2.prototype.beforeMergeSpace = function(t3) {
              return t3;
            }, t2.prototype.afterMergeSpace = function(t3) {
              return t3;
            }, t2.prototype.beforeReturn = function(t3) {
              return t3;
            }, t2.prototype.exec = function(t3, e2) {
              void 0 === t3 && (t3 = ""), void 0 === e2 && (e2 = "");
              var r2 = this.beforeParse();
              return r2 = t3 + (r2 = this.beforeMergeSpace(r2)) + e2, r2 = this.afterMergeSpace(r2), r2 = this.beforeReturn(r2);
            }, t2;
          }();
          e.default = i;
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true });
          var n = function() {
            function t2() {
            }
            return t2.prototype.exec = function() {
              return "";
            }, t2;
          }();
          e.default = n;
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.TRIPLE = e.DOUBLE = e.SINGLE = void 0;
          e.SINGLE = "\u2608";
          e.DOUBLE = "\u2608\u2608";
          e.TRIPLE = "\u2608\u2608\u2608";
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true });
          var n = r(13), o = { html: true, body: true, p: true, div: true, pre: true, section: true, blockquote: true, aside: true, li: true, ul: true, ol: true, form: true, hr: true, h1: true, h2: true, h3: true, h4: true, h5: true, h6: true, dl: true, dd: true, dt: true, br: true, table: true };
          e.default = function(t2) {
            if (!t2) return false;
            var e2 = (0, n.default)(t2);
            return !!e2 && !!o[e2];
          };
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }(), o = this && this.__assign || function() {
            return (o = Object.assign || function(t2) {
              for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++) for (var o2 in e2 = arguments[r2]) Object.prototype.hasOwnProperty.call(e2, o2) && (t2[o2] = e2[o2]);
              return t2;
            }).apply(this, arguments);
          };
          Object.defineProperty(e, "__esModule", { value: true }), e.__EmptySelfClose__ = e.__Empty__ = void 0;
          var i = r(0), a = r(4), c = function(t2) {
            function e2(e3, r2, n2) {
              return void 0 === r2 && (r2 = "__empty__"), t2.call(this, e3, r2, n2) || this;
            }
            return n(e2, t2), e2.prototype.slim = function(t3) {
              return t3;
            }, e2.prototype.parseValidSubTag = function(r2, n2, i2) {
              if ("__skip__" === this.tagName) return t2.prototype.parseValidSubTag.call(this, r2, n2, i2);
              var a2 = new e2(r2, n2, o({}, i2));
              return [a2.exec(), a2];
            }, e2.prototype.parseOnlyString = function(e3, r2, n2) {
              return "__skip__" === this.tagName ? t2.prototype.parseOnlyString.call(this, e3, r2, n2) : [e3, null];
            }, e2.prototype.exec = function() {
              return t2.prototype.exec.call(this, "", "");
            }, e2;
          }(i.default);
          e.__Empty__ = c;
          var u = function(t2) {
            function e2(e3, r2) {
              void 0 === r2 && (r2 = "__emptyselfclose__");
              var n2 = t2.call(this, e3, r2) || this;
              return n2.tagName = r2, n2;
            }
            return n(e2, t2), e2.prototype.exec = function() {
              return t2.prototype.exec.call(this, "", "");
            }, e2;
          }(a.default);
          e.__EmptySelfClose__ = u;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true }), e.__SkipSelfClose__ = e.__Skip__ = void 0;
          var o = r(0), i = r(4), a = r(1), c = function(t2) {
            function e2(e3, r2, n2) {
              void 0 === r2 && (r2 = "__skip__");
              var o2 = t2.call(this, e3, r2, n2) || this;
              return o2.noNeedWrap = ["td", "th"], o2;
            }
            return n(e2, t2), e2.prototype.exec = function() {
              var e3 = (0, a.isIndependentTag)((0, a.getRealTagName)(this.tagName)) && (!this.parentTag || !this.noNeedWrap.includes(this.parentTag)), r2 = e3 ? "\n" : "", n2 = e3 ? "\n" : "";
              return t2.prototype.exec.call(this, r2, n2);
            }, e2;
          }(o.default);
          e.__Skip__ = c;
          var u = function(t2) {
            function e2(e3, r2, n2) {
              return void 0 === r2 && (r2 = "__skipselfclose__"), t2.call(this, e3, r2, n2) || this;
            }
            return n(e2, t2), e2.prototype.exec = function() {
              return "";
            }, e2;
          }(i.default);
          e.__SkipSelfClose__ = u;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true }), e.__NoMatchSelfClose__ = e.__NoMatch__ = void 0;
          var o = r(0), i = r(4), a = function(t2) {
            function e2(e3, r2) {
              return void 0 === r2 && (r2 = "__nomatch__"), t2.call(this, e3, r2) || this;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function(t3) {
              return "<".concat(this.tagName, ">").concat(t3, "</").concat(this.tagName, ">");
            }, e2.prototype.exec = function() {
              return t2.prototype.exec.call(this, "", "");
            }, e2;
          }(o.default);
          e.__NoMatch__ = a;
          var c = function(t2) {
            function e2(e3, r2) {
              return void 0 === r2 && (r2 = "__nomatchselfclose__"), t2.call(this, e3, r2) || this;
            }
            return n(e2, t2), e2.prototype.exec = function() {
              return "<".concat(this.tagName, " />");
            }, e2;
          }(i.default);
          e.__NoMatchSelfClose__ = c;
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true });
          var n = { img: true, hr: true, input: true, br: true, meta: true, link: true, "!doctype": true, base: true, col: true, area: true, param: true, object: true, embed: true, keygen: true, source: true };
          e.default = function(t2) {
            return null != t2 && !!n[t2.toLowerCase()];
          };
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true });
          var n = r(1), o = r(7), i = function() {
            function t2(t3, e2, r2) {
              void 0 === e2 && (e2 = "__nomatch__");
              var n2 = void 0 === r2 ? {} : r2, o2 = n2.keepSpace, i2 = void 0 !== o2 && o2, a = n2.prevTagName, c = void 0 === a ? "" : a, u = n2.nextTagName, s = void 0 === u ? "" : u, p = n2.prevTagStr, l = void 0 === p ? "" : p, f = n2.prevHasEndSpace, h = void 0 !== f && f, d = n2.prevHasStartSpace, _ = void 0 !== d && d, y = n2.parentTag, v = void 0 === y ? "" : y, g = n2.calcLeading, b = void 0 !== g && g, O = n2.layer, m = void 0 === O ? 1 : O, S = n2.leadingSpace, T = void 0 === S ? "" : S, x = n2.inTable, j = void 0 !== x && x;
              this.tagName = e2, this.nextTagName = s, this.prevTagName = c, this.parentTag = v, this.prevTagStr = l, this.keepSpace = i2, this.calcLeading = b, this.leadingSpace = T, this.layer = m, this.rawStr = t3, this.inTable = j, this.prevHasEndSpace = h, this.prevHasStartSpace = _, this.hasEndSpace = false, this.hasStartSpace = false, t3.startsWith(" ") && (this.hasStartSpace = true), t3.endsWith(" ") && (this.hasEndSpace = true);
            }
            return t2.prototype.slim = function(t3) {
              if (this.keepSpace) return t3;
              var e2 = t3.replace(/\s+/g, " ");
              return (0, o.default)(this.prevTagName) && (e2 = e2.trimLeft()), (0, o.default)(this.nextTagName) && (e2 = e2.trimRight()), e2;
            }, t2.prototype.beforeReturn = function(t3) {
              if (this.keepSpace) return t3;
              if (this.calcLeading) return this.leadingSpace + (0, n.extraEscape)(t3);
              var e2 = (0, n.extraEscape)(t3);
              return this.inTable && (e2 = e2.replace(/\|/g, "\\|")), this.prevTagName, this.prevHasEndSpace, this.prevTagStr, (0, n.isSpacePassingTag)(this.prevTagName) && this.prevHasEndSpace && !/^\s+/.test(t3) && !/\s+$/.test(this.prevTagStr) ? " " + t3 : e2;
            }, t2.prototype.exec = function() {
              var t3 = this.rawStr;
              return t3 = this.slim(t3), t3 = this.beforeReturn(t3);
            }, t2;
          }();
          e.default = i;
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true });
          var n = r(2);
          e.default = function(t2) {
            if (!t2) return t2;
            var e2 = n.default.get().aliasTags;
            return null != (null === e2 || void 0 === e2 ? void 0 : e2[t2]) ? e2[t2] : t2;
          };
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2, n2) {
              void 0 === r2 && (r2 = "strong");
              var o2 = t2.call(this, e3, r2, n2) || this;
              return o2.layer = 1, o2.match = o2.match || "**", o2;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function(t3) {
              return this.match + t3 + this.match;
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), null != this.match && this.prevTagStr && !this.prevTagStr.endsWith("\\" + this.match[0]) && this.prevTagStr.endsWith(this.match[0]) && (e3 = " "), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(0).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2) {
              void 0 === r2 && (r2 = "del");
              var n2 = t2.call(this, e3, r2) || this;
              return n2.match = n2.match || "~~", n2;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function(t3) {
              return this.match + t3 + this.match;
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(0).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2, n2) {
              void 0 === r2 && (r2 = "em");
              var o2 = t2.call(this, e3, r2, n2) || this;
              return o2.match = o2.match || "*", o2;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function(t3) {
              return this.match + t3 + this.match;
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), "strong" === this.parentTag && this.nextTagStr && (r2 = " "), null != this.match && this.prevTagStr && !this.prevTagStr.endsWith("\\" + this.match) && this.prevTagStr.endsWith(this.match) && (e3 = " "), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(0).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2, n2) {
              void 0 === r2 && (r2 = "th");
              var o2 = t2.call(this, e3, r2, n2) || this;
              return o2.tagName = r2, o2;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function(t3) {
              return t3 + "|";
            }, e2.prototype.parseValidSubTag = function(e3, r2, n2) {
              return "ul" === r2 || "ol" === r2 || "table" === r2 || "pre" === r2 ? [e3.replace(/([\n\r])/g, ""), null] : t2.prototype.parseValidSubTag.call(this, e3, r2, n2);
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(0).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2, n2) {
              return void 0 === r2 && (r2 = "a"), t2.call(this, e3, r2, n2) || this;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function(t3) {
              var e3 = this.attrs, r2 = e3.href, n2 = e3.title, o2 = r2 || "";
              return n2 ? "[".concat(t3, "](").concat(o2, ' "').concat(n2, '")') : "[".concat(t3, "](").concat(o2, ")");
            }, e2.prototype.parseOnlyString = function(e3, r2, n2) {
              return "tbody" === this.parentTag || "thead" === this.parentTag ? [e3, null] : t2.prototype.parseOnlyString.call(this, e3, r2, n2);
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(0).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2, n2) {
              return void 0 === r2 && (r2 = "b"), t2.call(this, e3, r2, n2) || this;
            }
            return n(e2, t2), e2.prototype.exec = function(e3, r2) {
              return t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(14).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }(), o = this && this.__assign || function() {
            return (o = Object.assign || function(t2) {
              for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++) for (var o2 in e2 = arguments[r2]) Object.prototype.hasOwnProperty.call(e2, o2) && (t2[o2] = e2[o2]);
              return t2;
            }).apply(this, arguments);
          };
          Object.defineProperty(e, "__esModule", { value: true });
          var i = r(7), a = r(0), c = r(1), u = function(t2) {
            function e2(e3, r2, n2) {
              void 0 === r2 && (r2 = "blockquote");
              var o2 = t2.call(this, e3, r2, n2) || this;
              return o2.match = o2.match || ">", o2.fillPerLine = o2.fillPerLine.bind(o2), o2;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function(t3) {
              if ("" === t3.trim()) return "";
              var e3 = this.match + " " + t3;
              return this.calcLeading ? this.leadingSpace + e3 : e3;
            }, e2.prototype.afterMergeSpace = function(t3) {
              for (var e3 = this, r2 = t3.split("\n"), n2 = r2.length - 1; n2 >= 0; n2--) n2 < r2.length - 1 && ">" === r2[n2].trim() && ">" === r2[n2 + 1].trim() && r2.splice(n2, 1);
              return (r2 = r2.map(function(t4) {
                return "" === t4 ? "" : e3.fillPerLine(t4);
              })).join("\n");
            }, e2.prototype.beforeReturn = function(t3) {
              return t3.replace("\n\n", "\n");
            }, e2.prototype.fillPerLine = function(t3) {
              var e3 = ">";
              if (this.calcLeading && (e3 = this.leadingSpace + ">"), !t3.startsWith(e3)) {
                var r2 = this.match + " " + t3;
                return this.calcLeading ? this.leadingSpace + r2 : r2;
              }
              return t3;
            }, e2.prototype.parseValidSubTag = function(t3, e3, r2) {
              var n2;
              "blockquote" === e3 ? n2 = new ((0, c.getTagConstructor)(e3))(t3, e3, o(o({}, r2), { calcLeading: this.calcLeading, match: this.match + ">", noExtraLine: true })) : n2 = new ((0, c.getTagConstructor)(e3))(t3, e3, o(o({}, r2), { noExtraLine: true }));
              var a2 = n2.exec(), u2 = "";
              this.calcLeading && (u2 = this.leadingSpace);
              var s = (0, i.default)(r2.prevTagName) && "br" !== r2.prevTagName, p = (0, i.default)(r2.nextTagName) && "br" !== r2.nextTagName, l = (0, i.default)(e3) && "br" !== e3;
              return this.isFirstSubTag ? [a2.trimLeft().replace(u2, ""), n2] : l ? (a2 = u2 + this.match + a2, s || (a2 = "\n" + a2), !p && r2.nextTagStr && r2.nextTagStr.trim() && (a2 += this.match + "\n"), [a2, n2]) : s ? [u2 + this.match + "\n" + a2, n2] : [a2, n2];
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(a.default);
          e.default = u;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2, n2) {
              return void 0 === r2 && (r2 = "b"), t2.call(this, e3, r2, n2) || this;
            }
            return n(e2, t2), e2.prototype.exec = function(t3, e3) {
              return void 0 === e3 && (e3 = "\n"), this.inTable ? "" : "  " + e3;
            }, e2;
          }(r(4).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }(), o = this && this.__assign || function() {
            return (o = Object.assign || function(t2) {
              for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++) for (var o2 in e2 = arguments[r2]) Object.prototype.hasOwnProperty.call(e2, o2) && (t2[o2] = e2[o2]);
              return t2;
            }).apply(this, arguments);
          };
          Object.defineProperty(e, "__esModule", { value: true });
          var i = r(0), a = r(1), c = function(t2) {
            function e2(e3, r2, n2) {
              void 0 === r2 && (r2 = "code");
              var o2 = t2.call(this, e3, r2, n2) || this;
              return o2.match = null == o2.match ? "`" : o2.match, o2.noWrap = "`" === o2.match, o2.layer = 1, o2;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function(t3) {
              var e3, r2;
              return "" !== this.match && "`" !== this.match ? (e3 = this.match + " ", r2 = " " + this.match) : (e3 = this.match, r2 = this.match), e3 + t3 + r2;
            }, e2.prototype.parseValidSubTag = function(t3, e3, r2) {
              var n2;
              return "pre" === e3 ? [(n2 = new ((0, a.getTagConstructor)(e3))(t3, e3, o(o({}, r2), { language: "", match: "" }))).exec("", "\n"), n2] : [(n2 = new ((0, a.getTagConstructor)(e3))(t3, e3, o(o({}, r2), { keepSpace: this.keepSpace, noWrap: this.noWrap }))).exec("", ""), n2];
            }, e2.prototype.parseOnlyString = function(t3) {
              if ("" !== this.match && t3) {
                var e3 = 1;
                (t3.startsWith("`") || t3.endsWith("`")) && (e3 = 2, (t3.startsWith("``") || t3.endsWith("``")) && (e3 = 3)), this.match = "`".repeat(e3);
              }
              return [(0, a.unescapeStr)(t3), null];
            }, e2.prototype.slim = function(t3) {
              return this.keepSpace ? t3 : t3.trim();
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(i.default);
          e.default = c;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2) {
              void 0 === r2 && (r2 = "h1");
              var n2 = t2.call(this, e3, r2) || this;
              return n2.match = "#", n2;
            }
            return n(e2, t2), e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(3).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2) {
              void 0 === r2 && (r2 = "h2");
              var n2 = t2.call(this, e3, r2) || this;
              return n2.match = "##", n2;
            }
            return n(e2, t2), e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(3).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2) {
              void 0 === r2 && (r2 = "h3");
              var n2 = t2.call(this, e3, r2) || this;
              return n2.match = "###", n2;
            }
            return n(e2, t2), e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(3).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2) {
              void 0 === r2 && (r2 = "h4");
              var n2 = t2.call(this, e3, r2) || this;
              return n2.match = "####", n2;
            }
            return n(e2, t2), e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(3).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2) {
              void 0 === r2 && (r2 = "h5");
              var n2 = t2.call(this, e3, r2) || this;
              return n2.match = "#####", n2;
            }
            return n(e2, t2), e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(3).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2) {
              void 0 === r2 && (r2 = "h6");
              var n2 = t2.call(this, e3, r2) || this;
              return n2.match = "######", n2;
            }
            return n(e2, t2), e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(3).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2, n2) {
              void 0 === r2 && (r2 = "hr");
              var o2 = t2.call(this, e3, r2, n2) || this;
              return o2.match = "---", o2;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function() {
              return this.leadingSpace + this.match;
            }, e2.prototype.beforeReturn = function(t3) {
              return t3.replace(/^(?:\n\s*)/, "\n\n").replace(/(?:\n\s*)$/, "\n\n"), t3;
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(4).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2, n2) {
              return void 0 === r2 && (r2 = "i"), t2.call(this, e3, r2, n2) || this;
            }
            return n(e2, t2), e2.prototype.exec = function(e3, r2) {
              return t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(16).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2, n2) {
              return void 0 === r2 && (r2 = "img"), t2.call(this, e3, r2, n2) || this;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function() {
              var t3 = this.attrs, e3 = t3.src, r2 = t3.alt;
              return r2 || (r2 = ""), e3 || (e3 = ""), "![".concat(r2, "](").concat(e3, ")");
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(4).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2, n2) {
              return void 0 === r2 && (r2 = "input"), t2.call(this, e3, r2, n2) || this;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function() {
              var t3 = this.attrs, e3 = t3.type, r2 = t3.checked;
              return "li" === this.parentTag && "checkbox" === e3 ? null != r2 ? "[x] " : "[ ] " : "";
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(4).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }(), o = this && this.__assign || function() {
            return (o = Object.assign || function(t2) {
              for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++) for (var o2 in e2 = arguments[r2]) Object.prototype.hasOwnProperty.call(e2, o2) && (t2[o2] = e2[o2]);
              return t2;
            }).apply(this, arguments);
          };
          Object.defineProperty(e, "__esModule", { value: true });
          var i = r(0), a = r(1), c = r(7), u = r(6), s = function(t2) {
            function e2(e3, r2, n2) {
              void 0 === r2 && (r2 = "li");
              var o2 = t2.call(this, e3, r2, n2) || this;
              return o2.match = o2.match || "*", o2.extraGap = "", o2;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function(t3) {
              return this.extraGap + this.leadingSpace + this.match + " " + t3;
            }, e2.prototype.__calcNextLeading__ = function() {
              var t3, e3, r2;
              return 1 === (null === (t3 = this.match) || void 0 === t3 ? void 0 : t3.length) ? u.DOUBLE : 2 === (null === (e3 = this.match) || void 0 === e3 ? void 0 : e3.length) ? u.TRIPLE : 3 === (null === (r2 = this.match) || void 0 === r2 ? void 0 : r2.length) ? u.DOUBLE : u.TRIPLE + u.DOUBLE;
            }, e2.prototype.parseValidSubTag = function(t3, e3, r2) {
              var n2 = (0, a.getTagConstructor)(e3), i2 = this.__calcNextLeading__(), c2 = new n2(t3, e3, o(o({}, r2), { calcLeading: true, leadingSpace: this.leadingSpace + i2, layer: this.layer + 1 })), u2 = c2.exec();
              return "p" === e3 && (this.extraGap = "\n"), this.isFirstSubTag ? [u2.trimLeft().replace(this.leadingSpace + i2, ""), c2] : [u2, c2];
            }, e2.prototype.parseOnlyString = function(e3, r2, n2) {
              var i2 = false;
              (0, c.default)(n2.prevTagName) && (i2 = true);
              var a2 = this.__calcNextLeading__(), u2 = t2.prototype.parseOnlyString.call(this, e3, r2, o(o({}, n2), { calcLeading: i2, leadingSpace: this.leadingSpace + a2, layer: this.layer + 1 })), s2 = u2[0], p = u2[1];
              return this.isFirstSubTag ? [s2.replace(this.leadingSpace + a2, ""), p] : [s2, p];
            }, e2.prototype.beforeReturn = function(e3) {
              return t2.prototype.beforeReturn.call(this, e3);
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(i.default);
          e.default = s;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }(), o = this && this.__assign || function() {
            return (o = Object.assign || function(t2) {
              for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++) for (var o2 in e2 = arguments[r2]) Object.prototype.hasOwnProperty.call(e2, o2) && (t2[o2] = e2[o2]);
              return t2;
            }).apply(this, arguments);
          };
          Object.defineProperty(e, "__esModule", { value: true });
          var i = r(0), a = r(5), c = r(1), u = r(2), s = function(t2) {
            function e2(e3, r2, n2) {
              void 0 === r2 && (r2 = "ol");
              var o2, i2 = this;
              i2 = t2.call(this, e3, r2, n2) || this;
              var a2 = parseInt(null === (o2 = null === i2 || void 0 === i2 ? void 0 : i2.attrs) || void 0 === o2 ? void 0 : o2.start, 10);
              return i2.count = isNaN(a2) ? 1 : a2, i2;
            }
            return n(e2, t2), e2.prototype.__isValidSubTag__ = function(t3) {
              if (!t3) return false;
              var e3 = u.default.get().aliasTags, r2 = (0, c.getTagConstructor)(t3);
              return "li" === t3 || "li" == (null === e3 || void 0 === e3 ? void 0 : e3[t3]) || r2 === a.default;
            }, e2.prototype.getValidSubTagName = function(t3) {
              return t3 && this.__isValidSubTag__(t3) ? t3 : null;
            }, e2.prototype.parseValidSubTag = function(t3, e3, r2) {
              var n2 = (0, c.getTagConstructor)(e3);
              if (this.__isValidSubTag__(e3)) {
                var i2 = this.count + ".", a2 = new n2(t3, e3, o(o({}, r2), { calcLeading: true, leadingSpace: this.leadingSpace, layer: this.layer, match: i2 }));
                return this.count++, [a2.exec("", "\n"), a2];
              }
              return ["", null];
            }, e2.prototype.parseOnlyString = function() {
              return ["", null];
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(i.default);
          e.default = s;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2, n2) {
              return void 0 === r2 && (r2 = "p"), t2.call(this, e3, r2, n2) || this;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function(t3) {
              return this.calcLeading ? this.leadingSpace + t3 : t3;
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), this.prevTagName || !this.prevTagStr || this.prevTagStr.endsWith("\n") || (e3 = "\n\n"), this.nextTagName || !this.nextTagStr || this.nextTagStr.startsWith("\n") || (r2 = "\n\n"), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(0).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }(), o = this && this.__assign || function() {
            return (o = Object.assign || function(t2) {
              for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++) for (var o2 in e2 = arguments[r2]) Object.prototype.hasOwnProperty.call(e2, o2) && (t2[o2] = e2[o2]);
              return t2;
            }).apply(this, arguments);
          };
          Object.defineProperty(e, "__esModule", { value: true });
          var i = r(0), a = r(8), c = r(1), u = r(6), s = function(t2) {
            function e2(e3, r2, n2) {
              void 0 === r2 && (r2 = "pre");
              var o2 = t2.call(this, e3, r2, n2) || this;
              return o2.indentSpace = u.DOUBLE + u.DOUBLE, o2.isIndent = o2.innerHTML.includes("```"), o2.match = o2.isIndent ? "" : "```", o2.language = o2.language || (0, c.getLanguage)(e3), o2.keepSpace = true, o2;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function(t3) {
              var e3 = this.isIndent || "code" === this.parentTag ? "" : this.match + this.language + "\n", r2 = "";
              return t3.endsWith("\n") || (r2 = "\n"), e3 + t3 + (this.isIndent || "code" === this.parentTag ? "" : r2 + this.match);
            }, e2.prototype.fillPerLine = function(t3) {
              var e3 = "";
              return this.calcLeading && (e3 = this.leadingSpace), this.isIndent ? e3 + this.indentSpace + t3 : e3 + t3;
            }, e2.prototype.afterMergeSpace = function(t3) {
              var e3 = this, r2 = t3.split("\n");
              return (r2 = r2.map(function(t4) {
                return "" === t4 ? "" : e3.fillPerLine(t4);
              })).join("\n");
            }, e2.prototype.parseValidSubTag = function(t3, e3, r2) {
              if ("code" === e3) {
                var n2 = new ((0, c.getTagConstructor)(e3))(t3, e3, o(o({}, r2), { match: "", language: this.language, keepSpace: true }));
                return [n2.exec("", ""), n2];
              }
              var i2 = void 0;
              return [(i2 = (0, c.isSelfClosing)(e3) ? new a.__EmptySelfClose__(t3, e3) : new a.__Empty__(t3, e3, o(o({}, r2), { keepSpace: true }))).exec(), i2];
            }, e2.prototype.parseOnlyString = function(t3) {
              return [t3, null];
            }, e2.prototype.slim = function(t3) {
              return t3;
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(i.default);
          e.default = s;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2) {
              return void 0 === r2 && (r2 = "s"), t2.call(this, e3, r2) || this;
            }
            return n(e2, t2), e2.prototype.exec = function(e3, r2) {
              return t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(15).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2, n2) {
              return void 0 === r2 && (r2 = "span"), t2.call(this, e3, r2, n2) || this;
            }
            return n(e2, t2), e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(0).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }(), o = this && this.__assign || function() {
            return (o = Object.assign || function(t2) {
              for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++) for (var o2 in e2 = arguments[r2]) Object.prototype.hasOwnProperty.call(e2, o2) && (t2[o2] = e2[o2]);
              return t2;
            }).apply(this, arguments);
          };
          Object.defineProperty(e, "__esModule", { value: true });
          var i = r(0), a = r(1);
          var c = function(t2) {
            function e2(e3, r2, n2) {
              void 0 === r2 && (r2 = "table");
              var o2 = t2.call(this, e3, r2, n2) || this;
              return o2.exist_thead = false, o2.exist_tbody = false, o2.empty_tbody = true, o2.tableColumnCount = function(t3) {
                for (var e4 = "", r3 = 0; r3 < t3.length && !e4.endsWith("</tr>"); r3++) e4 += t3[r3];
                return Math.max(e4.split("</td>").length - 1, e4.split("</th>").length - 1);
              }(o2.innerHTML), o2;
            }
            return n(e2, t2), e2.prototype.parseValidSubTag = function(t3, e3, r2) {
              "thead" === e3 && (this.exist_thead = true), "tbody" === e3 && (this.exist_tbody = true, this.empty_tbody = false), "tr" === e3 && (this.empty_tbody = false);
              var n2 = new ((0, a.getTagConstructor)(e3))(t3, e3, o(o({}, r2), { tableColumnCount: this.tableColumnCount, inTable: true }));
              return [n2.exec("", "\n"), n2];
            }, e2.prototype.parseOnlyString = function() {
              return ["", null];
            }, e2.prototype.beforeReturn = function(t3) {
              if (!this.exist_thead && !this.exist_tbody && this.empty_tbody) return "";
              if (0 === this.tableColumnCount) return "";
              if (!this.exist_tbody) {
                for (var e3 = (0, a.getTableAlign)(this.innerHTML, this.tableColumnCount), r2 = this.leadingSpace + "|", n2 = 0; n2 < e3.length; n2++) r2 += e3[n2];
                t3 = this.empty_tbody ? t3 + r2 + "\n" : r2 + "" + t3;
              }
              return this.exist_thead || (t3 = "\n" + this.leadingSpace + "|".repeat(this.tableColumnCount + 1) + (t3.startsWith("\n") ? "" : "\n") + t3), t3;
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(i.default);
          e.default = c;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = r(0), i = r(1), a = function(t2) {
            function e2(e3, r2, n2) {
              return void 0 === r2 && (r2 = "tbody"), t2.call(this, e3, r2, n2) || this;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function(t3) {
              for (var e3 = (0, i.getTableAlign)(this.innerHTML, this.tableColumnCount), r2 = this.leadingSpace + "|", n2 = 0; n2 < e3.length; n2++) r2 += e3[n2];
              return r2 + "\n" + t3;
            }, e2.prototype.parseOnlyString = function() {
              return ["", null];
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(o.default);
          e.default = a;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2, n2) {
              return void 0 === r2 && (r2 = "td"), t2.call(this, e3, r2, n2) || this;
            }
            return n(e2, t2), e2.prototype.parseValidSubTag = function(e3, r2, n2) {
              return "ul" === r2 || "ol" === r2 || "table" === r2 || "pre" === r2 ? [e3.replace(/([\n\r])/g, ""), null] : t2.prototype.parseValidSubTag.call(this, e3, r2, n2);
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(17).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function(t2) {
            function e2(e3, r2, n2) {
              return void 0 === r2 && (r2 = "thead"), t2.call(this, e3, r2, n2) || this;
            }
            return n(e2, t2), e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(r(0).default);
          e.default = o;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }();
          Object.defineProperty(e, "__esModule", { value: true });
          var o = r(0), i = r(5), a = r(1), c = r(2), u = function(t2) {
            function e2(e3, r2, n2) {
              return void 0 === r2 && (r2 = "tr"), t2.call(this, e3, r2, n2) || this;
            }
            return n(e2, t2), e2.prototype.beforeMergeSpace = function(t3) {
              return this.leadingSpace + "|" + t3;
            }, e2.prototype.parseValidSubTag = function(t3, e3, r2) {
              var n2 = c.default.get().aliasTags, o2 = (0, a.getTagConstructor)(e3);
              if ("td" !== e3 && "th" !== e3 && "td" !== (null === n2 || void 0 === n2 ? void 0 : n2[e3]) && "th" !== (null === n2 || void 0 === n2 ? void 0 : n2[e3]) && o2 !== i.default) return "Should not have tags except <td> or <th> inside <tr>, current tag is ".concat(e3, " have been ignore."), ["", null];
              var u2 = new o2(t3, e3, r2);
              return [u2.exec("", ""), u2];
            }, e2.prototype.parseOnlyString = function() {
              return ["", null];
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = "\n"), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(o.default);
          e.default = u;
        }, function(t, e, r) {
          "use strict";
          var n = this && this.__extends || /* @__PURE__ */ function() {
            var t2 = function(e2, r2) {
              return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
                t3.__proto__ = e3;
              } || function(t3, e3) {
                for (var r3 in e3) Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
              })(e2, r2);
            };
            return function(e2, r2) {
              if ("function" !== typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }(), o = this && this.__assign || function() {
            return (o = Object.assign || function(t2) {
              for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++) for (var o2 in e2 = arguments[r2]) Object.prototype.hasOwnProperty.call(e2, o2) && (t2[o2] = e2[o2]);
              return t2;
            }).apply(this, arguments);
          };
          Object.defineProperty(e, "__esModule", { value: true });
          var i = r(0), a = r(5), c = r(1), u = r(2).default.get().aliasTags, s = function(t2) {
            function e2(e3, r2, n2) {
              return void 0 === r2 && (r2 = "ul"), t2.call(this, e3, r2, n2) || this;
            }
            return n(e2, t2), e2.prototype.__isValidSubTag__ = function(t3) {
              if (!t3) return false;
              var e3 = (0, c.getTagConstructor)(t3);
              return "li" === t3 || "li" == (null === u || void 0 === u ? void 0 : u[t3]) || e3 === a.default;
            }, e2.prototype.getValidSubTagName = function(t3) {
              return t3 && this.__isValidSubTag__(t3) ? t3 : null;
            }, e2.prototype.parseValidSubTag = function(t3, e3, r2) {
              var n2 = (0, c.getTagConstructor)(e3);
              if (this.__isValidSubTag__(e3)) {
                var i2 = new n2(t3, e3, o(o({}, r2), { calcLeading: true, leadingSpace: this.leadingSpace, layer: this.layer, match: "*" }));
                return [i2.exec("", "\n"), i2];
              }
              return ["", null];
            }, e2.prototype.parseOnlyString = function() {
              return ["", null];
            }, e2.prototype.exec = function(e3, r2) {
              return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t2.prototype.exec.call(this, e3, r2);
            }, e2;
          }(i.default);
          e.default = s;
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true });
          var n = r(1), o = r(2), i = r(6);
          e.default = function(t2, e2, r2) {
            void 0 === r2 && (r2 = false), o.default.reset(), o.default.set(e2, r2), t2 = (t2 = (t2 = (0, n.clearComment)(t2)).trim()).replace(/(\r\n)/g, "").replace(/&nbsp;/g, " "), t2 = "<".concat(i.DOUBLE, "skip").concat(i.DOUBLE, ">").concat(t2, "</").concat(i.DOUBLE, "skip").concat(i.DOUBLE, ">");
            var a = "", c = "".concat(i.DOUBLE, "skip").concat(i.DOUBLE), u = t2;
            return a += new ((0, n.getTagConstructor)(c))(u, c, { parentTag: null, prevTagName: null, prevTagStr: a }).exec(), function(t3) {
              return t3 = (t3 = (t3 = t3.replace(/^\s+/, "")).replace(/\s+$/, "")).replace(/\u2608/g, " ");
            }((0, n.unescapeStr)(a));
          };
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.unescapeStr = e.extraEscape = void 0;
          var n = {}, o = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;", "`": "&#x60;", "\u201C": "&ldquo;", "\u201D": "&rdquo;" };
          for (var i in o) n[o[i]] = i;
          var a = /&(?:amp|lt|gt|quot|#39|#x60|ldquo|rdquo);/g, c = RegExp(a.source), u = [[/\\/g, "\\\\"], [/\*/g, "\\*"], [/^-/g, "\\-"], [/^\+ /g, "\\+ "], [/^(=+)/g, "\\$1"], [/^(#{1,6}) /g, "\\$1 "], [/`/g, "\\`"], [/^~~~/g, "\\~~~"], [/\[/g, "\\["], [/\]/g, "\\]"], [/^>/g, "\\>"], [/_/g, "\\_"], [/^(\d+)\. /g, "$1\\. "]];
          e.unescapeStr = function(t2) {
            return t2 = t2 && c.test(t2) ? t2.replace(a, function(t3) {
              return n[t3];
            }) : t2;
          }, e.extraEscape = function(t2) {
            return u.reduce(function(t3, e2) {
              return t3.replace(e2[0], e2[1]);
            }, t2);
          };
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true });
          var n = r(11);
          function o(t2, e2) {
            for (var r2 = ""; e2 < t2.length && /[a-zA-Z0-9!\-_]/.test(t2[e2]); ) r2 += t2[e2++];
            return r2.toLowerCase();
          }
          e.default = function(t2) {
            var e2 = 0;
            return function() {
              var r2 = "", i = null, a = 0, c = null, u = false;
              if (e2 >= t2.length) return [i, r2];
              for (var s = e2; s < t2.length; s++) {
                if ("<" === t2[s] && "/" !== t2[s + 1]) {
                  if ("" !== r2 && null == i && !u) return e2 = s, [i, r2];
                  var p = o(t2, s + 1);
                  null == i && (i = p), i === p && a++, (0, n.default)(i) && (0 === --a && (u = true), a < 0 && "Tag ".concat(i, " is abnormal"));
                } else if ("<" === t2[s] && "/" === t2[s + 1]) {
                  if (null == i) {
                    "Tag is not integrity, current tagStr is ".concat(t2.slice(e2));
                    for (var l = s; l < t2.length && ">" !== t2[l]; ) l++;
                    s = l;
                    continue;
                  }
                  i === (c = o(t2, s + 2)) && a--, a <= 0 && (u = true);
                }
                if (r2 += t2[s], ">" === t2[s] && u) return e2 = s + 1, [i, r2];
                s === t2.length - 1 && i !== c && (null != c && null != i && (r2 = r2.replace("<".concat(i, ">"), "").replace("</".concat(c, ">"), "")), i = null);
              }
              return e2 = t2.length, [i, r2];
            };
          };
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true });
          var n = r(2), o = r(6), i = r(11), a = r(49);
          e.default = function t2(e2) {
            var c, u = n.default.get(), s = u.skipTags, p = u.emptyTags, l = u.ignoreTags, f = u.aliasTags, h = u.renderCustomTags, d = (0, i.default)(e2);
            if ((null === s || void 0 === s ? void 0 : s.includes(e2)) || e2 === "".concat(o.DOUBLE, "skip").concat(o.DOUBLE)) {
              var _ = r(9);
              return d ? _.__SkipSelfClose__ : _.__Skip__;
            }
            if (null === p || void 0 === p ? void 0 : p.includes(e2)) {
              var y = r(8);
              return d ? y.__EmptySelfClose__ : y.__Empty__;
            }
            if (null === l || void 0 === l ? void 0 : l.includes(e2)) return r(5).default;
            if (null != (null === f || void 0 === f ? void 0 : f[e2])) return t2(f[e2]);
            var v = e2.toLowerCase();
            if (true !== h && !(0, a.default)(v)) {
              if (false === h || "SKIP" === h) return _ = r(9), d ? _.__SkipSelfClose__ : _.__Skip__;
              if ("EMPTY" === h) return y = r(8), d ? y.__EmptySelfClose__ : y.__Empty__;
              if ("IGNORE" === h) return r(5).default;
            }
            try {
              c = r(50)("./".concat(e2)).default;
            } catch (g) {
              c = d ? r(10).__NoMatchSelfClose__ : r(10).__NoMatch__;
            }
            return c;
          };
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true });
          var n = ["!doctype", "a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "circle", "cite", "clipPath", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "defs", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "ellipse", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "foreignObject", "form", "frame", "frameset", "g", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "line", "linearGradient", "link", "listing", "main", "map", "mark", "marquee", "mask", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "path", "pattern", "picture", "plaintext", "polygon", "polyline", "pre", "progress", "q", "radialGradient", "rb", "rbc", "rect", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "stop", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "text", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tspan", "tt", "u", "ul", "var", "video", "wbr", "xmp"];
          e.default = function(t2) {
            return "string" === typeof t2 && n.includes(t2.toLowerCase());
          };
        }, function(t, e, r) {
          var n = { "./__Heading__": 3, "./__Heading__.ts": 3, "./__empty__": 8, "./__empty__.ts": 8, "./__ignore__": 5, "./__ignore__.ts": 5, "./__nomatch__": 10, "./__nomatch__.ts": 10, "./__rawString__": 12, "./__rawString__.ts": 12, "./__skip__": 9, "./__skip__.ts": 9, "./a": 18, "./a.ts": 18, "./b": 19, "./b.ts": 19, "./blockquote": 20, "./blockquote.ts": 20, "./br": 21, "./br.ts": 21, "./code": 22, "./code.ts": 22, "./del": 15, "./del.ts": 15, "./em": 16, "./em.ts": 16, "./h1": 23, "./h1.ts": 23, "./h2": 24, "./h2.ts": 24, "./h3": 25, "./h3.ts": 25, "./h4": 26, "./h4.ts": 26, "./h5": 27, "./h5.ts": 27, "./h6": 28, "./h6.ts": 28, "./hr": 29, "./hr.ts": 29, "./i": 30, "./i.ts": 30, "./img": 31, "./img.ts": 31, "./input": 32, "./input.ts": 32, "./li": 33, "./li.ts": 33, "./ol": 34, "./ol.ts": 34, "./p": 35, "./p.ts": 35, "./pre": 36, "./pre.ts": 36, "./s": 37, "./s.ts": 37, "./span": 38, "./span.ts": 38, "./strong": 14, "./strong.ts": 14, "./table": 39, "./table.ts": 39, "./tbody": 40, "./tbody.ts": 40, "./td": 41, "./td.ts": 41, "./th": 17, "./th.ts": 17, "./thead": 42, "./thead.ts": 42, "./tr": 43, "./tr.ts": 43, "./ul": 44, "./ul.ts": 44 };
          function o(t2) {
            var e2 = i(t2);
            return r(e2);
          }
          function i(t2) {
            if (!r.o(n, t2)) {
              var e2 = new Error("Cannot find module '" + t2 + "'");
              throw e2.code = "MODULE_NOT_FOUND", e2;
            }
            return n[t2];
          }
          o.keys = function() {
            return Object.keys(n);
          }, o.resolve = i, t.exports = o, o.id = 50;
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.default = function(t2) {
            for (var e2 = {}, r2 = false, n = "", o = "", i = null, a = 0; a <= t2.length; a++) {
              if (a === t2.length || /\s/.test(t2[a])) {
                if (a === t2.length || !r2) {
                  var c = n.trim();
                  "/" === c[c.length - 1] && (c = c.slice(0, c.length - 1)), c && (e2[c] = o.trim()), n = "", o = "";
                }
              } else {
                if (/['"]/.test(t2[a]) && (!i || t2[a] === i)) {
                  (r2 = !r2) && (i = t2[a]);
                  continue;
                }
                if ("=" === t2[a] && !r2) continue;
              }
              if (a === t2.length) break;
              r2 ? o += t2[a] : n += t2[a];
            }
            return e2;
          };
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true });
          var n = "javascript";
          e.default = function(t2) {
            var e2 = t2.match(/<.*?class=".*?language-([^\s"]*)?.*".*>/);
            return e2 ? e2[1] || "" : t2.match(/<span.*?hljs-(comment|keyword|number|string|literal|built_in|function|title|bullet).*?<\/span>/) ? n : "";
          };
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.default = function(t2) {
            return t2.replace(/<!--(?:[\s\S]*?)-->/g, "");
          };
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true });
          var n = r(13), o = { b: true, a: true, del: true, em: true, i: true, s: true, span: true, strong: true };
          e.default = function(t2) {
            if (null === t2) return true;
            if (!t2) return false;
            var e2 = (0, n.default)(t2);
            return !!e2 && !!o[e2];
          };
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.default = function(t2, e2) {
            var r2 = { _default_: "---|", center: ":---:|", left: ":---|", right: "---:|", start: ":---|", end: "---:|" }, n = Array(e2).fill(r2._default_), o = t2.match(/<(td|th)(.*?)>/g);
            return o ? n = (n = o.slice(0, e2)).map(function(t3) {
              var e3 = t3.match(/align\s*=\s*['"]\s*(center|left|right|start|end)/), n2 = t3.match(/text-align\s*:\s*(center|left|right|start|end)/);
              return e3 || n2 ? e3 && !n2 ? r2[e3[1]] || r2._default_ : n2 ? r2[n2[1]] || r2._default_ : void 0 : r2._default_;
            }) : n;
          };
        }, function(t, e, r) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.default = ["th", "td"];
        }]).default;
      });
    }
  });

  // node_modules/fast-safe-stringify/index.js
  var require_fast_safe_stringify = __commonJS({
    "node_modules/fast-safe-stringify/index.js"(exports, module) {
      module.exports = stringify2;
      stringify2.default = stringify2;
      stringify2.stable = deterministicStringify;
      stringify2.stableStringify = deterministicStringify;
      var LIMIT_REPLACE_NODE = "[...]";
      var CIRCULAR_REPLACE_NODE = "[Circular]";
      var arr = [];
      var replacerStack = [];
      function defaultOptions() {
        return {
          depthLimit: Number.MAX_SAFE_INTEGER,
          edgesLimit: Number.MAX_SAFE_INTEGER
        };
      }
      function stringify2(obj, replacer, spacer, options2) {
        if (typeof options2 === "undefined") {
          options2 = defaultOptions();
        }
        decirc(obj, "", 0, [], void 0, 0, options2);
        var res;
        try {
          if (replacerStack.length === 0) {
            res = JSON.stringify(obj, replacer, spacer);
          } else {
            res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
          }
        } catch (_) {
          return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
        } finally {
          while (arr.length !== 0) {
            var part = arr.pop();
            if (part.length === 4) {
              Object.defineProperty(part[0], part[1], part[3]);
            } else {
              part[0][part[1]] = part[2];
            }
          }
        }
        return res;
      }
      function setReplace(replace, val, k, parent) {
        var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
        if (propertyDescriptor.get !== void 0) {
          if (propertyDescriptor.configurable) {
            Object.defineProperty(parent, k, { value: replace });
            arr.push([parent, k, val, propertyDescriptor]);
          } else {
            replacerStack.push([val, k, replace]);
          }
        } else {
          parent[k] = replace;
          arr.push([parent, k, val]);
        }
      }
      function decirc(val, k, edgeIndex, stack, parent, depth, options2) {
        depth += 1;
        var i;
        if (typeof val === "object" && val !== null) {
          for (i = 0; i < stack.length; i++) {
            if (stack[i] === val) {
              setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
              return;
            }
          }
          if (typeof options2.depthLimit !== "undefined" && depth > options2.depthLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
          }
          if (typeof options2.edgesLimit !== "undefined" && edgeIndex + 1 > options2.edgesLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
          }
          stack.push(val);
          if (Array.isArray(val)) {
            for (i = 0; i < val.length; i++) {
              decirc(val[i], i, i, stack, val, depth, options2);
            }
          } else {
            var keys = Object.keys(val);
            for (i = 0; i < keys.length; i++) {
              var key = keys[i];
              decirc(val[key], key, i, stack, val, depth, options2);
            }
          }
          stack.pop();
        }
      }
      function compareFunction(a, b) {
        if (a < b) {
          return -1;
        }
        if (a > b) {
          return 1;
        }
        return 0;
      }
      function deterministicStringify(obj, replacer, spacer, options2) {
        if (typeof options2 === "undefined") {
          options2 = defaultOptions();
        }
        var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options2) || obj;
        var res;
        try {
          if (replacerStack.length === 0) {
            res = JSON.stringify(tmp, replacer, spacer);
          } else {
            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
          }
        } catch (_) {
          return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
        } finally {
          while (arr.length !== 0) {
            var part = arr.pop();
            if (part.length === 4) {
              Object.defineProperty(part[0], part[1], part[3]);
            } else {
              part[0][part[1]] = part[2];
            }
          }
        }
        return res;
      }
      function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options2) {
        depth += 1;
        var i;
        if (typeof val === "object" && val !== null) {
          for (i = 0; i < stack.length; i++) {
            if (stack[i] === val) {
              setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
              return;
            }
          }
          try {
            if (typeof val.toJSON === "function") {
              return;
            }
          } catch (_) {
            return;
          }
          if (typeof options2.depthLimit !== "undefined" && depth > options2.depthLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
          }
          if (typeof options2.edgesLimit !== "undefined" && edgeIndex + 1 > options2.edgesLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
          }
          stack.push(val);
          if (Array.isArray(val)) {
            for (i = 0; i < val.length; i++) {
              deterministicDecirc(val[i], i, i, stack, val, depth, options2);
            }
          } else {
            var tmp = {};
            var keys = Object.keys(val).sort(compareFunction);
            for (i = 0; i < keys.length; i++) {
              var key = keys[i];
              deterministicDecirc(val[key], key, i, stack, val, depth, options2);
              tmp[key] = val[key];
            }
            if (typeof parent !== "undefined") {
              arr.push([parent, k, val]);
              parent[k] = tmp;
            } else {
              return tmp;
            }
          }
          stack.pop();
        }
      }
      function replaceGetterValues(replacer) {
        replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
          return v;
        };
        return function(key, val) {
          if (replacerStack.length > 0) {
            for (var i = 0; i < replacerStack.length; i++) {
              var part = replacerStack[i];
              if (part[1] === key && part[0] === val) {
                val = part[2];
                replacerStack.splice(i, 1);
                break;
              }
            }
          }
          return replacer.call(this, key, val);
        };
      }
    }
  });

  // node_modules/@unified-latex/unified-latex-util-print-raw/index.cjs
  var require_unified_latex_util_print_raw = __commonJS({
    "node_modules/@unified-latex/unified-latex-util-print-raw/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
      var linebreak = Symbol("linebreak");
      var ESCAPE = "\\";
      function _printRaw(node) {
        if (typeof node === "string") {
          return [node];
        }
        if (Array.isArray(node)) {
          return [].concat(
            ...node.map((n) => _printRaw(n))
          );
        }
        let argsString, escape;
        switch (node.type) {
          case "root":
            return _printRaw(node.content);
          case "argument":
            return [node.openMark, ..._printRaw(node.content), node.closeMark];
          case "comment":
            let suffix = node.suffixParbreak ? "" : linebreak;
            let leadingWhitespace = "";
            if (node.sameline && node.leadingWhitespace) {
              leadingWhitespace = " ";
            }
            if (node.sameline) {
              return [
                leadingWhitespace,
                "%",
                ..._printRaw(node.content),
                suffix
              ];
            }
            return [linebreak, "%", ..._printRaw(node.content), suffix];
          case "environment":
          case "mathenv":
          case "verbatim":
            let env = _printRaw(node.env);
            let envStart = [ESCAPE + "begin{", ...env, "}"];
            let envEnd = [ESCAPE + "end{", ...env, "}"];
            argsString = node.args == null ? [] : _printRaw(node.args);
            return [
              ...envStart,
              ...argsString,
              ..._printRaw(node.content),
              ...envEnd
            ];
          case "displaymath":
            return [ESCAPE + "[", ..._printRaw(node.content), ESCAPE + "]"];
          case "group":
            return ["{", ..._printRaw(node.content), "}"];
          case "inlinemath":
            return ["$", ..._printRaw(node.content), "$"];
          case "macro":
            argsString = node.args == null ? [] : _printRaw(node.args);
            escape = node.escapeToken == null ? ESCAPE : node.escapeToken;
            return [escape, ..._printRaw(node.content), ...argsString];
          case "parbreak":
            return [linebreak, linebreak];
          case "string":
            return [node.content];
          case "verb":
            return [
              ESCAPE,
              node.env,
              node.escape,
              ..._printRaw(node.content),
              node.escape
            ];
          case "whitespace":
            return [" "];
          default:
            console.warn(
              "Cannot find render for node ",
              node,
              `(of type ${typeof node})`
            );
            return ["" + node];
        }
      }
      function printRaw(node, options2) {
        const asArray = options2 != null ? options2.asArray : false;
        const printedTokens = _printRaw(node);
        if (asArray) {
          return printedTokens;
        }
        return printedTokens.map((x) => x === linebreak ? "\n" : x).join("");
      }
      exports.linebreak = linebreak;
      exports.printRaw = printRaw;
    }
  });

  // node_modules/@unified-latex/unified-latex-util-match/index.cjs
  var require_unified_latex_util_match = __commonJS({
    "node_modules/@unified-latex/unified-latex-util-match/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
      var unifiedLatexUtilPrintRaw = require_unified_latex_util_print_raw();
      function createMacroMatcher(macros) {
        const macrosHash = Array.isArray(macros) ? macros.length > 0 ? typeof macros[0] === "string" ? Object.fromEntries(
          macros.map((macro2) => {
            if (typeof macro2 !== "string") {
              throw new Error("Wrong branch of map function");
            }
            return [macro2, {}];
          })
        ) : Object.fromEntries(
          macros.map((macro2) => {
            if (typeof macro2 === "string") {
              throw new Error("Wrong branch of map function");
            }
            if (macro2.escapeToken != null) {
              return [
                macro2.content,
                { escapeToken: macro2.escapeToken }
              ];
            }
            return [macro2.content, {}];
          })
        ) : {} : macros;
        return function matchAgainstMacros(node) {
          if (node == null || node.type !== "macro") {
            return false;
          }
          const spec = macrosHash[node.content];
          if (!spec) {
            return false;
          }
          if (typeof spec === "object" && "escapeToken" in spec) {
            return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
          }
          return true;
        };
      }
      function createEnvironmentMatcher(macros) {
        const environmentsHash = Array.isArray(macros) ? Object.fromEntries(
          macros.map((str) => {
            return [str, {}];
          })
        ) : macros;
        return function matchAgainstEnvironments(node) {
          if (!match.anyEnvironment(node)) {
            return false;
          }
          const envName = unifiedLatexUtilPrintRaw.printRaw(node.env);
          const spec = environmentsHash[envName];
          if (!spec) {
            return false;
          }
          return true;
        };
      }
      var match = {
        macro(node, macroName) {
          if (node == null) {
            return false;
          }
          return node.type === "macro" && (macroName == null || node.content === macroName);
        },
        anyMacro(node) {
          return match.macro(node);
        },
        environment(node, envName) {
          if (node == null) {
            return false;
          }
          return (node.type === "environment" || node.type === "mathenv") && (envName == null || unifiedLatexUtilPrintRaw.printRaw(node.env) === envName);
        },
        anyEnvironment(node) {
          return match.environment(node);
        },
        comment(node) {
          if (node == null) {
            return false;
          }
          return node.type === "comment";
        },
        parbreak(node) {
          if (node == null) {
            return false;
          }
          return node.type === "parbreak";
        },
        whitespace(node) {
          if (node == null) {
            return false;
          }
          return node.type === "whitespace";
        },
        /**
         * Matches whitespace or a comment with leading whitespace.
         */
        whitespaceLike(node) {
          if (node == null) {
            return false;
          }
          return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
        },
        string(node, value) {
          if (node == null) {
            return false;
          }
          return node.type === "string" && (value == null || node.content === value);
        },
        anyString(node) {
          return match.string(node);
        },
        group(node) {
          if (node == null) {
            return false;
          }
          return node.type === "group";
        },
        argument(node) {
          if (node == null) {
            return false;
          }
          return node.type === "argument";
        },
        blankArgument(node) {
          if (!match.argument(node)) {
            return false;
          }
          return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
        },
        math(node) {
          if (node == null) {
            return false;
          }
          return node.type === "displaymath" || node.type === "inlinemath";
        },
        createMacroMatcher,
        createEnvironmentMatcher
      };
      var {
        anyEnvironment,
        anyMacro,
        anyString,
        argument,
        blankArgument,
        comment,
        environment,
        group,
        macro,
        math,
        parbreak,
        string,
        whitespace
      } = match;
      exports.anyEnvironment = anyEnvironment;
      exports.anyMacro = anyMacro;
      exports.anyString = anyString;
      exports.argument = argument;
      exports.blankArgument = blankArgument;
      exports.comment = comment;
      exports.environment = environment;
      exports.group = group;
      exports.macro = macro;
      exports.match = match;
      exports.math = math;
      exports.parbreak = parbreak;
      exports.string = string;
      exports.whitespace = whitespace;
    }
  });

  // node_modules/@unified-latex/unified-latex-util-visit/index.cjs
  var require_unified_latex_util_visit = __commonJS({
    "node_modules/@unified-latex/unified-latex-util-visit/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
      var unifiedLatexUtilMatch = require_unified_latex_util_match();
      function listMathChildren(node) {
        const NULL_RETURN = { enter: [], leave: [] };
        if (Array.isArray(node)) {
          return NULL_RETURN;
        }
        if (unifiedLatexUtilMatch.match.math(node)) {
          return { enter: ["content"], leave: [] };
        }
        const renderInfo = node._renderInfo || {};
        if (renderInfo.inMathMode == null) {
          return NULL_RETURN;
        }
        if (unifiedLatexUtilMatch.match.macro(node)) {
          if (renderInfo.inMathMode === true) {
            return { enter: ["args"], leave: [] };
          } else if (renderInfo.inMathMode === false) {
            return { enter: [], leave: ["args"] };
          }
        }
        if (unifiedLatexUtilMatch.match.environment(node)) {
          if (renderInfo.inMathMode === true) {
            return { enter: ["content"], leave: [] };
          } else {
            return { enter: [], leave: ["content"] };
          }
        }
        return NULL_RETURN;
      }
      var CONTINUE = Symbol("continue");
      var SKIP = Symbol("skip");
      var EXIT = Symbol("exit");
      var DEFAULT_CONTEXT = {
        inMathMode: false,
        hasMathModeAncestor: false
      };
      function visit(tree, visitor, options2) {
        const {
          startingContext = DEFAULT_CONTEXT,
          test = () => true,
          includeArrays = false
        } = options2 || {};
        let enter;
        let leave;
        if (typeof visitor === "function") {
          enter = visitor;
        } else if (visitor && typeof visitor === "object") {
          enter = visitor.enter;
          leave = visitor.leave;
        }
        walk(tree, {
          key: void 0,
          index: void 0,
          parents: [],
          containingArray: void 0,
          context: { ...startingContext }
        });
        function walk(node, { key, index, parents, context, containingArray }) {
          const nodePassesTest = includeArrays ? test(node, { key, index, parents, context, containingArray }) : !Array.isArray(node) && test(node, { key, index, parents, context, containingArray });
          const result = enter && nodePassesTest ? toResult(
            enter(node, {
              key,
              index,
              parents,
              context,
              containingArray
            })
          ) : [CONTINUE];
          if (result[0] === EXIT) {
            return result;
          }
          if (result[0] === SKIP) {
            return leave && nodePassesTest ? toResult(
              leave(node, {
                key,
                index,
                parents,
                context,
                containingArray
              })
            ) : result;
          }
          if (Array.isArray(node)) {
            for (let index2 = 0; index2 > -1 && index2 < node.length; index2++) {
              const item = node[index2];
              const result2 = walk(item, {
                key,
                index: index2,
                parents,
                context,
                containingArray: node
              });
              if (result2[0] === EXIT) {
                return result2;
              }
              if (typeof result2[1] === "number") {
                index2 = result2[1] - 1;
              }
            }
          } else {
            let childProps = ["content", "args"];
            switch (node.type) {
              case "macro":
                childProps = ["args"];
                break;
              case "comment":
              case "string":
              case "verb":
              case "verbatim":
                childProps = [];
                break;
            }
            const mathModeProps = listMathChildren(node);
            for (const key2 of childProps) {
              const value = node[key2];
              const grandparents = [node].concat(parents);
              if (value == null) {
                continue;
              }
              const newContext = { ...context };
              if (mathModeProps.enter.includes(key2)) {
                newContext.inMathMode = true;
                newContext.hasMathModeAncestor = true;
              } else if (mathModeProps.leave.includes(key2)) {
                newContext.inMathMode = false;
              }
              const result2 = walk(value, {
                key: key2,
                index: void 0,
                parents: grandparents,
                context: newContext,
                containingArray: void 0
              });
              if (result2[0] === EXIT) {
                return result2;
              }
            }
          }
          return leave && nodePassesTest ? toResult(
            leave(node, {
              key,
              index,
              parents,
              context,
              containingArray
            })
          ) : result;
        }
      }
      function toResult(value) {
        if (value == null) {
          return [CONTINUE];
        }
        if (Array.isArray(value)) {
          return value;
        }
        if (typeof value === "number") {
          return [CONTINUE, value];
        }
        return [value];
      }
      exports.CONTINUE = CONTINUE;
      exports.EXIT = EXIT;
      exports.SKIP = SKIP;
      exports.visit = visit;
    }
  });

  // node_modules/@unified-latex/unified-latex-util-trim/index.cjs
  var require_unified_latex_util_trim = __commonJS({
    "node_modules/@unified-latex/unified-latex-util-trim/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
      var unifiedLatexUtilMatch = require_unified_latex_util_match();
      var unifiedLatexUtilVisit = require_unified_latex_util_visit();
      function trim(nodes) {
        if (!Array.isArray(nodes)) {
          console.warn("Trying to trim a non-array ast", nodes);
          return nodes;
        }
        const { trimmedStart } = trimStart(nodes);
        const { trimmedEnd } = trimEnd(nodes);
        return { trimmedStart, trimmedEnd };
      }
      function trimStart(nodes) {
        const { start } = amountOfLeadingAndTrailingWhitespace(nodes);
        nodes.splice(0, start);
        for (const leadingToken of nodes) {
          if (!unifiedLatexUtilMatch.match.comment(leadingToken)) {
            break;
          }
          if (leadingToken.leadingWhitespace || leadingToken.sameline) {
            leadingToken.leadingWhitespace = false;
          }
          if (start > 0 && leadingToken.sameline) {
            leadingToken.sameline = false;
          }
        }
        return { trimmedStart: start };
      }
      function trimEnd(nodes) {
        const { end } = amountOfLeadingAndTrailingWhitespace(nodes);
        nodes.splice(nodes.length - end, end);
        for (let i = nodes.length - 1; i >= 0; i--) {
          const trailingToken = nodes[i];
          if (!unifiedLatexUtilMatch.match.comment(trailingToken)) {
            break;
          }
          delete trailingToken.suffixParbreak;
          if (unifiedLatexUtilMatch.match.comment(trailingToken) && trailingToken.leadingWhitespace && !trailingToken.sameline) {
            trailingToken.leadingWhitespace = false;
          }
        }
        return { trimmedEnd: end };
      }
      function amountOfLeadingAndTrailingWhitespace(ast) {
        let start = 0;
        let end = 0;
        for (const node of ast) {
          if (unifiedLatexUtilMatch.match.whitespace(node) || unifiedLatexUtilMatch.match.parbreak(node)) {
            start++;
          } else {
            break;
          }
        }
        if (start === ast.length) {
          return { start, end: 0 };
        }
        for (let i = ast.length - 1; i >= 0; i--) {
          const node = ast[i];
          if (unifiedLatexUtilMatch.match.whitespace(node) || unifiedLatexUtilMatch.match.parbreak(node)) {
            end++;
          } else {
            break;
          }
        }
        return { start, end };
      }
      var unifiedLatexTrimEnvironmentContents = function unifiedLatexTrimEnvironmentContents2() {
        return (tree) => {
          unifiedLatexUtilVisit.visit(tree, (node) => {
            if (!(unifiedLatexUtilMatch.match.math(node) || unifiedLatexUtilMatch.match.anyEnvironment(node))) {
              return;
            }
            let firstNode = node.content[0];
            if (unifiedLatexUtilMatch.match.comment(firstNode) && firstNode.sameline) {
              firstNode.suffixParbreak = false;
              trimEnd(node.content);
              const { trimmedStart } = trimStart(node.content.slice(1));
              node.content.splice(1, trimmedStart);
            } else {
              trim(node.content);
            }
          });
        };
      };
      var unifiedLatexTrimRoot = function unifiedLatexTrimRoot2() {
        return (tree) => {
          trim(tree.content);
        };
      };
      function hasWhitespaceEquivalent(nodes) {
        let start = false;
        let end = false;
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (unifiedLatexUtilMatch.match.comment(node)) {
            if (node.leadingWhitespace) {
              start = true;
              break;
            }
            continue;
          }
          if (unifiedLatexUtilMatch.match.whitespace(node)) {
            start = true;
          }
          break;
        }
        for (let j = nodes.length - 1; j >= 0; j--) {
          const node = nodes[j];
          if (unifiedLatexUtilMatch.match.comment(node)) {
            if (node.leadingWhitespace) {
              end = true;
              break;
            }
            continue;
          }
          if (unifiedLatexUtilMatch.match.whitespace(node)) {
            end = true;
          }
          break;
        }
        return { start, end };
      }
      exports.hasWhitespaceEquivalent = hasWhitespaceEquivalent;
      exports.trim = trim;
      exports.trimEnd = trimEnd;
      exports.trimStart = trimStart;
      exports.unifiedLatexTrimEnvironmentContents = unifiedLatexTrimEnvironmentContents;
      exports.unifiedLatexTrimRoot = unifiedLatexTrimRoot;
    }
  });

  // node_modules/@unified-latex/unified-latex-util-split/index.cjs
  var require_unified_latex_util_split = __commonJS({
    "node_modules/@unified-latex/unified-latex-util-split/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
      var unifiedLatexUtilMatch = require_unified_latex_util_match();
      function splitOnCondition(nodes, splitFunc = () => false, options2) {
        if (!Array.isArray(nodes)) {
          throw new Error(`Can only split an Array, not ${nodes}`);
        }
        const { onlySplitOnFirstOccurrence = false } = options2 || {};
        const splitIndices = [];
        for (let i = 0; i < nodes.length; i++) {
          if (splitFunc(nodes[i])) {
            splitIndices.push(i);
            if (onlySplitOnFirstOccurrence) {
              break;
            }
          }
        }
        if (splitIndices.length === 0) {
          return { segments: [nodes], separators: [] };
        }
        let separators = splitIndices.map((i) => nodes[i]);
        let segments = splitIndices.map((splitEnd, i) => {
          const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;
          return nodes.slice(splitStart, splitEnd);
        });
        segments.push(
          nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length)
        );
        return { segments, separators };
      }
      function splitOnMacro(ast, macroName) {
        if (typeof macroName === "string") {
          macroName = [macroName];
        }
        if (!Array.isArray(macroName)) {
          throw new Error("Type coercion failed");
        }
        const isSeparator = unifiedLatexUtilMatch.match.createMacroMatcher(macroName);
        const { segments, separators } = splitOnCondition(ast, isSeparator);
        return { segments, macros: separators };
      }
      function unsplitOnMacro({
        segments,
        macros
      }) {
        if (segments.length === 0) {
          console.warn("Trying to join zero segments");
          return [];
        }
        if (segments.length !== macros.length + 1) {
          console.warn(
            "Mismatch between lengths of macros and segments when trying to unsplit"
          );
        }
        let ret = segments[0];
        for (let i = 0; i < macros.length; i++) {
          ret = ret.concat(macros[i]).concat(segments[i + 1]);
        }
        return ret;
      }
      function arrayJoin(array, sep) {
        return array.flatMap((item, i) => {
          if (i === 0) {
            return item;
          }
          if (Array.isArray(sep)) {
            return [...sep, ...item];
          } else {
            return [sep, ...item];
          }
        });
      }
      exports.arrayJoin = arrayJoin;
      exports.splitOnCondition = splitOnCondition;
      exports.splitOnMacro = splitOnMacro;
      exports.unsplitOnMacro = unsplitOnMacro;
    }
  });

  // node_modules/@unified-latex/unified-latex-util-replace/index.cjs
  var require_unified_latex_util_replace = __commonJS({
    "node_modules/@unified-latex/unified-latex-util-replace/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
      var unifiedLatexUtilVisit = require_unified_latex_util_visit();
      var unifiedLatexUtilMatch = require_unified_latex_util_match();
      var unifiedLatexUtilTrim = require_unified_latex_util_trim();
      var unifiedLatexUtilSplit = require_unified_latex_util_split();
      function replaceNode(ast, visitor) {
        unifiedLatexUtilVisit.visit(ast, {
          leave: (node, info) => {
            let replacement = visitor(node, info);
            if (typeof replacement === "undefined" || replacement === node) {
              return;
            }
            if (!info.containingArray || info.index == null) {
              throw new Error(
                "Trying to replace node, but cannot find containing array"
              );
            }
            if (replacement === null || Array.isArray(replacement) && replacement.length === 0) {
              info.containingArray.splice(info.index, 1);
              return info.index;
            }
            if (!Array.isArray(replacement)) {
              replacement = [replacement];
            }
            info.containingArray.splice(info.index, 1, ...replacement);
            return info.index + replacement.length;
          }
        });
      }
      function firstSignificantNode(nodes, parbreaksAreInsignificant) {
        const index = firstSignificantNodeIndex(nodes, parbreaksAreInsignificant);
        if (index == null) {
          return null;
        }
        return nodes[index];
      }
      function lastSignificantNode(nodes, parbreaksAreInsignificant) {
        const index = lastSignificantNodeIndex(nodes, parbreaksAreInsignificant);
        if (index == null) {
          return null;
        }
        return nodes[index];
      }
      function lastSignificantNodeIndex(nodes, parbreaksAreInsignificant) {
        for (let i = nodes.length - 1; i >= 0; i--) {
          const node = nodes[i];
          if (unifiedLatexUtilMatch.match.whitespace(node) || unifiedLatexUtilMatch.match.comment(node) || parbreaksAreInsignificant && unifiedLatexUtilMatch.match.parbreak(node)) {
            continue;
          }
          return i;
        }
        return void 0;
      }
      function firstSignificantNodeIndex(nodes, parbreaksAreInsignificant) {
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (unifiedLatexUtilMatch.match.whitespace(node) || unifiedLatexUtilMatch.match.comment(node) || parbreaksAreInsignificant && unifiedLatexUtilMatch.match.parbreak(node)) {
            continue;
          }
          return i;
        }
        return void 0;
      }
      function isSpaceLike(node) {
        return unifiedLatexUtilMatch.match.whitespace(node) || unifiedLatexUtilMatch.match.comment(node) && Boolean(node.leadingWhitespace);
      }
      function joinWithoutExcessWhitespace(head, tail) {
        if (tail.length === 0) {
          return;
        }
        if (head.length === 0) {
          head.push(...tail);
          return;
        }
        const headEnd = head[head.length - 1];
        const tailStart = tail[0];
        if (unifiedLatexUtilMatch.match.whitespace(headEnd) && unifiedLatexUtilMatch.match.whitespace(tailStart)) {
          head.push(...tail.slice(1));
          return;
        }
        if (!isSpaceLike(headEnd) || !isSpaceLike(tailStart)) {
          if (unifiedLatexUtilMatch.match.whitespace(headEnd) && unifiedLatexUtilMatch.match.comment(tailStart)) {
            const comment2 = {
              type: "comment",
              content: tailStart.content,
              sameline: true,
              leadingWhitespace: true
            };
            tail = tail.slice(1);
            unifiedLatexUtilTrim.trimStart(tail);
            head.pop();
            head.push(comment2, ...tail);
            return;
          }
          head.push(...tail);
          return;
        }
        if (unifiedLatexUtilMatch.match.comment(headEnd) && unifiedLatexUtilMatch.match.comment(tailStart)) {
          if (tailStart.leadingWhitespace || tailStart.sameline) {
            head.push(
              { type: "comment", content: tailStart.content },
              ...tail.slice(1)
            );
            return;
          }
          head.push(...tail);
          return;
        }
        let comment = unifiedLatexUtilMatch.match.comment(headEnd) ? headEnd : tailStart;
        if (!unifiedLatexUtilMatch.match.comment(comment)) {
          throw new Error(
            `Expected a comment but found ${JSON.stringify(comment)}`
          );
        }
        if (!comment.leadingWhitespace || !comment.sameline) {
          comment = {
            type: "comment",
            content: comment.content,
            leadingWhitespace: true,
            sameline: true
          };
        }
        head.pop();
        head.push(comment, ...tail.slice(1));
      }
      function wrapSignificantContent(content, wrapper) {
        let hoistUntil = 0;
        let hoistAfter = content.length;
        for (let i = 0; i < content.length; i++) {
          if (unifiedLatexUtilMatch.match.whitespace(content[i]) || unifiedLatexUtilMatch.match.comment(content[i])) {
            hoistUntil = i + 1;
            continue;
          }
          break;
        }
        for (let j = content.length - 1; j >= 0; j--) {
          if (unifiedLatexUtilMatch.match.whitespace(content[j]) || unifiedLatexUtilMatch.match.comment(content[j])) {
            hoistAfter = j;
            continue;
          }
          break;
        }
        if (hoistUntil === 0 && hoistAfter === content.length) {
          return ensureArray(wrapper(content));
        }
        const frontMatter = content.slice(0, hoistUntil);
        const middle = content.slice(hoistUntil, hoistAfter);
        const backMatter = content.slice(hoistAfter, content.length);
        return frontMatter.concat(wrapper(middle), backMatter);
      }
      function ensureArray(x) {
        if (!Array.isArray(x)) {
          return [x];
        }
        return x;
      }
      function replaceStreamingCommandInArray(nodes, isStreamingCommand, replacer) {
        while (nodes.length > 0 && isStreamingCommand(nodes[nodes.length - 1])) {
          nodes.pop();
          unifiedLatexUtilTrim.trimEnd(nodes);
        }
        const foundStreamingCommands = [];
        for (let i = nodes.length - 1; i >= 0; i--) {
          const node = nodes[i];
          if (isStreamingCommand(node)) {
            const wrapper = (content) => replacer(content, node);
            let tail = nodes.slice(i + 1);
            unifiedLatexUtilTrim.trimStart(tail);
            tail = wrapSignificantContent(tail, wrapper);
            foundStreamingCommands.push(node);
            nodes.splice(i);
            joinWithoutExcessWhitespace(nodes, tail);
          }
        }
        return { foundStreamingCommands };
      }
      function replaceStreamingCommandInGroup(group, isStreamingCommand, replacer, options2) {
        const content = group.content;
        let popFromGroup = isStreamingCommand(firstSignificantNode(content));
        let innerProcessed = replaceStreamingCommand(
          content,
          isStreamingCommand,
          replacer,
          options2
        );
        if (innerProcessed.length === 0) {
          return [];
        }
        if (popFromGroup) {
          return innerProcessed;
        } else {
          return [{ type: "group", content: innerProcessed }];
        }
      }
      function replaceStreamingCommand(ast, isStreamingCommand, replacer, options2) {
        if (typeof isStreamingCommand !== "function") {
          throw new Error(
            `'isStreamingCommand' must be a function, not '${typeof isStreamingCommand}'`
          );
        }
        const {
          macrosThatBreakPars = [
            "part",
            "chapter",
            "section",
            "subsection",
            "subsubsection",
            "vspace",
            "smallskip",
            "medskip",
            "bigskip",
            "hfill"
          ],
          environmentsThatDontBreakPars = []
        } = options2 || {};
        let processedContent = [];
        if (unifiedLatexUtilMatch.match.group(ast)) {
          processedContent = replaceStreamingCommandInGroup(
            ast,
            isStreamingCommand,
            replacer
          );
        }
        if (Array.isArray(ast)) {
          const nodes = ast;
          let scanIndex = nodes.length;
          let sliceIndex = scanIndex;
          while (scanIndex > 0 && (isStreamingCommand(nodes[scanIndex - 1]) || unifiedLatexUtilMatch.match.whitespace(nodes[scanIndex - 1]))) {
            scanIndex--;
            if (isStreamingCommand(nodes[scanIndex])) {
              sliceIndex = scanIndex;
            }
          }
          if (sliceIndex !== nodes.length) {
            nodes.splice(sliceIndex);
          }
          const macroThatBreaks = unifiedLatexUtilMatch.match.createMacroMatcher(macrosThatBreakPars);
          const envThatDoesntBreak = unifiedLatexUtilMatch.match.createEnvironmentMatcher(
            environmentsThatDontBreakPars
          );
          const isPar = (node) => unifiedLatexUtilMatch.match.parbreak(node) || unifiedLatexUtilMatch.match.macro(node, "par") || macroThatBreaks(node) || unifiedLatexUtilMatch.match.environment(node) && !envThatDoesntBreak(node) || node.type === "displaymath";
          const splitByPar = unifiedLatexUtilSplit.splitOnCondition(nodes, isPar);
          splitByPar.separators = splitByPar.separators.map(
            (sep) => unifiedLatexUtilMatch.match.macro(sep, "par") ? { type: "parbreak" } : sep
          );
          const replacers = [];
          let segments = splitByPar.segments.map((segment) => {
            if (segment.length === 0) {
              return segment;
            }
            function applyAccumulatedReplacers(nodes2) {
              if (replacers.length === 0) {
                return nodes2;
              }
              return wrapSignificantContent(
                nodes2,
                composeReplacers(replacers)
              );
            }
            const { foundStreamingCommands } = replaceStreamingCommandInArray(
              segment,
              isStreamingCommand,
              replacer
            );
            const ret = applyAccumulatedReplacers(segment);
            foundStreamingCommands.forEach((macro) => {
              replacers.push((nodes2) => {
                const ret2 = replacer(nodes2, macro);
                if (!Array.isArray(ret2)) {
                  return [ret2];
                }
                return ret2;
              });
            });
            return ret;
          });
          if (segments.length > 1) {
            segments.forEach((segment, i) => {
              if (i === 0) {
                unifiedLatexUtilTrim.trimEnd(segment);
              } else if (i === segments.length - 1) {
                unifiedLatexUtilTrim.trimStart(segment);
              } else {
                unifiedLatexUtilTrim.trim(segment);
              }
            });
          }
          processedContent = unifiedLatexUtilSplit.unsplitOnMacro({
            segments,
            macros: splitByPar.separators
          });
        }
        return processedContent;
      }
      function composeReplacers(replacers) {
        if (replacers.length === 0) {
          throw new Error("Cannot compose zero replacement functions");
        }
        return (nodes) => {
          let ret = nodes;
          for (let i = 0; i < replacers.length; i++) {
            const func = replacers[i];
            ret = func(ret);
          }
          return ret;
        };
      }
      function replaceNodeDuringVisit(replacement, info) {
        const parent = info.parents[0];
        if (!parent) {
          throw new Error(`Cannot replace node: parent not found`);
        }
        const container = parent[info.key];
        if (!Array.isArray(container)) {
          throw new Error(`Cannot replace node: containing array not found`);
        }
        if (info.index == null) {
          throw new Error(`Cannot replace node: node index undefined`);
        }
        if (!Array.isArray(replacement)) {
          container[info.index] = replacement;
        } else {
          container.splice(info.index, 1, ...replacement);
        }
      }
      var unifiedLatexReplaceStreamingCommands = function unifiedLatexReplaceStreamingCommands2(options2) {
        const { replacers = {} } = options2 || {};
        const isReplaceable = unifiedLatexUtilMatch.match.createMacroMatcher(replacers);
        return (tree) => {
          unifiedLatexUtilVisit.visit(
            tree,
            (group, info) => {
              if (info.context.hasMathModeAncestor || !group.content.some(isReplaceable)) {
                return;
              }
              let fixed = replaceStreamingCommand(
                group,
                isReplaceable,
                (content, command) => {
                  return replacers[command.content](content, command);
                }
              );
              if (!info.containingArray || info.index == null) {
                return;
              }
              const prevToken = info.containingArray[info.index - 1];
              const nextToken = info.containingArray[info.index + 1];
              if (unifiedLatexUtilMatch.match.whitespaceLike(prevToken) && unifiedLatexUtilMatch.match.whitespaceLike(fixed[0])) {
                unifiedLatexUtilTrim.trimStart(fixed);
              }
              if (unifiedLatexUtilMatch.match.whitespaceLike(nextToken) && unifiedLatexUtilMatch.match.whitespaceLike(fixed[fixed.length - 1])) {
                unifiedLatexUtilTrim.trimEnd(fixed);
              }
              replaceNodeDuringVisit(fixed, info);
            },
            { test: unifiedLatexUtilMatch.match.group }
          );
          unifiedLatexUtilVisit.visit(
            tree,
            (nodes, info) => {
              if (info.context.hasMathModeAncestor || !nodes.some(isReplaceable)) {
                return;
              }
              const replaced = replaceStreamingCommand(
                nodes,
                isReplaceable,
                (content, command) => {
                  return replacers[command.content](content, command);
                }
              );
              if (replaced !== nodes) {
                nodes.length = 0;
                nodes.push(...replaced);
              }
            },
            { includeArrays: true, test: Array.isArray }
          );
        };
      };
      exports.firstSignificantNode = firstSignificantNode;
      exports.firstSignificantNodeIndex = firstSignificantNodeIndex;
      exports.lastSignificantNode = lastSignificantNode;
      exports.lastSignificantNodeIndex = lastSignificantNodeIndex;
      exports.replaceNode = replaceNode;
      exports.replaceNodeDuringVisit = replaceNodeDuringVisit;
      exports.replaceStreamingCommand = replaceStreamingCommand;
      exports.replaceStreamingCommandInGroup = replaceStreamingCommandInGroup;
      exports.unifiedLatexReplaceStreamingCommands = unifiedLatexReplaceStreamingCommands;
    }
  });

  // node_modules/@unified-latex/unified-latex-util-pegjs/index.cjs
  var require_unified_latex_util_pegjs = __commonJS({
    "node_modules/@unified-latex/unified-latex-util-pegjs/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
      var unifiedLatexUtilMatch = require_unified_latex_util_match();
      function decorateArrayForPegjs(array) {
        array.charAt = function(i) {
          return this[i];
        };
        array.charCodeAt = () => 0;
        array.substring = function(i, j) {
          return this.slice(i, j);
        };
        array.replace = function(a, b) {
          const ret = JSON.stringify(this);
          return ret.replace(a, b);
        };
        return array;
      }
      function splitStringsIntoSingleChars(nodes) {
        return nodes.flatMap(
          (node) => unifiedLatexUtilMatch.match.anyString(node) ? Array.from(node.content).map((c) => ({
            type: "string",
            content: c
          })) : node
        );
      }
      var _LatexPegParser = (
        // Generated by Peggy 3.0.2.
        //
        // https://peggyjs.org/
        function() {
          function peg$subclass(child, parent) {
            function C() {
              this.constructor = child;
            }
            C.prototype = parent.prototype;
            child.prototype = new C();
          }
          function peg$SyntaxError(message, expected, found, location2) {
            var self2 = Error.call(this, message);
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
            }
            self2.expected = expected;
            self2.found = found;
            self2.location = location2;
            self2.name = "SyntaxError";
            return self2;
          }
          peg$subclass(peg$SyntaxError, Error);
          function peg$padEnd(str, targetLength, padString) {
            padString = padString || " ";
            if (str.length > targetLength) {
              return str;
            }
            targetLength -= str.length;
            padString += padString.repeat(targetLength);
            return str + padString.slice(0, targetLength);
          }
          peg$SyntaxError.prototype.format = function(sources) {
            var str = "Error: " + this.message;
            if (this.location) {
              var src = null;
              var k;
              for (k = 0; k < sources.length; k++) {
                if (sources[k].source === this.location.source) {
                  src = sources[k].text.split(/\r\n|\n|\r/g);
                  break;
                }
              }
              var s = this.location.start;
              var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
              var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
              if (src) {
                var e = this.location.end;
                var filler = peg$padEnd("", offset_s.line.toString().length, " ");
                var line = src[s.line - 1];
                var last = s.line === e.line ? e.column : line.length + 1;
                var hatLen = last - s.column || 1;
                str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
              } else {
                str += "\n at " + loc;
              }
            }
            return str;
          };
          peg$SyntaxError.buildMessage = function(expected, found) {
            var DESCRIBE_EXPECTATION_FNS = {
              literal: function(expectation) {
                return '"' + literalEscape(expectation.text) + '"';
              },
              class: function(expectation) {
                var escapedParts = expectation.parts.map(function(part) {
                  return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
                });
                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
              },
              any: function() {
                return "any character";
              },
              end: function() {
                return "end of input";
              },
              other: function(expectation) {
                return expectation.description;
              }
            };
            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            function literalEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function classEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function describeExpectation(expectation) {
              return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
            }
            function describeExpected(expected2) {
              var descriptions = expected2.map(describeExpectation);
              var i, j;
              descriptions.sort();
              if (descriptions.length > 0) {
                for (i = 1, j = 1; i < descriptions.length; i++) {
                  if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                  }
                }
                descriptions.length = j;
              }
              switch (descriptions.length) {
                case 1:
                  return descriptions[0];
                case 2:
                  return descriptions[0] + " or " + descriptions[1];
                default:
                  return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
              }
            }
            function describeFound(found2) {
              return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
            }
            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
          };
          function peg$parse(input, options2) {
            options2 = options2 !== void 0 ? options2 : {};
            var peg$FAILED = {};
            var peg$source = options2.grammarSource;
            var peg$startRuleFunctions = { document: peg$parsedocument, math: peg$parsemath };
            var peg$startRuleFunction = peg$parsedocument;
            var peg$c0 = "%";
            var peg$c1 = ".";
            var peg$c2 = "verb*";
            var peg$c3 = "verb";
            var peg$c4 = "[";
            var peg$c5 = "]";
            var peg$c6 = "lstinline";
            var peg$c7 = "mintinline";
            var peg$c8 = "mint";
            var peg$c9 = "minted";
            var peg$c10 = "verbatim*";
            var peg$c11 = "verbatim";
            var peg$c12 = "filecontents*";
            var peg$c13 = "filecontents";
            var peg$c14 = "comment";
            var peg$c15 = "lstlisting";
            var peg$c16 = "(";
            var peg$c17 = ")";
            var peg$c18 = "begin";
            var peg$c19 = "end";
            var peg$c20 = "equation*";
            var peg$c21 = "equation";
            var peg$c22 = "align*";
            var peg$c23 = "align";
            var peg$c24 = "alignat*";
            var peg$c25 = "alignat";
            var peg$c26 = "gather*";
            var peg$c27 = "gather";
            var peg$c28 = "multline*";
            var peg$c29 = "multline";
            var peg$c30 = "flalign*";
            var peg$c31 = "flalign";
            var peg$c32 = "split";
            var peg$c33 = "math";
            var peg$c34 = "displaymath";
            var peg$c35 = "\\";
            var peg$c36 = "{";
            var peg$c37 = "}";
            var peg$c38 = "$";
            var peg$c39 = "&";
            var peg$c40 = "\r";
            var peg$c41 = "\n";
            var peg$c42 = "\r\n";
            var peg$c43 = "#";
            var peg$c44 = "^";
            var peg$c45 = "_";
            var peg$c46 = "\0";
            var peg$r0 = /^[^ \t\n\r]/;
            var peg$r1 = /^[ \t]/;
            var peg$r2 = /^[a-zA-Z]/;
            var peg$r3 = /^[0-9]/;
            var peg$r4 = /^[.,;:\-*\/()!?=+<>[\]`'"~]/;
            var peg$e0 = peg$otherExpectation("document");
            var peg$e1 = peg$otherExpectation("math");
            var peg$e2 = peg$otherExpectation("token");
            var peg$e3 = peg$anyExpectation();
            var peg$e4 = peg$otherExpectation("parbreak");
            var peg$e5 = peg$otherExpectation("math token");
            var peg$e6 = peg$otherExpectation("nonchar token");
            var peg$e7 = peg$literalExpectation("%", false);
            var peg$e8 = peg$otherExpectation("whitespace");
            var peg$e9 = peg$otherExpectation("number");
            var peg$e10 = peg$literalExpectation(".", false);
            var peg$e11 = peg$otherExpectation("special macro");
            var peg$e12 = peg$literalExpectation("verb*", false);
            var peg$e13 = peg$literalExpectation("verb", false);
            var peg$e14 = peg$literalExpectation("[", false);
            var peg$e15 = peg$literalExpectation("]", false);
            var peg$e16 = peg$classExpectation([" ", "	", "\n", "\r"], true, false);
            var peg$e17 = peg$otherExpectation("verbatim listings");
            var peg$e18 = peg$literalExpectation("lstinline", false);
            var peg$e19 = peg$otherExpectation("verbatim minted");
            var peg$e20 = peg$literalExpectation("mintinline", false);
            var peg$e21 = peg$literalExpectation("mint", false);
            var peg$e22 = peg$otherExpectation("verbatim minted environment");
            var peg$e23 = peg$literalExpectation("minted", false);
            var peg$e24 = peg$otherExpectation("verbatim environment");
            var peg$e25 = peg$literalExpectation("verbatim*", false);
            var peg$e26 = peg$literalExpectation("verbatim", false);
            var peg$e27 = peg$literalExpectation("filecontents*", false);
            var peg$e28 = peg$literalExpectation("filecontents", false);
            var peg$e29 = peg$literalExpectation("comment", false);
            var peg$e30 = peg$literalExpectation("lstlisting", false);
            var peg$e31 = peg$otherExpectation("macro");
            var peg$e32 = peg$otherExpectation("group");
            var peg$e33 = peg$otherExpectation("environment");
            var peg$e34 = peg$otherExpectation("math environment");
            var peg$e36 = peg$literalExpectation("(", false);
            var peg$e37 = peg$literalExpectation(")", false);
            var peg$e38 = peg$literalExpectation("begin", false);
            var peg$e39 = peg$literalExpectation("end", false);
            var peg$e40 = peg$literalExpectation("equation*", false);
            var peg$e41 = peg$literalExpectation("equation", false);
            var peg$e42 = peg$literalExpectation("align*", false);
            var peg$e43 = peg$literalExpectation("align", false);
            var peg$e44 = peg$literalExpectation("alignat*", false);
            var peg$e45 = peg$literalExpectation("alignat", false);
            var peg$e46 = peg$literalExpectation("gather*", false);
            var peg$e47 = peg$literalExpectation("gather", false);
            var peg$e48 = peg$literalExpectation("multline*", false);
            var peg$e49 = peg$literalExpectation("multline", false);
            var peg$e50 = peg$literalExpectation("flalign*", false);
            var peg$e51 = peg$literalExpectation("flalign", false);
            var peg$e52 = peg$literalExpectation("split", false);
            var peg$e53 = peg$literalExpectation("math", false);
            var peg$e54 = peg$literalExpectation("displaymath", false);
            var peg$e55 = peg$otherExpectation("escape");
            var peg$e56 = peg$literalExpectation("\\", false);
            var peg$e57 = peg$literalExpectation("{", false);
            var peg$e58 = peg$literalExpectation("}", false);
            var peg$e59 = peg$literalExpectation("$", false);
            var peg$e60 = peg$literalExpectation("&", false);
            var peg$e61 = peg$otherExpectation("newline");
            var peg$e62 = peg$literalExpectation("\r", false);
            var peg$e63 = peg$literalExpectation("\n", false);
            var peg$e64 = peg$literalExpectation("\r\n", false);
            var peg$e65 = peg$literalExpectation("#", false);
            var peg$e66 = peg$literalExpectation("^", false);
            var peg$e67 = peg$literalExpectation("_", false);
            var peg$e68 = peg$literalExpectation("\0", false);
            var peg$e69 = peg$classExpectation([" ", "	"], false, false);
            var peg$e70 = peg$otherExpectation("letter");
            var peg$e71 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
            var peg$e72 = peg$otherExpectation("digit");
            var peg$e73 = peg$classExpectation([["0", "9"]], false, false);
            var peg$e74 = peg$otherExpectation("punctuation");
            var peg$e75 = peg$classExpectation([".", ",", ";", ":", "-", "*", "/", "(", ")", "!", "?", "=", "+", "<", ">", "[", "]", "`", "'", '"', "~"], false, false);
            var peg$e76 = peg$otherExpectation("full comment");
            var peg$e77 = peg$otherExpectation("comment");
            var peg$f0 = function(content) {
              return createNode("root", { content: content.flatMap((x) => x) });
            };
            var peg$f1 = function(t) {
              return t;
            };
            var peg$f2 = function(eq) {
              return createNode("inlinemath", { content: eq.flatMap((x) => x) });
            };
            var peg$f3 = function(s) {
              return createNode("string", { content: s });
            };
            var peg$f4 = function(s) {
              return createNode("string", { content: s });
            };
            var peg$f5 = function() {
              return createNode("parbreak");
            };
            var peg$f6 = function(x) {
              return x;
            };
            var peg$f7 = function(x) {
              return x;
            };
            var peg$f8 = function() {
              return createNode("macro", { content: "^", escapeToken: "" });
            };
            var peg$f9 = function() {
              return createNode("macro", { content: "_", escapeToken: "" });
            };
            var peg$f10 = function(s) {
              return createNode("string", { content: s });
            };
            var peg$f11 = function() {
              return createNode("whitespace");
            };
            var peg$f12 = function(a, b) {
              return a.join("") + "." + b.join("");
            };
            var peg$f13 = function(b) {
              return "." + b.join("");
            };
            var peg$f14 = function(a) {
              return a.join("") + ".";
            };
            var peg$f15 = function(s) {
              return createNode("string", { content: s });
            };
            var peg$f16 = function(env, e, end) {
              return end == e;
            };
            var peg$f17 = function(env, e, x) {
              return x;
            };
            var peg$f18 = function(env, e, x, end) {
              return end == e;
            };
            var peg$f19 = function(env, e, x) {
              return createNode("verb", {
                env,
                escape: e,
                content: x.join("")
              });
            };
            var peg$f20 = function(x) {
              return x;
            };
            var peg$f21 = function(x) {
              return createNode("displaymath", { content: x.flatMap((x2) => x2) });
            };
            var peg$f22 = function(x) {
              return x;
            };
            var peg$f23 = function(x) {
              return createNode("inlinemath", { content: x.flatMap((x2) => x2) });
            };
            var peg$f24 = function(x) {
              return x;
            };
            var peg$f25 = function(x) {
              return createNode("displaymath", { content: x.flatMap((x2) => x2) });
            };
            var peg$f26 = function(end) {
              return end.type === "string" && end.content === "]";
            };
            var peg$f27 = function(x) {
              return x;
            };
            var peg$f28 = function(o) {
              return [
                createNode("string", { content: "[" }),
                ...o,
                createNode("string", { content: "]" })
              ];
            };
            var peg$f29 = function(x) {
              return x;
            };
            var peg$f30 = function(v) {
              return createNode("group", {
                content: createNode("string", { content: v.join("") })
              });
            };
            var peg$f31 = function(d, end) {
              return end == d;
            };
            var peg$f32 = function(d, x) {
              return x;
            };
            var peg$f33 = function(d, v, end) {
              return end == d;
            };
            var peg$f34 = function(d, v) {
              return [
                createNode("string", { content: d }),
                createNode("string", { content: v.join("") }),
                createNode("string", { content: d })
              ];
            };
            var peg$f35 = function(macro, option, verbatim) {
              return [
                createNode("macro", { content: macro }),
                ...option || [],
                ...[].concat(verbatim)
              ];
            };
            var peg$f36 = function(macro, option, language, verbatim) {
              return [
                createNode("macro", { content: macro }),
                ...option || [],
                language,
                ...[].concat(verbatim)
              ];
            };
            var peg$f37 = function(env, option, language, end_env) {
              return compare_env({ content: [env] }, end_env);
            };
            var peg$f38 = function(env, option, language, body) {
              const content = [
                ...option || [],
                language,
                { type: "string", content: body }
              ];
              return createNode("environment", {
                env,
                content
              });
            };
            var peg$f39 = function(env, end_env) {
              return compare_env({ content: [env] }, end_env);
            };
            var peg$f40 = function(env, x) {
              return x;
            };
            var peg$f41 = function(env, body) {
              return createNode("verbatim", {
                env,
                content: body
              });
            };
            var peg$f42 = function(n) {
              return n.join("");
            };
            var peg$f43 = function(n) {
              return n;
            };
            var peg$f44 = function(m) {
              return createNode("macro", { content: m });
            };
            var peg$f45 = function(c) {
              return c;
            };
            var peg$f46 = function(x) {
              return createNode("group", { content: x.flatMap((x2) => x2) });
            };
            var peg$f47 = function(g) {
              return text().slice(1, -1);
            };
            var peg$f48 = function(env, env_comment, end_env) {
              return compare_env(env, end_env);
            };
            var peg$f49 = function(env, env_comment, x) {
              return x;
            };
            var peg$f50 = function(env, env_comment, body) {
              body = body.flatMap((x) => x);
              return createNode("environment", {
                env,
                content: env_comment ? [env_comment, ...body] : body
              });
            };
            var peg$f51 = function(env, env_comment, end_env) {
              return compare_env({ content: [env] }, end_env);
            };
            var peg$f52 = function(env, env_comment, x) {
              return x;
            };
            var peg$f53 = function(env, env_comment, body) {
              body = body.flatMap((x) => x);
              return createNode("mathenv", {
                env,
                content: env_comment ? [env_comment, ...body] : body
              });
            };
            var peg$f56 = function(e) {
              return createNode("string", { content: e });
            };
            var peg$f57 = function() {
              return createNode("string", { content: "\\" });
            };
            var peg$f58 = function(s) {
              return createNode("string", { content: s });
            };
            var peg$f59 = function(s) {
              return createNode("string", { content: s });
            };
            var peg$f60 = function(s) {
              return createNode("string", { content: s });
            };
            var peg$f61 = function(s) {
              return createNode("string", { content: s });
            };
            var peg$f62 = function(s) {
              return createNode("string", { content: s });
            };
            var peg$f63 = function(s) {
              return createNode("string", { content: s });
            };
            var peg$f64 = function(s) {
              return createNode("string", { content: s });
            };
            var peg$f65 = function() {
              return " ";
            };
            var peg$f66 = function(p) {
              return createNode("string", { content: p });
            };
            var peg$f67 = function(leading_sp, comment) {
              return createNode("comment", {
                ...comment,
                sameline: false,
                leadingWhitespace: leading_sp.length > 0
              });
            };
            var peg$f68 = function(spaces, x) {
              return createNode("comment", {
                ...x,
                sameline: true,
                leadingWhitespace: spaces.length > 0
              });
            };
            var peg$f69 = function(c) {
              return c;
            };
            var peg$f70 = function(c) {
              return { content: c.join(""), suffixParbreak: true };
            };
            var peg$f71 = function(c) {
              return c;
            };
            var peg$f72 = function(c) {
              return { content: c.join("") };
            };
            var peg$f73 = function() {
              var loc = location2();
              return loc.start.column === 1;
            };
            var peg$currPos = 0;
            var peg$savedPos = 0;
            var peg$posDetailsCache = [{ line: 1, column: 1 }];
            var peg$maxFailPos = 0;
            var peg$maxFailExpected = [];
            var peg$silentFails = 0;
            var peg$result;
            if ("startRule" in options2) {
              if (!(options2.startRule in peg$startRuleFunctions)) {
                throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
              }
              peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
            }
            function text() {
              return input.substring(peg$savedPos, peg$currPos);
            }
            function location2() {
              return peg$computeLocation(peg$savedPos, peg$currPos);
            }
            function peg$literalExpectation(text2, ignoreCase) {
              return { type: "literal", text: text2, ignoreCase };
            }
            function peg$classExpectation(parts, inverted, ignoreCase) {
              return { type: "class", parts, inverted, ignoreCase };
            }
            function peg$anyExpectation() {
              return { type: "any" };
            }
            function peg$endExpectation() {
              return { type: "end" };
            }
            function peg$otherExpectation(description) {
              return { type: "other", description };
            }
            function peg$computePosDetails(pos) {
              var details = peg$posDetailsCache[pos];
              var p;
              if (details) {
                return details;
              } else {
                p = pos - 1;
                while (!peg$posDetailsCache[p]) {
                  p--;
                }
                details = peg$posDetailsCache[p];
                details = {
                  line: details.line,
                  column: details.column
                };
                while (p < pos) {
                  if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                  } else {
                    details.column++;
                  }
                  p++;
                }
                peg$posDetailsCache[pos] = details;
                return details;
              }
            }
            function peg$computeLocation(startPos, endPos, offset2) {
              var startPosDetails = peg$computePosDetails(startPos);
              var endPosDetails = peg$computePosDetails(endPos);
              var res = {
                source: peg$source,
                start: {
                  offset: startPos,
                  line: startPosDetails.line,
                  column: startPosDetails.column
                },
                end: {
                  offset: endPos,
                  line: endPosDetails.line,
                  column: endPosDetails.column
                }
              };
              if (offset2 && peg$source && typeof peg$source.offset === "function") {
                res.start = peg$source.offset(res.start);
                res.end = peg$source.offset(res.end);
              }
              return res;
            }
            function peg$fail(expected2) {
              if (peg$currPos < peg$maxFailPos) {
                return;
              }
              if (peg$currPos > peg$maxFailPos) {
                peg$maxFailPos = peg$currPos;
                peg$maxFailExpected = [];
              }
              peg$maxFailExpected.push(expected2);
            }
            function peg$buildStructuredError(expected2, found, location22) {
              return new peg$SyntaxError(
                peg$SyntaxError.buildMessage(expected2, found),
                expected2,
                found,
                location22
              );
            }
            function peg$parsedocument() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsetoken();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsetoken();
              }
              peg$savedPos = s0;
              s1 = peg$f0(s1);
              s0 = s1;
              peg$silentFails--;
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
              return s0;
            }
            function peg$parsemath() {
              var s0, s1;
              peg$silentFails++;
              s0 = [];
              s1 = peg$parsemath_token();
              while (s1 !== peg$FAILED) {
                s0.push(s1);
                s1 = peg$parsemath_token();
              }
              peg$silentFails--;
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
              return s0;
            }
            function peg$parsetoken() {
              var s0, s1, s2, s3, s4, s5;
              peg$silentFails++;
              s0 = peg$parsespecial_macro();
              if (s0 === peg$FAILED) {
                s0 = peg$parsemacro();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsefull_comment();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsegroup();
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = peg$parsemath_shift();
                      if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$currPos;
                        s4 = peg$currPos;
                        peg$silentFails++;
                        s5 = peg$parsemath_shift();
                        peg$silentFails--;
                        if (s5 === peg$FAILED) {
                          s4 = void 0;
                        } else {
                          peg$currPos = s4;
                          s4 = peg$FAILED;
                        }
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parsemath_token();
                          if (s5 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s3 = peg$f1(s5);
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                        if (s3 !== peg$FAILED) {
                          while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$currPos;
                            s4 = peg$currPos;
                            peg$silentFails++;
                            s5 = peg$parsemath_shift();
                            peg$silentFails--;
                            if (s5 === peg$FAILED) {
                              s4 = void 0;
                            } else {
                              peg$currPos = s4;
                              s4 = peg$FAILED;
                            }
                            if (s4 !== peg$FAILED) {
                              s5 = peg$parsemath_token();
                              if (s5 !== peg$FAILED) {
                                peg$savedPos = s3;
                                s3 = peg$f1(s5);
                              } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s3;
                              s3 = peg$FAILED;
                            }
                          }
                        } else {
                          s2 = peg$FAILED;
                        }
                        if (s2 !== peg$FAILED) {
                          s3 = peg$parsemath_shift();
                          if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f2(s2);
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsealignment_tab();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseparbreak();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsemacro_parameter();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseignore();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parsenumber();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parsewhitespace();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parsepunctuation();
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$currPos;
                                      s1 = peg$currPos;
                                      s2 = [];
                                      s3 = peg$currPos;
                                      s4 = peg$currPos;
                                      peg$silentFails++;
                                      s5 = peg$parsenonchar_token();
                                      peg$silentFails--;
                                      if (s5 === peg$FAILED) {
                                        s4 = void 0;
                                      } else {
                                        peg$currPos = s4;
                                        s4 = peg$FAILED;
                                      }
                                      if (s4 !== peg$FAILED) {
                                        if (input.length > peg$currPos) {
                                          s5 = input.charAt(peg$currPos);
                                          peg$currPos++;
                                        } else {
                                          s5 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$e3);
                                          }
                                        }
                                        if (s5 !== peg$FAILED) {
                                          s4 = [s4, s5];
                                          s3 = s4;
                                        } else {
                                          peg$currPos = s3;
                                          s3 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s3;
                                        s3 = peg$FAILED;
                                      }
                                      if (s3 !== peg$FAILED) {
                                        while (s3 !== peg$FAILED) {
                                          s2.push(s3);
                                          s3 = peg$currPos;
                                          s4 = peg$currPos;
                                          peg$silentFails++;
                                          s5 = peg$parsenonchar_token();
                                          peg$silentFails--;
                                          if (s5 === peg$FAILED) {
                                            s4 = void 0;
                                          } else {
                                            peg$currPos = s4;
                                            s4 = peg$FAILED;
                                          }
                                          if (s4 !== peg$FAILED) {
                                            if (input.length > peg$currPos) {
                                              s5 = input.charAt(peg$currPos);
                                              peg$currPos++;
                                            } else {
                                              s5 = peg$FAILED;
                                              if (peg$silentFails === 0) {
                                                peg$fail(peg$e3);
                                              }
                                            }
                                            if (s5 !== peg$FAILED) {
                                              s4 = [s4, s5];
                                              s3 = s4;
                                            } else {
                                              peg$currPos = s3;
                                              s3 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s3;
                                            s3 = peg$FAILED;
                                          }
                                        }
                                      } else {
                                        s2 = peg$FAILED;
                                      }
                                      if (s2 !== peg$FAILED) {
                                        s1 = input.substring(s1, peg$currPos);
                                      } else {
                                        s1 = s2;
                                      }
                                      if (s1 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$f3(s1);
                                      }
                                      s0 = s1;
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$parsebegin_group();
                                        if (s0 === peg$FAILED) {
                                          s0 = peg$parseend_group();
                                          if (s0 === peg$FAILED) {
                                            s0 = peg$parsemath_shift();
                                            if (s0 === peg$FAILED) {
                                              s0 = peg$currPos;
                                              if (input.length > peg$currPos) {
                                                s1 = input.charAt(peg$currPos);
                                                peg$currPos++;
                                              } else {
                                                s1 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                  peg$fail(peg$e3);
                                                }
                                              }
                                              if (s1 !== peg$FAILED) {
                                                peg$savedPos = s0;
                                                s1 = peg$f4(s1);
                                              }
                                              s0 = s1;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              return s0;
            }
            function peg$parseparbreak() {
              var s0, s1, s2, s3, s4, s5, s6, s7;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = [];
              s3 = peg$parsesp();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsesp();
              }
              s3 = peg$parsenl();
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$currPos;
                s6 = [];
                s7 = peg$parsesp();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parsesp();
                }
                s7 = peg$parsenl();
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                if (s5 !== peg$FAILED) {
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$currPos;
                    s6 = [];
                    s7 = peg$parsesp();
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      s7 = peg$parsesp();
                    }
                    s7 = peg$parsenl();
                    if (s7 !== peg$FAILED) {
                      s6 = [s6, s7];
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  }
                } else {
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parsesp();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parsesp();
                  }
                  s6 = peg$currPos;
                  peg$silentFails++;
                  s7 = peg$parsecomment_start();
                  peg$silentFails--;
                  if (s7 === peg$FAILED) {
                    s6 = void 0;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    s2 = [s2, s3, s4, s5, s6];
                    s1 = s2;
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                s2 = [];
                s3 = peg$parsesp();
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parsesp();
                }
                s3 = peg$parsenl();
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$currPos;
                  s6 = [];
                  s7 = peg$parsesp();
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parsesp();
                  }
                  s7 = peg$parsenl();
                  if (s7 !== peg$FAILED) {
                    s6 = [s6, s7];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                  if (s5 !== peg$FAILED) {
                    while (s5 !== peg$FAILED) {
                      s4.push(s5);
                      s5 = peg$currPos;
                      s6 = [];
                      s7 = peg$parsesp();
                      while (s7 !== peg$FAILED) {
                        s6.push(s7);
                        s7 = peg$parsesp();
                      }
                      s7 = peg$parsenl();
                      if (s7 !== peg$FAILED) {
                        s6 = [s6, s7];
                        s5 = s6;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    }
                  } else {
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    s2 = [s2, s3, s4];
                    s1 = s2;
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f5();
              }
              s0 = s1;
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e4);
                }
              }
              return s0;
            }
            function peg$parsemath_token() {
              var s0, s1, s2, s3, s4;
              peg$silentFails++;
              s0 = peg$parsespecial_macro();
              if (s0 === peg$FAILED) {
                s0 = peg$parsemacro();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsefull_comment();
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = [];
                    s2 = peg$parsewhitespace();
                    while (s2 !== peg$FAILED) {
                      s1.push(s2);
                      s2 = peg$parsewhitespace();
                    }
                    s2 = peg$parsegroup();
                    if (s2 !== peg$FAILED) {
                      s3 = [];
                      s4 = peg$parsewhitespace();
                      while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        s4 = peg$parsewhitespace();
                      }
                      peg$savedPos = s0;
                      s0 = peg$f6(s2);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = [];
                      s2 = peg$parsewhitespace();
                      while (s2 !== peg$FAILED) {
                        s1.push(s2);
                        s2 = peg$parsewhitespace();
                      }
                      s2 = peg$parsealignment_tab();
                      if (s2 !== peg$FAILED) {
                        s3 = [];
                        s4 = peg$parsewhitespace();
                        while (s4 !== peg$FAILED) {
                          s3.push(s4);
                          s4 = peg$parsewhitespace();
                        }
                        peg$savedPos = s0;
                        s0 = peg$f7(s2);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsemacro_parameter();
                        if (s0 === peg$FAILED) {
                          s0 = peg$currPos;
                          s1 = [];
                          s2 = peg$parsewhitespace();
                          while (s2 !== peg$FAILED) {
                            s1.push(s2);
                            s2 = peg$parsewhitespace();
                          }
                          s2 = peg$parsesuperscript();
                          if (s2 !== peg$FAILED) {
                            s3 = [];
                            s4 = peg$parsewhitespace();
                            while (s4 !== peg$FAILED) {
                              s3.push(s4);
                              s4 = peg$parsewhitespace();
                            }
                            peg$savedPos = s0;
                            s0 = peg$f8();
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = [];
                            s2 = peg$parsewhitespace();
                            while (s2 !== peg$FAILED) {
                              s1.push(s2);
                              s2 = peg$parsewhitespace();
                            }
                            s2 = peg$parsesubscript();
                            if (s2 !== peg$FAILED) {
                              s3 = [];
                              s4 = peg$parsewhitespace();
                              while (s4 !== peg$FAILED) {
                                s3.push(s4);
                                s4 = peg$parsewhitespace();
                              }
                              peg$savedPos = s0;
                              s0 = peg$f9();
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseignore();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parsewhitespace();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$currPos;
                                  if (input.length > peg$currPos) {
                                    s1 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e3);
                                    }
                                  }
                                  if (s1 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$f10(s1);
                                  }
                                  s0 = s1;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e5);
                }
              }
              return s0;
            }
            function peg$parsenonchar_token() {
              var s0;
              peg$silentFails++;
              s0 = peg$parseescape();
              if (s0 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 37) {
                  s0 = peg$c0;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e7);
                  }
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsebegin_group();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseend_group();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsemath_shift();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsealignment_tab();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsenl();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsemacro_parameter();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseignore();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parsesp();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parsepunctuation();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parseEOF();
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                if (peg$silentFails === 0) {
                  peg$fail(peg$e6);
                }
              }
              return s0;
            }
            function peg$parsewhitespace() {
              var s0, s1, s2, s3, s4, s5, s6, s7;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = peg$parsenl();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsesp();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsesp();
                }
                s2 = [s2, s3];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                s2 = [];
                s3 = peg$parsesp();
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parsesp();
                  }
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsenl();
                  if (s3 !== peg$FAILED) {
                    s4 = peg$currPos;
                    peg$silentFails++;
                    s5 = peg$parsecomment_start();
                    peg$silentFails--;
                    if (s5 === peg$FAILED) {
                      s4 = void 0;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = [];
                      s6 = peg$parsesp();
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parsesp();
                      }
                      s6 = peg$currPos;
                      peg$silentFails++;
                      s7 = peg$parsenl();
                      peg$silentFails--;
                      if (s7 === peg$FAILED) {
                        s6 = void 0;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                      if (s6 !== peg$FAILED) {
                        s2 = [s2, s3, s4, s5, s6];
                        s1 = s2;
                      } else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
                if (s1 === peg$FAILED) {
                  s1 = [];
                  s2 = peg$parsesp();
                  if (s2 !== peg$FAILED) {
                    while (s2 !== peg$FAILED) {
                      s1.push(s2);
                      s2 = peg$parsesp();
                    }
                  } else {
                    s1 = peg$FAILED;
                  }
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f11();
              }
              s0 = s1;
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e8);
                }
              }
              return s0;
            }
            function peg$parsenumber() {
              var s0, s1, s2, s3, s4, s5;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = [];
              s3 = peg$parsenum();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parsenum();
                }
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s3 = peg$c1;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e10);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parsenum();
                  if (s5 !== peg$FAILED) {
                    while (s5 !== peg$FAILED) {
                      s4.push(s5);
                      s5 = peg$parsenum();
                    }
                  } else {
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    peg$savedPos = s1;
                    s1 = peg$f12(s2, s4);
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 46) {
                  s2 = peg$c1;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e10);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$parsenum();
                  if (s4 !== peg$FAILED) {
                    while (s4 !== peg$FAILED) {
                      s3.push(s4);
                      s4 = peg$parsenum();
                    }
                  } else {
                    s3 = peg$FAILED;
                  }
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s1;
                    s1 = peg$f13(s3);
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  s2 = [];
                  s3 = peg$parsenum();
                  if (s3 !== peg$FAILED) {
                    while (s3 !== peg$FAILED) {
                      s2.push(s3);
                      s3 = peg$parsenum();
                    }
                  } else {
                    s2 = peg$FAILED;
                  }
                  if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 46) {
                      s3 = peg$c1;
                      peg$currPos++;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e10);
                      }
                    }
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s1;
                      s1 = peg$f14(s2);
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f15(s1);
              }
              s0 = s1;
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e9);
                }
              }
              return s0;
            }
            function peg$parsespecial_macro() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parseescape();
              if (s1 !== peg$FAILED) {
                if (input.substr(peg$currPos, 5) === peg$c2) {
                  s2 = peg$c2;
                  peg$currPos += 5;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e12);
                  }
                }
                if (s2 === peg$FAILED) {
                  if (input.substr(peg$currPos, 4) === peg$c3) {
                    s2 = peg$c3;
                    peg$currPos += 4;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e13);
                    }
                  }
                }
                if (s2 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$currPos;
                    s6 = peg$currPos;
                    peg$silentFails++;
                    s7 = peg$currPos;
                    if (input.length > peg$currPos) {
                      s8 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s9 = peg$f16(s2, s3, s8);
                      if (s9) {
                        s9 = void 0;
                      } else {
                        s9 = peg$FAILED;
                      }
                      if (s9 !== peg$FAILED) {
                        s8 = [s8, s9];
                        s7 = s8;
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s7 === peg$FAILED) {
                      s6 = void 0;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                    if (s6 !== peg$FAILED) {
                      if (input.length > peg$currPos) {
                        s7 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e3);
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        peg$savedPos = s5;
                        s5 = peg$f17(s2, s3, s7);
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                    while (s5 !== peg$FAILED) {
                      s4.push(s5);
                      s5 = peg$currPos;
                      s6 = peg$currPos;
                      peg$silentFails++;
                      s7 = peg$currPos;
                      if (input.length > peg$currPos) {
                        s8 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e3);
                        }
                      }
                      if (s8 !== peg$FAILED) {
                        peg$savedPos = peg$currPos;
                        s9 = peg$f16(s2, s3, s8);
                        if (s9) {
                          s9 = void 0;
                        } else {
                          s9 = peg$FAILED;
                        }
                        if (s9 !== peg$FAILED) {
                          s8 = [s8, s9];
                          s7 = s8;
                        } else {
                          peg$currPos = s7;
                          s7 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                      peg$silentFails--;
                      if (s7 === peg$FAILED) {
                        s6 = void 0;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                      if (s6 !== peg$FAILED) {
                        if (input.length > peg$currPos) {
                          s7 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s7 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e3);
                          }
                        }
                        if (s7 !== peg$FAILED) {
                          peg$savedPos = s5;
                          s5 = peg$f17(s2, s3, s7);
                        } else {
                          peg$currPos = s5;
                          s5 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    }
                    s5 = peg$currPos;
                    if (input.length > peg$currPos) {
                      s6 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s7 = peg$f18(s2, s3, s4, s6);
                      if (s7) {
                        s7 = void 0;
                      } else {
                        s7 = peg$FAILED;
                      }
                      if (s7 !== peg$FAILED) {
                        s6 = [s6, s7];
                        s5 = s6;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s0 = peg$f19(s2, s3, s4);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parseverbatim_listings();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseverbatim_minted();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseverbatim_minted_environment();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseverbatim_environment();
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parsebegin_display_math();
                        if (s1 !== peg$FAILED) {
                          s2 = [];
                          s3 = peg$currPos;
                          s4 = peg$currPos;
                          peg$silentFails++;
                          s5 = peg$parseend_display_math();
                          peg$silentFails--;
                          if (s5 === peg$FAILED) {
                            s4 = void 0;
                          } else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                          }
                          if (s4 !== peg$FAILED) {
                            s5 = peg$parsemath_token();
                            if (s5 !== peg$FAILED) {
                              peg$savedPos = s3;
                              s3 = peg$f20(s5);
                            } else {
                              peg$currPos = s3;
                              s3 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                          while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$currPos;
                            s4 = peg$currPos;
                            peg$silentFails++;
                            s5 = peg$parseend_display_math();
                            peg$silentFails--;
                            if (s5 === peg$FAILED) {
                              s4 = void 0;
                            } else {
                              peg$currPos = s4;
                              s4 = peg$FAILED;
                            }
                            if (s4 !== peg$FAILED) {
                              s5 = peg$parsemath_token();
                              if (s5 !== peg$FAILED) {
                                peg$savedPos = s3;
                                s3 = peg$f20(s5);
                              } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s3;
                              s3 = peg$FAILED;
                            }
                          }
                          s3 = peg$parseend_display_math();
                          if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f21(s2);
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                          s0 = peg$currPos;
                          s1 = peg$parsebegin_inline_math();
                          if (s1 !== peg$FAILED) {
                            s2 = [];
                            s3 = peg$currPos;
                            s4 = peg$currPos;
                            peg$silentFails++;
                            s5 = peg$parseend_inline_math();
                            peg$silentFails--;
                            if (s5 === peg$FAILED) {
                              s4 = void 0;
                            } else {
                              peg$currPos = s4;
                              s4 = peg$FAILED;
                            }
                            if (s4 !== peg$FAILED) {
                              s5 = peg$parsemath_token();
                              if (s5 !== peg$FAILED) {
                                peg$savedPos = s3;
                                s3 = peg$f22(s5);
                              } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s3;
                              s3 = peg$FAILED;
                            }
                            while (s3 !== peg$FAILED) {
                              s2.push(s3);
                              s3 = peg$currPos;
                              s4 = peg$currPos;
                              peg$silentFails++;
                              s5 = peg$parseend_inline_math();
                              peg$silentFails--;
                              if (s5 === peg$FAILED) {
                                s4 = void 0;
                              } else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                              }
                              if (s4 !== peg$FAILED) {
                                s5 = peg$parsemath_token();
                                if (s5 !== peg$FAILED) {
                                  peg$savedPos = s3;
                                  s3 = peg$f22(s5);
                                } else {
                                  peg$currPos = s3;
                                  s3 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                              }
                            }
                            s3 = peg$parseend_inline_math();
                            if (s3 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s0 = peg$f23(s2);
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parsemath_shift();
                            if (s1 !== peg$FAILED) {
                              s2 = peg$parsemath_shift();
                              if (s2 !== peg$FAILED) {
                                s3 = [];
                                s4 = peg$currPos;
                                s5 = peg$currPos;
                                peg$silentFails++;
                                s6 = peg$currPos;
                                s7 = peg$parsemath_shift();
                                if (s7 !== peg$FAILED) {
                                  s8 = peg$parsemath_shift();
                                  if (s8 !== peg$FAILED) {
                                    s7 = [s7, s8];
                                    s6 = s7;
                                  } else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s6;
                                  s6 = peg$FAILED;
                                }
                                peg$silentFails--;
                                if (s6 === peg$FAILED) {
                                  s5 = void 0;
                                } else {
                                  peg$currPos = s5;
                                  s5 = peg$FAILED;
                                }
                                if (s5 !== peg$FAILED) {
                                  s6 = peg$parsemath_token();
                                  if (s6 !== peg$FAILED) {
                                    peg$savedPos = s4;
                                    s4 = peg$f24(s6);
                                  } else {
                                    peg$currPos = s4;
                                    s4 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s4;
                                  s4 = peg$FAILED;
                                }
                                while (s4 !== peg$FAILED) {
                                  s3.push(s4);
                                  s4 = peg$currPos;
                                  s5 = peg$currPos;
                                  peg$silentFails++;
                                  s6 = peg$currPos;
                                  s7 = peg$parsemath_shift();
                                  if (s7 !== peg$FAILED) {
                                    s8 = peg$parsemath_shift();
                                    if (s8 !== peg$FAILED) {
                                      s7 = [s7, s8];
                                      s6 = s7;
                                    } else {
                                      peg$currPos = s6;
                                      s6 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                  }
                                  peg$silentFails--;
                                  if (s6 === peg$FAILED) {
                                    s5 = void 0;
                                  } else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                  }
                                  if (s5 !== peg$FAILED) {
                                    s6 = peg$parsemath_token();
                                    if (s6 !== peg$FAILED) {
                                      peg$savedPos = s4;
                                      s4 = peg$f24(s6);
                                    } else {
                                      peg$currPos = s4;
                                      s4 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s4;
                                    s4 = peg$FAILED;
                                  }
                                }
                                s4 = peg$parsemath_shift();
                                if (s4 !== peg$FAILED) {
                                  s5 = peg$parsemath_shift();
                                  if (s5 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s0 = peg$f25(s3);
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsemath_environment();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parseenvironment();
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e11);
                }
              }
              return s0;
            }
            function peg$parsesquare_bracket_argument() {
              var s0, s1, s2, s3, s4, s5, s6, s7;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c4;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e14);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$currPos;
                s6 = peg$parsetoken();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s7 = peg$f26(s6);
                  if (s7) {
                    s7 = void 0;
                  } else {
                    s7 = peg$FAILED;
                  }
                  if (s7 !== peg$FAILED) {
                    s6 = [s6, s7];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = void 0;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsetoken();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s3 = peg$f27(s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$currPos;
                  s4 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$currPos;
                  s6 = peg$parsetoken();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s7 = peg$f26(s6);
                    if (s7) {
                      s7 = void 0;
                    } else {
                      s7 = peg$FAILED;
                    }
                    if (s7 !== peg$FAILED) {
                      s6 = [s6, s7];
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s4 = void 0;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsetoken();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s3 = peg$f27(s5);
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
                if (input.charCodeAt(peg$currPos) === 93) {
                  s3 = peg$c5;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e15);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f28(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseverbatim_group() {
              var s0, s1, s2, s3, s4, s5;
              s0 = peg$currPos;
              s1 = peg$parsebegin_group();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseend_group();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = void 0;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s3 = peg$f29(s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$currPos;
                  s4 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parseend_group();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s4 = void 0;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s5 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s3 = peg$f29(s5);
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
                s3 = peg$parseend_group();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f30(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseverbatim_delimited_by_char() {
              var s0, s1, s2, s3, s4, s5, s6, s7;
              s0 = peg$currPos;
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e16);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$currPos;
                if (input.length > peg$currPos) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s6 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s7 = peg$f31(s1, s6);
                  if (s7) {
                    s7 = void 0;
                  } else {
                    s7 = peg$FAILED;
                  }
                  if (s7 !== peg$FAILED) {
                    s6 = [s6, s7];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = void 0;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s3 = peg$f32(s1, s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$currPos;
                  s4 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$currPos;
                  if (input.length > peg$currPos) {
                    s6 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s7 = peg$f31(s1, s6);
                    if (s7) {
                      s7 = void 0;
                    } else {
                      s7 = peg$FAILED;
                    }
                    if (s7 !== peg$FAILED) {
                      s6 = [s6, s7];
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s4 = void 0;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s5 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s3 = peg$f32(s1, s5);
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
                s3 = peg$currPos;
                if (input.length > peg$currPos) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s5 = peg$f33(s1, s2, s4);
                  if (s5) {
                    s5 = void 0;
                  } else {
                    s5 = peg$FAILED;
                  }
                  if (s5 !== peg$FAILED) {
                    s4 = [s4, s5];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f34(s1, s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseverbatim_listings() {
              var s0, s1, s2, s3, s4;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parseescape();
              if (s1 !== peg$FAILED) {
                if (input.substr(peg$currPos, 9) === peg$c6) {
                  s2 = peg$c6;
                  peg$currPos += 9;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e18);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsesquare_bracket_argument();
                  if (s3 === peg$FAILED) {
                    s3 = null;
                  }
                  s4 = peg$parseverbatim_group();
                  if (s4 === peg$FAILED) {
                    s4 = peg$parseverbatim_delimited_by_char();
                  }
                  if (s4 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f35(s2, s3, s4);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e17);
                }
              }
              return s0;
            }
            function peg$parseverbatim_minted() {
              var s0, s1, s2, s3, s4, s5;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parseescape();
              if (s1 !== peg$FAILED) {
                if (input.substr(peg$currPos, 10) === peg$c7) {
                  s2 = peg$c7;
                  peg$currPos += 10;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e20);
                  }
                }
                if (s2 === peg$FAILED) {
                  if (input.substr(peg$currPos, 4) === peg$c8) {
                    s2 = peg$c8;
                    peg$currPos += 4;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e21);
                    }
                  }
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsesquare_bracket_argument();
                  if (s3 === peg$FAILED) {
                    s3 = null;
                  }
                  s4 = peg$parsegroup();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseverbatim_group();
                    if (s5 === peg$FAILED) {
                      s5 = peg$parseverbatim_delimited_by_char();
                    }
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s0 = peg$f36(s2, s3, s4, s5);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e19);
                }
              }
              return s0;
            }
            function peg$parseverbatim_minted_environment() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parsebegin_env();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsebegin_group();
                if (s2 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 6) === peg$c9) {
                    s3 = peg$c9;
                    peg$currPos += 6;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e23);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parseend_group();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsesquare_bracket_argument();
                      if (s5 === peg$FAILED) {
                        s5 = null;
                      }
                      s6 = peg$parsegroup();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$currPos;
                        s8 = [];
                        s9 = peg$currPos;
                        s10 = peg$currPos;
                        peg$silentFails++;
                        s11 = peg$currPos;
                        s12 = peg$parseend_env();
                        if (s12 !== peg$FAILED) {
                          s13 = peg$parsegroup();
                          if (s13 !== peg$FAILED) {
                            peg$savedPos = peg$currPos;
                            s14 = peg$f37(s3, s5, s6, s13);
                            if (s14) {
                              s14 = void 0;
                            } else {
                              s14 = peg$FAILED;
                            }
                            if (s14 !== peg$FAILED) {
                              s12 = [s12, s13, s14];
                              s11 = s12;
                            } else {
                              peg$currPos = s11;
                              s11 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s11;
                            s11 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s11;
                          s11 = peg$FAILED;
                        }
                        peg$silentFails--;
                        if (s11 === peg$FAILED) {
                          s10 = void 0;
                        } else {
                          peg$currPos = s10;
                          s10 = peg$FAILED;
                        }
                        if (s10 !== peg$FAILED) {
                          if (input.length > peg$currPos) {
                            s11 = input.charAt(peg$currPos);
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e3);
                            }
                          }
                          if (s11 !== peg$FAILED) {
                            s10 = [s10, s11];
                            s9 = s10;
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                        while (s9 !== peg$FAILED) {
                          s8.push(s9);
                          s9 = peg$currPos;
                          s10 = peg$currPos;
                          peg$silentFails++;
                          s11 = peg$currPos;
                          s12 = peg$parseend_env();
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parsegroup();
                            if (s13 !== peg$FAILED) {
                              peg$savedPos = peg$currPos;
                              s14 = peg$f37(s3, s5, s6, s13);
                              if (s14) {
                                s14 = void 0;
                              } else {
                                s14 = peg$FAILED;
                              }
                              if (s14 !== peg$FAILED) {
                                s12 = [s12, s13, s14];
                                s11 = s12;
                              } else {
                                peg$currPos = s11;
                                s11 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s11;
                              s11 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s11;
                            s11 = peg$FAILED;
                          }
                          peg$silentFails--;
                          if (s11 === peg$FAILED) {
                            s10 = void 0;
                          } else {
                            peg$currPos = s10;
                            s10 = peg$FAILED;
                          }
                          if (s10 !== peg$FAILED) {
                            if (input.length > peg$currPos) {
                              s11 = input.charAt(peg$currPos);
                              peg$currPos++;
                            } else {
                              s11 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e3);
                              }
                            }
                            if (s11 !== peg$FAILED) {
                              s10 = [s10, s11];
                              s9 = s10;
                            } else {
                              peg$currPos = s9;
                              s9 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        }
                        s7 = input.substring(s7, peg$currPos);
                        s8 = peg$parseend_env();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parsebegin_group();
                          if (s9 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 6) === peg$c9) {
                              s10 = peg$c9;
                              peg$currPos += 6;
                            } else {
                              s10 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e23);
                              }
                            }
                            if (s10 !== peg$FAILED) {
                              s11 = peg$parseend_group();
                              if (s11 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s0 = peg$f38(s3, s5, s6, s7);
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e22);
                }
              }
              return s0;
            }
            function peg$parseverbatim_environment() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parsebegin_env();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsebegin_group();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parseverbatim_env_name();
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parseend_group();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$currPos;
                      s6 = [];
                      s7 = peg$currPos;
                      s8 = peg$currPos;
                      peg$silentFails++;
                      s9 = peg$currPos;
                      s10 = peg$parseend_env();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parsegroup();
                        if (s11 !== peg$FAILED) {
                          peg$savedPos = peg$currPos;
                          s12 = peg$f39(s3, s11);
                          if (s12) {
                            s12 = void 0;
                          } else {
                            s12 = peg$FAILED;
                          }
                          if (s12 !== peg$FAILED) {
                            s10 = [s10, s11, s12];
                            s9 = s10;
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                      peg$silentFails--;
                      if (s9 === peg$FAILED) {
                        s8 = void 0;
                      } else {
                        peg$currPos = s8;
                        s8 = peg$FAILED;
                      }
                      if (s8 !== peg$FAILED) {
                        if (input.length > peg$currPos) {
                          s9 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s9 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e3);
                          }
                        }
                        if (s9 !== peg$FAILED) {
                          peg$savedPos = s7;
                          s7 = peg$f40(s3, s9);
                        } else {
                          peg$currPos = s7;
                          s7 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                      while (s7 !== peg$FAILED) {
                        s6.push(s7);
                        s7 = peg$currPos;
                        s8 = peg$currPos;
                        peg$silentFails++;
                        s9 = peg$currPos;
                        s10 = peg$parseend_env();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parsegroup();
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = peg$currPos;
                            s12 = peg$f39(s3, s11);
                            if (s12) {
                              s12 = void 0;
                            } else {
                              s12 = peg$FAILED;
                            }
                            if (s12 !== peg$FAILED) {
                              s10 = [s10, s11, s12];
                              s9 = s10;
                            } else {
                              peg$currPos = s9;
                              s9 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                        peg$silentFails--;
                        if (s9 === peg$FAILED) {
                          s8 = void 0;
                        } else {
                          peg$currPos = s8;
                          s8 = peg$FAILED;
                        }
                        if (s8 !== peg$FAILED) {
                          if (input.length > peg$currPos) {
                            s9 = input.charAt(peg$currPos);
                            peg$currPos++;
                          } else {
                            s9 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e3);
                            }
                          }
                          if (s9 !== peg$FAILED) {
                            peg$savedPos = s7;
                            s7 = peg$f40(s3, s9);
                          } else {
                            peg$currPos = s7;
                            s7 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s7;
                          s7 = peg$FAILED;
                        }
                      }
                      s5 = input.substring(s5, peg$currPos);
                      s6 = peg$parseend_env();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parsebegin_group();
                        if (s7 !== peg$FAILED) {
                          s8 = peg$parseverbatim_env_name();
                          if (s8 !== peg$FAILED) {
                            s9 = peg$parseend_group();
                            if (s9 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s0 = peg$f41(s3, s5);
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e24);
                }
              }
              return s0;
            }
            function peg$parseverbatim_env_name() {
              var s0;
              if (input.substr(peg$currPos, 9) === peg$c10) {
                s0 = peg$c10;
                peg$currPos += 9;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e25);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c11) {
                  s0 = peg$c11;
                  peg$currPos += 8;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e26);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 13) === peg$c12) {
                    s0 = peg$c12;
                    peg$currPos += 13;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e27);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 12) === peg$c13) {
                      s0 = peg$c13;
                      peg$currPos += 12;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e28);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 7) === peg$c14) {
                        s0 = peg$c14;
                        peg$currPos += 7;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e29);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 10) === peg$c15) {
                          s0 = peg$c15;
                          peg$currPos += 10;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e30);
                          }
                        }
                      }
                    }
                  }
                }
              }
              return s0;
            }
            function peg$parsemacro() {
              var s0, s1, s2, s3, s4;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = peg$parseescape();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsechar();
                if (s4 !== peg$FAILED) {
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parsechar();
                  }
                } else {
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s1 = peg$f42(s3);
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                s2 = peg$parseescape();
                if (s2 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s1;
                    s1 = peg$f43(s3);
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f44(s1);
              }
              s0 = s1;
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e31);
                }
              }
              return s0;
            }
            function peg$parsegroup() {
              var s0, s1, s2, s3, s4, s5;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parsebegin_group();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseend_group();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = void 0;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsetoken();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s3 = peg$f45(s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$currPos;
                  s4 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parseend_group();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s4 = void 0;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsetoken();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s3 = peg$f45(s5);
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
                s3 = peg$parseend_group();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f46(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e32);
                }
              }
              return s0;
            }
            function peg$parsegroup_contents_as_string() {
              var s0, s1;
              s0 = peg$currPos;
              s1 = peg$parsegroup();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f47();
              }
              s0 = s1;
              return s0;
            }
            function peg$parseenvironment() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parsebegin_env();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsegroup_contents_as_string();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsesameline_comment();
                  if (s3 === peg$FAILED) {
                    s3 = null;
                  }
                  s4 = [];
                  s5 = peg$currPos;
                  s6 = peg$currPos;
                  peg$silentFails++;
                  s7 = peg$currPos;
                  s8 = peg$parseend_env();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsegroup_contents_as_string();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s10 = peg$f48(s2, s3, s9);
                      if (s10) {
                        s10 = void 0;
                      } else {
                        s10 = peg$FAILED;
                      }
                      if (s10 !== peg$FAILED) {
                        s8 = [s8, s9, s10];
                        s7 = s8;
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s7 === peg$FAILED) {
                    s6 = void 0;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parsetoken();
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s5;
                      s5 = peg$f49(s2, s3, s7);
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$currPos;
                    s6 = peg$currPos;
                    peg$silentFails++;
                    s7 = peg$currPos;
                    s8 = peg$parseend_env();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsegroup_contents_as_string();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = peg$currPos;
                        s10 = peg$f48(s2, s3, s9);
                        if (s10) {
                          s10 = void 0;
                        } else {
                          s10 = peg$FAILED;
                        }
                        if (s10 !== peg$FAILED) {
                          s8 = [s8, s9, s10];
                          s7 = s8;
                        } else {
                          peg$currPos = s7;
                          s7 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s7 === peg$FAILED) {
                      s6 = void 0;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parsetoken();
                      if (s7 !== peg$FAILED) {
                        peg$savedPos = s5;
                        s5 = peg$f49(s2, s3, s7);
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  }
                  s5 = peg$parseend_env();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsegroup_contents_as_string();
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s0 = peg$f50(s2, s3, s4);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e33);
                }
              }
              return s0;
            }
            function peg$parsemath_environment() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parsebegin_env();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsebegin_group();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsemath_env_name();
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parseend_group();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsesameline_comment();
                      if (s5 === peg$FAILED) {
                        s5 = null;
                      }
                      s6 = [];
                      s7 = peg$currPos;
                      s8 = peg$currPos;
                      peg$silentFails++;
                      s9 = peg$currPos;
                      s10 = peg$parseend_env();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parsegroup();
                        if (s11 !== peg$FAILED) {
                          peg$savedPos = peg$currPos;
                          s12 = peg$f51(s3, s5, s11);
                          if (s12) {
                            s12 = void 0;
                          } else {
                            s12 = peg$FAILED;
                          }
                          if (s12 !== peg$FAILED) {
                            s10 = [s10, s11, s12];
                            s9 = s10;
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                      peg$silentFails--;
                      if (s9 === peg$FAILED) {
                        s8 = void 0;
                      } else {
                        peg$currPos = s8;
                        s8 = peg$FAILED;
                      }
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parsemath_token();
                        if (s9 !== peg$FAILED) {
                          peg$savedPos = s7;
                          s7 = peg$f52(s3, s5, s9);
                        } else {
                          peg$currPos = s7;
                          s7 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                      while (s7 !== peg$FAILED) {
                        s6.push(s7);
                        s7 = peg$currPos;
                        s8 = peg$currPos;
                        peg$silentFails++;
                        s9 = peg$currPos;
                        s10 = peg$parseend_env();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parsegroup();
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = peg$currPos;
                            s12 = peg$f51(s3, s5, s11);
                            if (s12) {
                              s12 = void 0;
                            } else {
                              s12 = peg$FAILED;
                            }
                            if (s12 !== peg$FAILED) {
                              s10 = [s10, s11, s12];
                              s9 = s10;
                            } else {
                              peg$currPos = s9;
                              s9 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                        peg$silentFails--;
                        if (s9 === peg$FAILED) {
                          s8 = void 0;
                        } else {
                          peg$currPos = s8;
                          s8 = peg$FAILED;
                        }
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parsemath_token();
                          if (s9 !== peg$FAILED) {
                            peg$savedPos = s7;
                            s7 = peg$f52(s3, s5, s9);
                          } else {
                            peg$currPos = s7;
                            s7 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s7;
                          s7 = peg$FAILED;
                        }
                      }
                      s7 = peg$parseend_env();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parsebegin_group();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parsemath_env_name();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parseend_group();
                            if (s10 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s0 = peg$f53(s3, s5, s6);
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e34);
                }
              }
              return s0;
            }
            function peg$parsebegin_display_math() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$parseescape();
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 91) {
                  s2 = peg$c4;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e14);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseend_display_math() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$parseescape();
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s2 = peg$c5;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e15);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsebegin_inline_math() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$parseescape();
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 40) {
                  s2 = peg$c16;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e36);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseend_inline_math() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$parseescape();
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s2 = peg$c17;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e37);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsebegin_env() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$parseescape();
              if (s1 !== peg$FAILED) {
                if (input.substr(peg$currPos, 5) === peg$c18) {
                  s2 = peg$c18;
                  peg$currPos += 5;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e38);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseend_env() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$parseescape();
              if (s1 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c19) {
                  s2 = peg$c19;
                  peg$currPos += 3;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e39);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsemath_env_name() {
              var s0, s1;
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 9) === peg$c20) {
                s1 = peg$c20;
                peg$currPos += 9;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e40);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c21) {
                  s1 = peg$c21;
                  peg$currPos += 8;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e41);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 6) === peg$c22) {
                    s1 = peg$c22;
                    peg$currPos += 6;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e42);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 5) === peg$c23) {
                      s1 = peg$c23;
                      peg$currPos += 5;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e43);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 8) === peg$c24) {
                        s1 = peg$c24;
                        peg$currPos += 8;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e44);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 7) === peg$c25) {
                          s1 = peg$c25;
                          peg$currPos += 7;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e45);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 7) === peg$c26) {
                            s1 = peg$c26;
                            peg$currPos += 7;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e46);
                            }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 6) === peg$c27) {
                              s1 = peg$c27;
                              peg$currPos += 6;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e47);
                              }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 9) === peg$c28) {
                                s1 = peg$c28;
                                peg$currPos += 9;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e48);
                                }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 8) === peg$c29) {
                                  s1 = peg$c29;
                                  peg$currPos += 8;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e49);
                                  }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 8) === peg$c30) {
                                    s1 = peg$c30;
                                    peg$currPos += 8;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e50);
                                    }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 7) === peg$c31) {
                                      s1 = peg$c31;
                                      peg$currPos += 7;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$e51);
                                      }
                                    }
                                    if (s1 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 5) === peg$c32) {
                                        s1 = peg$c32;
                                        peg$currPos += 5;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$e52);
                                        }
                                      }
                                      if (s1 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 4) === peg$c33) {
                                          s1 = peg$c33;
                                          peg$currPos += 4;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$e53);
                                          }
                                        }
                                        if (s1 === peg$FAILED) {
                                          if (input.substr(peg$currPos, 11) === peg$c34) {
                                            s1 = peg$c34;
                                            peg$currPos += 11;
                                          } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                              peg$fail(peg$e54);
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f56(s1);
              }
              s0 = s1;
              return s0;
            }
            function peg$parseescape() {
              var s0, s1;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 92) {
                s1 = peg$c35;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e56);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f57();
              }
              s0 = s1;
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e55);
                }
              }
              return s0;
            }
            function peg$parsebegin_group() {
              var s0, s1;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 123) {
                s1 = peg$c36;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e57);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f58(s1);
              }
              s0 = s1;
              return s0;
            }
            function peg$parseend_group() {
              var s0, s1;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 125) {
                s1 = peg$c37;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e58);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f59(s1);
              }
              s0 = s1;
              return s0;
            }
            function peg$parsemath_shift() {
              var s0, s1;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 36) {
                s1 = peg$c38;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e59);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f60(s1);
              }
              s0 = s1;
              return s0;
            }
            function peg$parsealignment_tab() {
              var s0, s1;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 38) {
                s1 = peg$c39;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e60);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f61(s1);
              }
              s0 = s1;
              return s0;
            }
            function peg$parsenl() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 13) {
                s2 = peg$c40;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e62);
                }
              }
              peg$silentFails--;
              if (s2 === peg$FAILED) {
                s1 = void 0;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 10) {
                  s2 = peg$c41;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e63);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 13) {
                  s0 = peg$c40;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e62);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c42) {
                    s0 = peg$c42;
                    peg$currPos += 2;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e64);
                    }
                  }
                }
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e61);
                }
              }
              return s0;
            }
            function peg$parsemacro_parameter() {
              var s0, s1;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 35) {
                s1 = peg$c43;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e65);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f62(s1);
              }
              s0 = s1;
              return s0;
            }
            function peg$parsesuperscript() {
              var s0, s1;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 94) {
                s1 = peg$c44;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e66);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f63(s1);
              }
              s0 = s1;
              return s0;
            }
            function peg$parsesubscript() {
              var s0, s1;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 95) {
                s1 = peg$c45;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e67);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f64(s1);
              }
              s0 = s1;
              return s0;
            }
            function peg$parseignore() {
              var s0;
              if (input.charCodeAt(peg$currPos) === 0) {
                s0 = peg$c46;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e68);
                }
              }
              return s0;
            }
            function peg$parsesp() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = [];
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e69);
                }
              }
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  if (peg$r1.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e69);
                    }
                  }
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f65();
              }
              s0 = s1;
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e8);
                }
              }
              return s0;
            }
            function peg$parsechar() {
              var s0;
              peg$silentFails++;
              if (peg$r2.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e71);
                }
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                if (peg$silentFails === 0) {
                  peg$fail(peg$e70);
                }
              }
              return s0;
            }
            function peg$parsenum() {
              var s0;
              peg$silentFails++;
              if (peg$r3.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e73);
                }
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                if (peg$silentFails === 0) {
                  peg$fail(peg$e72);
                }
              }
              return s0;
            }
            function peg$parsepunctuation() {
              var s0, s1;
              peg$silentFails++;
              s0 = peg$currPos;
              if (peg$r4.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e75);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f66(s1);
              }
              s0 = s1;
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e74);
                }
              }
              return s0;
            }
            function peg$parsecomment_start() {
              var s0;
              if (input.charCodeAt(peg$currPos) === 37) {
                s0 = peg$c0;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e7);
                }
              }
              return s0;
            }
            function peg$parsefull_comment() {
              var s0;
              peg$silentFails++;
              s0 = peg$parseownline_comment();
              if (s0 === peg$FAILED) {
                s0 = peg$parsesameline_comment();
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                if (peg$silentFails === 0) {
                  peg$fail(peg$e76);
                }
              }
              return s0;
            }
            function peg$parseownline_comment() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = [];
              s3 = peg$parsesp();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsesp();
              }
              s3 = peg$parsenl();
              if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 === peg$FAILED) {
                s1 = null;
              }
              s2 = peg$parseleading_sp();
              if (s2 !== peg$FAILED) {
                s3 = peg$parsecomment();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f67(s2, s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsesameline_comment() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsesp();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsesp();
              }
              s2 = peg$parsecomment();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f68(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsecomment() {
              var s0, s1, s2, s3, s4, s5, s6, s7;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parsecomment_start();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parsenl();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = void 0;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s3 = peg$f69(s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$currPos;
                  s4 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parsenl();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s4 = void 0;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s5 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s3 = peg$f69(s5);
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
                s3 = peg$currPos;
                peg$silentFails++;
                s4 = peg$parseparbreak();
                peg$silentFails--;
                if (s4 !== peg$FAILED) {
                  peg$currPos = s3;
                  s3 = void 0;
                } else {
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f70(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsecomment_start();
                if (s1 !== peg$FAILED) {
                  s2 = [];
                  s3 = peg$currPos;
                  s4 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parsenl();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s4 = void 0;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s5 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s3 = peg$f71(s5);
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$currPos;
                    s4 = peg$currPos;
                    peg$silentFails++;
                    s5 = peg$parsenl();
                    peg$silentFails--;
                    if (s5 === peg$FAILED) {
                      s4 = void 0;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                    if (s4 !== peg$FAILED) {
                      if (input.length > peg$currPos) {
                        s5 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e3);
                        }
                      }
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s3 = peg$f71(s5);
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  }
                  s3 = peg$currPos;
                  s4 = peg$parsenl();
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parsesp();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parsesp();
                    }
                    s6 = peg$currPos;
                    peg$silentFails++;
                    s7 = peg$parsecomment_start();
                    peg$silentFails--;
                    if (s7 === peg$FAILED) {
                      s6 = void 0;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                    if (s6 !== peg$FAILED) {
                      s4 = [s4, s5, s6];
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 === peg$FAILED) {
                    s3 = peg$parsenl();
                    if (s3 === peg$FAILED) {
                      s3 = peg$parseEOF();
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f72(s2);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e77);
                }
              }
              return s0;
            }
            function peg$parseleading_sp() {
              var s0, s1, s2, s3, s4;
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = peg$parsestart_of_line();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsesp();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsesp();
                }
                s2 = [s2, s3];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s0 = input.substring(s0, peg$currPos);
              } else {
                s0 = s1;
              }
              return s0;
            }
            function peg$parsestart_of_line() {
              var s0;
              peg$savedPos = peg$currPos;
              s0 = peg$f73();
              if (s0) {
                s0 = void 0;
              } else {
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseEOF() {
              var s0, s1;
              s0 = peg$currPos;
              peg$silentFails++;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              peg$silentFails--;
              if (s1 === peg$FAILED) {
                s0 = void 0;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function toString2(e) {
              if (typeof e === "string") {
                return e;
              }
              if (typeof e.content === "string") {
                return e.content;
              }
              if (e && e.type === "whitespace") {
                return " ";
              }
              return e;
            }
            function compare_env(g1, g2) {
              const g1Name = typeof g1 === "string" ? g1 : g1.content.map(toString2).join("");
              const g2Name = typeof g2 === "string" ? g2 : g2.content.map(toString2).join("");
              return g1Name === g2Name;
            }
            function createNode(type, extra = {}) {
              return { type, ...extra, position: location2() };
            }
            peg$result = peg$startRuleFunction();
            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
              return peg$result;
            } else {
              if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                peg$fail(peg$endExpectation());
              }
              throw peg$buildStructuredError(
                peg$maxFailExpected,
                peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
                peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
              );
            }
          }
          return {
            SyntaxError: peg$SyntaxError,
            parse: peg$parse
          };
        }()
      );
      var _AlignEnvironmentPegParser = (
        // Generated by Peggy 3.0.2.
        //
        // https://peggyjs.org/
        function() {
          function peg$subclass(child, parent) {
            function C() {
              this.constructor = child;
            }
            C.prototype = parent.prototype;
            child.prototype = new C();
          }
          function peg$SyntaxError(message, expected, found, location2) {
            var self2 = Error.call(this, message);
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
            }
            self2.expected = expected;
            self2.found = found;
            self2.location = location2;
            self2.name = "SyntaxError";
            return self2;
          }
          peg$subclass(peg$SyntaxError, Error);
          function peg$padEnd(str, targetLength, padString) {
            padString = padString || " ";
            if (str.length > targetLength) {
              return str;
            }
            targetLength -= str.length;
            padString += padString.repeat(targetLength);
            return str + padString.slice(0, targetLength);
          }
          peg$SyntaxError.prototype.format = function(sources) {
            var str = "Error: " + this.message;
            if (this.location) {
              var src = null;
              var k;
              for (k = 0; k < sources.length; k++) {
                if (sources[k].source === this.location.source) {
                  src = sources[k].text.split(/\r\n|\n|\r/g);
                  break;
                }
              }
              var s = this.location.start;
              var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
              var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
              if (src) {
                var e = this.location.end;
                var filler = peg$padEnd("", offset_s.line.toString().length, " ");
                var line = src[s.line - 1];
                var last = s.line === e.line ? e.column : line.length + 1;
                var hatLen = last - s.column || 1;
                str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
              } else {
                str += "\n at " + loc;
              }
            }
            return str;
          };
          peg$SyntaxError.buildMessage = function(expected, found) {
            var DESCRIBE_EXPECTATION_FNS = {
              literal: function(expectation) {
                return '"' + literalEscape(expectation.text) + '"';
              },
              class: function(expectation) {
                var escapedParts = expectation.parts.map(function(part) {
                  return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
                });
                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
              },
              any: function() {
                return "any character";
              },
              end: function() {
                return "end of input";
              },
              other: function(expectation) {
                return expectation.description;
              }
            };
            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            function literalEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function classEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function describeExpectation(expectation) {
              return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
            }
            function describeExpected(expected2) {
              var descriptions = expected2.map(describeExpectation);
              var i, j;
              descriptions.sort();
              if (descriptions.length > 0) {
                for (i = 1, j = 1; i < descriptions.length; i++) {
                  if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                  }
                }
                descriptions.length = j;
              }
              switch (descriptions.length) {
                case 1:
                  return descriptions[0];
                case 2:
                  return descriptions[0] + " or " + descriptions[1];
                default:
                  return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
              }
            }
            function describeFound(found2) {
              return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
            }
            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
          };
          function peg$parse(input, options2) {
            options2 = options2 !== void 0 ? options2 : {};
            var peg$FAILED = {};
            var peg$source = options2.grammarSource;
            var peg$startRuleFunctions = { body: peg$parsebody };
            var peg$startRuleFunction = peg$parsebody;
            var peg$e0 = peg$anyExpectation();
            var peg$f0 = function() {
              return [];
            };
            var peg$f1 = function(x) {
              return { cells: [], colSeps: [], ...x };
            };
            var peg$f2 = function(rowItems, rowSep, trailingComment) {
              return { ...rowItems, rowSep, trailingComment };
            };
            var peg$f3 = function(rowItems, trailingComment) {
              return { ...rowItems, rowSep: null, trailingComment };
            };
            var peg$f4 = function(x) {
              return x;
            };
            var peg$f5 = function(x) {
              return {
                cells: [],
                colSeps: [],
                rowSep: null,
                trailingComment: x
              };
            };
            var peg$f6 = function(x) {
              return x;
            };
            var peg$f7 = function(colSep, cell) {
              return { colSep, cell };
            };
            var peg$f8 = function(colSep) {
              return { colSep };
            };
            var peg$f9 = function(a, b) {
              return processRow(a, b);
            };
            var peg$f10 = function(b) {
              return processRow(null, b);
            };
            var peg$f11 = function(tok) {
              return options2.isSameLineComment(tok);
            };
            var peg$f12 = function(tok) {
              return tok;
            };
            var peg$f13 = function(tok) {
              return options2.isOwnLineComment(tok);
            };
            var peg$f14 = function(tok) {
              return tok;
            };
            var peg$f15 = function(tok) {
              return options2.isWhitespace(tok);
            };
            var peg$f16 = function(tok) {
              return tok;
            };
            var peg$f17 = function(tok) {
              return options2.isRowSep(tok);
            };
            var peg$f18 = function(tok) {
              return tok;
            };
            var peg$f19 = function(tok) {
              return options2.isColSep(tok);
            };
            var peg$f20 = function(tok) {
              return tok;
            };
            var peg$currPos = 0;
            var peg$posDetailsCache = [{ line: 1, column: 1 }];
            var peg$maxFailPos = 0;
            var peg$maxFailExpected = [];
            var peg$silentFails = 0;
            var peg$result;
            if ("startRule" in options2) {
              if (!(options2.startRule in peg$startRuleFunctions)) {
                throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
              }
              peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
            }
            function peg$anyExpectation() {
              return { type: "any" };
            }
            function peg$endExpectation() {
              return { type: "end" };
            }
            function peg$computePosDetails(pos) {
              var details = peg$posDetailsCache[pos];
              var p;
              if (details) {
                return details;
              } else {
                p = pos - 1;
                while (!peg$posDetailsCache[p]) {
                  p--;
                }
                details = peg$posDetailsCache[p];
                details = {
                  line: details.line,
                  column: details.column
                };
                while (p < pos) {
                  if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                  } else {
                    details.column++;
                  }
                  p++;
                }
                peg$posDetailsCache[pos] = details;
                return details;
              }
            }
            function peg$computeLocation(startPos, endPos, offset2) {
              var startPosDetails = peg$computePosDetails(startPos);
              var endPosDetails = peg$computePosDetails(endPos);
              var res = {
                source: peg$source,
                start: {
                  offset: startPos,
                  line: startPosDetails.line,
                  column: startPosDetails.column
                },
                end: {
                  offset: endPos,
                  line: endPosDetails.line,
                  column: endPosDetails.column
                }
              };
              if (offset2 && peg$source && typeof peg$source.offset === "function") {
                res.start = peg$source.offset(res.start);
                res.end = peg$source.offset(res.end);
              }
              return res;
            }
            function peg$fail(expected2) {
              if (peg$currPos < peg$maxFailPos) {
                return;
              }
              if (peg$currPos > peg$maxFailPos) {
                peg$maxFailPos = peg$currPos;
                peg$maxFailExpected = [];
              }
              peg$maxFailExpected.push(expected2);
            }
            function peg$buildStructuredError(expected2, found, location2) {
              return new peg$SyntaxError(
                peg$SyntaxError.buildMessage(expected2, found),
                expected2,
                found,
                location2
              );
            }
            function peg$parsebody() {
              var s0, s1;
              s0 = [];
              s1 = peg$parsecomment_only_line();
              if (s1 === peg$FAILED) {
                s1 = peg$parserow_with_end();
                if (s1 === peg$FAILED) {
                  s1 = peg$parserow_without_end();
                }
              }
              if (s1 !== peg$FAILED) {
                while (s1 !== peg$FAILED) {
                  s0.push(s1);
                  s1 = peg$parsecomment_only_line();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parserow_with_end();
                    if (s1 === peg$FAILED) {
                      s1 = peg$parserow_without_end();
                    }
                  }
                }
              } else {
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseEOL();
                if (s1 !== peg$FAILED) {
                  s1 = peg$f0();
                }
                s0 = s1;
              }
              return s0;
            }
            function peg$parserow_with_end() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = peg$parserow_items();
              if (s2 === peg$FAILED) {
                s2 = null;
              }
              s2 = peg$f1(s2);
              s1 = s2;
              s2 = peg$parserow_sep();
              if (s2 !== peg$FAILED) {
                s3 = peg$parsetrailing_comment();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                s0 = peg$f2(s1, s2, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parserow_without_end() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$parserow_items();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsetrailing_comment();
                if (s2 === peg$FAILED) {
                  s2 = null;
                }
                s0 = peg$f3(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsetrailing_comment() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsewhitespace();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsewhitespace();
              }
              s2 = peg$parsesame_line_comment();
              if (s2 !== peg$FAILED) {
                s0 = peg$f4(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsecomment_only_line() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsewhitespace();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsewhitespace();
              }
              s2 = peg$parseown_line_comment();
              if (s2 !== peg$FAILED) {
                s0 = peg$f5(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsetoken() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              s2 = peg$parserow_sep();
              if (s2 === peg$FAILED) {
                s2 = peg$parsecol_sep();
                if (s2 === peg$FAILED) {
                  s2 = peg$parsetrailing_comment();
                  if (s2 === peg$FAILED) {
                    s2 = peg$parseown_line_comment();
                  }
                }
              }
              peg$silentFails--;
              if (s2 === peg$FAILED) {
                s1 = void 0;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f6(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsecell() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsetoken();
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$parsetoken();
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s0 = input.substring(s0, peg$currPos);
              } else {
                s0 = s1;
              }
              return s0;
            }
            function peg$parseseparated_cell() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$parsecol_sep();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsecell();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f7(s1, s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsecol_sep();
                if (s1 !== peg$FAILED) {
                  s1 = peg$f8(s1);
                }
                s0 = s1;
              }
              return s0;
            }
            function peg$parserow_items() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              s1 = peg$parsecell();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parseseparated_cell();
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseseparated_cell();
                }
                s0 = peg$f9(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                s2 = peg$parseseparated_cell();
                if (s2 !== peg$FAILED) {
                  while (s2 !== peg$FAILED) {
                    s1.push(s2);
                    s2 = peg$parseseparated_cell();
                  }
                } else {
                  s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                  s1 = peg$f10(s1);
                }
                s0 = s1;
              }
              return s0;
            }
            function peg$parsesame_line_comment() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f11(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f12(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseown_line_comment() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f13(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f14(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsewhitespace() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f15(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f16(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parserow_sep() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f17(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f18(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsecol_sep() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f19(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f20(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseEOL() {
              var s0, s1;
              s0 = peg$currPos;
              peg$silentFails++;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              peg$silentFails--;
              if (s1 === peg$FAILED) {
                s0 = void 0;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function processRow(leadCell, otherCells) {
              const cells = [leadCell || []];
              const seps = [];
              for (const x of otherCells) {
                cells.push(x.cell || []);
                seps.push(x.colSep);
              }
              return { cells, colSeps: seps };
            }
            if (!options2.isWhitespace) {
              try {
                Object.assign(
                  options2,
                  createMatchers(["\\", "hline", "cr"], ["&"])
                );
              } catch (e) {
                console.warn("Error when initializing parser", e);
              }
            }
            peg$result = peg$startRuleFunction();
            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
              return peg$result;
            } else {
              if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                peg$fail(peg$endExpectation());
              }
              throw peg$buildStructuredError(
                peg$maxFailExpected,
                peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
                peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
              );
            }
          }
          return {
            SyntaxError: peg$SyntaxError,
            parse: peg$parse
          };
        }()
      );
      var _ArgSpecPegParser = (
        // Generated by Peggy 3.0.2.
        //
        // https://peggyjs.org/
        function() {
          function peg$subclass(child, parent) {
            function C() {
              this.constructor = child;
            }
            C.prototype = parent.prototype;
            child.prototype = new C();
          }
          function peg$SyntaxError(message, expected, found, location2) {
            var self2 = Error.call(this, message);
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
            }
            self2.expected = expected;
            self2.found = found;
            self2.location = location2;
            self2.name = "SyntaxError";
            return self2;
          }
          peg$subclass(peg$SyntaxError, Error);
          function peg$padEnd(str, targetLength, padString) {
            padString = padString || " ";
            if (str.length > targetLength) {
              return str;
            }
            targetLength -= str.length;
            padString += padString.repeat(targetLength);
            return str + padString.slice(0, targetLength);
          }
          peg$SyntaxError.prototype.format = function(sources) {
            var str = "Error: " + this.message;
            if (this.location) {
              var src = null;
              var k;
              for (k = 0; k < sources.length; k++) {
                if (sources[k].source === this.location.source) {
                  src = sources[k].text.split(/\r\n|\n|\r/g);
                  break;
                }
              }
              var s = this.location.start;
              var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
              var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
              if (src) {
                var e = this.location.end;
                var filler = peg$padEnd("", offset_s.line.toString().length, " ");
                var line = src[s.line - 1];
                var last = s.line === e.line ? e.column : line.length + 1;
                var hatLen = last - s.column || 1;
                str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
              } else {
                str += "\n at " + loc;
              }
            }
            return str;
          };
          peg$SyntaxError.buildMessage = function(expected, found) {
            var DESCRIBE_EXPECTATION_FNS = {
              literal: function(expectation) {
                return '"' + literalEscape(expectation.text) + '"';
              },
              class: function(expectation) {
                var escapedParts = expectation.parts.map(function(part) {
                  return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
                });
                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
              },
              any: function() {
                return "any character";
              },
              end: function() {
                return "end of input";
              },
              other: function(expectation) {
                return expectation.description;
              }
            };
            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            function literalEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function classEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function describeExpectation(expectation) {
              return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
            }
            function describeExpected(expected2) {
              var descriptions = expected2.map(describeExpectation);
              var i, j;
              descriptions.sort();
              if (descriptions.length > 0) {
                for (i = 1, j = 1; i < descriptions.length; i++) {
                  if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                  }
                }
                descriptions.length = j;
              }
              switch (descriptions.length) {
                case 1:
                  return descriptions[0];
                case 2:
                  return descriptions[0] + " or " + descriptions[1];
                default:
                  return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
              }
            }
            function describeFound(found2) {
              return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
            }
            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
          };
          function peg$parse(input, options2) {
            options2 = options2 !== void 0 ? options2 : {};
            var peg$FAILED = {};
            var peg$source = options2.grammarSource;
            var peg$startRuleFunctions = { args_spec_list: peg$parseargs_spec_list };
            var peg$startRuleFunction = peg$parseargs_spec_list;
            var peg$c1 = "v";
            var peg$c2 = "b";
            var peg$c3 = "!";
            var peg$c4 = "D";
            var peg$c5 = "d";
            var peg$c6 = "s";
            var peg$c7 = "O";
            var peg$c8 = "o";
            var peg$c9 = "e";
            var peg$c10 = "E";
            var peg$c11 = "t";
            var peg$c12 = "R";
            var peg$c13 = "r";
            var peg$c14 = "u";
            var peg$c15 = "m";
            var peg$c16 = "{";
            var peg$c17 = "}";
            var peg$c18 = " ";
            var peg$c19 = "\n";
            var peg$c20 = "\r";
            var peg$c21 = "\\";
            var peg$r0 = /^[{ ]/;
            var peg$r1 = /^[a-zA-Z]/;
            var peg$r2 = /^[{}]/;
            var peg$e0 = peg$literalExpectation("+", false);
            var peg$e1 = peg$literalExpectation("v", false);
            var peg$e2 = peg$anyExpectation();
            var peg$e3 = peg$literalExpectation("b", false);
            var peg$e4 = peg$literalExpectation("!", false);
            var peg$e5 = peg$literalExpectation("D", false);
            var peg$e6 = peg$literalExpectation("d", false);
            var peg$e7 = peg$literalExpectation("s", false);
            var peg$e8 = peg$literalExpectation("O", false);
            var peg$e9 = peg$literalExpectation("o", false);
            var peg$e10 = peg$literalExpectation("e", false);
            var peg$e11 = peg$literalExpectation("E", false);
            var peg$e12 = peg$literalExpectation("t", false);
            var peg$e13 = peg$literalExpectation("R", false);
            var peg$e14 = peg$literalExpectation("r", false);
            var peg$e15 = peg$literalExpectation("u", false);
            var peg$e16 = peg$classExpectation(["{", " "], false, false);
            var peg$e17 = peg$literalExpectation("m", false);
            var peg$e18 = peg$literalExpectation("{", false);
            var peg$e19 = peg$literalExpectation("}", false);
            var peg$e20 = peg$literalExpectation(" ", false);
            var peg$e21 = peg$literalExpectation("\n", false);
            var peg$e22 = peg$literalExpectation("\r", false);
            var peg$e23 = peg$literalExpectation("\\", false);
            var peg$e24 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
            var peg$e25 = peg$classExpectation(["{", "}"], false, false);
            var peg$f0 = function(x) {
              return x;
            };
            var peg$f1 = function(spec) {
              return spec;
            };
            var peg$f2 = function(spec) {
              return spec;
            };
            var peg$f3 = function(openBrace) {
              return createNode("verbatim", { openBrace, closeBrace: openBrace });
            };
            var peg$f4 = function() {
              return createNode("body");
            };
            var peg$f5 = function(leading_bang, spec) {
              return leading_bang ? { ...spec, noLeadingWhitespace: true } : spec;
            };
            var peg$f6 = function(braceSpec, defaultArg) {
              return createNode("optional", { ...braceSpec, defaultArg });
            };
            var peg$f7 = function(braceSpec) {
              return createNode("optional", braceSpec);
            };
            var peg$f8 = function() {
              return createNode("optionalStar");
            };
            var peg$f9 = function(g) {
              return createNode("optional", { defaultArg: g });
            };
            var peg$f10 = function() {
              return createNode("optional");
            };
            var peg$f11 = function(args) {
              return createNode("embellishment", {
                embellishmentTokens: args
              });
            };
            var peg$f12 = function(args, g) {
              return createNode("embellishment", {
                embellishmentTokens: args,
                defaultArg: g
              });
            };
            var peg$f13 = function(tok) {
              return createNode("optionalToken", { token: tok });
            };
            var peg$f14 = function(braceSpec, defaultArg) {
              return createNode("mandatory", { ...braceSpec, defaultArg });
            };
            var peg$f15 = function(braceSpec) {
              return createNode("mandatory", braceSpec);
            };
            var peg$f16 = function(stopTokens) {
              return createNode("until", { stopTokens });
            };
            var peg$f17 = function(x) {
              return [x];
            };
            var peg$f18 = function(g) {
              return g.content;
            };
            var peg$f19 = function() {
              return createNode("mandatory");
            };
            var peg$f20 = function(openBrace, closeBrace) {
              return { openBrace, closeBrace };
            };
            var peg$f21 = function(g) {
              return g.content.map(groupToStr).join("");
            };
            var peg$f22 = function(t) {
              return [t];
            };
            var peg$f23 = function(args) {
              return args.filter((a) => !a.match(/^\s*$/));
            };
            var peg$f24 = function(content) {
              return { type: "group", content };
            };
            var peg$f25 = function() {
              return "";
            };
            var peg$currPos = 0;
            var peg$posDetailsCache = [{ line: 1, column: 1 }];
            var peg$maxFailPos = 0;
            var peg$maxFailExpected = [];
            var peg$silentFails = 0;
            var peg$result;
            if ("startRule" in options2) {
              if (!(options2.startRule in peg$startRuleFunctions)) {
                throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
              }
              peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
            }
            function peg$literalExpectation(text2, ignoreCase) {
              return { type: "literal", text: text2, ignoreCase };
            }
            function peg$classExpectation(parts, inverted, ignoreCase) {
              return { type: "class", parts, inverted, ignoreCase };
            }
            function peg$anyExpectation() {
              return { type: "any" };
            }
            function peg$endExpectation() {
              return { type: "end" };
            }
            function peg$computePosDetails(pos) {
              var details = peg$posDetailsCache[pos];
              var p;
              if (details) {
                return details;
              } else {
                p = pos - 1;
                while (!peg$posDetailsCache[p]) {
                  p--;
                }
                details = peg$posDetailsCache[p];
                details = {
                  line: details.line,
                  column: details.column
                };
                while (p < pos) {
                  if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                  } else {
                    details.column++;
                  }
                  p++;
                }
                peg$posDetailsCache[pos] = details;
                return details;
              }
            }
            function peg$computeLocation(startPos, endPos, offset2) {
              var startPosDetails = peg$computePosDetails(startPos);
              var endPosDetails = peg$computePosDetails(endPos);
              var res = {
                source: peg$source,
                start: {
                  offset: startPos,
                  line: startPosDetails.line,
                  column: startPosDetails.column
                },
                end: {
                  offset: endPos,
                  line: endPosDetails.line,
                  column: endPosDetails.column
                }
              };
              if (offset2 && peg$source && typeof peg$source.offset === "function") {
                res.start = peg$source.offset(res.start);
                res.end = peg$source.offset(res.end);
              }
              return res;
            }
            function peg$fail(expected2) {
              if (peg$currPos < peg$maxFailPos) {
                return;
              }
              if (peg$currPos > peg$maxFailPos) {
                peg$maxFailPos = peg$currPos;
                peg$maxFailExpected = [];
              }
              peg$maxFailExpected.push(expected2);
            }
            function peg$buildStructuredError(expected2, found, location2) {
              return new peg$SyntaxError(
                peg$SyntaxError.buildMessage(expected2, found),
                expected2,
                found,
                location2
              );
            }
            function peg$parseargs_spec_list() {
              var s0, s1, s2, s4;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$currPos;
              peg$parsewhitespace();
              s4 = peg$parsearg_spec();
              if (s4 !== peg$FAILED) {
                s2 = peg$f0(s4);
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$currPos;
                peg$parsewhitespace();
                s4 = peg$parsearg_spec();
                if (s4 !== peg$FAILED) {
                  s2 = peg$f0(s4);
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              }
              s2 = peg$parsewhitespace();
              s0 = peg$f1(s1);
              return s0;
            }
            function peg$parsearg_spec() {
              var s0, s2;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 43) {
                peg$currPos++;
              } else {
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              s2 = peg$parseoptional();
              if (s2 === peg$FAILED) {
                s2 = peg$parsemandatory();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseverbatim();
                  if (s2 === peg$FAILED) {
                    s2 = peg$parserequired();
                    if (s2 === peg$FAILED) {
                      s2 = peg$parsebody();
                      if (s2 === peg$FAILED) {
                        s2 = peg$parseuntil();
                      }
                    }
                  }
                }
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f2(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseverbatim() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 118) {
                s1 = peg$c1;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e1);
                }
              }
              if (s1 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f3(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsebody() {
              var s0, s1;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 98) {
                s1 = peg$c2;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s1 = peg$f4();
              }
              s0 = s1;
              return s0;
            }
            function peg$parseoptional() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 33) {
                s1 = peg$c3;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e4);
                }
              }
              if (s1 === peg$FAILED) {
                s1 = null;
              }
              s2 = peg$parseoptional_star();
              if (s2 === peg$FAILED) {
                s2 = peg$parseoptional_standard();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseoptional_delimited();
                  if (s2 === peg$FAILED) {
                    s2 = peg$parseoptional_embellishment();
                    if (s2 === peg$FAILED) {
                      s2 = peg$parseoptional_token();
                    }
                  }
                }
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f5(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseoptional_delimited() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 68) {
                s1 = peg$c4;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e5);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsebrace_spec();
                s3 = peg$parsearg();
                if (s3 !== peg$FAILED) {
                  s0 = peg$f6(s2, s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 100) {
                  s1 = peg$c5;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e6);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parsebrace_spec();
                  s0 = peg$f7(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
              return s0;
            }
            function peg$parseoptional_star() {
              var s0, s1;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 115) {
                s1 = peg$c6;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e7);
                }
              }
              if (s1 !== peg$FAILED) {
                s1 = peg$f8();
              }
              s0 = s1;
              return s0;
            }
            function peg$parseoptional_standard() {
              var s0, s1, s3;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 79) {
                s1 = peg$c7;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e8);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$parsewhitespace();
                s3 = peg$parsearg();
                if (s3 !== peg$FAILED) {
                  s0 = peg$f9(s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 111) {
                  s1 = peg$c8;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e9);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s1 = peg$f10();
                }
                s0 = s1;
              }
              return s0;
            }
            function peg$parseoptional_embellishment() {
              var s0, s1, s3, s5;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 101) {
                s1 = peg$c9;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e10);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$parsewhitespace();
                s3 = peg$parseargs();
                if (s3 !== peg$FAILED) {
                  s0 = peg$f11(s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 69) {
                  s1 = peg$c10;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e11);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$parsewhitespace();
                  s3 = peg$parseargs();
                  if (s3 !== peg$FAILED) {
                    peg$parsewhitespace();
                    s5 = peg$parseargs();
                    if (s5 !== peg$FAILED) {
                      s0 = peg$f12(s3, s5);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
              return s0;
            }
            function peg$parseoptional_token() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 116) {
                s1 = peg$c11;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e12);
                }
              }
              if (s1 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f13(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parserequired() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 82) {
                s1 = peg$c12;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e13);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsebrace_spec();
                s3 = peg$parsearg();
                if (s3 !== peg$FAILED) {
                  s0 = peg$f14(s2, s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 114) {
                  s1 = peg$c13;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e14);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parsebrace_spec();
                  s0 = peg$f15(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
              return s0;
            }
            function peg$parseuntil() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 117) {
                s1 = peg$c14;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e15);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parseuntil_stop_token();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f16(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseuntil_stop_token() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e16);
                }
              }
              peg$silentFails--;
              if (s2 === peg$FAILED) {
                s1 = void 0;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f17(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsebraced_group();
                if (s1 !== peg$FAILED) {
                  s1 = peg$f18(s1);
                }
                s0 = s1;
              }
              return s0;
            }
            function peg$parsemandatory() {
              var s0, s1;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 109) {
                s1 = peg$c15;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e17);
                }
              }
              if (s1 !== peg$FAILED) {
                s1 = peg$f19();
              }
              s0 = s1;
              return s0;
            }
            function peg$parsebrace_spec() {
              var s0, s1, s2, s3, s4, s5;
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = peg$currPos;
              s3 = peg$currPos;
              peg$silentFails++;
              s4 = peg$parsewhitespace_token();
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = void 0;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parsemacro();
                if (s4 === peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e2);
                    }
                  }
                }
                if (s4 !== peg$FAILED) {
                  s3 = [s3, s4];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 === peg$FAILED) {
                s2 = null;
              }
              s1 = input.substring(s1, peg$currPos);
              s2 = peg$currPos;
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parsewhitespace_token();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsemacro();
                if (s5 === peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e2);
                    }
                  }
                }
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              s2 = input.substring(s2, peg$currPos);
              s0 = peg$f20(s1, s2);
              return s0;
            }
            function peg$parsearg() {
              var s0, s1;
              s0 = peg$parsetoken();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsebraced_group();
                if (s1 !== peg$FAILED) {
                  s1 = peg$f21(s1);
                }
                s0 = s1;
              }
              return s0;
            }
            function peg$parseargs() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              s1 = peg$parsetoken();
              if (s1 !== peg$FAILED) {
                s1 = peg$f22(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 123) {
                  s1 = peg$c16;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e18);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = [];
                  s3 = peg$parsearg();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parsewhitespace_token();
                  }
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parsearg();
                    if (s3 === peg$FAILED) {
                      s3 = peg$parsewhitespace_token();
                    }
                  }
                  if (input.charCodeAt(peg$currPos) === 125) {
                    s3 = peg$c17;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e19);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s0 = peg$f23(s2);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
              return s0;
            }
            function peg$parsebraced_group() {
              var s0, s1, s2, s3, s4, s5, s6, s7;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 123) {
                s1 = peg$c16;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                s4 = peg$currPos;
                s5 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 125) {
                  s6 = peg$c17;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e19);
                  }
                }
                peg$silentFails--;
                if (s6 === peg$FAILED) {
                  s5 = void 0;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$currPos;
                  peg$silentFails++;
                  s7 = peg$parsebraced_group();
                  peg$silentFails--;
                  if (s7 === peg$FAILED) {
                    s6 = void 0;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parsetoken();
                    if (s7 === peg$FAILED) {
                      s7 = peg$parsewhitespace_token();
                    }
                    if (s7 !== peg$FAILED) {
                      s5 = [s5, s6, s7];
                      s4 = s5;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s3 = input.substring(s3, peg$currPos);
                } else {
                  s3 = s4;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$parsebraced_group();
                }
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$currPos;
                  s4 = peg$currPos;
                  s5 = peg$currPos;
                  peg$silentFails++;
                  if (input.charCodeAt(peg$currPos) === 125) {
                    s6 = peg$c17;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e19);
                    }
                  }
                  peg$silentFails--;
                  if (s6 === peg$FAILED) {
                    s5 = void 0;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$currPos;
                    peg$silentFails++;
                    s7 = peg$parsebraced_group();
                    peg$silentFails--;
                    if (s7 === peg$FAILED) {
                      s6 = void 0;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parsetoken();
                      if (s7 === peg$FAILED) {
                        s7 = peg$parsewhitespace_token();
                      }
                      if (s7 !== peg$FAILED) {
                        s5 = [s5, s6, s7];
                        s4 = s5;
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    s3 = input.substring(s3, peg$currPos);
                  } else {
                    s3 = s4;
                  }
                  if (s3 === peg$FAILED) {
                    s3 = peg$parsebraced_group();
                  }
                }
                if (input.charCodeAt(peg$currPos) === 125) {
                  s3 = peg$c17;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e19);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s0 = peg$f24(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsewhitespace() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsewhitespace_token();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsewhitespace_token();
              }
              s1 = peg$f25();
              s0 = s1;
              return s0;
            }
            function peg$parsewhitespace_token() {
              var s0;
              if (input.charCodeAt(peg$currPos) === 32) {
                s0 = peg$c18;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 10) {
                  s0 = peg$c19;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e21);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 13) {
                    s0 = peg$c20;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e22);
                    }
                  }
                }
              }
              return s0;
            }
            function peg$parsemacro() {
              var s0, s1, s2, s3, s4;
              s0 = peg$currPos;
              s1 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 92) {
                s2 = peg$c21;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e24);
                  }
                }
                if (s4 !== peg$FAILED) {
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    if (peg$r1.test(input.charAt(peg$currPos))) {
                      s4 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e24);
                      }
                    }
                  }
                } else {
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  s2 = [s2, s3];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s0 = input.substring(s0, peg$currPos);
              } else {
                s0 = s1;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 92) {
                  s2 = peg$c21;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e23);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$currPos;
                  peg$silentFails++;
                  if (peg$r1.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e24);
                    }
                  }
                  peg$silentFails--;
                  if (s4 === peg$FAILED) {
                    s3 = void 0;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s4 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e2);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      s2 = [s2, s3, s4];
                      s1 = s2;
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                  s0 = input.substring(s0, peg$currPos);
                } else {
                  s0 = s1;
                }
              }
              return s0;
            }
            function peg$parsetoken() {
              var s0, s1, s2, s3;
              s0 = peg$parsemacro();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                peg$silentFails++;
                if (peg$r2.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e25);
                  }
                }
                peg$silentFails--;
                if (s2 === peg$FAILED) {
                  s1 = void 0;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$currPos;
                  peg$silentFails++;
                  s3 = peg$parsewhitespace_token();
                  peg$silentFails--;
                  if (s3 === peg$FAILED) {
                    s2 = void 0;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                  if (s2 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s3 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e2);
                      }
                    }
                    if (s3 !== peg$FAILED) {
                      s0 = s3;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
              return s0;
            }
            const DEFAULT_OPTIONS = {
              optional: { openBrace: "[", closeBrace: "]" },
              mandatory: { openBrace: "{", closeBrace: "}" }
            };
            function createNode(type, options22) {
              const computedOptions = DEFAULT_OPTIONS[type] || {};
              return { type, ...computedOptions, ...options22 };
            }
            function groupToStr(node) {
              if (typeof node !== "object" || !node) {
                return node;
              }
              if (node.type === "group") {
                return `{${node.content.map(groupToStr).join("")}}`;
              }
              return node;
            }
            peg$result = peg$startRuleFunction();
            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
              return peg$result;
            } else {
              if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                peg$fail(peg$endExpectation());
              }
              throw peg$buildStructuredError(
                peg$maxFailExpected,
                peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
                peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
              );
            }
          }
          return {
            SyntaxError: peg$SyntaxError,
            parse: peg$parse
          };
        }()
      );
      var _PgfkeysPegParser = (
        // Generated by Peggy 3.0.2.
        //
        // https://peggyjs.org/
        function() {
          function peg$subclass(child, parent) {
            function C() {
              this.constructor = child;
            }
            C.prototype = parent.prototype;
            child.prototype = new C();
          }
          function peg$SyntaxError(message, expected, found, location2) {
            var self2 = Error.call(this, message);
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
            }
            self2.expected = expected;
            self2.found = found;
            self2.location = location2;
            self2.name = "SyntaxError";
            return self2;
          }
          peg$subclass(peg$SyntaxError, Error);
          function peg$padEnd(str, targetLength, padString) {
            padString = padString || " ";
            if (str.length > targetLength) {
              return str;
            }
            targetLength -= str.length;
            padString += padString.repeat(targetLength);
            return str + padString.slice(0, targetLength);
          }
          peg$SyntaxError.prototype.format = function(sources) {
            var str = "Error: " + this.message;
            if (this.location) {
              var src = null;
              var k;
              for (k = 0; k < sources.length; k++) {
                if (sources[k].source === this.location.source) {
                  src = sources[k].text.split(/\r\n|\n|\r/g);
                  break;
                }
              }
              var s = this.location.start;
              var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
              var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
              if (src) {
                var e = this.location.end;
                var filler = peg$padEnd("", offset_s.line.toString().length, " ");
                var line = src[s.line - 1];
                var last = s.line === e.line ? e.column : line.length + 1;
                var hatLen = last - s.column || 1;
                str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
              } else {
                str += "\n at " + loc;
              }
            }
            return str;
          };
          peg$SyntaxError.buildMessage = function(expected, found) {
            var DESCRIBE_EXPECTATION_FNS = {
              literal: function(expectation) {
                return '"' + literalEscape(expectation.text) + '"';
              },
              class: function(expectation) {
                var escapedParts = expectation.parts.map(function(part) {
                  return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
                });
                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
              },
              any: function() {
                return "any character";
              },
              end: function() {
                return "end of input";
              },
              other: function(expectation) {
                return expectation.description;
              }
            };
            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            function literalEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function classEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function describeExpectation(expectation) {
              return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
            }
            function describeExpected(expected2) {
              var descriptions = expected2.map(describeExpectation);
              var i, j;
              descriptions.sort();
              if (descriptions.length > 0) {
                for (i = 1, j = 1; i < descriptions.length; i++) {
                  if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                  }
                }
                descriptions.length = j;
              }
              switch (descriptions.length) {
                case 1:
                  return descriptions[0];
                case 2:
                  return descriptions[0] + " or " + descriptions[1];
                default:
                  return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
              }
            }
            function describeFound(found2) {
              return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
            }
            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
          };
          function peg$parse(input, options2) {
            options2 = options2 !== void 0 ? options2 : {};
            var peg$FAILED = {};
            var peg$source = options2.grammarSource;
            var peg$startRuleFunctions = { body: peg$parsebody };
            var peg$startRuleFunction = peg$parsebody;
            var peg$e0 = peg$anyExpectation();
            var peg$f0 = function() {
              return [];
            };
            var peg$f1 = function(rowItems, trailingComment) {
              return {
                itemParts: [],
                ...rowItems,
                trailingComment,
                trailingComma: true
              };
            };
            var peg$f2 = function(rowItems, trailingComment) {
              return { ...rowItems, trailingComment };
            };
            var peg$f3 = function(a, b) {
              return processItem(a, b);
            };
            var peg$f4 = function(b) {
              return processItem(null, b);
            };
            var peg$f5 = function(cell) {
              return { cell };
            };
            var peg$f6 = function() {
              return {};
            };
            var peg$f7 = function(part) {
              return part;
            };
            var peg$f8 = function(x) {
              return x;
            };
            var peg$f9 = function(space, x) {
              return {
                trailingComment: x,
                leadingParbreak: space.parbreak > 0
              };
            };
            var peg$f10 = function(list) {
              return {
                whitespace: list.filter((x) => options2.isWhitespace(x)).length,
                parbreak: list.filter((x) => options2.isParbreak(x)).length
              };
            };
            var peg$f11 = function() {
              return !options2.allowParenGroups;
            };
            var peg$f12 = function(tok) {
              return options2.isSameLineComment(tok);
            };
            var peg$f13 = function(tok) {
              return tok;
            };
            var peg$f14 = function(tok) {
              return options2.isOwnLineComment(tok);
            };
            var peg$f15 = function(tok) {
              return tok;
            };
            var peg$f16 = function(tok) {
              return options2.isWhitespace(tok);
            };
            var peg$f17 = function(tok) {
              return tok;
            };
            var peg$f18 = function(tok) {
              return options2.isParbreak(tok);
            };
            var peg$f19 = function(tok) {
              return tok;
            };
            var peg$f20 = function(tok) {
              return options2.isComma(tok);
            };
            var peg$f21 = function(tok) {
              return tok;
            };
            var peg$f22 = function(tok) {
              return options2.isEquals(tok);
            };
            var peg$f23 = function(tok) {
              return tok;
            };
            var peg$f24 = function(tok) {
              return options2.isChar(tok, "(");
            };
            var peg$f25 = function(tok) {
              return tok;
            };
            var peg$f26 = function(tok) {
              return options2.isChar(tok, ")");
            };
            var peg$f27 = function(tok) {
              return tok;
            };
            var peg$currPos = 0;
            var peg$posDetailsCache = [{ line: 1, column: 1 }];
            var peg$maxFailPos = 0;
            var peg$maxFailExpected = [];
            var peg$silentFails = 0;
            var peg$result;
            if ("startRule" in options2) {
              if (!(options2.startRule in peg$startRuleFunctions)) {
                throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
              }
              peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
            }
            function peg$anyExpectation() {
              return { type: "any" };
            }
            function peg$endExpectation() {
              return { type: "end" };
            }
            function peg$computePosDetails(pos) {
              var details = peg$posDetailsCache[pos];
              var p;
              if (details) {
                return details;
              } else {
                p = pos - 1;
                while (!peg$posDetailsCache[p]) {
                  p--;
                }
                details = peg$posDetailsCache[p];
                details = {
                  line: details.line,
                  column: details.column
                };
                while (p < pos) {
                  if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                  } else {
                    details.column++;
                  }
                  p++;
                }
                peg$posDetailsCache[pos] = details;
                return details;
              }
            }
            function peg$computeLocation(startPos, endPos, offset2) {
              var startPosDetails = peg$computePosDetails(startPos);
              var endPosDetails = peg$computePosDetails(endPos);
              var res = {
                source: peg$source,
                start: {
                  offset: startPos,
                  line: startPosDetails.line,
                  column: startPosDetails.column
                },
                end: {
                  offset: endPos,
                  line: endPosDetails.line,
                  column: endPosDetails.column
                }
              };
              if (offset2 && peg$source && typeof peg$source.offset === "function") {
                res.start = peg$source.offset(res.start);
                res.end = peg$source.offset(res.end);
              }
              return res;
            }
            function peg$fail(expected2) {
              if (peg$currPos < peg$maxFailPos) {
                return;
              }
              if (peg$currPos > peg$maxFailPos) {
                peg$maxFailPos = peg$currPos;
                peg$maxFailExpected = [];
              }
              peg$maxFailExpected.push(expected2);
            }
            function peg$buildStructuredError(expected2, found, location2) {
              return new peg$SyntaxError(
                peg$SyntaxError.buildMessage(expected2, found),
                expected2,
                found,
                location2
              );
            }
            function peg$parsebody() {
              var s0, s1, s2;
              s0 = [];
              s1 = peg$parsecomment_only_line();
              if (s1 === peg$FAILED) {
                s1 = peg$parseitem_with_end();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseitem_without_end();
                }
              }
              if (s1 !== peg$FAILED) {
                while (s1 !== peg$FAILED) {
                  s0.push(s1);
                  s1 = peg$parsecomment_only_line();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseitem_with_end();
                    if (s1 === peg$FAILED) {
                      s1 = peg$parseitem_without_end();
                    }
                  }
                }
              } else {
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                s2 = peg$parsewhitespace();
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$parsewhitespace();
                }
                s2 = peg$parseEOL();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f0();
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
              return s0;
            }
            function peg$parseitem_with_end() {
              var s0, s2, s4, s5, s6, s7, s8;
              s0 = peg$currPos;
              peg$parsewhitespace_or_parbreaks();
              s2 = peg$parserow_items();
              if (s2 === peg$FAILED) {
                s2 = null;
              }
              peg$parsewhitespace_or_parbreaks();
              s4 = peg$parseitem_sep();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parsewhitespace();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parsewhitespace();
                }
                s6 = peg$parsetrailing_comment();
                if (s6 === peg$FAILED) {
                  s6 = null;
                }
                s7 = [];
                s8 = peg$parsewhitespace();
                while (s8 !== peg$FAILED) {
                  s7.push(s8);
                  s8 = peg$parsewhitespace();
                }
                s0 = peg$f1(s2, s6);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseitem_without_end() {
              var s0, s2, s3;
              s0 = peg$currPos;
              peg$parsewhitespace_or_parbreaks();
              s2 = peg$parserow_items();
              if (s2 !== peg$FAILED) {
                s3 = peg$parsetrailing_comment();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                s0 = peg$f2(s2, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parserow_items() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              s1 = peg$parseitem_part();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parseseparated_part();
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseseparated_part();
                }
                s0 = peg$f3(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                s2 = peg$parseseparated_part();
                if (s2 !== peg$FAILED) {
                  while (s2 !== peg$FAILED) {
                    s1.push(s2);
                    s2 = peg$parseseparated_part();
                  }
                } else {
                  s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                  s1 = peg$f4(s1);
                }
                s0 = s1;
              }
              return s0;
            }
            function peg$parseseparated_part() {
              var s0, s1, s2, s3, s4;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseparbreak();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseparbreak();
              }
              s2 = peg$parseequals();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseparbreak();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseparbreak();
                }
                s4 = peg$parseitem_part();
                if (s4 !== peg$FAILED) {
                  s0 = peg$f5(s4);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                s2 = peg$parseparbreak();
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$parseparbreak();
                }
                s2 = peg$parseequals();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f6();
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
              return s0;
            }
            function peg$parseitem_part() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsewhitespace();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsewhitespace();
              }
              s2 = peg$currPos;
              s3 = [];
              s4 = peg$parsenon_whitespace_non_parbreak_token();
              if (s4 === peg$FAILED) {
                s4 = peg$currPos;
                s5 = peg$parsewhitespace();
                if (s5 === peg$FAILED) {
                  s5 = peg$parseparbreak();
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$currPos;
                  peg$silentFails++;
                  s7 = peg$currPos;
                  s8 = [];
                  s9 = peg$parsewhitespace();
                  if (s9 === peg$FAILED) {
                    s9 = peg$parseparbreak();
                  }
                  while (s9 !== peg$FAILED) {
                    s8.push(s9);
                    s9 = peg$parsewhitespace();
                    if (s9 === peg$FAILED) {
                      s9 = peg$parseparbreak();
                    }
                  }
                  s9 = peg$parsenon_whitespace_non_parbreak_token();
                  if (s9 !== peg$FAILED) {
                    s8 = [s8, s9];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s7 !== peg$FAILED) {
                    peg$currPos = s6;
                    s6 = void 0;
                  } else {
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    s5 = [s5, s6];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsenon_whitespace_non_parbreak_token();
                  if (s4 === peg$FAILED) {
                    s4 = peg$currPos;
                    s5 = peg$parsewhitespace();
                    if (s5 === peg$FAILED) {
                      s5 = peg$parseparbreak();
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$currPos;
                      peg$silentFails++;
                      s7 = peg$currPos;
                      s8 = [];
                      s9 = peg$parsewhitespace();
                      if (s9 === peg$FAILED) {
                        s9 = peg$parseparbreak();
                      }
                      while (s9 !== peg$FAILED) {
                        s8.push(s9);
                        s9 = peg$parsewhitespace();
                        if (s9 === peg$FAILED) {
                          s9 = peg$parseparbreak();
                        }
                      }
                      s9 = peg$parsenon_whitespace_non_parbreak_token();
                      if (s9 !== peg$FAILED) {
                        s8 = [s8, s9];
                        s7 = s8;
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                      peg$silentFails--;
                      if (s7 !== peg$FAILED) {
                        peg$currPos = s6;
                        s6 = void 0;
                      } else {
                        s6 = peg$FAILED;
                      }
                      if (s6 !== peg$FAILED) {
                        s5 = [s5, s6];
                        s4 = s5;
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                s2 = input.substring(s2, peg$currPos);
              } else {
                s2 = s3;
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsewhitespace();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsewhitespace();
                }
                s0 = peg$f7(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsetrailing_comment() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsewhitespace();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsewhitespace();
              }
              s2 = peg$parsesame_line_comment();
              if (s2 !== peg$FAILED) {
                s0 = peg$f8(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsecomment_only_line() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$parsewhitespace_or_parbreaks();
              s2 = peg$parseown_line_comment();
              if (s2 !== peg$FAILED) {
                s0 = peg$f9(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsetoken() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = peg$currPos;
              peg$silentFails++;
              s3 = peg$parsenon_token();
              peg$silentFails--;
              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s2 = [s2, s3];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s0 = input.substring(s0, peg$currPos);
              } else {
                s0 = s1;
              }
              return s0;
            }
            function peg$parsenon_whitespace_non_parbreak_token() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = peg$currPos;
              peg$silentFails++;
              s3 = peg$parsewhitespace();
              if (s3 === peg$FAILED) {
                s3 = peg$parseparbreak();
              }
              peg$silentFails--;
              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseparen_block();
                if (s3 === peg$FAILED) {
                  s3 = peg$parsetoken();
                }
                if (s3 !== peg$FAILED) {
                  s2 = [s2, s3];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s0 = input.substring(s0, peg$currPos);
              } else {
                s0 = s1;
              }
              return s0;
            }
            function peg$parsenon_token() {
              var s0;
              s0 = peg$parseitem_sep();
              if (s0 === peg$FAILED) {
                s0 = peg$parseequals();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsetrailing_comment();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseown_line_comment();
                  }
                }
              }
              return s0;
            }
            function peg$parsewhitespace_or_parbreaks() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsewhitespace();
              if (s2 === peg$FAILED) {
                s2 = peg$parseparbreak();
              }
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsewhitespace();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseparbreak();
                }
              }
              s1 = peg$f10(s1);
              s0 = s1;
              return s0;
            }
            function peg$parseparen_block() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8;
              s0 = peg$currPos;
              s1 = peg$f11();
              if (s1) {
                s1 = peg$FAILED;
              } else {
                s1 = void 0;
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$currPos;
                s4 = peg$parseopen_paren();
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$currPos;
                  s7 = peg$currPos;
                  peg$silentFails++;
                  s8 = peg$parseclose_paren();
                  peg$silentFails--;
                  if (s8 === peg$FAILED) {
                    s7 = void 0;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  if (s7 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s8 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      s7 = [s7, s8];
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$currPos;
                    s7 = peg$currPos;
                    peg$silentFails++;
                    s8 = peg$parseclose_paren();
                    peg$silentFails--;
                    if (s8 === peg$FAILED) {
                      s7 = void 0;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                    if (s7 !== peg$FAILED) {
                      if (input.length > peg$currPos) {
                        s8 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e0);
                        }
                      }
                      if (s8 !== peg$FAILED) {
                        s7 = [s7, s8];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  }
                  s6 = peg$parseclose_paren();
                  if (s6 !== peg$FAILED) {
                    s4 = [s4, s5, s6];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  s2 = input.substring(s2, peg$currPos);
                } else {
                  s2 = s3;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsesame_line_comment() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f12(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f13(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseown_line_comment() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f14(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f15(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsewhitespace() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f16(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f17(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseparbreak() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f18(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f19(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseitem_sep() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f20(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f21(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseequals() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f22(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f23(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseopen_paren() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f24(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f25(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseclose_paren() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f26(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f27(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseEOL() {
              var s0, s1;
              s0 = peg$currPos;
              peg$silentFails++;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              peg$silentFails--;
              if (s1 === peg$FAILED) {
                s0 = void 0;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function processItem(leadCell, otherCells) {
              const cells = [leadCell || []];
              for (const x of otherCells) {
                cells.push(x.cell || []);
              }
              return { itemParts: cells };
            }
            if (!options2.isWhitespace) {
              try {
                Object.assign(options2, {
                  isChar: (node, char) => node.type === "string" && node.content === char,
                  isComma(node) {
                    return node.type === "string" && node.content === ",";
                  },
                  isEquals(node) {
                    return node.type === "string" && node.content === "=";
                  },
                  isParbreak(node) {
                    return node.type === "parbreak";
                  },
                  isWhitespace(node) {
                    return node.type === "whitespace";
                  },
                  isSameLineComment: (node) => node.type === "comment" && node.sameline,
                  isOwnLineComment: (node) => node.type === "comment" && !node.sameline,
                  isComment: (node) => node.type === "comment",
                  allowParenGroups: true
                });
              } catch (e) {
                console.warn("Error when initializing parser", e);
              }
            }
            peg$result = peg$startRuleFunction();
            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
              return peg$result;
            } else {
              if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                peg$fail(peg$endExpectation());
              }
              throw peg$buildStructuredError(
                peg$maxFailExpected,
                peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
                peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
              );
            }
          }
          return {
            SyntaxError: peg$SyntaxError,
            parse: peg$parse
          };
        }()
      );
      var _MacroSubstitutionPegParser = (
        // Generated by Peggy 3.0.2.
        //
        // https://peggyjs.org/
        function() {
          function peg$subclass(child, parent) {
            function C() {
              this.constructor = child;
            }
            C.prototype = parent.prototype;
            child.prototype = new C();
          }
          function peg$SyntaxError(message, expected, found, location2) {
            var self2 = Error.call(this, message);
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
            }
            self2.expected = expected;
            self2.found = found;
            self2.location = location2;
            self2.name = "SyntaxError";
            return self2;
          }
          peg$subclass(peg$SyntaxError, Error);
          function peg$padEnd(str, targetLength, padString) {
            padString = padString || " ";
            if (str.length > targetLength) {
              return str;
            }
            targetLength -= str.length;
            padString += padString.repeat(targetLength);
            return str + padString.slice(0, targetLength);
          }
          peg$SyntaxError.prototype.format = function(sources) {
            var str = "Error: " + this.message;
            if (this.location) {
              var src = null;
              var k;
              for (k = 0; k < sources.length; k++) {
                if (sources[k].source === this.location.source) {
                  src = sources[k].text.split(/\r\n|\n|\r/g);
                  break;
                }
              }
              var s = this.location.start;
              var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
              var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
              if (src) {
                var e = this.location.end;
                var filler = peg$padEnd("", offset_s.line.toString().length, " ");
                var line = src[s.line - 1];
                var last = s.line === e.line ? e.column : line.length + 1;
                var hatLen = last - s.column || 1;
                str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
              } else {
                str += "\n at " + loc;
              }
            }
            return str;
          };
          peg$SyntaxError.buildMessage = function(expected, found) {
            var DESCRIBE_EXPECTATION_FNS = {
              literal: function(expectation) {
                return '"' + literalEscape(expectation.text) + '"';
              },
              class: function(expectation) {
                var escapedParts = expectation.parts.map(function(part) {
                  return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
                });
                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
              },
              any: function() {
                return "any character";
              },
              end: function() {
                return "end of input";
              },
              other: function(expectation) {
                return expectation.description;
              }
            };
            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            function literalEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function classEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function describeExpectation(expectation) {
              return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
            }
            function describeExpected(expected2) {
              var descriptions = expected2.map(describeExpectation);
              var i, j;
              descriptions.sort();
              if (descriptions.length > 0) {
                for (i = 1, j = 1; i < descriptions.length; i++) {
                  if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                  }
                }
                descriptions.length = j;
              }
              switch (descriptions.length) {
                case 1:
                  return descriptions[0];
                case 2:
                  return descriptions[0] + " or " + descriptions[1];
                default:
                  return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
              }
            }
            function describeFound(found2) {
              return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
            }
            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
          };
          function peg$parse(input, options2) {
            options2 = options2 !== void 0 ? options2 : {};
            var peg$FAILED = {};
            var peg$source = options2.grammarSource;
            var peg$startRuleFunctions = { body: peg$parsebody };
            var peg$startRuleFunction = peg$parsebody;
            var peg$e0 = peg$anyExpectation();
            var peg$f0 = function(e) {
              return [].concat(...e).filter((n) => !!n);
            };
            var peg$f1 = function() {
              return [];
            };
            var peg$f2 = function(tok) {
              return options2.isHash(tok);
            };
            var peg$f3 = function(tok) {
              return tok;
            };
            var peg$f4 = function(tok) {
              return options2.isNumber(tok);
            };
            var peg$f5 = function(tok) {
              return tok;
            };
            var peg$f6 = function() {
              return { type: "string", content: "#" };
            };
            var peg$f7 = function(num) {
              const split = options2.splitNumber(num);
              return [{ type: "hash_number", number: split.number }, split.rest];
            };
            var peg$currPos = 0;
            var peg$posDetailsCache = [{ line: 1, column: 1 }];
            var peg$maxFailPos = 0;
            var peg$maxFailExpected = [];
            var peg$silentFails = 0;
            var peg$result;
            if ("startRule" in options2) {
              if (!(options2.startRule in peg$startRuleFunctions)) {
                throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
              }
              peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
            }
            function peg$anyExpectation() {
              return { type: "any" };
            }
            function peg$endExpectation() {
              return { type: "end" };
            }
            function peg$computePosDetails(pos) {
              var details = peg$posDetailsCache[pos];
              var p;
              if (details) {
                return details;
              } else {
                p = pos - 1;
                while (!peg$posDetailsCache[p]) {
                  p--;
                }
                details = peg$posDetailsCache[p];
                details = {
                  line: details.line,
                  column: details.column
                };
                while (p < pos) {
                  if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                  } else {
                    details.column++;
                  }
                  p++;
                }
                peg$posDetailsCache[pos] = details;
                return details;
              }
            }
            function peg$computeLocation(startPos, endPos, offset2) {
              var startPosDetails = peg$computePosDetails(startPos);
              var endPosDetails = peg$computePosDetails(endPos);
              var res = {
                source: peg$source,
                start: {
                  offset: startPos,
                  line: startPosDetails.line,
                  column: startPosDetails.column
                },
                end: {
                  offset: endPos,
                  line: endPosDetails.line,
                  column: endPosDetails.column
                }
              };
              if (offset2 && peg$source && typeof peg$source.offset === "function") {
                res.start = peg$source.offset(res.start);
                res.end = peg$source.offset(res.end);
              }
              return res;
            }
            function peg$fail(expected2) {
              if (peg$currPos < peg$maxFailPos) {
                return;
              }
              if (peg$currPos > peg$maxFailPos) {
                peg$maxFailPos = peg$currPos;
                peg$maxFailExpected = [];
              }
              peg$maxFailExpected.push(expected2);
            }
            function peg$buildStructuredError(expected2, found, location2) {
              return new peg$SyntaxError(
                peg$SyntaxError.buildMessage(expected2, found),
                expected2,
                found,
                location2
              );
            }
            function peg$parsebody() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsedouble_hash();
              if (s2 === peg$FAILED) {
                s2 = peg$parsehash_number();
                if (s2 === peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                }
              }
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$parsedouble_hash();
                  if (s2 === peg$FAILED) {
                    s2 = peg$parsehash_number();
                    if (s2 === peg$FAILED) {
                      if (input.length > peg$currPos) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e0);
                        }
                      }
                    }
                  }
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s1 = peg$f0(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseEOL();
                if (s1 !== peg$FAILED) {
                  s1 = peg$f1();
                }
                s0 = s1;
              }
              return s0;
            }
            function peg$parsehash() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f2(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f3(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsenumber() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f4(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f5(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsedouble_hash() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$parsehash();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsehash();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f6();
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsehash_number() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$parsehash();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsenumber();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f7(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseEOL() {
              var s0, s1;
              s0 = peg$currPos;
              peg$silentFails++;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              peg$silentFails--;
              if (s1 === peg$FAILED) {
                s0 = void 0;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            if (!options2.isHash) {
              try {
                Object.assign(options2, {
                  isHash: (node) => node.type === "string" && node.content === "#",
                  isNumber: (node) => node.type === "string" && 0 < +node.content.charAt(0),
                  splitNumber: (node) => {
                    const number = +node.content.charAt(0);
                    if (node.content.length > 1) {
                      return {
                        number,
                        rest: {
                          type: "string",
                          content: node.content.slice(1)
                        }
                      };
                    }
                    return { number };
                  }
                });
              } catch (e) {
                console.warn("Error when initializing parser", e);
              }
            }
            peg$result = peg$startRuleFunction();
            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
              return peg$result;
            } else {
              if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                peg$fail(peg$endExpectation());
              }
              throw peg$buildStructuredError(
                peg$maxFailExpected,
                peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
                peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
              );
            }
          }
          return {
            SyntaxError: peg$SyntaxError,
            parse: peg$parse
          };
        }()
      );
      var _LigaturesPegParser = (
        // Generated by Peggy 3.0.2.
        //
        // https://peggyjs.org/
        function() {
          function peg$subclass(child, parent) {
            function C() {
              this.constructor = child;
            }
            C.prototype = parent.prototype;
            child.prototype = new C();
          }
          function peg$SyntaxError(message, expected, found, location2) {
            var self2 = Error.call(this, message);
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
            }
            self2.expected = expected;
            self2.found = found;
            self2.location = location2;
            self2.name = "SyntaxError";
            return self2;
          }
          peg$subclass(peg$SyntaxError, Error);
          function peg$padEnd(str, targetLength, padString) {
            padString = padString || " ";
            if (str.length > targetLength) {
              return str;
            }
            targetLength -= str.length;
            padString += padString.repeat(targetLength);
            return str + padString.slice(0, targetLength);
          }
          peg$SyntaxError.prototype.format = function(sources) {
            var str = "Error: " + this.message;
            if (this.location) {
              var src = null;
              var k;
              for (k = 0; k < sources.length; k++) {
                if (sources[k].source === this.location.source) {
                  src = sources[k].text.split(/\r\n|\n|\r/g);
                  break;
                }
              }
              var s = this.location.start;
              var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
              var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
              if (src) {
                var e = this.location.end;
                var filler = peg$padEnd("", offset_s.line.toString().length, " ");
                var line = src[s.line - 1];
                var last = s.line === e.line ? e.column : line.length + 1;
                var hatLen = last - s.column || 1;
                str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
              } else {
                str += "\n at " + loc;
              }
            }
            return str;
          };
          peg$SyntaxError.buildMessage = function(expected, found) {
            var DESCRIBE_EXPECTATION_FNS = {
              literal: function(expectation) {
                return '"' + literalEscape(expectation.text) + '"';
              },
              class: function(expectation) {
                var escapedParts = expectation.parts.map(function(part) {
                  return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
                });
                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
              },
              any: function() {
                return "any character";
              },
              end: function() {
                return "end of input";
              },
              other: function(expectation) {
                return expectation.description;
              }
            };
            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            function literalEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function classEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function describeExpectation(expectation) {
              return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
            }
            function describeExpected(expected2) {
              var descriptions = expected2.map(describeExpectation);
              var i, j;
              descriptions.sort();
              if (descriptions.length > 0) {
                for (i = 1, j = 1; i < descriptions.length; i++) {
                  if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                  }
                }
                descriptions.length = j;
              }
              switch (descriptions.length) {
                case 1:
                  return descriptions[0];
                case 2:
                  return descriptions[0] + " or " + descriptions[1];
                default:
                  return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
              }
            }
            function describeFound(found2) {
              return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
            }
            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
          };
          function peg$parse(input, options2) {
            options2 = options2 !== void 0 ? options2 : {};
            var peg$FAILED = {};
            var peg$source = options2.grammarSource;
            var peg$startRuleFunctions = { body: peg$parsebody };
            var peg$startRuleFunction = peg$parsebody;
            var peg$e0 = peg$anyExpectation();
            var peg$f0 = function(e) {
              return [].concat(...e).filter((n) => !!n);
            };
            var peg$f1 = function() {
              return [];
            };
            var peg$f2 = function(toks) {
              return options2.isRecognized(toks);
            };
            var peg$f3 = function(toks) {
              return options2.isRecognized(toks);
            };
            var peg$f4 = function(tok1, tok2) {
              const split = options2.split(tok2);
              return options2.isRecognized([tok1, split[0]]);
            };
            var peg$f5 = function(tok1, tok2) {
              const split = options2.split(tok2);
              return [options2.isRecognized([tok1, split[0]]), split[1]];
            };
            var peg$f6 = function(tok1, tok2) {
              return options2.isRecognized([tok1, tok2]);
            };
            var peg$f7 = function(tok1, tok2) {
              return options2.isRecognized([tok1, tok2]);
            };
            var peg$f8 = function(toks) {
              return options2.isRecognized(toks);
            };
            var peg$f9 = function(toks) {
              return options2.isRecognized(toks);
            };
            var peg$f10 = function(tok) {
              return options2.isRecognized([tok]);
            };
            var peg$f11 = function(tok) {
              return options2.isRecognized([tok]);
            };
            var peg$f12 = function(tok) {
              return options2.isMacro(tok);
            };
            var peg$f13 = function(tok) {
              return tok;
            };
            var peg$f14 = function(tok) {
              return options2.isWhitespace(tok);
            };
            var peg$f15 = function(tok) {
              return tok;
            };
            var peg$f16 = function(tok) {
              return options2.isSplitable(tok);
            };
            var peg$f17 = function(tok) {
              return tok;
            };
            var peg$currPos = 0;
            var peg$posDetailsCache = [{ line: 1, column: 1 }];
            var peg$maxFailPos = 0;
            var peg$maxFailExpected = [];
            var peg$silentFails = 0;
            var peg$result;
            if ("startRule" in options2) {
              if (!(options2.startRule in peg$startRuleFunctions)) {
                throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
              }
              peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
            }
            function peg$anyExpectation() {
              return { type: "any" };
            }
            function peg$endExpectation() {
              return { type: "end" };
            }
            function peg$computePosDetails(pos) {
              var details = peg$posDetailsCache[pos];
              var p;
              if (details) {
                return details;
              } else {
                p = pos - 1;
                while (!peg$posDetailsCache[p]) {
                  p--;
                }
                details = peg$posDetailsCache[p];
                details = {
                  line: details.line,
                  column: details.column
                };
                while (p < pos) {
                  if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                  } else {
                    details.column++;
                  }
                  p++;
                }
                peg$posDetailsCache[pos] = details;
                return details;
              }
            }
            function peg$computeLocation(startPos, endPos, offset2) {
              var startPosDetails = peg$computePosDetails(startPos);
              var endPosDetails = peg$computePosDetails(endPos);
              var res = {
                source: peg$source,
                start: {
                  offset: startPos,
                  line: startPosDetails.line,
                  column: startPosDetails.column
                },
                end: {
                  offset: endPos,
                  line: endPosDetails.line,
                  column: endPosDetails.column
                }
              };
              if (offset2 && peg$source && typeof peg$source.offset === "function") {
                res.start = peg$source.offset(res.start);
                res.end = peg$source.offset(res.end);
              }
              return res;
            }
            function peg$fail(expected2) {
              if (peg$currPos < peg$maxFailPos) {
                return;
              }
              if (peg$currPos > peg$maxFailPos) {
                peg$maxFailPos = peg$currPos;
                peg$maxFailExpected = [];
              }
              peg$maxFailExpected.push(expected2);
            }
            function peg$buildStructuredError(expected2, found, location2) {
              return new peg$SyntaxError(
                peg$SyntaxError.buildMessage(expected2, found),
                expected2,
                found,
                location2
              );
            }
            function peg$parsebody() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsetriple_ligature();
              if (s2 === peg$FAILED) {
                s2 = peg$parsedouble_ligature();
                if (s2 === peg$FAILED) {
                  s2 = peg$parsemono_ligature();
                  if (s2 === peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s2 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s2 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                      }
                    }
                  }
                }
              }
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$parsetriple_ligature();
                  if (s2 === peg$FAILED) {
                    s2 = peg$parsedouble_ligature();
                    if (s2 === peg$FAILED) {
                      s2 = peg$parsemono_ligature();
                      if (s2 === peg$FAILED) {
                        if (input.length > peg$currPos) {
                          s2 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s2 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e0);
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s1 = peg$f0(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseEOL();
                if (s1 !== peg$FAILED) {
                  s1 = peg$f1();
                }
                s0 = s1;
              }
              return s0;
            }
            function peg$parsetriple_ligature() {
              var s0, s1, s2, s3, s4;
              s0 = peg$currPos;
              s1 = peg$currPos;
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s2 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s3 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s2 = [s2, s3, s4];
                    s1 = s2;
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f2(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f3(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsedouble_ligature() {
              var s0;
              s0 = peg$parsedouble_macro_ligature();
              if (s0 === peg$FAILED) {
                s0 = peg$parsedouble_macro_ligature_extracted();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsedouble_char_ligature();
                }
              }
              return s0;
            }
            function peg$parsedouble_macro_ligature_extracted() {
              var s0, s1, s2, s3, s4;
              s0 = peg$currPos;
              s1 = peg$parsemacro();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parsewhitespace();
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parsewhitespace();
                }
                s3 = peg$parsesplitable();
                if (s3 !== peg$FAILED) {
                  s4 = peg$f4(s1, s3);
                  if (s4) {
                    s4 = void 0;
                  } else {
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    s0 = peg$f5(s1, s3);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsedouble_macro_ligature() {
              var s0, s1, s2, s3, s4;
              s0 = peg$currPos;
              s1 = peg$parsemacro();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parsewhitespace();
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parsewhitespace();
                }
                if (input.length > peg$currPos) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$f6(s1, s3);
                  if (s4) {
                    s4 = void 0;
                  } else {
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    s0 = peg$f7(s1, s3);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsedouble_char_ligature() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              s1 = peg$currPos;
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s2 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s2 = [s2, s3];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f8(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f9(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsemono_ligature() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f10(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f11(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsemacro() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f12(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f13(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsewhitespace() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f14(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f15(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsesplitable() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f16(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f17(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseEOL() {
              var s0, s1;
              s0 = peg$currPos;
              peg$silentFails++;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              peg$silentFails--;
              if (s1 === peg$FAILED) {
                s0 = void 0;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            if (!options2.isWhitespace) {
              try {
                Object.assign(options2, {
                  isMacro: (node) => node.type === "macro",
                  isWhitespace: (node) => node.type === "whitespace",
                  isRecognized: (nodes) => {
                    if (nodes.length == 2 && nodes[0].content === "^" && nodes[1].content === "o") {
                      return { type: "string", content: "\xF4" };
                    }
                    return null;
                  },
                  isSplitable: (node) => node.type === "string" && node.content.length > 1,
                  split: (node) => [
                    { type: "string", content: node.content.charAt(0) },
                    { type: "string", content: node.content.slice(1) }
                  ]
                });
              } catch (e) {
                console.warn("Error when initializing parser", e);
              }
            }
            peg$result = peg$startRuleFunction();
            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
              return peg$result;
            } else {
              if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                peg$fail(peg$endExpectation());
              }
              throw peg$buildStructuredError(
                peg$maxFailExpected,
                peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
                peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
              );
            }
          }
          return {
            SyntaxError: peg$SyntaxError,
            parse: peg$parse
          };
        }()
      );
      var _XColorPegParser = (
        // Generated by Peggy 3.0.2.
        //
        // https://peggyjs.org/
        function() {
          function peg$subclass(child, parent) {
            function C() {
              this.constructor = child;
            }
            C.prototype = parent.prototype;
            child.prototype = new C();
          }
          function peg$SyntaxError(message, expected, found, location2) {
            var self2 = Error.call(this, message);
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
            }
            self2.expected = expected;
            self2.found = found;
            self2.location = location2;
            self2.name = "SyntaxError";
            return self2;
          }
          peg$subclass(peg$SyntaxError, Error);
          function peg$padEnd(str, targetLength, padString) {
            padString = padString || " ";
            if (str.length > targetLength) {
              return str;
            }
            targetLength -= str.length;
            padString += padString.repeat(targetLength);
            return str + padString.slice(0, targetLength);
          }
          peg$SyntaxError.prototype.format = function(sources) {
            var str = "Error: " + this.message;
            if (this.location) {
              var src = null;
              var k;
              for (k = 0; k < sources.length; k++) {
                if (sources[k].source === this.location.source) {
                  src = sources[k].text.split(/\r\n|\n|\r/g);
                  break;
                }
              }
              var s = this.location.start;
              var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
              var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
              if (src) {
                var e = this.location.end;
                var filler = peg$padEnd("", offset_s.line.toString().length, " ");
                var line = src[s.line - 1];
                var last = s.line === e.line ? e.column : line.length + 1;
                var hatLen = last - s.column || 1;
                str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
              } else {
                str += "\n at " + loc;
              }
            }
            return str;
          };
          peg$SyntaxError.buildMessage = function(expected, found) {
            var DESCRIBE_EXPECTATION_FNS = {
              literal: function(expectation) {
                return '"' + literalEscape(expectation.text) + '"';
              },
              class: function(expectation) {
                var escapedParts = expectation.parts.map(function(part) {
                  return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
                });
                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
              },
              any: function() {
                return "any character";
              },
              end: function() {
                return "end of input";
              },
              other: function(expectation) {
                return expectation.description;
              }
            };
            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            function literalEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function classEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function describeExpectation(expectation) {
              return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
            }
            function describeExpected(expected2) {
              var descriptions = expected2.map(describeExpectation);
              var i, j;
              descriptions.sort();
              if (descriptions.length > 0) {
                for (i = 1, j = 1; i < descriptions.length; i++) {
                  if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                  }
                }
                descriptions.length = j;
              }
              switch (descriptions.length) {
                case 1:
                  return descriptions[0];
                case 2:
                  return descriptions[0] + " or " + descriptions[1];
                default:
                  return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
              }
            }
            function describeFound(found2) {
              return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
            }
            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
          };
          function peg$parse(input, options2) {
            options2 = options2 !== void 0 ? options2 : {};
            var peg$FAILED = {};
            var peg$source = options2.grammarSource;
            var peg$startRuleFunctions = { start: peg$parsestart };
            var peg$startRuleFunction = peg$parsestart;
            var peg$c0 = ";";
            var peg$c1 = ",";
            var peg$c2 = ":";
            var peg$c3 = "/";
            var peg$c4 = ">";
            var peg$c5 = "!";
            var peg$c6 = ".";
            var peg$c7 = "!![";
            var peg$c8 = "]";
            var peg$c9 = "!!";
            var peg$c10 = "+";
            var peg$c11 = "-";
            var peg$r0 = /^[a-zA-Z0-9]/;
            var peg$r1 = /^[0-9]/;
            var peg$r2 = /^[ \t\n\r]/;
            var peg$r3 = /^[0-9a-fA-F]/;
            var peg$e0 = peg$anyExpectation();
            var peg$e1 = peg$literalExpectation(";", false);
            var peg$e2 = peg$literalExpectation(",", false);
            var peg$e3 = peg$otherExpectation("model list");
            var peg$e4 = peg$literalExpectation(":", false);
            var peg$e5 = peg$literalExpectation("/", false);
            var peg$e6 = peg$otherExpectation("model");
            var peg$e7 = peg$otherExpectation("color spec list");
            var peg$e8 = peg$otherExpectation("color spec");
            var peg$e9 = peg$otherExpectation("color");
            var peg$e10 = peg$otherExpectation("function expression");
            var peg$e11 = peg$literalExpectation(">", false);
            var peg$e12 = peg$otherExpectation("function");
            var peg$e13 = peg$otherExpectation("extended expression");
            var peg$e14 = peg$otherExpectation("core model");
            var peg$e15 = peg$otherExpectation("expr");
            var peg$e16 = peg$literalExpectation("!", false);
            var peg$e17 = peg$otherExpectation("mix expr");
            var peg$e18 = peg$otherExpectation("name");
            var peg$e19 = peg$literalExpectation(".", false);
            var peg$e20 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false);
            var peg$e21 = peg$otherExpectation("postfix");
            var peg$e22 = peg$literalExpectation("!![", false);
            var peg$e23 = peg$literalExpectation("]", false);
            var peg$e24 = peg$literalExpectation("!!", false);
            var peg$e25 = peg$otherExpectation("prefix");
            var peg$e26 = peg$otherExpectation("plus");
            var peg$e27 = peg$literalExpectation("+", false);
            var peg$e28 = peg$otherExpectation("minus");
            var peg$e29 = peg$literalExpectation("-", false);
            var peg$e30 = peg$otherExpectation("num");
            var peg$e31 = peg$classExpectation([["0", "9"]], false, false);
            var peg$e32 = peg$otherExpectation("positive float");
            var peg$e33 = peg$otherExpectation("divisor");
            var peg$e34 = peg$otherExpectation("int");
            var peg$e36 = peg$classExpectation([" ", "	", "\n", "\r"], false, false);
            var peg$e37 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false);
            var peg$f0 = function(m) {
              return m;
            };
            var peg$f1 = function(m) {
              return m;
            };
            var peg$f2 = function(m) {
              return m;
            };
            var peg$f3 = function(m) {
              return m;
            };
            var peg$f4 = function(m) {
              return m;
            };
            var peg$f5 = function(a) {
              return { type: "invalid_spec", content: a };
            };
            var peg$f6 = function(f, c) {
              return c;
            };
            var peg$f7 = function(f, r) {
              return { type: "color_set", content: [f].concat(r) };
            };
            var peg$f8 = function(n, s) {
              return { type: "color_set_item", name: n, spec_list: s };
            };
            var peg$f9 = function(c, m) {
              return { type: "model_list", contents: m, core_model: c };
            };
            var peg$f10 = function(m) {
              return { type: "model_list", contents: m, core_model: null };
            };
            var peg$f11 = function(m, a) {
              return a;
            };
            var peg$f12 = function(m, r) {
              return [m].concat(r);
            };
            var peg$f13 = function(s, a) {
              return a;
            };
            var peg$f14 = function(s, r) {
              return { type: "spec_list", content: [s].concat(r) };
            };
            var peg$f15 = function(c) {
              return { type: "hex_spec", content: [c] };
            };
            var peg$f16 = function(c, d) {
              return d;
            };
            var peg$f17 = function(c, d) {
              return d;
            };
            var peg$f18 = function(c, r) {
              return { type: "num_spec", content: r ? [c].concat(r) : [c] };
            };
            var peg$f19 = function(c, fs) {
              return { type: "color", color: c, functions: fs };
            };
            var peg$f20 = function(f, n) {
              return n;
            };
            var peg$f21 = function(f, args) {
              return { type: "function", name: f, args };
            };
            var peg$f22 = function(core, d, e, es) {
              return {
                type: "extended_expr",
                core_model: core,
                div: d,
                expressions: [e].concat(es)
              };
            };
            var peg$f23 = function(core, e, es) {
              return {
                type: "extended_expr",
                core_model: core,
                div: null,
                expressions: [e].concat(es)
              };
            };
            var peg$f24 = function(e, d) {
              return { type: "weighted_expr", color: e, weight: d };
            };
            var peg$f25 = function(e) {
              return e;
            };
            var peg$f26 = function(p, n, e, po) {
              return {
                type: "expr",
                prefix: p,
                name: n,
                mix_expr: e,
                postfix: po
              };
            };
            var peg$f27 = function(p, n) {
              return { type: "complete_mix", mix_percent: p, name: n };
            };
            var peg$f28 = function(p) {
              return { type: "partial_mix", mix_percent: p };
            };
            var peg$f29 = function(c, p) {
              return c.concat(p || []);
            };
            var peg$f30 = function(n) {
              return { type: "postfix", num: n };
            };
            var peg$f31 = function(p) {
              return { type: "postfix", plusses: p };
            };
            var peg$f32 = function(n) {
              return parseInt(n, 10);
            };
            var peg$f33 = function(n) {
              return parseFloat(n);
            };
            var peg$f34 = function(n) {
              return n;
            };
            var peg$f35 = function(n) {
              return -n;
            };
            var peg$f36 = function(m, n) {
              return m ? -n : n;
            };
            var peg$f37 = function(h) {
              return h.toUpperCase();
            };
            var peg$currPos = 0;
            var peg$posDetailsCache = [{ line: 1, column: 1 }];
            var peg$maxFailPos = 0;
            var peg$maxFailExpected = [];
            var peg$silentFails = 0;
            var peg$result;
            if ("startRule" in options2) {
              if (!(options2.startRule in peg$startRuleFunctions)) {
                throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
              }
              peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
            }
            function peg$literalExpectation(text2, ignoreCase) {
              return { type: "literal", text: text2, ignoreCase };
            }
            function peg$classExpectation(parts, inverted, ignoreCase) {
              return { type: "class", parts, inverted, ignoreCase };
            }
            function peg$anyExpectation() {
              return { type: "any" };
            }
            function peg$endExpectation() {
              return { type: "end" };
            }
            function peg$otherExpectation(description) {
              return { type: "other", description };
            }
            function peg$computePosDetails(pos) {
              var details = peg$posDetailsCache[pos];
              var p;
              if (details) {
                return details;
              } else {
                p = pos - 1;
                while (!peg$posDetailsCache[p]) {
                  p--;
                }
                details = peg$posDetailsCache[p];
                details = {
                  line: details.line,
                  column: details.column
                };
                while (p < pos) {
                  if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                  } else {
                    details.column++;
                  }
                  p++;
                }
                peg$posDetailsCache[pos] = details;
                return details;
              }
            }
            function peg$computeLocation(startPos, endPos, offset2) {
              var startPosDetails = peg$computePosDetails(startPos);
              var endPosDetails = peg$computePosDetails(endPos);
              var res = {
                source: peg$source,
                start: {
                  offset: startPos,
                  line: startPosDetails.line,
                  column: startPosDetails.column
                },
                end: {
                  offset: endPos,
                  line: endPosDetails.line,
                  column: endPosDetails.column
                }
              };
              if (offset2 && peg$source && typeof peg$source.offset === "function") {
                res.start = peg$source.offset(res.start);
                res.end = peg$source.offset(res.end);
              }
              return res;
            }
            function peg$fail(expected2) {
              if (peg$currPos < peg$maxFailPos) {
                return;
              }
              if (peg$currPos > peg$maxFailPos) {
                peg$maxFailPos = peg$currPos;
                peg$maxFailExpected = [];
              }
              peg$maxFailExpected.push(expected2);
            }
            function peg$buildStructuredError(expected2, found, location2) {
              return new peg$SyntaxError(
                peg$SyntaxError.buildMessage(expected2, found),
                expected2,
                found,
                location2
              );
            }
            function peg$parsestart() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              s1 = peg$parsespec();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseEOL();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f0(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsespec_list();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseEOL();
                  if (s2 !== peg$FAILED) {
                    s0 = peg$f1(s1);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parsecolor();
                  if (s1 !== peg$FAILED) {
                    s2 = peg$parseEOL();
                    if (s2 !== peg$FAILED) {
                      s0 = peg$f2(s1);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parsemodel_list();
                    if (s1 !== peg$FAILED) {
                      s2 = peg$parseEOL();
                      if (s2 !== peg$FAILED) {
                        s0 = peg$f3(s1);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = peg$parsecolor_set_spec();
                      if (s1 !== peg$FAILED) {
                        s2 = peg$parseEOL();
                        if (s2 !== peg$FAILED) {
                          s0 = peg$f4(s1);
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$currPos;
                        s2 = [];
                        if (input.length > peg$currPos) {
                          s3 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s3 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e0);
                          }
                        }
                        while (s3 !== peg$FAILED) {
                          s2.push(s3);
                          if (input.length > peg$currPos) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                          } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e0);
                            }
                          }
                        }
                        s1 = input.substring(s1, peg$currPos);
                        s1 = peg$f5(s1);
                        s0 = s1;
                      }
                    }
                  }
                }
              }
              return s0;
            }
            function peg$parsecolor_set_spec() {
              var s0, s1, s2, s3, s4, s5;
              s0 = peg$currPos;
              s1 = peg$parsecolor_set_item();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 59) {
                  s4 = peg$c0;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e1);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsecolor_set_item();
                  if (s5 !== peg$FAILED) {
                    s3 = peg$f6(s1, s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 59) {
                    s4 = peg$c0;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e1);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsecolor_set_item();
                    if (s5 !== peg$FAILED) {
                      s3 = peg$f6(s1, s5);
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
                s0 = peg$f7(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsecolor_set_item() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              s1 = peg$parsename();
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s2 = peg$c1;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsespec_list();
                  if (s3 !== peg$FAILED) {
                    s0 = peg$f8(s1, s3);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsemodel_list() {
              var s0, s1, s2, s3;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parsecore_model();
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                  s2 = peg$c2;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e4);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsemodel_list_tail();
                  if (s3 !== peg$FAILED) {
                    s0 = peg$f9(s1, s3);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsemodel_list_tail();
                if (s1 !== peg$FAILED) {
                  s1 = peg$f10(s1);
                }
                s0 = s1;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              return s0;
            }
            function peg$parsemodel_list_tail() {
              var s0, s1, s2, s3, s4, s5;
              s0 = peg$currPos;
              s1 = peg$parsemodel();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 47) {
                  s4 = peg$c3;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e5);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsemodel();
                  if (s5 !== peg$FAILED) {
                    s3 = peg$f11(s1, s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 47) {
                    s4 = peg$c3;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e5);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsemodel();
                    if (s5 !== peg$FAILED) {
                      s3 = peg$f11(s1, s5);
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
                s0 = peg$f12(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsemodel() {
              var s0;
              peg$silentFails++;
              s0 = peg$parsecore_model();
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                if (peg$silentFails === 0) {
                  peg$fail(peg$e6);
                }
              }
              return s0;
            }
            function peg$parsespec_list() {
              var s0, s1, s2, s3, s4, s5;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parsespec();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 47) {
                  s4 = peg$c3;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e5);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsespec();
                  if (s5 !== peg$FAILED) {
                    s3 = peg$f13(s1, s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 47) {
                    s4 = peg$c3;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e5);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsespec();
                    if (s5 !== peg$FAILED) {
                      s3 = peg$f13(s1, s5);
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
                s0 = peg$f14(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e7);
                }
              }
              return s0;
            }
            function peg$parsespec() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = peg$currPos;
              s3 = peg$parsehex();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsehex();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsehex();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsehex();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parsehex();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parsehex();
                        if (s8 !== peg$FAILED) {
                          s3 = [s3, s4, s5, s6, s7, s8];
                          s2 = s3;
                        } else {
                          peg$currPos = s2;
                          s2 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = input.substring(s1, peg$currPos);
              } else {
                s1 = s2;
              }
              if (s1 !== peg$FAILED) {
                s1 = peg$f15(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsedec();
                if (s1 !== peg$FAILED) {
                  s2 = [];
                  s3 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s4 = peg$c1;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e2);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsedec();
                    if (s5 !== peg$FAILED) {
                      s3 = peg$f16(s1, s5);
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 !== peg$FAILED) {
                    while (s3 !== peg$FAILED) {
                      s2.push(s3);
                      s3 = peg$currPos;
                      if (input.charCodeAt(peg$currPos) === 44) {
                        s4 = peg$c1;
                        peg$currPos++;
                      } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e2);
                        }
                      }
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parsedec();
                        if (s5 !== peg$FAILED) {
                          s3 = peg$f16(s1, s5);
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    }
                  } else {
                    s2 = peg$FAILED;
                  }
                  if (s2 === peg$FAILED) {
                    s2 = [];
                    s3 = peg$currPos;
                    s4 = peg$parsesp();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsedec();
                      if (s5 !== peg$FAILED) {
                        s3 = peg$f17(s1, s5);
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                    if (s3 !== peg$FAILED) {
                      while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        s3 = peg$currPos;
                        s4 = peg$parsesp();
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parsedec();
                          if (s5 !== peg$FAILED) {
                            s3 = peg$f17(s1, s5);
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      }
                    } else {
                      s2 = peg$FAILED;
                    }
                  }
                  if (s2 === peg$FAILED) {
                    s2 = null;
                  }
                  s0 = peg$f18(s1, s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e8);
                }
              }
              return s0;
            }
            function peg$parsecolor() {
              var s0, s1, s2, s3;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parsecolor_expr();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parsefunc_expr();
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parsefunc_expr();
                }
                s0 = peg$f19(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e9);
                }
              }
              return s0;
            }
            function peg$parsecolor_expr() {
              var s0;
              s0 = peg$parseext_expr();
              if (s0 === peg$FAILED) {
                s0 = peg$parseexpr();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsename();
                }
              }
              return s0;
            }
            function peg$parsefunc_expr() {
              var s0, s1, s2, s3, s4, s5, s6;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 62) {
                s1 = peg$c4;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e11);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsefunction();
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s5 = peg$c1;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e2);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseint();
                    if (s6 !== peg$FAILED) {
                      s4 = peg$f20(s2, s6);
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s5 = peg$c1;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e2);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseint();
                      if (s6 !== peg$FAILED) {
                        s4 = peg$f20(s2, s6);
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  }
                  s0 = peg$f21(s2, s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e10);
                }
              }
              return s0;
            }
            function peg$parsefunction() {
              var s0;
              peg$silentFails++;
              s0 = peg$parsename();
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                if (peg$silentFails === 0) {
                  peg$fail(peg$e12);
                }
              }
              return s0;
            }
            function peg$parseext_expr() {
              var s0, s1, s2, s3, s4, s5, s6, s7;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parsecore_model();
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s2 = peg$c1;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsediv();
                  if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s4 = peg$c2;
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e4);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parseweighted_expr();
                      if (s5 !== peg$FAILED) {
                        s6 = [];
                        s7 = peg$parseadditional_weighted_expr();
                        while (s7 !== peg$FAILED) {
                          s6.push(s7);
                          s7 = peg$parseadditional_weighted_expr();
                        }
                        s0 = peg$f22(s1, s3, s5, s6);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsecore_model();
                if (s1 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s2 = peg$c2;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e4);
                    }
                  }
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parseweighted_expr();
                    if (s3 !== peg$FAILED) {
                      s4 = [];
                      s5 = peg$parseadditional_weighted_expr();
                      while (s5 !== peg$FAILED) {
                        s4.push(s5);
                        s5 = peg$parseadditional_weighted_expr();
                      }
                      s0 = peg$f23(s1, s3, s4);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e13);
                }
              }
              return s0;
            }
            function peg$parseweighted_expr() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              s1 = peg$parseexpr();
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s2 = peg$c1;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsedec();
                  if (s3 !== peg$FAILED) {
                    s0 = peg$f24(s1, s3);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseadditional_weighted_expr() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 59) {
                s1 = peg$c0;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e1);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parseweighted_expr();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f25(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsecore_model() {
              var s0;
              peg$silentFails++;
              s0 = peg$parsename();
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                if (peg$silentFails === 0) {
                  peg$fail(peg$e14);
                }
              }
              return s0;
            }
            function peg$parseexpr() {
              var s0, s1, s2, s3, s4;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parseprefix();
              s2 = peg$parsename();
              if (s2 !== peg$FAILED) {
                s3 = peg$parsemix_expr();
                s4 = peg$parsepostfix();
                if (s4 === peg$FAILED) {
                  s4 = null;
                }
                s0 = peg$f26(s1, s2, s3, s4);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e15);
                }
              }
              return s0;
            }
            function peg$parsecomplete_mix() {
              var s0, s1, s2, s3, s4;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 33) {
                s1 = peg$c5;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e16);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsepct();
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 33) {
                    s3 = peg$c5;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e16);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parsename();
                    if (s4 !== peg$FAILED) {
                      s0 = peg$f27(s2, s4);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsepartial_mix() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 33) {
                s1 = peg$c5;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e16);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsepct();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f28(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsemix_expr() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsecomplete_mix();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsecomplete_mix();
              }
              s2 = peg$parsepartial_mix();
              if (s2 === peg$FAILED) {
                s2 = null;
              }
              s0 = peg$f29(s1, s2);
              peg$silentFails--;
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
              return s0;
            }
            function peg$parsename() {
              var s0, s1, s2;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 46) {
                s0 = peg$c6;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e19);
                }
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                if (peg$r0.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e20);
                  }
                }
                if (s2 !== peg$FAILED) {
                  while (s2 !== peg$FAILED) {
                    s1.push(s2);
                    if (peg$r0.test(input.charAt(peg$currPos))) {
                      s2 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s2 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e20);
                      }
                    }
                  }
                } else {
                  s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                  s0 = input.substring(s0, peg$currPos);
                } else {
                  s0 = s1;
                }
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
              return s0;
            }
            function peg$parsepostfix() {
              var s0, s1, s2, s3, s4;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 3) === peg$c7) {
                s1 = peg$c7;
                peg$currPos += 3;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e22);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsenum();
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c8;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e23);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s0 = peg$f30(s2);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c9) {
                  s1 = peg$c9;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e24);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$currPos;
                  s3 = [];
                  s4 = peg$parseplus();
                  if (s4 !== peg$FAILED) {
                    while (s4 !== peg$FAILED) {
                      s3.push(s4);
                      s4 = peg$parseplus();
                    }
                  } else {
                    s3 = peg$FAILED;
                  }
                  if (s3 !== peg$FAILED) {
                    s2 = input.substring(s2, peg$currPos);
                  } else {
                    s2 = s3;
                  }
                  if (s2 !== peg$FAILED) {
                    s0 = peg$f31(s2);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e21);
                }
              }
              return s0;
            }
            function peg$parseprefix() {
              var s0;
              peg$silentFails++;
              s0 = peg$parseminus();
              if (s0 === peg$FAILED) {
                s0 = null;
              }
              peg$silentFails--;
              if (peg$silentFails === 0) {
                peg$fail(peg$e25);
              }
              return s0;
            }
            function peg$parseplus() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = [];
              if (input.charCodeAt(peg$currPos) === 43) {
                s2 = peg$c10;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e27);
                }
              }
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  if (input.charCodeAt(peg$currPos) === 43) {
                    s2 = peg$c10;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e27);
                    }
                  }
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s0 = input.substring(s0, peg$currPos);
              } else {
                s0 = s1;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e26);
                }
              }
              return s0;
            }
            function peg$parseminus() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = [];
              if (input.charCodeAt(peg$currPos) === 45) {
                s2 = peg$c11;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e29);
                }
              }
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  if (input.charCodeAt(peg$currPos) === 45) {
                    s2 = peg$c11;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e29);
                    }
                  }
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s0 = input.substring(s0, peg$currPos);
              } else {
                s0 = s1;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e28);
                }
              }
              return s0;
            }
            function peg$parsenum() {
              var s0, s1, s2, s3;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = [];
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e31);
                }
              }
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  if (peg$r1.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e31);
                    }
                  }
                }
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = input.substring(s1, peg$currPos);
              } else {
                s1 = s2;
              }
              if (s1 !== peg$FAILED) {
                s1 = peg$f32(s1);
              }
              s0 = s1;
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e30);
                }
              }
              return s0;
            }
            function peg$parsepct() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = peg$currPos;
              s3 = peg$currPos;
              s4 = [];
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e31);
                }
              }
              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  if (peg$r1.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e31);
                    }
                  }
                }
              } else {
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s3 = input.substring(s3, peg$currPos);
              } else {
                s3 = s4;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$currPos;
                s5 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 46) {
                  s6 = peg$c6;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e19);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$currPos;
                  s8 = [];
                  if (peg$r1.test(input.charAt(peg$currPos))) {
                    s9 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s9 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e31);
                    }
                  }
                  while (s9 !== peg$FAILED) {
                    s8.push(s9);
                    if (peg$r1.test(input.charAt(peg$currPos))) {
                      s9 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e31);
                      }
                    }
                  }
                  s7 = input.substring(s7, peg$currPos);
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                s4 = input.substring(s4, peg$currPos);
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = input.substring(s1, peg$currPos);
              } else {
                s1 = s2;
              }
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                s2 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 46) {
                  s3 = peg$c6;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e19);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$currPos;
                  s5 = [];
                  if (peg$r1.test(input.charAt(peg$currPos))) {
                    s6 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e31);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      if (peg$r1.test(input.charAt(peg$currPos))) {
                        s6 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e31);
                        }
                      }
                    }
                  } else {
                    s5 = peg$FAILED;
                  }
                  if (s5 !== peg$FAILED) {
                    s4 = input.substring(s4, peg$currPos);
                  } else {
                    s4 = s5;
                  }
                  if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = input.substring(s1, peg$currPos);
                } else {
                  s1 = s2;
                }
              }
              if (s1 !== peg$FAILED) {
                s1 = peg$f33(s1);
              }
              s0 = s1;
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e32);
                }
              }
              return s0;
            }
            function peg$parsediv() {
              var s0;
              peg$silentFails++;
              s0 = peg$parsepct();
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                if (peg$silentFails === 0) {
                  peg$fail(peg$e33);
                }
              }
              return s0;
            }
            function peg$parsedec() {
              var s0, s1, s2;
              s0 = peg$parsepct();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 43) {
                  s1 = peg$c10;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e27);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parsepct();
                  if (s2 !== peg$FAILED) {
                    s0 = peg$f34(s2);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 45) {
                    s1 = peg$c11;
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e29);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    s2 = peg$parsepct();
                    if (s2 !== peg$FAILED) {
                      s0 = peg$f35(s2);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                }
              }
              return s0;
            }
            function peg$parseint() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parseminus();
              if (s1 === peg$FAILED) {
                s1 = null;
              }
              s2 = peg$parsenum();
              if (s2 !== peg$FAILED) {
                s0 = peg$f36(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e34);
                }
              }
              return s0;
            }
            function peg$parsesp() {
              var s0, s1;
              s0 = [];
              if (peg$r2.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e36);
                }
              }
              if (s1 !== peg$FAILED) {
                while (s1 !== peg$FAILED) {
                  s0.push(s1);
                  if (peg$r2.test(input.charAt(peg$currPos))) {
                    s1 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e36);
                    }
                  }
                }
              } else {
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsehex() {
              var s0, s1;
              s0 = peg$currPos;
              if (peg$r3.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e37);
                }
              }
              if (s1 !== peg$FAILED) {
                s1 = peg$f37(s1);
              }
              s0 = s1;
              return s0;
            }
            function peg$parseEOL() {
              var s0, s1;
              s0 = peg$currPos;
              peg$silentFails++;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              peg$silentFails--;
              if (s1 === peg$FAILED) {
                s0 = void 0;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            peg$result = peg$startRuleFunction();
            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
              return peg$result;
            } else {
              if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                peg$fail(peg$endExpectation());
              }
              throw peg$buildStructuredError(
                peg$maxFailExpected,
                peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
                peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
              );
            }
          }
          return {
            SyntaxError: peg$SyntaxError,
            parse: peg$parse
          };
        }()
      );
      var _TabularPegParser = (
        // Generated by Peggy 3.0.2.
        //
        // https://peggyjs.org/
        function() {
          function peg$subclass(child, parent) {
            function C() {
              this.constructor = child;
            }
            C.prototype = parent.prototype;
            child.prototype = new C();
          }
          function peg$SyntaxError(message, expected, found, location2) {
            var self2 = Error.call(this, message);
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
            }
            self2.expected = expected;
            self2.found = found;
            self2.location = location2;
            self2.name = "SyntaxError";
            return self2;
          }
          peg$subclass(peg$SyntaxError, Error);
          function peg$padEnd(str, targetLength, padString) {
            padString = padString || " ";
            if (str.length > targetLength) {
              return str;
            }
            targetLength -= str.length;
            padString += padString.repeat(targetLength);
            return str + padString.slice(0, targetLength);
          }
          peg$SyntaxError.prototype.format = function(sources) {
            var str = "Error: " + this.message;
            if (this.location) {
              var src = null;
              var k;
              for (k = 0; k < sources.length; k++) {
                if (sources[k].source === this.location.source) {
                  src = sources[k].text.split(/\r\n|\n|\r/g);
                  break;
                }
              }
              var s = this.location.start;
              var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
              var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
              if (src) {
                var e = this.location.end;
                var filler = peg$padEnd("", offset_s.line.toString().length, " ");
                var line = src[s.line - 1];
                var last = s.line === e.line ? e.column : line.length + 1;
                var hatLen = last - s.column || 1;
                str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
              } else {
                str += "\n at " + loc;
              }
            }
            return str;
          };
          peg$SyntaxError.buildMessage = function(expected, found) {
            var DESCRIBE_EXPECTATION_FNS = {
              literal: function(expectation) {
                return '"' + literalEscape(expectation.text) + '"';
              },
              class: function(expectation) {
                var escapedParts = expectation.parts.map(function(part) {
                  return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
                });
                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
              },
              any: function() {
                return "any character";
              },
              end: function() {
                return "end of input";
              },
              other: function(expectation) {
                return expectation.description;
              }
            };
            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            function literalEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function classEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function describeExpectation(expectation) {
              return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
            }
            function describeExpected(expected2) {
              var descriptions = expected2.map(describeExpectation);
              var i, j;
              descriptions.sort();
              if (descriptions.length > 0) {
                for (i = 1, j = 1; i < descriptions.length; i++) {
                  if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                  }
                }
                descriptions.length = j;
              }
              switch (descriptions.length) {
                case 1:
                  return descriptions[0];
                case 2:
                  return descriptions[0] + " or " + descriptions[1];
                default:
                  return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
              }
            }
            function describeFound(found2) {
              return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
            }
            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
          };
          function peg$parse(input, options2) {
            options2 = options2 !== void 0 ? options2 : {};
            var peg$FAILED = {};
            var peg$source = options2.grammarSource;
            var peg$startRuleFunctions = { body: peg$parsebody };
            var peg$startRuleFunction = peg$parsebody;
            var peg$e0 = peg$otherExpectation("decl_start");
            var peg$e1 = peg$otherExpectation("decl_end");
            var peg$e2 = peg$otherExpectation("vert");
            var peg$e3 = peg$anyExpectation();
            var peg$e4 = peg$otherExpectation("l");
            var peg$e5 = peg$otherExpectation("r");
            var peg$e6 = peg$otherExpectation("c");
            var peg$e7 = peg$otherExpectation("p");
            var peg$e8 = peg$otherExpectation("m");
            var peg$e9 = peg$otherExpectation("b");
            var peg$e10 = peg$otherExpectation("w");
            var peg$e11 = peg$otherExpectation("W");
            var peg$e12 = peg$otherExpectation("X");
            var peg$e13 = peg$otherExpectation("!");
            var peg$e14 = peg$otherExpectation("@");
            var peg$e15 = peg$otherExpectation("<");
            var peg$e16 = peg$otherExpectation(">");
            var peg$e17 = peg$otherExpectation("group");
            var peg$e18 = peg$otherExpectation("whitespace");
            var peg$f0 = function(c) {
              return c;
            };
            var peg$f1 = function(cols) {
              return cols;
            };
            var peg$f2 = function() {
              return [];
            };
            var peg$f3 = function(divs1, start, a, end, divs2) {
              return {
                type: "column",
                pre_dividers: divs1,
                post_dividers: divs2,
                before_start_code: start,
                before_end_code: end,
                alignment: a
              };
            };
            var peg$f4 = function() {
              return {
                type: "vert_divider"
              };
            };
            var peg$f5 = function(b, g) {
              return {
                type: "bang_divider",
                content: g[0].content
              };
            };
            var peg$f6 = function(g) {
              return {
                type: "at_divider",
                content: g[0].content
              };
            };
            var peg$f7 = function(div) {
              return div;
            };
            var peg$f8 = function(g) {
              return { type: "decl_code", code: g[0].content };
            };
            var peg$f9 = function(g) {
              return { type: "decl_code", code: g[0].content };
            };
            var peg$f10 = function() {
              return { type: "alignment", alignment: "left" };
            };
            var peg$f11 = function() {
              return { type: "alignment", alignment: "center" };
            };
            var peg$f12 = function() {
              return { type: "alignment", alignment: "right" };
            };
            var peg$f13 = function() {
              return { type: "alignment", alignment: "X" };
            };
            var peg$f14 = function() {
              return "top";
            };
            var peg$f15 = function() {
              return "default";
            };
            var peg$f16 = function() {
              return "bottom";
            };
            var peg$f17 = function(a, g) {
              return {
                type: "alignment",
                alignment: "parbox",
                baseline: a,
                size: g[0].content
              };
            };
            var peg$f18 = function(g1, g2) {
              return {
                type: "alignment",
                alignment: "parbox",
                baseline: g1[0].content,
                size: g2[0].content
              };
            };
            var peg$f19 = function(tok) {
              return options2.matchChar(tok, "|");
            };
            var peg$f20 = function(tok) {
              return options2.matchChar(tok, "l");
            };
            var peg$f21 = function(tok) {
              return options2.matchChar(tok, "r");
            };
            var peg$f22 = function(tok) {
              return options2.matchChar(tok, "c");
            };
            var peg$f23 = function(tok) {
              return options2.matchChar(tok, "p");
            };
            var peg$f24 = function(tok) {
              return options2.matchChar(tok, "m");
            };
            var peg$f25 = function(tok) {
              return options2.matchChar(tok, "b");
            };
            var peg$f26 = function(tok) {
              return options2.matchChar(tok, "w");
            };
            var peg$f27 = function(tok) {
              return options2.matchChar(tok, "W");
            };
            var peg$f28 = function(tok) {
              return options2.matchChar(tok, "X");
            };
            var peg$f29 = function(tok) {
              return options2.matchChar(tok, "!");
            };
            var peg$f30 = function(tok) {
              return options2.matchChar(tok, "@");
            };
            var peg$f31 = function(tok) {
              return options2.matchChar(tok, "<");
            };
            var peg$f32 = function(tok) {
              return options2.matchChar(tok, ">");
            };
            var peg$f33 = function(tok) {
              return options2.isGroup(tok);
            };
            var peg$f34 = function(tok) {
              return options2.isWhitespace(tok);
            };
            var peg$currPos = 0;
            var peg$posDetailsCache = [{ line: 1, column: 1 }];
            var peg$maxFailPos = 0;
            var peg$maxFailExpected = [];
            var peg$silentFails = 0;
            var peg$result;
            if ("startRule" in options2) {
              if (!(options2.startRule in peg$startRuleFunctions)) {
                throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
              }
              peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
            }
            function peg$anyExpectation() {
              return { type: "any" };
            }
            function peg$endExpectation() {
              return { type: "end" };
            }
            function peg$otherExpectation(description) {
              return { type: "other", description };
            }
            function peg$computePosDetails(pos) {
              var details = peg$posDetailsCache[pos];
              var p;
              if (details) {
                return details;
              } else {
                p = pos - 1;
                while (!peg$posDetailsCache[p]) {
                  p--;
                }
                details = peg$posDetailsCache[p];
                details = {
                  line: details.line,
                  column: details.column
                };
                while (p < pos) {
                  if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                  } else {
                    details.column++;
                  }
                  p++;
                }
                peg$posDetailsCache[pos] = details;
                return details;
              }
            }
            function peg$computeLocation(startPos, endPos, offset2) {
              var startPosDetails = peg$computePosDetails(startPos);
              var endPosDetails = peg$computePosDetails(endPos);
              var res = {
                source: peg$source,
                start: {
                  offset: startPos,
                  line: startPosDetails.line,
                  column: startPosDetails.column
                },
                end: {
                  offset: endPos,
                  line: endPosDetails.line,
                  column: endPosDetails.column
                }
              };
              if (offset2 && peg$source && typeof peg$source.offset === "function") {
                res.start = peg$source.offset(res.start);
                res.end = peg$source.offset(res.end);
              }
              return res;
            }
            function peg$fail(expected2) {
              if (peg$currPos < peg$maxFailPos) {
                return;
              }
              if (peg$currPos > peg$maxFailPos) {
                peg$maxFailPos = peg$currPos;
                peg$maxFailExpected = [];
              }
              peg$maxFailExpected.push(expected2);
            }
            function peg$buildStructuredError(expected2, found, location2) {
              return new peg$SyntaxError(
                peg$SyntaxError.buildMessage(expected2, found),
                expected2,
                found,
                location2
              );
            }
            function peg$parsebody() {
              var s0, s1, s2, s3, s4, s5;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$currPos;
              s3 = peg$parsecolumn();
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parse_();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parse_();
                }
                s2 = peg$f0(s3);
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$currPos;
                  s3 = peg$parsecolumn();
                  if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$parse_();
                    while (s5 !== peg$FAILED) {
                      s4.push(s5);
                      s5 = peg$parse_();
                    }
                    s2 = peg$f0(s3);
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s1 = peg$f1(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseEOL();
                if (s1 !== peg$FAILED) {
                  s1 = peg$f2();
                }
                s0 = s1;
              }
              return s0;
            }
            function peg$parsecolumn() {
              var s0, s1, s2, s3, s4, s5, s6;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsecolumn_divider();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsecolumn_divider();
              }
              s2 = peg$parsedecl_start();
              if (s2 === peg$FAILED) {
                s2 = null;
              }
              s3 = peg$parsealignment();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsedecl_end();
                if (s4 === peg$FAILED) {
                  s4 = null;
                }
                s5 = [];
                s6 = peg$parsecolumn_divider();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parsecolumn_divider();
                }
                s0 = peg$f3(s1, s2, s3, s4, s5);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsecolumn_divider() {
              var s0, s1, s2, s3, s4;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parse_();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parse_();
              }
              s2 = peg$currPos;
              s3 = peg$parsevert();
              if (s3 !== peg$FAILED) {
                s3 = peg$f4();
              }
              s2 = s3;
              if (s2 === peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parsebang();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parsegroup();
                  if (s4 !== peg$FAILED) {
                    s2 = peg$f5(s3, s4);
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
                if (s2 === peg$FAILED) {
                  s2 = peg$currPos;
                  s3 = peg$parseat();
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parsegroup();
                    if (s4 !== peg$FAILED) {
                      s2 = peg$f6(s4);
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parse_();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parse_();
                }
                s0 = peg$f7(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsedecl_start() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parsegreater();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsegroup();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f8(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              return s0;
            }
            function peg$parsedecl_end() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parseless();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsegroup();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f9(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e1);
                }
              }
              return s0;
            }
            function peg$parsealignment() {
              var s0, s1, s2, s3, s4, s5;
              s0 = peg$currPos;
              s1 = peg$parsel();
              if (s1 !== peg$FAILED) {
                s1 = peg$f10();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsec();
                if (s1 !== peg$FAILED) {
                  s1 = peg$f11();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parser();
                  if (s1 !== peg$FAILED) {
                    s1 = peg$f12();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parseX();
                    if (s1 !== peg$FAILED) {
                      s1 = peg$f13();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = peg$currPos;
                      s2 = peg$parsep();
                      if (s2 !== peg$FAILED) {
                        s2 = peg$f14();
                      }
                      s1 = s2;
                      if (s1 === peg$FAILED) {
                        s1 = peg$currPos;
                        s2 = peg$parsem();
                        if (s2 !== peg$FAILED) {
                          s2 = peg$f15();
                        }
                        s1 = s2;
                        if (s1 === peg$FAILED) {
                          s1 = peg$currPos;
                          s2 = peg$parseb();
                          if (s2 !== peg$FAILED) {
                            s2 = peg$f16();
                          }
                          s1 = s2;
                        }
                      }
                      if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$parse_();
                        while (s3 !== peg$FAILED) {
                          s2.push(s3);
                          s3 = peg$parse_();
                        }
                        s3 = peg$parsegroup();
                        if (s3 !== peg$FAILED) {
                          s0 = peg$f17(s1, s3);
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parsew();
                        if (s1 === peg$FAILED) {
                          s1 = peg$parseW();
                        }
                        if (s1 !== peg$FAILED) {
                          s2 = [];
                          s3 = peg$parse_();
                          while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$parse_();
                          }
                          s3 = peg$parsegroup();
                          if (s3 !== peg$FAILED) {
                            s4 = [];
                            s5 = peg$parse_();
                            while (s5 !== peg$FAILED) {
                              s4.push(s5);
                              s5 = peg$parse_();
                            }
                            s5 = peg$parsegroup();
                            if (s5 !== peg$FAILED) {
                              s0 = peg$f18(s3, s5);
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      }
                    }
                  }
                }
              }
              return s0;
            }
            function peg$parsevert() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f19(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              return s0;
            }
            function peg$parsel() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f20(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e4);
                }
              }
              return s0;
            }
            function peg$parser() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f21(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e5);
                }
              }
              return s0;
            }
            function peg$parsec() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f22(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e6);
                }
              }
              return s0;
            }
            function peg$parsep() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f23(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e7);
                }
              }
              return s0;
            }
            function peg$parsem() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f24(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e8);
                }
              }
              return s0;
            }
            function peg$parseb() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f25(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e9);
                }
              }
              return s0;
            }
            function peg$parsew() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f26(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e10);
                }
              }
              return s0;
            }
            function peg$parseW() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f27(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e11);
                }
              }
              return s0;
            }
            function peg$parseX() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f28(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e12);
                }
              }
              return s0;
            }
            function peg$parsebang() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f29(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e13);
                }
              }
              return s0;
            }
            function peg$parseat() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f30(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e14);
                }
              }
              return s0;
            }
            function peg$parseless() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f31(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e15);
                }
              }
              return s0;
            }
            function peg$parsegreater() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f32(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e16);
                }
              }
              return s0;
            }
            function peg$parsegroup() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f33(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e17);
                }
              }
              return s0;
            }
            function peg$parse_() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f34(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
              return s0;
            }
            function peg$parseEOL() {
              var s0, s1;
              s0 = peg$currPos;
              peg$silentFails++;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              peg$silentFails--;
              if (s1 === peg$FAILED) {
                s0 = void 0;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            if (!options2.isHash) {
              try {
                Object.assign(options2, {
                  matchChar: (node, char) => node.type === "string" && node.content === char,
                  isGroup: (node) => node.type === "group",
                  isWhitespace: (node) => node.type === "whitespace"
                });
              } catch (e) {
                console.warn("Error when initializing parser", e);
              }
            }
            peg$result = peg$startRuleFunction();
            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
              return peg$result;
            } else {
              if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                peg$fail(peg$endExpectation());
              }
              throw peg$buildStructuredError(
                peg$maxFailExpected,
                peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
                peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
              );
            }
          }
          return {
            SyntaxError: peg$SyntaxError,
            parse: peg$parse
          };
        }()
      );
      var _SystemePegParser = (
        // Generated by Peggy 3.0.2.
        //
        // https://peggyjs.org/
        function() {
          function peg$subclass(child, parent) {
            function C() {
              this.constructor = child;
            }
            C.prototype = parent.prototype;
            child.prototype = new C();
          }
          function peg$SyntaxError(message, expected, found, location2) {
            var self2 = Error.call(this, message);
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
            }
            self2.expected = expected;
            self2.found = found;
            self2.location = location2;
            self2.name = "SyntaxError";
            return self2;
          }
          peg$subclass(peg$SyntaxError, Error);
          function peg$padEnd(str, targetLength, padString) {
            padString = padString || " ";
            if (str.length > targetLength) {
              return str;
            }
            targetLength -= str.length;
            padString += padString.repeat(targetLength);
            return str + padString.slice(0, targetLength);
          }
          peg$SyntaxError.prototype.format = function(sources) {
            var str = "Error: " + this.message;
            if (this.location) {
              var src = null;
              var k;
              for (k = 0; k < sources.length; k++) {
                if (sources[k].source === this.location.source) {
                  src = sources[k].text.split(/\r\n|\n|\r/g);
                  break;
                }
              }
              var s = this.location.start;
              var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
              var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
              if (src) {
                var e = this.location.end;
                var filler = peg$padEnd("", offset_s.line.toString().length, " ");
                var line = src[s.line - 1];
                var last = s.line === e.line ? e.column : line.length + 1;
                var hatLen = last - s.column || 1;
                str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
              } else {
                str += "\n at " + loc;
              }
            }
            return str;
          };
          peg$SyntaxError.buildMessage = function(expected, found) {
            var DESCRIBE_EXPECTATION_FNS = {
              literal: function(expectation) {
                return '"' + literalEscape(expectation.text) + '"';
              },
              class: function(expectation) {
                var escapedParts = expectation.parts.map(function(part) {
                  return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
                });
                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
              },
              any: function() {
                return "any character";
              },
              end: function() {
                return "end of input";
              },
              other: function(expectation) {
                return expectation.description;
              }
            };
            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            function literalEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function classEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function describeExpectation(expectation) {
              return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
            }
            function describeExpected(expected2) {
              var descriptions = expected2.map(describeExpectation);
              var i, j;
              descriptions.sort();
              if (descriptions.length > 0) {
                for (i = 1, j = 1; i < descriptions.length; i++) {
                  if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                  }
                }
                descriptions.length = j;
              }
              switch (descriptions.length) {
                case 1:
                  return descriptions[0];
                case 2:
                  return descriptions[0] + " or " + descriptions[1];
                default:
                  return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
              }
            }
            function describeFound(found2) {
              return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
            }
            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
          };
          function peg$parse(input, options2) {
            options2 = options2 !== void 0 ? options2 : {};
            var peg$FAILED = {};
            var peg$source = options2.grammarSource;
            var peg$startRuleFunctions = { body: peg$parsebody };
            var peg$startRuleFunction = peg$parsebody;
            var peg$e1 = peg$otherExpectation("item");
            var peg$e2 = peg$anyExpectation();
            var peg$e3 = peg$otherExpectation("equation");
            var peg$e4 = peg$otherExpectation("trailing comment");
            var peg$e5 = peg$otherExpectation("comment only line");
            var peg$e6 = peg$otherExpectation("non-var token");
            var peg$e7 = peg$otherExpectation("token");
            var peg$e8 = peg$otherExpectation("same line comment");
            var peg$e9 = peg$otherExpectation("own line comment");
            var peg$e10 = peg$otherExpectation(",");
            var peg$e11 = peg$otherExpectation("@");
            var peg$e12 = peg$otherExpectation("variable token");
            var peg$e13 = peg$otherExpectation("+/-");
            var peg$e14 = peg$otherExpectation("=");
            var peg$f0 = function(a, b) {
              return a.concat(b ? b : []);
            };
            var peg$f1 = function() {
              return [];
            };
            var peg$f3 = function(op, a, b, c) {
              return { type: "item", op, variable: b, content: a.concat(b, c) };
            };
            var peg$f4 = function(op, a) {
              return { type: "item", op, variable: null, content: a };
            };
            var peg$f5 = function(line, sep, comment) {
              return { ...line, sep: [].concat(sep), trailingComment: comment };
            };
            var peg$f6 = function(line, comment) {
              return { ...line, trailingComment: comment };
            };
            var peg$f7 = function(eq, ann) {
              return {
                type: "line",
                equation: eq,
                annotation: ann,
                sep: null
              };
            };
            var peg$f8 = function(at, ann) {
              return at ? { type: "annotation", marker: at, content: ann } : null;
            };
            var peg$f9 = function(left, eq, right) {
              return { type: "equation", left, right, equals: eq };
            };
            var peg$f10 = function(x) {
              return x;
            };
            var peg$f11 = function(x) {
              return {
                type: "line",
                trailingComment: x
              };
            };
            var peg$f12 = function(v, s) {
              return [v].concat(s ? s : []);
            };
            var peg$f13 = function(t) {
              return t;
            };
            var peg$f14 = function(x) {
              return x;
            };
            var peg$f15 = function(x) {
              return x;
            };
            var peg$f16 = function(tok) {
              return options2.isSameLineComment(tok);
            };
            var peg$f17 = function(tok) {
              return tok;
            };
            var peg$f18 = function(tok) {
              return options2.isOwnLineComment(tok);
            };
            var peg$f19 = function(tok) {
              return tok;
            };
            var peg$f20 = function(tok) {
              return options2.isWhitespace(tok);
            };
            var peg$f21 = function(tok) {
              return tok;
            };
            var peg$f22 = function(tok) {
              return options2.isSep(tok);
            };
            var peg$f23 = function(tok) {
              return tok;
            };
            var peg$f24 = function(tok) {
              return options2.isAt(tok);
            };
            var peg$f25 = function(tok) {
              return tok;
            };
            var peg$f26 = function(tok) {
              return options2.isVar(tok);
            };
            var peg$f27 = function(tok) {
              return tok;
            };
            var peg$f28 = function(tok) {
              return options2.isOperation(tok);
            };
            var peg$f29 = function(tok) {
              return tok;
            };
            var peg$f30 = function(tok) {
              return options2.isEquals(tok);
            };
            var peg$f31 = function(tok) {
              return tok;
            };
            var peg$f32 = function(tok) {
              return options2.isSubscript(tok);
            };
            var peg$f33 = function(tok) {
              return tok;
            };
            var peg$currPos = 0;
            var peg$posDetailsCache = [{ line: 1, column: 1 }];
            var peg$maxFailPos = 0;
            var peg$maxFailExpected = [];
            var peg$silentFails = 0;
            var peg$result;
            if ("startRule" in options2) {
              if (!(options2.startRule in peg$startRuleFunctions)) {
                throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
              }
              peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
            }
            function peg$anyExpectation() {
              return { type: "any" };
            }
            function peg$endExpectation() {
              return { type: "end" };
            }
            function peg$otherExpectation(description) {
              return { type: "other", description };
            }
            function peg$computePosDetails(pos) {
              var details = peg$posDetailsCache[pos];
              var p;
              if (details) {
                return details;
              } else {
                p = pos - 1;
                while (!peg$posDetailsCache[p]) {
                  p--;
                }
                details = peg$posDetailsCache[p];
                details = {
                  line: details.line,
                  column: details.column
                };
                while (p < pos) {
                  if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                  } else {
                    details.column++;
                  }
                  p++;
                }
                peg$posDetailsCache[pos] = details;
                return details;
              }
            }
            function peg$computeLocation(startPos, endPos, offset2) {
              var startPosDetails = peg$computePosDetails(startPos);
              var endPosDetails = peg$computePosDetails(endPos);
              var res = {
                source: peg$source,
                start: {
                  offset: startPos,
                  line: startPosDetails.line,
                  column: startPosDetails.column
                },
                end: {
                  offset: endPos,
                  line: endPosDetails.line,
                  column: endPosDetails.column
                }
              };
              if (offset2 && peg$source && typeof peg$source.offset === "function") {
                res.start = peg$source.offset(res.start);
                res.end = peg$source.offset(res.end);
              }
              return res;
            }
            function peg$fail(expected2) {
              if (peg$currPos < peg$maxFailPos) {
                return;
              }
              if (peg$currPos > peg$maxFailPos) {
                peg$maxFailPos = peg$currPos;
                peg$maxFailExpected = [];
              }
              peg$maxFailExpected.push(expected2);
            }
            function peg$buildStructuredError(expected2, found, location2) {
              return new peg$SyntaxError(
                peg$SyntaxError.buildMessage(expected2, found),
                expected2,
                found,
                location2
              );
            }
            function peg$parsebody() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsecomment_only_line();
              if (s2 === peg$FAILED) {
                s2 = peg$parseline_with_sep();
                if (s2 === peg$FAILED) {
                  s2 = peg$parsepartial_line_with_comment();
                }
              }
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsecomment_only_line();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseline_with_sep();
                  if (s2 === peg$FAILED) {
                    s2 = peg$parsepartial_line_with_comment();
                  }
                }
              }
              s2 = peg$parseline_without_sep();
              if (s2 === peg$FAILED) {
                s2 = peg$parseEOL();
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f0(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseEOL();
                if (s1 !== peg$FAILED) {
                  s1 = peg$f1();
                }
                s0 = s1;
              }
              return s0;
            }
            function peg$parseitem() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parseoperation();
              if (s1 === peg$FAILED) {
                s1 = null;
              }
              s2 = [];
              s3 = peg$parse_();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parse_();
              }
              s3 = [];
              s4 = peg$parsenon_var_token();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsenon_var_token();
              }
              s4 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parse_();
              }
              s5 = peg$parsevar();
              if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$parse_();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parse_();
                }
                s7 = [];
                s8 = peg$parsetoken();
                while (s8 !== peg$FAILED) {
                  s7.push(s8);
                  s8 = peg$parsetoken();
                }
                s8 = [];
                s9 = peg$parse_();
                while (s9 !== peg$FAILED) {
                  s8.push(s9);
                  s9 = peg$parse_();
                }
                s0 = peg$f3(s1, s3, s5, s7);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseoperation();
                if (s1 === peg$FAILED) {
                  s1 = null;
                }
                s2 = [];
                s3 = peg$parse_();
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parse_();
                }
                s3 = [];
                s4 = peg$parsenon_var_token();
                if (s4 !== peg$FAILED) {
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parsenon_var_token();
                  }
                } else {
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parse_();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parse_();
                  }
                  s0 = peg$f4(s1, s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e1);
                }
              }
              return s0;
            }
            function peg$parseline_with_sep() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              s1 = peg$parseline_without_sep();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsesep();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsetrailing_comment();
                  if (s3 === peg$FAILED) {
                    s3 = null;
                  }
                  s0 = peg$f5(s1, s2, s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsepartial_line_with_comment() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$parseline_without_sep();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsetrailing_comment();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f6(s1, s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseline_without_sep() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              peg$silentFails--;
              if (s2 !== peg$FAILED) {
                peg$currPos = s1;
                s1 = void 0;
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parseequation();
                s3 = peg$parseannotation();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                s0 = peg$f7(s2, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseannotation() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              s1 = peg$parseat();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parsenon_sep_token();
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parsenon_sep_token();
                }
                s0 = peg$f8(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseequation() {
              var s0, s1, s2, s3, s4;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseitem();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseitem();
              }
              s2 = peg$parseequals();
              if (s2 === peg$FAILED) {
                s2 = null;
              }
              s3 = [];
              s4 = peg$parsetoken();
              if (s4 === peg$FAILED) {
                s4 = peg$parseoperation();
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsetoken();
                if (s4 === peg$FAILED) {
                  s4 = peg$parseoperation();
                }
              }
              s0 = peg$f9(s1, s2, s3);
              peg$silentFails--;
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
              return s0;
            }
            function peg$parsetrailing_comment() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parse_();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parse_();
              }
              s2 = peg$parsesame_line_comment();
              if (s2 !== peg$FAILED) {
                s0 = peg$f10(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e4);
                }
              }
              return s0;
            }
            function peg$parsecomment_only_line() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parse_();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parse_();
              }
              s2 = peg$parseown_line_comment();
              if (s2 !== peg$FAILED) {
                s0 = peg$f11(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e5);
                }
              }
              return s0;
            }
            function peg$parsevar() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              s1 = peg$parsevar_token();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parse_();
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parse_();
                }
                s3 = peg$parsesubscript();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                s0 = peg$f12(s1, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsenon_var_token() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              s2 = peg$parsevar();
              peg$silentFails--;
              if (s2 === peg$FAILED) {
                s1 = void 0;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsetoken();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f13(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e6);
                }
              }
              return s0;
            }
            function peg$parsenon_sep_token() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              s2 = peg$parsesep();
              if (s2 === peg$FAILED) {
                s2 = peg$parsetrailing_comment();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseown_line_comment();
                }
              }
              peg$silentFails--;
              if (s2 === peg$FAILED) {
                s1 = void 0;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f14(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsetoken() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              s2 = peg$parsesep();
              if (s2 === peg$FAILED) {
                s2 = peg$parseat();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseoperation();
                  if (s2 === peg$FAILED) {
                    s2 = peg$parseequals();
                    if (s2 === peg$FAILED) {
                      s2 = peg$parsetrailing_comment();
                      if (s2 === peg$FAILED) {
                        s2 = peg$parseown_line_comment();
                      }
                    }
                  }
                }
              }
              peg$silentFails--;
              if (s2 === peg$FAILED) {
                s1 = void 0;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f15(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e7);
                }
              }
              return s0;
            }
            function peg$parsesame_line_comment() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f16(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f17(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e8);
                }
              }
              return s0;
            }
            function peg$parseown_line_comment() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f18(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f19(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e9);
                }
              }
              return s0;
            }
            function peg$parse_() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f20(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f21(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsesep() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f22(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f23(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e10);
                }
              }
              return s0;
            }
            function peg$parseat() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f24(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f25(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e11);
                }
              }
              return s0;
            }
            function peg$parsevar_token() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f26(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f27(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e12);
                }
              }
              return s0;
            }
            function peg$parseoperation() {
              var s0, s1, s2, s3, s4;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parse_();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parse_();
              }
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parse_();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parse_();
                }
                s4 = peg$f28(s2);
                if (s4) {
                  s4 = void 0;
                } else {
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s0 = peg$f29(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e13);
                }
              }
              return s0;
            }
            function peg$parseequals() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f30(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f31(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e14);
                }
              }
              return s0;
            }
            function peg$parsesubscript() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f32(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f33(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseEOL() {
              var s0, s1;
              s0 = peg$currPos;
              peg$silentFails++;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              peg$silentFails--;
              if (s1 === peg$FAILED) {
                s0 = void 0;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            if (!options2.isWhitespace) {
              try {
                Object.assign(options2, {
                  isSep: (node) => node.type === "string" && node.content === ",",
                  isVar: (node) => node.type === "string" && node.content.match(/[a-zA-Z]/),
                  isOperation: (node) => node.type === "string" && node.content.match(/[+-]/),
                  isEquals: (node) => node.type === "string" && node.content === "=",
                  isAt: (node) => node.type === "string" && node.content === "@",
                  isSubscript: (node) => node.content === "_",
                  isWhitespace: (node) => node.type === "whitespace",
                  isSameLineComment: (node) => node.type === "comment" && node.sameline,
                  isOwnLineComment: (node) => node.type === "comment" && !node.sameline
                });
              } catch (e) {
                console.warn("Error when initializing parser", e);
              }
            }
            peg$result = peg$startRuleFunction();
            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
              return peg$result;
            } else {
              if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                peg$fail(peg$endExpectation());
              }
              throw peg$buildStructuredError(
                peg$maxFailExpected,
                peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
                peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
              );
            }
          }
          return {
            SyntaxError: peg$SyntaxError,
            parse: peg$parse
          };
        }()
      );
      var _GluePegParser = (
        // Generated by Peggy 3.0.2.
        //
        // https://peggyjs.org/
        function() {
          function peg$subclass(child, parent) {
            function C() {
              this.constructor = child;
            }
            C.prototype = parent.prototype;
            child.prototype = new C();
          }
          function peg$SyntaxError(message, expected, found, location2) {
            var self2 = Error.call(this, message);
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
            }
            self2.expected = expected;
            self2.found = found;
            self2.location = location2;
            self2.name = "SyntaxError";
            return self2;
          }
          peg$subclass(peg$SyntaxError, Error);
          function peg$padEnd(str, targetLength, padString) {
            padString = padString || " ";
            if (str.length > targetLength) {
              return str;
            }
            targetLength -= str.length;
            padString += padString.repeat(targetLength);
            return str + padString.slice(0, targetLength);
          }
          peg$SyntaxError.prototype.format = function(sources) {
            var str = "Error: " + this.message;
            if (this.location) {
              var src = null;
              var k;
              for (k = 0; k < sources.length; k++) {
                if (sources[k].source === this.location.source) {
                  src = sources[k].text.split(/\r\n|\n|\r/g);
                  break;
                }
              }
              var s = this.location.start;
              var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
              var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
              if (src) {
                var e = this.location.end;
                var filler = peg$padEnd("", offset_s.line.toString().length, " ");
                var line = src[s.line - 1];
                var last = s.line === e.line ? e.column : line.length + 1;
                var hatLen = last - s.column || 1;
                str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
              } else {
                str += "\n at " + loc;
              }
            }
            return str;
          };
          peg$SyntaxError.buildMessage = function(expected, found) {
            var DESCRIBE_EXPECTATION_FNS = {
              literal: function(expectation) {
                return '"' + literalEscape(expectation.text) + '"';
              },
              class: function(expectation) {
                var escapedParts = expectation.parts.map(function(part) {
                  return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
                });
                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
              },
              any: function() {
                return "any character";
              },
              end: function() {
                return "end of input";
              },
              other: function(expectation) {
                return expectation.description;
              }
            };
            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            function literalEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function classEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function describeExpectation(expectation) {
              return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
            }
            function describeExpected(expected2) {
              var descriptions = expected2.map(describeExpectation);
              var i, j;
              descriptions.sort();
              if (descriptions.length > 0) {
                for (i = 1, j = 1; i < descriptions.length; i++) {
                  if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                  }
                }
                descriptions.length = j;
              }
              switch (descriptions.length) {
                case 1:
                  return descriptions[0];
                case 2:
                  return descriptions[0] + " or " + descriptions[1];
                default:
                  return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
              }
            }
            function describeFound(found2) {
              return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
            }
            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
          };
          function peg$parse(input, options2) {
            options2 = options2 !== void 0 ? options2 : {};
            var peg$FAILED = {};
            var peg$source = options2.grammarSource;
            var peg$startRuleFunctions = { root: peg$parseroot };
            var peg$startRuleFunction = peg$parseroot;
            var peg$c0 = "plus";
            var peg$c1 = "minus";
            var peg$c2 = "pt";
            var peg$c3 = "mm";
            var peg$c4 = "cm";
            var peg$c5 = "in";
            var peg$c6 = "ex";
            var peg$c7 = "em";
            var peg$c8 = "bp";
            var peg$c9 = "pc";
            var peg$c10 = "dd";
            var peg$c11 = "cc";
            var peg$c12 = "nd";
            var peg$c13 = "nc";
            var peg$c14 = "sp";
            var peg$c15 = "filll";
            var peg$c16 = "fill";
            var peg$c17 = "fil";
            var peg$c18 = ".";
            var peg$c19 = "+";
            var peg$c20 = "-";
            var peg$r0 = /^[0-9]/;
            var peg$e0 = peg$anyExpectation();
            var peg$e1 = peg$literalExpectation("plus", false);
            var peg$e2 = peg$literalExpectation("minus", false);
            var peg$e3 = peg$literalExpectation("pt", false);
            var peg$e4 = peg$literalExpectation("mm", false);
            var peg$e5 = peg$literalExpectation("cm", false);
            var peg$e6 = peg$literalExpectation("in", false);
            var peg$e7 = peg$literalExpectation("ex", false);
            var peg$e8 = peg$literalExpectation("em", false);
            var peg$e9 = peg$literalExpectation("bp", false);
            var peg$e10 = peg$literalExpectation("pc", false);
            var peg$e11 = peg$literalExpectation("dd", false);
            var peg$e12 = peg$literalExpectation("cc", false);
            var peg$e13 = peg$literalExpectation("nd", false);
            var peg$e14 = peg$literalExpectation("nc", false);
            var peg$e15 = peg$literalExpectation("sp", false);
            var peg$e16 = peg$literalExpectation("filll", false);
            var peg$e17 = peg$literalExpectation("fill", false);
            var peg$e18 = peg$literalExpectation("fil", false);
            var peg$e19 = peg$otherExpectation("number");
            var peg$e20 = peg$classExpectation([["0", "9"]], false, false);
            var peg$e21 = peg$literalExpectation(".", false);
            var peg$e22 = peg$literalExpectation("+", false);
            var peg$e23 = peg$literalExpectation("-", false);
            var peg$f0 = function(b, st, sh) {
              return {
                type: "glue",
                fixed: b,
                stretchable: st,
                shrinkable: sh,
                position: location2()
              };
            };
            var peg$f1 = function(glue) {
              return glue;
            };
            var peg$f2 = function(n, u) {
              return { type: "dim", value: n, unit: u };
            };
            var peg$f3 = function(n, u) {
              return { type: "dim", value: n, unit: u };
            };
            var peg$f4 = function(n, u) {
              return { type: "dim", value: n, unit: u };
            };
            var peg$f5 = function(n) {
              return parseFloat(n);
            };
            var peg$currPos = 0;
            var peg$savedPos = 0;
            var peg$posDetailsCache = [{ line: 1, column: 1 }];
            var peg$maxFailPos = 0;
            var peg$maxFailExpected = [];
            var peg$silentFails = 0;
            var peg$result;
            if ("startRule" in options2) {
              if (!(options2.startRule in peg$startRuleFunctions)) {
                throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
              }
              peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
            }
            function location2() {
              return peg$computeLocation(peg$savedPos, peg$currPos);
            }
            function peg$literalExpectation(text2, ignoreCase) {
              return { type: "literal", text: text2, ignoreCase };
            }
            function peg$classExpectation(parts, inverted, ignoreCase) {
              return { type: "class", parts, inverted, ignoreCase };
            }
            function peg$anyExpectation() {
              return { type: "any" };
            }
            function peg$endExpectation() {
              return { type: "end" };
            }
            function peg$otherExpectation(description) {
              return { type: "other", description };
            }
            function peg$computePosDetails(pos) {
              var details = peg$posDetailsCache[pos];
              var p;
              if (details) {
                return details;
              } else {
                p = pos - 1;
                while (!peg$posDetailsCache[p]) {
                  p--;
                }
                details = peg$posDetailsCache[p];
                details = {
                  line: details.line,
                  column: details.column
                };
                while (p < pos) {
                  if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                  } else {
                    details.column++;
                  }
                  p++;
                }
                peg$posDetailsCache[pos] = details;
                return details;
              }
            }
            function peg$computeLocation(startPos, endPos, offset2) {
              var startPosDetails = peg$computePosDetails(startPos);
              var endPosDetails = peg$computePosDetails(endPos);
              var res = {
                source: peg$source,
                start: {
                  offset: startPos,
                  line: startPosDetails.line,
                  column: startPosDetails.column
                },
                end: {
                  offset: endPos,
                  line: endPosDetails.line,
                  column: endPosDetails.column
                }
              };
              if (offset2 && peg$source && typeof peg$source.offset === "function") {
                res.start = peg$source.offset(res.start);
                res.end = peg$source.offset(res.end);
              }
              return res;
            }
            function peg$fail(expected2) {
              if (peg$currPos < peg$maxFailPos) {
                return;
              }
              if (peg$currPos > peg$maxFailPos) {
                peg$maxFailPos = peg$currPos;
                peg$maxFailExpected = [];
              }
              peg$maxFailExpected.push(expected2);
            }
            function peg$buildStructuredError(expected2, found, location22) {
              return new peg$SyntaxError(
                peg$SyntaxError.buildMessage(expected2, found),
                expected2,
                found,
                location22
              );
            }
            function peg$parseroot() {
              var s0, s1, s2, s3, s4;
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = peg$parsebase();
              if (s2 !== peg$FAILED) {
                s3 = peg$parsestretchable();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                s4 = peg$parseshrinkable();
                if (s4 === peg$FAILED) {
                  s4 = null;
                }
                peg$savedPos = s1;
                s1 = peg$f0(s2, s3, s4);
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                if (input.length > peg$currPos) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  if (input.length > peg$currPos) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                }
                peg$savedPos = s0;
                s0 = peg$f1(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsebase() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$parsenumber();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseunit();
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f2(s1, s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsestretchable() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 4) === peg$c0) {
                s1 = peg$c0;
                peg$currPos += 4;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e1);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsenumber();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parserubber_unit();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f3(s2, s3);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseshrinkable() {
              var s0, s1, s2, s3;
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 5) === peg$c1) {
                s1 = peg$c1;
                peg$currPos += 5;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsenumber();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parserubber_unit();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f4(s2, s3);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseunit() {
              var s0;
              if (input.substr(peg$currPos, 2) === peg$c2) {
                s0 = peg$c2;
                peg$currPos += 2;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c3) {
                  s0 = peg$c3;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e4);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c4) {
                    s0 = peg$c4;
                    peg$currPos += 2;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e5);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c5) {
                      s0 = peg$c5;
                      peg$currPos += 2;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e6);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c6) {
                        s0 = peg$c6;
                        peg$currPos += 2;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e7);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c7) {
                          s0 = peg$c7;
                          peg$currPos += 2;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e8);
                          }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c8) {
                            s0 = peg$c8;
                            peg$currPos += 2;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e9);
                            }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c9) {
                              s0 = peg$c9;
                              peg$currPos += 2;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e10);
                              }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 2) === peg$c10) {
                                s0 = peg$c10;
                                peg$currPos += 2;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e11);
                                }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c11) {
                                  s0 = peg$c11;
                                  peg$currPos += 2;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e12);
                                  }
                                }
                                if (s0 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 2) === peg$c12) {
                                    s0 = peg$c12;
                                    peg$currPos += 2;
                                  } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e13);
                                    }
                                  }
                                  if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 2) === peg$c13) {
                                      s0 = peg$c13;
                                      peg$currPos += 2;
                                    } else {
                                      s0 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$e14);
                                      }
                                    }
                                    if (s0 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 2) === peg$c14) {
                                        s0 = peg$c14;
                                        peg$currPos += 2;
                                      } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$e15);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              return s0;
            }
            function peg$parserubber_unit() {
              var s0;
              s0 = peg$parseunit();
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 5) === peg$c15) {
                  s0 = peg$c15;
                  peg$currPos += 5;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e16);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 4) === peg$c16) {
                    s0 = peg$c16;
                    peg$currPos += 4;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e17);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 3) === peg$c17) {
                      s0 = peg$c17;
                      peg$currPos += 3;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e18);
                      }
                    }
                  }
                }
              }
              return s0;
            }
            function peg$parsenumber() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = peg$currPos;
              s3 = peg$parsesign();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              s4 = peg$currPos;
              s5 = [];
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$r0.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e20);
                  }
                }
              }
              if (input.charCodeAt(peg$currPos) === 46) {
                s6 = peg$c18;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e21);
                }
              }
              if (s6 !== peg$FAILED) {
                s7 = [];
                if (peg$r0.test(input.charAt(peg$currPos))) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e20);
                  }
                }
                if (s8 !== peg$FAILED) {
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    if (peg$r0.test(input.charAt(peg$currPos))) {
                      s8 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e20);
                      }
                    }
                  }
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 === peg$FAILED) {
                s4 = [];
                if (peg$r0.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e20);
                  }
                }
                if (s5 !== peg$FAILED) {
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    if (peg$r0.test(input.charAt(peg$currPos))) {
                      s5 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e20);
                      }
                    }
                  }
                } else {
                  s4 = peg$FAILED;
                }
              }
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = input.substring(s1, peg$currPos);
              } else {
                s1 = s2;
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f5(s1);
              }
              s0 = s1;
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e19);
                }
              }
              return s0;
            }
            function peg$parsesign() {
              var s0;
              if (input.charCodeAt(peg$currPos) === 43) {
                s0 = peg$c19;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e22);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 45) {
                  s0 = peg$c20;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e23);
                  }
                }
              }
              return s0;
            }
            peg$result = peg$startRuleFunction();
            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
              return peg$result;
            } else {
              if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                peg$fail(peg$endExpectation());
              }
              throw peg$buildStructuredError(
                peg$maxFailExpected,
                peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
                peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
              );
            }
          }
          return {
            SyntaxError: peg$SyntaxError,
            parse: peg$parse
          };
        }()
      );
      var _TikzPegParser = (
        // Generated by Peggy 3.0.2.
        //
        // https://peggyjs.org/
        function() {
          function peg$subclass(child, parent) {
            function C() {
              this.constructor = child;
            }
            C.prototype = parent.prototype;
            child.prototype = new C();
          }
          function peg$SyntaxError(message, expected, found, location2) {
            var self2 = Error.call(this, message);
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
            }
            self2.expected = expected;
            self2.found = found;
            self2.location = location2;
            self2.name = "SyntaxError";
            return self2;
          }
          peg$subclass(peg$SyntaxError, Error);
          function peg$padEnd(str, targetLength, padString) {
            padString = padString || " ";
            if (str.length > targetLength) {
              return str;
            }
            targetLength -= str.length;
            padString += padString.repeat(targetLength);
            return str + padString.slice(0, targetLength);
          }
          peg$SyntaxError.prototype.format = function(sources) {
            var str = "Error: " + this.message;
            if (this.location) {
              var src = null;
              var k;
              for (k = 0; k < sources.length; k++) {
                if (sources[k].source === this.location.source) {
                  src = sources[k].text.split(/\r\n|\n|\r/g);
                  break;
                }
              }
              var s = this.location.start;
              var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
              var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
              if (src) {
                var e = this.location.end;
                var filler = peg$padEnd("", offset_s.line.toString().length, " ");
                var line = src[s.line - 1];
                var last = s.line === e.line ? e.column : line.length + 1;
                var hatLen = last - s.column || 1;
                str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
              } else {
                str += "\n at " + loc;
              }
            }
            return str;
          };
          peg$SyntaxError.buildMessage = function(expected, found) {
            var DESCRIBE_EXPECTATION_FNS = {
              literal: function(expectation) {
                return '"' + literalEscape(expectation.text) + '"';
              },
              class: function(expectation) {
                var escapedParts = expectation.parts.map(function(part) {
                  return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
                });
                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
              },
              any: function() {
                return "any character";
              },
              end: function() {
                return "end of input";
              },
              other: function(expectation) {
                return expectation.description;
              }
            };
            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            function literalEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function classEscape(s) {
              return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
              });
            }
            function describeExpectation(expectation) {
              return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
            }
            function describeExpected(expected2) {
              var descriptions = expected2.map(describeExpectation);
              var i, j;
              descriptions.sort();
              if (descriptions.length > 0) {
                for (i = 1, j = 1; i < descriptions.length; i++) {
                  if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                  }
                }
                descriptions.length = j;
              }
              switch (descriptions.length) {
                case 1:
                  return descriptions[0];
                case 2:
                  return descriptions[0] + " or " + descriptions[1];
                default:
                  return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
              }
            }
            function describeFound(found2) {
              return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
            }
            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
          };
          function peg$parse(input, options2) {
            options2 = options2 !== void 0 ? options2 : {};
            var peg$FAILED = {};
            var peg$source = options2.grammarSource;
            var peg$startRuleFunctions = { path_spec: peg$parsepath_spec, foreach_body: peg$parseforeach_body };
            var peg$startRuleFunction = peg$parsepath_spec;
            var peg$e0 = peg$anyExpectation();
            var peg$e3 = peg$otherExpectation("comment");
            var peg$e4 = peg$otherExpectation("floating comment");
            var peg$e5 = peg$otherExpectation("operation");
            var peg$e6 = peg$otherExpectation("=");
            var peg$f0 = function(v) {
              return v;
            };
            var peg$f1 = function(ops) {
              return { type: "path_spec", content: ops };
            };
            var peg$f2 = function(c1, op, comment) {
              return { op, comment };
            };
            var peg$f3 = function(c1, ops, c2, body) {
              const comments = [c1, ...ops.map((x) => x.comment), c2].filter(
                (x) => x
              );
              const attribute = ops.map((x) => x.op.content.content).join(" ");
              return {
                type: "animation",
                comments,
                attribute,
                content: body.content
              };
            };
            var peg$f4 = function(start, b) {
              return { ...b, start, type: "foreach" };
            };
            var peg$f5 = function(c1, variables, options22, c2, c3, list, c4, command) {
              const comments = [c1, c2, c3, c4].filter((x) => x);
              return {
                type: "foreach_body",
                variables,
                options: options22 && options22.content,
                list,
                command,
                comments
              };
            };
            var peg$f6 = function(c1, options22, c2, body) {
              const comments = [c1, c2].filter((x) => x);
              return {
                type: "svg_operation",
                options: options22 && options22.content,
                content: body,
                comments
              };
            };
            var peg$f7 = function(c1, c2, coord, c3, c4, x) {
              return { coord: x, comment: c4 };
            };
            var peg$f8 = function(c1, c2, coord, c3, a, c5) {
              const comments = [c1, c2, c3, a && a.comment, c5].filter((x) => x);
              return {
                type: "curve_to",
                controls: a ? [coord, a.coord] : [coord],
                comments
              };
            };
            var peg$f9 = function() {
              return { type: "line_to", command: "|-" };
            };
            var peg$f10 = function() {
              return { type: "line_to", command: "-|" };
            };
            var peg$f11 = function() {
              return { type: "line_to", command: "--" };
            };
            var peg$f12 = function(prefix, content) {
              return { type: "coordinate", content, prefix };
            };
            var peg$f13 = function(content) {
              return { type: "square_brace_group", content };
            };
            var peg$f14 = function(v) {
              return { type: "unknown", content: v };
            };
            var peg$f19 = function(tok) {
              return options2.isComment(tok);
            };
            var peg$f20 = function(tok) {
              return tok;
            };
            var peg$f21 = function(tok) {
              return options2.isWhitespace(tok);
            };
            var peg$f22 = function(tok) {
              return tok;
            };
            var peg$f23 = function(c) {
              return c;
            };
            var peg$f24 = function(tok) {
              return options2.isOperation(tok);
            };
            var peg$f25 = function(tok) {
              return { type: "operation", content: tok };
            };
            var peg$f26 = function(tok) {
              return options2.isChar(tok, "=");
            };
            var peg$f27 = function(tok) {
              return tok;
            };
            var peg$f28 = function(tok) {
              return options2.isChar(tok, "[");
            };
            var peg$f29 = function(tok) {
              return tok;
            };
            var peg$f30 = function(tok) {
              return options2.isChar(tok, "]");
            };
            var peg$f31 = function(tok) {
              return tok;
            };
            var peg$f32 = function(tok) {
              return options2.isChar(tok, "(");
            };
            var peg$f33 = function(tok) {
              return tok;
            };
            var peg$f34 = function(tok) {
              return options2.isChar(tok, ")");
            };
            var peg$f35 = function(tok) {
              return tok;
            };
            var peg$f36 = function(tok) {
              return options2.isChar(tok, "+");
            };
            var peg$f37 = function(tok) {
              return tok;
            };
            var peg$f38 = function(tok) {
              return options2.isChar(tok, "-");
            };
            var peg$f39 = function(tok) {
              return tok;
            };
            var peg$f40 = function(tok) {
              return options2.isChar(tok, "|");
            };
            var peg$f41 = function(tok) {
              return tok;
            };
            var peg$f42 = function(tok) {
              return options2.isChar(tok, ".");
            };
            var peg$f43 = function(tok) {
              return tok;
            };
            var peg$f44 = function(tok) {
              return options2.isChar(tok, "controls");
            };
            var peg$f45 = function(tok) {
              return tok;
            };
            var peg$f46 = function(tok) {
              return options2.isChar(tok, "and");
            };
            var peg$f47 = function(tok) {
              return tok;
            };
            var peg$f48 = function(tok) {
              return options2.isChar(tok, "svg");
            };
            var peg$f49 = function(tok) {
              return tok;
            };
            var peg$f50 = function(tok) {
              return options2.isGroup(tok);
            };
            var peg$f51 = function(tok) {
              return tok;
            };
            var peg$f52 = function(tok) {
              return options2.isAnyMacro(tok);
            };
            var peg$f53 = function(tok) {
              return tok;
            };
            var peg$f54 = function(tok) {
              return options2.isChar(tok, "foreach");
            };
            var peg$f55 = function(tok) {
              return tok;
            };
            var peg$f56 = function(tok) {
              return options2.isMacro(tok, "foreach");
            };
            var peg$f57 = function(tok) {
              return tok;
            };
            var peg$f58 = function(tok) {
              return options2.isChar(tok, "in");
            };
            var peg$f59 = function(tok) {
              return tok;
            };
            var peg$f60 = function(tok) {
              return options2.isChar(tok, ":");
            };
            var peg$f61 = function(tok) {
              return tok;
            };
            var peg$currPos = 0;
            var peg$posDetailsCache = [{ line: 1, column: 1 }];
            var peg$maxFailPos = 0;
            var peg$maxFailExpected = [];
            var peg$silentFails = 0;
            var peg$result;
            if ("startRule" in options2) {
              if (!(options2.startRule in peg$startRuleFunctions)) {
                throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
              }
              peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
            }
            function peg$anyExpectation() {
              return { type: "any" };
            }
            function peg$endExpectation() {
              return { type: "end" };
            }
            function peg$otherExpectation(description) {
              return { type: "other", description };
            }
            function peg$computePosDetails(pos) {
              var details = peg$posDetailsCache[pos];
              var p;
              if (details) {
                return details;
              } else {
                p = pos - 1;
                while (!peg$posDetailsCache[p]) {
                  p--;
                }
                details = peg$posDetailsCache[p];
                details = {
                  line: details.line,
                  column: details.column
                };
                while (p < pos) {
                  if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                  } else {
                    details.column++;
                  }
                  p++;
                }
                peg$posDetailsCache[pos] = details;
                return details;
              }
            }
            function peg$computeLocation(startPos, endPos, offset2) {
              var startPosDetails = peg$computePosDetails(startPos);
              var endPosDetails = peg$computePosDetails(endPos);
              var res = {
                source: peg$source,
                start: {
                  offset: startPos,
                  line: startPosDetails.line,
                  column: startPosDetails.column
                },
                end: {
                  offset: endPos,
                  line: endPosDetails.line,
                  column: endPosDetails.column
                }
              };
              if (offset2 && peg$source && typeof peg$source.offset === "function") {
                res.start = peg$source.offset(res.start);
                res.end = peg$source.offset(res.end);
              }
              return res;
            }
            function peg$fail(expected2) {
              if (peg$currPos < peg$maxFailPos) {
                return;
              }
              if (peg$currPos > peg$maxFailPos) {
                peg$maxFailPos = peg$currPos;
                peg$maxFailExpected = [];
              }
              peg$maxFailExpected.push(expected2);
            }
            function peg$buildStructuredError(expected2, found, location2) {
              return new peg$SyntaxError(
                peg$SyntaxError.buildMessage(expected2, found),
                expected2,
                found,
                location2
              );
            }
            function peg$parsepath_spec() {
              var s0, s1, s2, s3, s4, s5;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$currPos;
              s3 = peg$parsesquare_brace_group();
              if (s3 === peg$FAILED) {
                s3 = peg$parsecoordinate();
                if (s3 === peg$FAILED) {
                  s3 = peg$parsecurve_to();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parseline_to();
                    if (s3 === peg$FAILED) {
                      s3 = peg$parsesvg();
                      if (s3 === peg$FAILED) {
                        s3 = peg$parseforeach();
                        if (s3 === peg$FAILED) {
                          s3 = peg$parseoperation();
                          if (s3 === peg$FAILED) {
                            s3 = peg$parsecomment();
                            if (s3 === peg$FAILED) {
                              s3 = peg$parseanimation();
                              if (s3 === peg$FAILED) {
                                s3 = peg$parseunknown();
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parse_();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parse_();
                }
                s2 = peg$f0(s3);
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$currPos;
                  s3 = peg$parsesquare_brace_group();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parsecoordinate();
                    if (s3 === peg$FAILED) {
                      s3 = peg$parsecurve_to();
                      if (s3 === peg$FAILED) {
                        s3 = peg$parseline_to();
                        if (s3 === peg$FAILED) {
                          s3 = peg$parsesvg();
                          if (s3 === peg$FAILED) {
                            s3 = peg$parseforeach();
                            if (s3 === peg$FAILED) {
                              s3 = peg$parseoperation();
                              if (s3 === peg$FAILED) {
                                s3 = peg$parsecomment();
                                if (s3 === peg$FAILED) {
                                  s3 = peg$parseanimation();
                                  if (s3 === peg$FAILED) {
                                    s3 = peg$parseunknown();
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$parse_();
                    while (s5 !== peg$FAILED) {
                      s4.push(s5);
                      s5 = peg$parse_();
                    }
                    s2 = peg$f0(s3);
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s1 = peg$f1(s1);
              }
              s0 = s1;
              return s0;
            }
            function peg$parseanimation() {
              var s0, s1, s2, s3, s4, s5, s6;
              s0 = peg$currPos;
              s1 = peg$parsecolon();
              if (s1 !== peg$FAILED) {
                s2 = peg$parse_comment_();
                s3 = [];
                s4 = peg$currPos;
                s5 = peg$parseoperation();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_comment_();
                  s4 = peg$f2(s2, s5, s6);
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$currPos;
                    s5 = peg$parseoperation();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parse_comment_();
                      s4 = peg$f2(s2, s5, s6);
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  }
                } else {
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseequals();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parse_comment_();
                    s6 = peg$parsegroup();
                    if (s6 !== peg$FAILED) {
                      s0 = peg$f3(s2, s3, s5, s6);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseforeach() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$parseforeach_keyword();
              if (s1 === peg$FAILED) {
                s1 = peg$parseforeach_macro();
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parseforeach_body();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f4(s1, s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseforeach_body() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
              s0 = peg$currPos;
              s1 = peg$parse_comment_();
              s2 = peg$currPos;
              s3 = [];
              s4 = peg$currPos;
              s5 = peg$currPos;
              peg$silentFails++;
              s6 = peg$parsein_keyword();
              if (s6 === peg$FAILED) {
                s6 = peg$parsesquare_brace_group();
              }
              peg$silentFails--;
              if (s6 === peg$FAILED) {
                s5 = void 0;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                s5 = peg$currPos;
                peg$silentFails++;
                s6 = peg$parsein_keyword();
                if (s6 === peg$FAILED) {
                  s6 = peg$parsesquare_brace_group();
                }
                peg$silentFails--;
                if (s6 === peg$FAILED) {
                  s5 = void 0;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                if (s5 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s6 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    s5 = [s5, s6];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
              s2 = input.substring(s2, peg$currPos);
              s3 = peg$parsesquare_brace_group();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              s4 = peg$parse_comment_();
              s5 = peg$parsein_keyword();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_comment_();
                s7 = peg$parsegroup();
                if (s7 === peg$FAILED) {
                  s7 = peg$parsemacro();
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_comment_();
                  s9 = peg$parseforeach();
                  if (s9 === peg$FAILED) {
                    s9 = peg$parsegroup();
                    if (s9 === peg$FAILED) {
                      s9 = peg$parsemacro();
                    }
                  }
                  if (s9 !== peg$FAILED) {
                    s0 = peg$f5(s1, s2, s3, s4, s6, s7, s8, s9);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsesvg() {
              var s0, s1, s2, s3, s4, s5;
              s0 = peg$currPos;
              s1 = peg$parsesvg_keyword();
              if (s1 !== peg$FAILED) {
                s2 = peg$parse_comment_();
                s3 = peg$parsesquare_brace_group();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                s4 = peg$parse_comment_();
                s5 = peg$parsegroup();
                if (s5 !== peg$FAILED) {
                  s0 = peg$f6(s2, s3, s4, s5);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsecurve_to() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
              s0 = peg$currPos;
              s1 = peg$parsedotdot();
              if (s1 !== peg$FAILED) {
                s2 = peg$parse_comment_();
                s3 = peg$parsecontrols_keyword();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_comment_();
                  s5 = peg$parsecoordinate();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parse_comment_();
                    s7 = peg$currPos;
                    s8 = peg$parseand_keyword();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_comment_();
                      s10 = peg$parsecoordinate();
                      if (s10 !== peg$FAILED) {
                        s7 = peg$f7(s2, s4, s5, s6, s9, s10);
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                    if (s7 === peg$FAILED) {
                      s7 = null;
                    }
                    s8 = peg$parse_comment_();
                    s9 = peg$parsedotdot();
                    if (s9 !== peg$FAILED) {
                      s0 = peg$f8(s2, s4, s5, s6, s7, s8);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseline_to() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$parsepipe();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseminus();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f9();
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseminus();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parsepipe();
                  if (s2 !== peg$FAILED) {
                    s0 = peg$f10();
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parseminus();
                  if (s1 !== peg$FAILED) {
                    s2 = peg$parseminus();
                    if (s2 !== peg$FAILED) {
                      s0 = peg$f11();
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                }
              }
              return s0;
            }
            function peg$parsecoordinate() {
              var s0, s1, s2, s3, s4, s5, s6, s7;
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = peg$currPos;
              s3 = peg$parseplus();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseplus();
                if (s4 === peg$FAILED) {
                  s4 = null;
                }
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 === peg$FAILED) {
                s2 = null;
              }
              s1 = input.substring(s1, peg$currPos);
              s2 = peg$parseopen_paren();
              if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = [];
                s5 = peg$currPos;
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$parseclose_paren();
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    s6 = [s6, s7];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$currPos;
                  s6 = peg$currPos;
                  peg$silentFails++;
                  s7 = peg$parseclose_paren();
                  peg$silentFails--;
                  if (s7 === peg$FAILED) {
                    s6 = void 0;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s7 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      s6 = [s6, s7];
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                }
                s3 = input.substring(s3, peg$currPos);
                s4 = peg$parseclose_paren();
                if (s4 !== peg$FAILED) {
                  s0 = peg$f12(s1, s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsesquare_brace_group() {
              var s0, s1, s2, s3, s4, s5, s6;
              s0 = peg$currPos;
              s1 = peg$parseopen_square_brace();
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = [];
                s4 = peg$currPos;
                s5 = peg$currPos;
                peg$silentFails++;
                s6 = peg$parseclose_square_brace();
                peg$silentFails--;
                if (s6 === peg$FAILED) {
                  s5 = void 0;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                if (s5 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s6 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    s5 = [s5, s6];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$currPos;
                  s5 = peg$currPos;
                  peg$silentFails++;
                  s6 = peg$parseclose_square_brace();
                  peg$silentFails--;
                  if (s6 === peg$FAILED) {
                    s5 = void 0;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                  if (s5 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s6 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      s5 = [s5, s6];
                      s4 = s5;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                }
                s2 = input.substring(s2, peg$currPos);
                s3 = peg$parseclose_square_brace();
                if (s3 !== peg$FAILED) {
                  s0 = peg$f13(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsedotdot() {
              var s0, s1, s2;
              s0 = peg$currPos;
              s1 = peg$parsedot();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsedot();
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseunknown() {
              var s0, s1;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s1 = peg$f14(s1);
              }
              s0 = s1;
              return s0;
            }
            function peg$parsecomment() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f19(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f20(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              return s0;
            }
            function peg$parse_() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f21(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f22(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parse_comment_() {
              var s0, s1, s2, s3, s4;
              peg$silentFails++;
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parse_();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parse_();
              }
              s2 = peg$parsecomment();
              if (s2 === peg$FAILED) {
                s2 = null;
              }
              s3 = [];
              s4 = peg$parse_();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_();
              }
              s0 = peg$f23(s2);
              peg$silentFails--;
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e4);
              }
              return s0;
            }
            function peg$parseoperation() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f24(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f25(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e5);
                }
              }
              return s0;
            }
            function peg$parseequals() {
              var s0, s1, s2;
              peg$silentFails++;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f26(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f27(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e6);
                }
              }
              return s0;
            }
            function peg$parseopen_square_brace() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f28(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f29(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseclose_square_brace() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f30(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f31(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseopen_paren() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f32(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f33(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseclose_paren() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f34(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f35(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseplus() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f36(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f37(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseminus() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f38(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f39(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsepipe() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f40(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f41(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsedot() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f42(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f43(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsecontrols_keyword() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f44(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f45(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseand_keyword() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f46(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f47(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsesvg_keyword() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f48(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f49(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsegroup() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f50(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f51(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsemacro() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f52(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f53(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseforeach_keyword() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f54(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f55(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parseforeach_macro() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f56(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f57(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsein_keyword() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f58(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f59(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            function peg$parsecolon() {
              var s0, s1, s2;
              s0 = peg$currPos;
              if (input.length > peg$currPos) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$f60(s1);
                if (s2) {
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f61(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              return s0;
            }
            if (!options2.isWhitespace) {
              try {
                Object.assign(options2, {
                  isChar: (node, char) => node.type === "string" && node.content === char,
                  isOperation: (node) => node.type === "string" && node.content.match(/[a-zA-Z]/),
                  isWhitespace: (node) => node.type === "whitespace" || node.type === "parbreak",
                  isSameLineComment: (node) => node.type === "comment" && node.sameline,
                  isOwnLineComment: (node) => node.type === "comment" && !node.sameline,
                  isComment: (node) => node.type === "comment",
                  isGroup: (node) => node.type === "group",
                  isMacro: (node, name) => node.type === "macro" && node.content === name,
                  isAnyMacro: (node) => node.type === "macro"
                });
              } catch (e) {
                console.warn("Error when initializing parser", e);
              }
            }
            peg$result = peg$startRuleFunction();
            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
              return peg$result;
            } else {
              if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                peg$fail(peg$endExpectation());
              }
              throw peg$buildStructuredError(
                peg$maxFailExpected,
                peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
                peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
              );
            }
          }
          return {
            SyntaxError: peg$SyntaxError,
            parse: peg$parse
          };
        }()
      );
      var LatexPegParser = _LatexPegParser;
      var AlignEnvironmentPegParser = _AlignEnvironmentPegParser;
      var ArgSpecPegParser = _ArgSpecPegParser;
      var PgfkeysPegParser = _PgfkeysPegParser;
      var MacroSubstitutionPegParser = _MacroSubstitutionPegParser;
      var LigaturesPegParser = _LigaturesPegParser;
      var XColorPegParser = _XColorPegParser;
      var TabularPegParser = _TabularPegParser;
      var SystemePegParser = _SystemePegParser;
      var GluePegParser = _GluePegParser;
      var TikzPegParser = _TikzPegParser;
      exports.AlignEnvironmentPegParser = AlignEnvironmentPegParser;
      exports.ArgSpecPegParser = ArgSpecPegParser;
      exports.GluePegParser = GluePegParser;
      exports.LatexPegParser = LatexPegParser;
      exports.LigaturesPegParser = LigaturesPegParser;
      exports.MacroSubstitutionPegParser = MacroSubstitutionPegParser;
      exports.PgfkeysPegParser = PgfkeysPegParser;
      exports.SystemePegParser = SystemePegParser;
      exports.TabularPegParser = TabularPegParser;
      exports.TikzPegParser = TikzPegParser;
      exports.XColorPegParser = XColorPegParser;
      exports.decorateArrayForPegjs = decorateArrayForPegjs;
      exports.splitStringsIntoSingleChars = splitStringsIntoSingleChars;
    }
  });

  // node_modules/unicode2latex/tables/biblatex.json
  var require_biblatex = __commonJS({
    "node_modules/unicode2latex/tables/biblatex.json"(exports, module) {
      module.exports = { "base": { "#": { "text": "\\#", "math": "\\#" }, "$": { "text": "\\$", "math": "\\$" }, "%": { "text": "\\%", "math": "\\%" }, "&": { "text": "\\&", "math": "\\&" }, "_": { "text": "\\_", "math": "\\_" }, "\xA0": { "text": "~", "math": "~" }, "\xA3": { "text": "\\pounds", "math": "\\pounds", "macrospacer": true }, "\xA7": { "text": "\\S", "math": "\\S", "macrospacer": true }, "\xA9": { "text": "\\copyright", "math": "\\copyright", "macrospacer": true, "alt": ["textcomp"] }, "\xAD": { "text": "\\-", "math": "\\-" }, "\xB6": { "text": "\\P", "math": "\\P", "macrospacer": true, "alt": ["textcomp"] }, "\u2020": { "text": "\\dag", "math": "\\dag", "macrospacer": true }, "\u2021": { "text": "\\ddag", "math": "\\ddag", "macrospacer": true }, "\u2026": { "text": "\\dots", "math": "\\dots", "macrospacer": true }, "\u205F": { "text": "\\:", "math": "\\:" }, "\u2212": { "text": "-", "math": "-" }, "\u263F": { "text": "\\mercury", "math": "\\mercury", "macrospacer": true }, "\u2643": { "text": "\\jupiter", "math": "\\jupiter", "macrospacer": true }, "\u2644": { "text": "\\saturn", "math": "\\saturn", "macrospacer": true }, "\u2645": { "text": "\\uranus", "math": "\\uranus", "macrospacer": true }, "\u2646": { "text": "\\neptune", "math": "\\neptune", "macrospacer": true }, "\u2647": { "text": "\\pluto", "math": "\\pluto", "macrospacer": true }, "\u2648": { "text": "\\aries", "math": "\\aries", "macrospacer": true }, "\u2649": { "text": "\\taurus", "math": "\\taurus", "macrospacer": true }, "\u264A": { "text": "\\gemini", "math": "\\gemini", "macrospacer": true }, "\u264B": { "text": "\\cancer", "math": "\\cancer", "macrospacer": true }, "\u264C": { "text": "\\leo", "math": "\\leo", "macrospacer": true }, "\u264D": { "text": "\\virgo", "math": "\\virgo", "macrospacer": true }, "\u264E": { "text": "\\libra", "math": "\\libra", "macrospacer": true }, "\u264F": { "text": "\\scorpio", "math": "\\scorpio", "macrospacer": true }, "\u2650": { "text": "\\sagittarius", "math": "\\sagittarius", "macrospacer": true }, "\u2651": { "text": "\\capricornus", "math": "\\capricornus", "macrospacer": true }, "\u2652": { "text": "\\aquarius", "math": "\\aquarius", "macrospacer": true }, "<": { "math": "<" }, ">": { "math": ">" }, "\\": { "text": "\\textbackslash", "math": "\\backslash", "macrospacer": true }, "|": { "text": "\\textbar", "math": "\\vert", "macrospacer": true }, "\xAC": { "text": "\\textlnot", "math": "\\lnot", "macrospacer": true }, "\xB0": { "math": "^\\circ", "alt": ["textcomp"] }, "\xB1": { "text": "\\textpm", "math": "\\pm", "macrospacer": true }, "\xB2": { "math": "^{2}" }, "\xB3": { "math": "^{3}" }, "\xB7": { "math": "\\cdot" }, "\xB9": { "math": "^{1}" }, "\xBC": { "math": "\\frac{1}{4}" }, "\xBD": { "math": "\\frac{1}{2}" }, "\xBE": { "math": "\\frac{3}{4}" }, "\xD7": { "text": "\\texttimes", "math": "\\times", "macrospacer": true }, "\xF7": { "text": "\\textdiv", "math": "\\div", "macrospacer": true }, "\u0127": { "math": "\\hbar", "alt": ["tipa"] }, "\u0131": { "text": "\\i", "math": "\\imath", "macrospacer": true }, "\u0192": { "text": "\\textflorin", "math": "f", "macrospacer": true }, "\u0237": { "math": "\\jmath" }, "\u025B": { "math": "\\varepsilon" }, "\u0263": { "math": "\\gamma", "alt": ["tipa"] }, "\u02B0": { "text": "\\textsuperscript{h}", "math": "^{h}" }, "\u02B2": { "text": "\\textsuperscript{j}", "math": "^{j}" }, "\u02B3": { "text": "\\textsuperscript{r}", "math": "^{r}" }, "\u02B7": { "text": "\\textsuperscript{w}", "math": "^{w}" }, "\u02B8": { "text": "\\textsuperscript{y}", "math": "^{y}" }, "\u02E1": { "text": "\\textsuperscript{l}", "math": "^{l}" }, "\u02E2": { "text": "\\textsuperscript{s}", "math": "^{s}" }, "\u02E3": { "text": "\\textsuperscript{x}", "math": "^{x}" }, "\u0305": { "math": "\\overline" }, "\u030A": { "text": "\\r", "math": "\\mathring", "macrospacer": true }, "\u0331": { "math": "\\underbar", "alt": ["tipa"] }, "\u0332": { "math": "\\underline" }, "\u0338": { "math": "\\not" }, "\u03A5\u0301": { "math": "\\mathrm{'Y}" }, "\u03A9\u0301": { "math": "\\mathrm{'\\Omega}" }, "\u03B9\u0308\u0301": { "math": "\\acute{\\ddot{\\iota}}" }, "\u0393": { "math": "\\Gamma", "alt": ["unicode-math"] }, "\u0394": { "math": "\\Delta", "alt": ["unicode-math"] }, "\u0398": { "math": "\\Theta", "alt": ["unicode-math"] }, "\u039B": { "math": "\\Lambda", "alt": ["unicode-math"] }, "\u039E": { "math": "\\Xi" }, "\u03A0": { "math": "\\Pi" }, "\u03A3": { "math": "\\Sigma" }, "\u03A5": { "math": "\\Upsilon" }, "\u03A6": { "math": "\\Phi" }, "\u03A8": { "math": "\\Psi" }, "\u03A9": { "text": "\\textohm", "math": "\\Omega", "macrospacer": true }, "\u0399\u0308": { "math": "\\mathrm{\\ddot{I}}" }, "\u03A5\u0308": { "math": "\\mathrm{\\ddot{Y}}" }, "\u03B1\u0301": { "math": "\\acute{\\alpha}" }, "\u03B5\u0301": { "math": "\\acute{\\epsilon}" }, "\u03B7\u0301": { "math": "\\acute{\\eta}" }, "\u03B9\u0301": { "math": "\\acute{\\iota}" }, "\u03C5\u0308\u0301": { "math": "\\acute{\\ddot{\\upsilon}}" }, "\u03B1": { "math": "\\alpha", "alt": ["textalpha"] }, "\u03B2": { "math": "\\beta" }, "\u03B3": { "math": "\\gamma" }, "\u03B4": { "math": "\\delta" }, "\u03B5": { "math": "\\varepsilon" }, "\u03B6": { "math": "\\zeta" }, "\u03B7": { "math": "\\eta" }, "\u03B8": { "text": "\\texttheta", "math": "\\theta", "macrospacer": true }, "\u03B9": { "math": "\\iota" }, "\u03BA": { "math": "\\kappa" }, "\u03BB": { "math": "\\lambda" }, "\u03BC": { "math": "\\mu" }, "\u03BD": { "math": "\\nu" }, "\u03BE": { "math": "\\xi" }, "\u03C0": { "math": "\\pi" }, "\u{1D70C}": { "math": "\\rho", "alt": ["unicode-math"] }, "\u03C1": { "math": "\\rho" }, "\u03C2": { "math": "\\varsigma" }, "\u03C3": { "math": "\\sigma" }, "\u03C4": { "math": "\\tau" }, "\u03C5": { "math": "\\upsilon" }, "\u03C6": { "math": "\\varphi" }, "\u03C7": { "math": "\\chi" }, "\u03C8": { "math": "\\psi" }, "\u03C9": { "math": "\\omega" }, "\u03B9\u0308": { "math": "\\ddot{\\iota}" }, "\u03C5\u0308": { "math": "\\ddot{\\upsilon}" }, "\u03C5\u0301": { "math": "\\acute{\\upsilon}" }, "\u03C9\u0301": { "math": "\\acute{\\omega}" }, "\u03D1": { "text": "\\textvartheta", "math": "\\vartheta", "macrospacer": true }, "\u03D2": { "math": "\\Upsilon" }, "\u03D5": { "math": "\\phi" }, "\u03D6": { "math": "\\varpi" }, "\u03D8": { "math": "\\Qoppa" }, "\u03D9": { "math": "\\qoppa" }, "\u03DA": { "math": "\\Stigma" }, "\u03DB": { "math": "\\stigma" }, "\u03DC": { "math": "\\Digamma" }, "\u03DD": { "math": "\\digamma" }, "\u03DE": { "math": "\\Koppa" }, "\u03DF": { "math": "\\koppa" }, "\u03E0": { "math": "\\Sampi" }, "\u03E1": { "math": "\\sampi" }, "\u03F1": { "math": "\\varrho" }, "\u03F4": { "text": "\\textTheta", "math": "\\upvarTheta", "macrospacer": true }, "\u03F5": { "math": "\\epsilon" }, "\u03F6": { "math": "\\backepsilon", "alt": ["unicode-math"] }, "\u0871": { "math": "\\\\backslash" }, "\u1D43": { "text": "\\textsuperscript{a}", "math": "^{a}" }, "\u1D2C": { "text": "\\textsuperscript{A}", "math": "^{A}" }, "\u1D47": { "text": "\\textsuperscript{b}", "math": "^{b}" }, "\u1D48": { "text": "\\textsuperscript{d}", "math": "^{d}" }, "\u1D49": { "text": "\\textsuperscript{e}", "math": "^{e}" }, "\u1D4D": { "text": "\\textsuperscript{g}", "math": "^{g}" }, "\u1D4F": { "text": "\\textsuperscript{k}", "math": "^{k}" }, "\u1D50": { "text": "\\textsuperscript{m}", "math": "^{m}" }, "\u1D52": { "text": "\\textsuperscript{o}", "math": "^{o}" }, "\u1D56": { "text": "\\textsuperscript{p}", "math": "^{p}" }, "\u1D57": { "text": "\\textsuperscript{t}", "math": "^{t}" }, "\u1D58": { "text": "\\textsuperscript{u}", "math": "^{u}" }, "\u1D5B": { "text": "\\textsuperscript{v}", "math": "^{v}" }, "\u1D9C": { "text": "\\textsuperscript{c}", "math": "^{c}" }, "\u1DA0": { "text": "\\textsuperscript{f}", "math": "^{f}" }, "\u1DBB": { "text": "\\textsuperscript{z}", "math": "^{z}" }, "\u2003": { "math": "\\quad" }, "\u200A": { "math": "\\mkern1mu" }, "\u2022": { "math": "\\bullet", "alt": ["textcomp"] }, "\u2032": { "math": "\\prime" }, "\u2033": { "math": "{''}", "alt": ["unicode-math"] }, "\u2034": { "math": "{'''}", "alt": ["unicode-math"] }, "\u2057": { "math": "''''", "alt": ["unicode-math"] }, "\u2070": { "math": "^{0}" }, "\u2071": { "text": "\\textsuperscript{i}", "math": "^{i}" }, "\u2074": { "math": "^{4}" }, "\u2075": { "math": "^{5}" }, "\u2076": { "math": "^{6}" }, "\u2077": { "math": "^{7}" }, "\u2078": { "math": "^{8}" }, "\u2079": { "math": "^{9}" }, "\u207A": { "math": "^{+}" }, "\u207B": { "math": "^{-}" }, "\u207C": { "math": "^{=}" }, "\u207D": { "math": "^{(}" }, "\u207E": { "math": "^{)}" }, "\u207F": { "math": "^{n}" }, "\u2080": { "math": "_{0}" }, "\u2081": { "math": "_{1}" }, "\u2082": { "math": "_{2}" }, "\u2083": { "math": "_{3}" }, "\u2084": { "math": "_{4}" }, "\u2085": { "math": "_{5}" }, "\u2086": { "math": "_{6}" }, "\u2087": { "math": "_{7}" }, "\u2088": { "math": "_{8}" }, "\u2089": { "math": "_{9}" }, "\u208A": { "math": "_{+}" }, "\u208B": { "math": "_{-}" }, "\u208C": { "math": "_{=}" }, "\u208D": { "math": "_{(}" }, "\u208E": { "math": "_{)}" }, "\u2090": { "text": "\\textsubscript{a}", "math": "_{a}" }, "\u2091": { "text": "\\textsubscript{e}", "math": "_{e}" }, "\u2092": { "text": "\\textsubscript{o}", "math": "_{o}" }, "\u2093": { "text": "\\textsubscript{x}", "math": "_{x}" }, "\u2095": { "text": "\\textsubscript{h}", "math": "_{h}" }, "\u2096": { "text": "\\textsubscript{k}", "math": "_{k}" }, "\u2097": { "text": "\\textsubscript{l}", "math": "_{l}" }, "\u2098": { "text": "\\textsubscript{m}", "math": "_{m}" }, "\u2099": { "text": "\\textsubscript{n}", "math": "_{n}" }, "\u209A": { "text": "\\textsubscript{p}", "math": "_{p}" }, "\u209B": { "text": "\\textsubscript{s}", "math": "_{s}" }, "\u209C": { "text": "\\textsubscript{t}", "math": "_{t}" }, "\u20D0": { "math": "\\lvec" }, "\u20D6": { "math": "\\LVec" }, "\u2102": { "math": "\\mathbb{C}" }, "\u2107": { "math": "\\Euler" }, "\u210B": { "math": "\\mathcal{H}", "alt": ["mathrsfs"] }, "\u210C": { "math": "\\mathfrak{H}" }, "\u210D": { "math": "\\mathbb{H}" }, "\u2111": { "math": "\\mathfrak{I}" }, "\u2113": { "math": "\\ell" }, "\u2115": { "math": "\\mathbb{N}" }, "\u2118": { "math": "\\wp" }, "\u2119": { "math": "\\mathbb{P}" }, "\u211A": { "math": "\\mathbb{Q}" }, "\u211C": { "math": "\\mathfrak{R}" }, "\u211D": { "math": "\\mathbb{R}" }, "\u2124": { "math": "\\mathbb{Z}" }, "\u2128": { "math": "\\mathfrak{Z}" }, "A\u030A": { "text": "\\AA", "math": "\\Angstroem", "macrospacer": true }, "\u212D": { "math": "\\mathfrak{C}" }, "\u2135": { "math": "\\aleph" }, "\u213C": { "math": "\\mathbb{\\pi}" }, "\u213D": { "math": "\\mathbb{\\gamma}" }, "\u213E": { "math": "\\mathbb{\\Gamma}" }, "\u213F": { "math": "\\mathbb{\\Pi}" }, "\u2140": { "math": "\\mathbb{\\Sigma}" }, "\u2146": { "math": "\\DifferentialD" }, "\u2147": { "math": "\\ExponetialE" }, "\u2148": { "math": "\\ComplexI" }, "\u2149": { "math": "\\ComplexJ" }, "\u214B": { "math": "\\invamp" }, "\u2150": { "math": "\\frac{1}{7}" }, "\u2151": { "math": "\\frac{1}{9}" }, "\u2152": { "math": "\\frac{1}{10}" }, "\u2153": { "math": "\\frac{1}{3}" }, "\u2154": { "math": "\\frac{2}{3}" }, "\u2155": { "math": "\\frac{1}{5}" }, "\u2156": { "math": "\\frac{2}{5}" }, "\u2157": { "math": "\\frac{3}{5}" }, "\u2158": { "math": "\\frac{4}{5}" }, "\u2159": { "math": "\\frac{1}{6}" }, "\u215A": { "math": "\\frac{5}{6}" }, "\u215B": { "math": "\\frac{1}{8}" }, "\u215C": { "math": "\\frac{3}{8}" }, "\u215D": { "math": "\\frac{5}{8}" }, "\u215E": { "math": "\\frac{7}{8}" }, "\u215F": { "math": "\\frac{1}" }, "\u2189": { "math": "\\frac{0}{3}" }, "\u2190": { "text": "\\textleftarrow", "math": "\\leftarrow", "macrospacer": true }, "\u2191": { "math": "\\uparrow", "alt": ["textcomp"] }, "\u2192": { "math": "\\rightarrow", "alt": ["textcomp"] }, "\u2193": { "text": "\\textdownarrow", "math": "\\downarrow", "macrospacer": true }, "\u2194": { "math": "\\leftrightarrow" }, "\u2195": { "math": "\\updownarrow" }, "\u2196": { "math": "\\nwarrow" }, "\u2197": { "math": "\\nearrow" }, "\u2198": { "math": "\\searrow" }, "\u2199": { "math": "\\swarrow" }, "\u219C": { "math": "\\arrowwaveleft" }, "\u219D": { "math": "\\arrowwaveright" }, "\u21A6": { "math": "\\mapsto" }, "\u21A9": { "math": "\\hookleftarrow" }, "\u21AA": { "math": "\\hookrightarrow" }, "\u21AF": { "math": "\\lightning" }, "\u21B2": { "math": "\\dlsh" }, "\u21BB": { "math": "\\circlearrowright" }, "\u21BC": { "math": "\\leftharpoonup" }, "\u21BD": { "math": "\\leftharpoondown" }, "\u21C0": { "math": "\\rightharpoonup" }, "\u21C5": { "math": "\\dblarrowupdown" }, "\u21CC": { "math": "\\rightleftharpoons" }, "\u21D0": { "math": "\\Leftarrow" }, "\u21D1": { "math": "\\Uparrow" }, "\u21D2": { "math": "\\Rightarrow" }, "\u21D3": { "math": "\\Downarrow" }, "\u21D4": { "math": "\\Leftrightarrow" }, "\u21D5": { "math": "\\Updownarrow" }, "\u21E0": { "math": "\\dashleftarrow" }, "\u21E2": { "math": "\\dashrightarrow" }, "\u21E4": { "math": "\\LeftArrowBar" }, "\u21E5": { "math": "\\RightArrowBar" }, "\u21F5": { "math": "\\DownArrowUpArrow" }, "\u21F8": { "math": "\\pfun" }, "\u21FB": { "math": "\\ffun" }, "\u2200": { "math": "\\forall" }, "\u2202": { "math": "\\partial" }, "\u2203": { "math": "\\exists" }, "\u2208": { "math": "\\in" }, "\u2208\u0338": { "math": "\\notin" }, "\u220B": { "math": "\\ni" }, "\u220B\u0338": { "math": "\\not\\ni" }, "\u220F": { "math": "\\prod" }, "\u2210": { "math": "\\coprod" }, "\u2211": { "math": "\\sum" }, "\u2213": { "math": "\\mp" }, "\u2217": { "math": "\\ast" }, "\u2218": { "math": "\\circ" }, "\u2219": { "math": "\\bullet" }, "\u221B": { "math": "\\sqrt[3]" }, "\u221C": { "math": "\\sqrt[4]" }, "\u221D": { "math": "\\propto" }, "\u221E": { "math": "\\infty" }, "\u2220": { "math": "\\angle" }, "\u2223": { "math": "\\mid" }, "\u2225": { "math": "\\parallel" }, "\u2227": { "math": "\\wedge" }, "\u2228": { "math": "\\vee" }, "\u2229": { "math": "\\cap" }, "\u222A": { "math": "\\cup" }, "\u222B": { "math": "\\int" }, "\u222C": { "math": "{\\int\\!\\int}" }, "\u222D": { "math": "{\\int\\!\\int\\!\\int}" }, "\u222E": { "math": "\\oint" }, "\u222F": { "math": "\\surfintegral" }, "\u2230": { "math": "\\volintegral" }, "\u2231": { "math": "\\clwintegral" }, "\u2236": { "math": ":" }, "\u223A": { "math": "\\mathbin{{:}\\!\\!{-}\\!\\!{:}}" }, "\u223B": { "math": "\\homothetic" }, "\u223C": { "math": "\\sim" }, "\u223E": { "math": "\\lazysinv" }, "\u223F": { "math": "\\AC" }, "\u2240": { "math": "\\wr" }, "\u223C\u0338": { "math": "\\not\\sim" }, "\u2242\u0338": { "math": "\\NotEqualTilde" }, "\u2243": { "math": "\\simeq" }, "\u2243\u0338": { "math": "\\not\\simeq" }, "\u2245": { "math": "\\cong" }, "\u2246": { "math": "\\approxnotequal" }, "\u2245\u0338": { "math": "\\not\\cong" }, "\u2248": { "math": "\\approx", "alt": ["inputenx"] }, "\u2248\u0338": { "math": "\\not\\approx" }, "\u224B": { "math": "\\tildetrpl" }, "\u224B\u0338": { "math": "\\not\\apid" }, "\u224C": { "math": "\\allequal" }, "\u224D": { "math": "\\asymp" }, "\u224E\u0338": { "math": "\\NotHumpDownHump" }, "\u224F\u0338": { "math": "\\NotHumpEqual" }, "\u2250": { "math": "\\doteq" }, "\u2250\u0338": { "math": "\\not\\doteq" }, "\u2251": { "math": "\\doteqdot" }, "\u2254": { "text": ":=", "math": ":=", "alt": ["unicode-math"] }, "\u2255": { "math": "=:" }, "\u2259": { "math": "\\estimates" }, "\u225B": { "math": "\\starequal" }, "=\u0338": { "math": "\\neq" }, "\u2261": { "math": "\\equiv" }, "\u2261\u0338": { "math": "\\not\\equiv" }, "\u2264": { "math": "\\leq" }, "\u2265": { "math": "\\geq" }, "\u2266": { "math": "\\leqq" }, "\u2267": { "math": "\\geqq" }, "\u2268\uFE00": { "math": "\\lvertneqq" }, "\u2269\uFE00": { "math": "\\gvertneqq" }, "\u226A": { "math": "\\ll" }, "\u226A\u0338": { "math": "\\NotLessLess" }, "\u226B": { "math": "\\gg" }, "\u226B\u0338": { "math": "\\NotGreaterGreater" }, "\u224D\u0338": { "math": "{\\not\\kern-0.3em\\times}", "alt": ["unicode-math"] }, "<\u0338": { "math": "\\not<" }, ">\u0338": { "math": "\\not>" }, "\u2264\u0338": { "math": "\\not\\leq" }, "\u2265\u0338": { "math": "\\not\\geq" }, "\u2272": { "math": "\\lessequivlnt" }, "\u2273": { "math": "\\greaterequivlnt" }, "\u2276\u0338": { "math": "\\notlessgreater" }, "\u2277\u0338": { "math": "\\notgreaterless" }, "\u227A": { "math": "\\prec" }, "\u227B": { "math": "\\succ" }, "\u227E": { "math": "\\precapprox" }, "\u227E\u0338": { "math": "\\NotPrecedesTilde" }, "\u227F": { "math": "\\succapprox" }, "\u227F\u0338": { "math": "\\NotSucceedsTilde" }, "\u227A\u0338": { "math": "\\not\\prec" }, "\u227B\u0338": { "math": "\\not\\succ" }, "\u2282": { "math": "\\subset" }, "\u2283": { "math": "\\supset" }, "\u2282\u0338": { "math": "\\not\\subset" }, "\u2283\u0338": { "math": "\\not\\supset" }, "\u2286": { "math": "\\subseteq" }, "\u2287": { "math": "\\supseteq" }, "\u2286\u0338": { "math": "\\not\\subseteq" }, "\u2287\u0338": { "math": "\\not\\supseteq" }, "\u228A\uFE00": { "math": "\\varsubsetneqq" }, "\u228B\uFE00": { "math": "\\varsupsetneq" }, "\u228E": { "math": "\\uplus" }, "\u228F\u0338": { "math": "\\NotSquareSubset" }, "\u2290\u0338": { "math": "\\NotSquareSuperset" }, "\u2291": { "math": "\\sqsubseteq" }, "\u2292": { "math": "\\sqsupseteq" }, "\u2293": { "math": "\\sqcap" }, "\u2294": { "math": "\\sqcup" }, "\u2295": { "math": "\\oplus" }, "\u2296": { "math": "\\ominus" }, "\u2297": { "math": "\\otimes" }, "\u2298": { "math": "\\oslash" }, "\u2299": { "math": "\\odot" }, "\u22A2": { "math": "\\vdash" }, "\u22A3": { "math": "\\dashv" }, "\u22A4": { "math": "\\top" }, "\u22A5": { "math": "\\perp" }, "\u22A7": { "math": "\\truestate" }, "\u22A8": { "math": "\\forcesextra" }, "\u22B6": { "math": "\\original" }, "\u22B7": { "math": "\\image" }, "\u22B9": { "math": "\\hermitconjmatrix" }, "\u22BE": { "math": "\\rightanglearc" }, "\u22C0": { "math": "\\bigwedge" }, "\u22C1": { "math": "\\bigvee" }, "\u22C2": { "math": "\\bigcap" }, "\u22C3": { "math": "\\bigcup" }, "\u22C4": { "math": "\\diamond" }, "\u22C5": { "math": "\\cdot" }, "\u22C6": { "math": "\\star" }, "\u22C8": { "math": "\\bowtie" }, "\u22D8": { "math": "\\verymuchless" }, "\u22D9": { "math": "\\verymuchgreater" }, "\u2291\u0338": { "math": "\\not\\sqsubseteq" }, "\u2292\u0338": { "math": "\\not\\sqsupseteq" }, "\u22B2\u0338": { "math": "\\ntriangleleft" }, "\u22B3\u0338": { "math": "\\ntriangleright" }, "\u22EE": { "math": "\\vdots" }, "\u22EF": { "math": "\\cdots" }, "\u22F0": { "math": "\\upslopeellipsis" }, "\u22F1": { "math": "\\ddots" }, "\u22F6": { "math": "\\barin" }, "\u2306": { "math": "\\perspcorrespond" }, "\u2308": { "math": "\\lceil" }, "\u2309": { "math": "\\rceil" }, "\u230A": { "math": "\\lfloor" }, "\u230B": { "math": "\\rfloor" }, "\u2311": { "math": "\\wasylozenge" }, "\u2315": { "math": "\\recorder" }, "\u2316": { "math": '{\\mathchar"2208}' }, "\u2322": { "math": "\\frown" }, "\u2323": { "math": "\\smile" }, "\u3008": { "text": "\\textlangle", "math": "\\langle", "macrospacer": true }, "\u3009": { "text": "\\textrangle", "math": "\\rangle", "macrospacer": true }, "\u2339": { "math": "\\APLinv" }, "\u233F": { "math": "\\notslash" }, "\u2340": { "math": "\\notbackslash" }, "\u2347": { "math": "\\APLleftarrowbox" }, "\u2348": { "math": "\\APLrightarrowbox" }, "\u2349": { "math": "\\invdiameter" }, "\u2350": { "math": "\\APLuparrowbox" }, "\u2357": { "math": "\\APLdownarrowbox" }, "\u235D": { "math": "\\APLcomment" }, "\u235E": { "math": "\\APLinput" }, "\u235F": { "math": "\\APLlog" }, "\u23B0": { "math": "\\lmoustache" }, "\u23B1": { "math": "\\rmoustache" }, "\u24C8": { "math": "\\circledS" }, "\u2571": { "math": "\\diagup" }, "\u25A1": { "math": "\\square" }, "\u25B6": { "math": "\\RHD" }, "\u25B7": { "math": "\\rhd" }, "\u25BD": { "math": "\\bigtriangledown" }, "\u25C0": { "math": "\\LHD" }, "\u25C1": { "math": "\\lhd" }, "\u25C6": { "text": "\\ding{117}", "math": "\\Diamondblack" }, "\u25C7": { "math": "\\Diamond" }, "\u25CB": { "math": "\\bigcirc" }, "\u25CF": { "text": "\\ding{108}", "math": "\\CIRCLE" }, "\u25EF": { "text": "\\textbigcircle", "math": "\\bigcirc", "macrospacer": true }, "\u2609": { "math": "\\Sun" }, "\u2610": { "math": "\\Square" }, "\u2611": { "math": "\\CheckedBox" }, "\u2612": { "math": "\\XBox" }, "\u2615": { "math": "\\steaming" }, "\u261E": { "text": "\\ding{43}", "math": "\\pointright" }, "\u2620": { "math": "\\skull" }, "\u2622": { "math": "\\radiation" }, "\u2623": { "math": "\\biohazard" }, "\u262F": { "math": "\\yinyang" }, "\u2639": { "math": "\\frownie" }, "\u263A": { "math": "\\smiley" }, "\u2641": { "math": "\\earth" }, "\u2660": { "text": "\\ding{171}", "math": "\\spadesuit" }, "\u2661": { "math": "\\heartsuit" }, "\u2662": { "math": "\\diamondsuit" }, "\u2663": { "math": "\\clubsuit" }, "\u266D": { "math": "\\flat" }, "\u266E": { "math": "\\natural" }, "\u266F": { "math": "\\sharp" }, "\u267B": { "math": "\\recycle" }, "\u2693": { "math": "\\anchor" }, "\u2694": { "math": "\\swords" }, "\u26A0": { "math": "\\warning" }, "\u26AA": { "math": "\\medcirc" }, "\u26AB": { "math": "\\medbullet" }, "\u270E": { "text": "\\ding{46}", "math": "\\pencil" }, "\u2717": { "text": "\\ding{55}", "math": "\\ballotx" }, "\u27A2": { "text": "\\ding{226}", "math": "\\arrowbullet" }, "\u27C2": { "math": "\\perp" }, "\u27C5": { "math": "\\Lbag" }, "\u27C6": { "math": "\\Rbag" }, "\u27D0": { "math": "\\Diamonddot" }, "\u27E6": { "math": "\\llbracket" }, "\u27E7": { "math": "\\rrbracket" }, "\u27E8": { "math": "\\langle" }, "\u27E9": { "math": "\\rangle" }, "\u27EA": { "math": "\\lang" }, "\u27EE": { "math": "\\lgroup" }, "\u27EF": { "math": "\\rgroup" }, "\u27F5": { "math": "\\longleftarrow" }, "\u27F6": { "math": "\\longrightarrow" }, "\u27F7": { "math": "\\longleftrightarrow" }, "\u27F8": { "math": "\\Longleftarrow" }, "\u27F9": { "math": "\\Longrightarrow" }, "\u27FA": { "math": "\\Longleftrightarrow" }, "\u27FC": { "math": "\\longmapsto" }, "\u2900": { "math": "\\psur" }, "\u2912": { "math": "\\UpArrowBar" }, "\u2913": { "math": "\\DownArrowBar" }, "\u2914": { "math": "\\pinj" }, "\u2915": { "math": "\\finj" }, "\u2916": { "math": "\\bij" }, "\u2940": { "math": "\\Elolarr" }, "\u2941": { "math": "\\Elorarr" }, "\u294A": { "math": "\\leftrightharpoon" }, "\u294B": { "math": "\\rightleftharpoon" }, "\u294F": { "math": "\\RightUpDownVector" }, "\u2951": { "math": "\\LeftUpDownVector" }, "\u2952": { "math": "\\LeftVectorBar" }, "\u2953": { "math": "\\RightVectorBar" }, "\u2954": { "math": "\\RightUpVectorBar" }, "\u2955": { "math": "\\RightDownVectorBar" }, "\u2956": { "math": "\\DownLeftVectorBar" }, "\u2957": { "math": "\\DownRightVectorBar" }, "\u2958": { "math": "\\LeftUpVectorBar" }, "\u2959": { "math": "\\LeftDownVectorBar" }, "\u295A": { "math": "\\LeftTeeVector" }, "\u295B": { "math": "\\RightTeeVector" }, "\u295C": { "math": "\\RightUpTeeVector" }, "\u295D": { "math": "\\RightDownTeeVector" }, "\u295E": { "math": "\\DownLeftTeeVector" }, "\u295F": { "math": "\\DownRightTeeVector" }, "\u2960": { "math": "\\LeftUpTeeVector" }, "\u2961": { "math": "\\LeftDownTeeVector" }, "\u2962": { "math": "\\leftleftharpoons" }, "\u2963": { "math": "\\upupharpoons" }, "\u2964": { "math": "\\rightrightharpoons" }, "\u2965": { "math": "\\downdownharpoons" }, "\u296A": { "math": "\\leftbarharpoon" }, "\u296B": { "math": "\\barleftharpoon" }, "\u296C": { "math": "\\rightbarharpoon" }, "\u296D": { "math": "\\barrightharpoon" }, "\u296E": { "math": "\\UpEquilibrium" }, "\u296F": { "math": "\\ReverseUpEquilibrium" }, "\u2970": { "math": "\\RoundImplies" }, "\u2988": { "math": "\\rimg" }, "\u2989": { "math": "\\lblot" }, "\u298A": { "math": "\\rblot" }, "\u299C": { "math": "\\Angle" }, "\u29C4": { "math": "\\boxslash" }, "\u29CF": { "math": "\\LeftTriangleBar" }, "\u29CF\u0338": { "math": "\\NotLeftTriangleBar" }, "\u29D0": { "math": "\\RightTriangleBar" }, "\u29D0\u0338": { "math": "\\NotRightTriangleBar" }, "\u29DF": { "math": "\\multimapboth" }, "\u29F5": { "math": "\\setminus" }, "\u29F9": { "math": "\\zhide" }, "\u2A00": { "math": "\\bigodot" }, "\u2A01": { "math": "\\bigoplus" }, "\u2A02": { "math": "\\bigotimes" }, "\u2A06": { "math": "\\Elxsqcup" }, "\u2A09": { "math": "\\varprod" }, "\u2A0F": { "math": "\\clockoint" }, "\u2A16": { "math": "\\sqrint" }, "\u2A3F": { "math": "\\amalg" }, "\u2A56": { "math": "\\ElOr" }, "\u2A6E": { "math": "\\stackrel{*}{=}" }, "\u2A75": { "math": "\\Equal" }, "\u2A76": { "math": "\\Same" }, "\u2A7D": { "math": "\\leq", "alt": ["amssymb", "unicode-math"] }, "\u2AA1": { "math": "\\NestedLessLess" }, "\u2AA1\u0338": { "math": "\\NotNestedLessLess" }, "\u2AA2": { "math": "\\NestedGreaterGreater" }, "\u2AA2\u0338": { "math": "\\NotNestedGreaterGreater" }, "\u2AA6": { "math": "\\leftslice" }, "\u2AA7": { "math": "\\rightslice" }, "\u2AAF": { "math": "\\preceq" }, "\u2AAF\u0338": { "math": "\\not\\preceq" }, "\u2AB0": { "math": "\\succeq" }, "\u2AB0\u0338": { "math": "\\not\\succeq" }, "\u2ABB": { "math": "\\llcurly" }, "\u2ABC": { "math": "\\ggcurly" }, "\u2AC5\u0338": { "math": "\\nsubseteqq" }, "\u2AC6\u0338": { "math": "\\nsupseteqq" }, "\u2ADD\u0338": { "math": "\\forks", "alt": ["unicode-math"] }, "\u2AEA": { "math": "\\Top" }, "\u2AFD": { "math": "{{/}\\!\\!{/}}" }, "\u2AFD\u20E5": { "math": "{\\rlap{\\textbackslash}{{/}\\!\\!{/}}}" }, "\u3014": { "math": "\\lbrbrak" }, "\u3015": { "math": "\\rbrbrak" }, "\u301A": { "math": "\\openbracketleft" }, "\u301B": { "math": "\\openbracketright" }, "\u{1D400}": { "math": "\\mathbf{A}", "alt": ["unicode-math"] }, "\u{1D401}": { "math": "\\mathbf{B}", "alt": ["unicode-math"] }, "\u{1D402}": { "math": "\\mathbf{C}", "alt": ["unicode-math"] }, "\u{1D403}": { "math": "\\mathbf{D}", "alt": ["unicode-math"] }, "\u{1D404}": { "math": "\\mathbf{E}", "alt": ["unicode-math"] }, "\u{1D405}": { "math": "\\mathbf{F}", "alt": ["unicode-math"] }, "\u{1D406}": { "math": "\\mathbf{G}", "alt": ["unicode-math"] }, "\u{1D407}": { "math": "\\mathbf{H}", "alt": ["unicode-math"] }, "\u{1D408}": { "math": "\\mathbf{I}", "alt": ["unicode-math"] }, "\u{1D409}": { "math": "\\mathbf{J}", "alt": ["unicode-math"] }, "\u{1D40A}": { "math": "\\mathbf{K}", "alt": ["unicode-math"] }, "\u{1D40B}": { "math": "\\mathbf{L}", "alt": ["unicode-math"] }, "\u{1D40C}": { "math": "\\mathbf{M}", "alt": ["unicode-math"] }, "\u{1D40D}": { "math": "\\mathbf{N}", "alt": ["unicode-math"] }, "\u{1D40E}": { "math": "\\mathbf{O}", "alt": ["unicode-math"] }, "\u{1D40F}": { "math": "\\mathbf{P}", "alt": ["unicode-math"] }, "\u{1D410}": { "math": "\\mathbf{Q}", "alt": ["unicode-math"] }, "\u{1D411}": { "math": "\\mathbf{R}", "alt": ["unicode-math"] }, "\u{1D412}": { "math": "\\mathbf{S}", "alt": ["unicode-math"] }, "\u{1D413}": { "math": "\\mathbf{T}", "alt": ["unicode-math"] }, "\u{1D414}": { "math": "\\mathbf{U}", "alt": ["unicode-math"] }, "\u{1D415}": { "math": "\\mathbf{V}", "alt": ["unicode-math"] }, "\u{1D416}": { "math": "\\mathbf{W}", "alt": ["unicode-math"] }, "\u{1D417}": { "math": "\\mathbf{X}", "alt": ["unicode-math"] }, "\u{1D418}": { "math": "\\mathbf{Y}", "alt": ["unicode-math"] }, "\u{1D419}": { "math": "\\mathbf{Z}", "alt": ["unicode-math"] }, "\u{1D41A}": { "math": "\\mathbf{a}", "alt": ["unicode-math"] }, "\u{1D41B}": { "math": "\\mathbf{b}", "alt": ["unicode-math"] }, "\u{1D41C}": { "math": "\\mathbf{c}", "alt": ["unicode-math"] }, "\u{1D41D}": { "math": "\\mathbf{d}", "alt": ["unicode-math"] }, "\u{1D41E}": { "math": "\\mathbf{e}", "alt": ["unicode-math"] }, "\u{1D41F}": { "math": "\\mathbf{f}", "alt": ["unicode-math"] }, "\u{1D420}": { "math": "\\mathbf{g}", "alt": ["unicode-math"] }, "\u{1D421}": { "math": "\\mathbf{h}", "alt": ["unicode-math"] }, "\u{1D422}": { "math": "\\mathbf{i}", "alt": ["unicode-math"] }, "\u{1D423}": { "math": "\\mathbf{j}", "alt": ["unicode-math"] }, "\u{1D424}": { "math": "\\mathbf{k}", "alt": ["unicode-math"] }, "\u{1D425}": { "math": "\\mathbf{l}", "alt": ["unicode-math"] }, "\u{1D426}": { "math": "\\mathbf{m}", "alt": ["unicode-math"] }, "\u{1D427}": { "math": "\\mathbf{n}", "alt": ["unicode-math"] }, "\u{1D428}": { "math": "\\mathbf{o}", "alt": ["unicode-math"] }, "\u{1D429}": { "math": "\\mathbf{p}", "alt": ["unicode-math"] }, "\u{1D42A}": { "math": "\\mathbf{q}", "alt": ["unicode-math"] }, "\u{1D42B}": { "math": "\\mathbf{r}", "alt": ["unicode-math"] }, "\u{1D42C}": { "math": "\\mathbf{s}", "alt": ["unicode-math"] }, "\u{1D42D}": { "math": "\\mathbf{t}", "alt": ["unicode-math"] }, "\u{1D42E}": { "math": "\\mathbf{u}", "alt": ["unicode-math"] }, "\u{1D42F}": { "math": "\\mathbf{v}", "alt": ["unicode-math"] }, "\u{1D430}": { "math": "\\mathbf{w}", "alt": ["unicode-math"] }, "\u{1D431}": { "math": "\\mathbf{x}", "alt": ["unicode-math"] }, "\u{1D432}": { "math": "\\mathbf{y}", "alt": ["unicode-math"] }, "\u{1D433}": { "math": "\\mathbf{z}", "alt": ["unicode-math"] }, "\u{1D434}": { "math": "A", "alt": ["unicode-math"] }, "\u{1D435}": { "math": "B", "alt": ["unicode-math"] }, "\u{1D436}": { "math": "C", "alt": ["unicode-math"] }, "\u{1D437}": { "math": "D", "alt": ["unicode-math"] }, "\u{1D438}": { "math": "E", "alt": ["unicode-math"] }, "\u{1D439}": { "math": "F", "alt": ["unicode-math"] }, "\u{1D43A}": { "math": "G", "alt": ["unicode-math"] }, "\u{1D43B}": { "math": "H", "alt": ["unicode-math"] }, "\u{1D43C}": { "math": "I", "alt": ["unicode-math"] }, "\u{1D43D}": { "math": "J", "alt": ["unicode-math"] }, "\u{1D43E}": { "math": "K", "alt": ["unicode-math"] }, "\u{1D43F}": { "math": "L", "alt": ["unicode-math"] }, "\u{1D440}": { "math": "M", "alt": ["unicode-math"] }, "\u{1D441}": { "math": "N", "alt": ["unicode-math"] }, "\u{1D442}": { "math": "O", "alt": ["unicode-math"] }, "\u{1D443}": { "math": "P", "alt": ["unicode-math"] }, "\u{1D444}": { "math": "Q", "alt": ["unicode-math"] }, "\u{1D445}": { "math": "R", "alt": ["unicode-math"] }, "\u{1D446}": { "math": "S", "alt": ["unicode-math"] }, "\u{1D447}": { "math": "T", "alt": ["unicode-math"] }, "\u{1D448}": { "math": "U", "alt": ["unicode-math"] }, "\u{1D449}": { "math": "V", "alt": ["unicode-math"] }, "\u{1D44A}": { "math": "W", "alt": ["unicode-math"] }, "\u{1D44B}": { "math": "X", "alt": ["unicode-math"] }, "\u{1D44C}": { "math": "Y", "alt": ["unicode-math"] }, "\u{1D44D}": { "math": "Z", "alt": ["unicode-math"] }, "\u{1D44E}": { "math": "a", "alt": ["unicode-math"] }, "\u{1D44F}": { "math": "b", "alt": ["unicode-math"] }, "\u{1D450}": { "math": "c", "alt": ["unicode-math"] }, "\u{1D451}": { "math": "d", "alt": ["unicode-math"] }, "\u{1D452}": { "math": "e", "alt": ["unicode-math"] }, "\u{1D453}": { "math": "f", "alt": ["unicode-math"] }, "\u{1D454}": { "math": "g", "alt": ["unicode-math"] }, "\u{1D456}": { "math": "i", "alt": ["unicode-math"] }, "\u{1D457}": { "math": "j", "alt": ["unicode-math"] }, "\u{1D458}": { "math": "k", "alt": ["unicode-math"] }, "\u{1D459}": { "math": "l", "alt": ["unicode-math"] }, "\u{1D45A}": { "math": "m", "alt": ["unicode-math"] }, "\u{1D45B}": { "math": "n", "alt": ["unicode-math"] }, "\u{1D45C}": { "math": "o", "alt": ["unicode-math"] }, "\u{1D45D}": { "math": "p", "alt": ["unicode-math"] }, "\u{1D45E}": { "math": "q", "alt": ["unicode-math"] }, "\u{1D45F}": { "math": "r", "alt": ["unicode-math"] }, "\u{1D460}": { "math": "s", "alt": ["unicode-math"] }, "\u{1D461}": { "math": "t", "alt": ["unicode-math"] }, "\u{1D462}": { "math": "u", "alt": ["unicode-math"] }, "\u{1D463}": { "math": "v", "alt": ["unicode-math"] }, "\u{1D464}": { "math": "w", "alt": ["unicode-math"] }, "\u{1D465}": { "math": "x", "alt": ["unicode-math"] }, "\u{1D466}": { "math": "y", "alt": ["unicode-math"] }, "\u{1D467}": { "math": "z", "alt": ["unicode-math"] }, "\u{1D468}": { "math": "\\mathbit{A}", "alt": ["unicode-math"] }, "\u{1D469}": { "math": "\\mathbit{B}", "alt": ["unicode-math"] }, "\u{1D46A}": { "math": "\\mathbit{C}", "alt": ["unicode-math"] }, "\u{1D46B}": { "math": "\\mathbit{D}", "alt": ["unicode-math"] }, "\u{1D46C}": { "math": "\\mathbit{E}", "alt": ["unicode-math"] }, "\u{1D46D}": { "math": "\\mathbit{F}", "alt": ["unicode-math"] }, "\u{1D46E}": { "math": "\\mathbit{G}", "alt": ["unicode-math"] }, "\u{1D46F}": { "math": "\\mathbit{H}", "alt": ["unicode-math"] }, "\u{1D470}": { "math": "\\mathbit{I}", "alt": ["unicode-math"] }, "\u{1D471}": { "math": "\\mathbit{J}", "alt": ["unicode-math"] }, "\u{1D472}": { "math": "\\mathbit{K}", "alt": ["unicode-math"] }, "\u{1D473}": { "math": "\\mathbit{L}", "alt": ["unicode-math"] }, "\u{1D474}": { "math": "\\mathbit{M}", "alt": ["unicode-math"] }, "\u{1D475}": { "math": "\\mathbit{N}", "alt": ["unicode-math"] }, "\u{1D476}": { "math": "\\mathbit{O}", "alt": ["unicode-math"] }, "\u{1D477}": { "math": "\\mathbit{P}", "alt": ["unicode-math"] }, "\u{1D478}": { "math": "\\mathbit{Q}", "alt": ["unicode-math"] }, "\u{1D479}": { "math": "\\mathbit{R}", "alt": ["unicode-math"] }, "\u{1D47A}": { "math": "\\mathbit{S}", "alt": ["unicode-math"] }, "\u{1D47B}": { "math": "\\mathbit{T}", "alt": ["unicode-math"] }, "\u{1D47C}": { "math": "\\mathbit{U}", "alt": ["unicode-math"] }, "\u{1D47D}": { "math": "\\mathbit{V}", "alt": ["unicode-math"] }, "\u{1D47E}": { "math": "\\mathbit{W}", "alt": ["unicode-math"] }, "\u{1D47F}": { "math": "\\mathbit{X}", "alt": ["unicode-math"] }, "\u{1D480}": { "math": "\\mathbit{Y}", "alt": ["unicode-math"] }, "\u{1D481}": { "math": "\\mathbit{Z}", "alt": ["unicode-math"] }, "\u{1D482}": { "math": "\\mathbit{a}", "alt": ["unicode-math"] }, "\u{1D483}": { "math": "\\mathbit{b}", "alt": ["unicode-math"] }, "\u{1D484}": { "math": "\\mathbit{c}", "alt": ["unicode-math"] }, "\u{1D485}": { "math": "\\mathbit{d}", "alt": ["unicode-math"] }, "\u{1D486}": { "math": "\\mathbit{e}", "alt": ["unicode-math"] }, "\u{1D487}": { "math": "\\mathbit{f}", "alt": ["unicode-math"] }, "\u{1D488}": { "math": "\\mathbit{g}", "alt": ["unicode-math"] }, "\u{1D489}": { "math": "\\mathbit{h}", "alt": ["unicode-math"] }, "\u{1D48A}": { "math": "\\mathbit{i}", "alt": ["unicode-math"] }, "\u{1D48B}": { "math": "\\mathbit{j}", "alt": ["unicode-math"] }, "\u{1D48C}": { "math": "\\mathbit{k}", "alt": ["unicode-math"] }, "\u{1D48D}": { "math": "\\mathbit{l}", "alt": ["unicode-math"] }, "\u{1D48E}": { "math": "\\mathbit{m}", "alt": ["unicode-math"] }, "\u{1D48F}": { "math": "\\mathbit{n}", "alt": ["unicode-math"] }, "\u{1D490}": { "math": "\\mathbit{o}", "alt": ["unicode-math"] }, "\u{1D491}": { "math": "\\mathbit{p}", "alt": ["unicode-math"] }, "\u{1D492}": { "math": "\\mathbit{q}", "alt": ["unicode-math"] }, "\u{1D493}": { "math": "\\mathbit{r}", "alt": ["unicode-math"] }, "\u{1D494}": { "math": "\\mathbit{s}", "alt": ["unicode-math"] }, "\u{1D495}": { "math": "\\mathbit{t}", "alt": ["unicode-math"] }, "\u{1D496}": { "math": "\\mathbit{u}", "alt": ["unicode-math"] }, "\u{1D497}": { "math": "\\mathbit{v}", "alt": ["unicode-math"] }, "\u{1D498}": { "math": "\\mathbit{w}", "alt": ["unicode-math"] }, "\u{1D499}": { "math": "\\mathbit{x}", "alt": ["unicode-math"] }, "\u{1D49A}": { "math": "\\mathbit{y}", "alt": ["unicode-math"] }, "\u{1D49B}": { "math": "\\mathbit{z}", "alt": ["unicode-math"] }, "\u{1D4D0}": { "math": "\\mathmit{A}", "alt": ["unicode-math"] }, "\u{1D4D1}": { "math": "\\mathmit{B}", "alt": ["unicode-math"] }, "\u{1D4D2}": { "math": "\\mathmit{C}", "alt": ["unicode-math"] }, "\u{1D4D3}": { "math": "\\mathmit{D}", "alt": ["unicode-math"] }, "\u{1D4D4}": { "math": "\\mathmit{E}", "alt": ["unicode-math"] }, "\u{1D4D5}": { "math": "\\mathmit{F}", "alt": ["unicode-math"] }, "\u{1D4D6}": { "math": "\\mathmit{G}", "alt": ["unicode-math"] }, "\u{1D4D7}": { "math": "\\mathmit{H}", "alt": ["unicode-math"] }, "\u{1D4D8}": { "math": "\\mathmit{I}", "alt": ["unicode-math"] }, "\u{1D4D9}": { "math": "\\mathmit{J}", "alt": ["unicode-math"] }, "\u{1D4DA}": { "math": "\\mathmit{K}", "alt": ["unicode-math"] }, "\u{1D4DB}": { "math": "\\mathmit{L}", "alt": ["unicode-math"] }, "\u{1D4DC}": { "math": "\\mathmit{M}", "alt": ["unicode-math"] }, "\u{1D4DD}": { "math": "\\mathmit{N}", "alt": ["unicode-math"] }, "\u{1D4DE}": { "math": "\\mathmit{O}", "alt": ["unicode-math"] }, "\u{1D4DF}": { "math": "\\mathmit{P}", "alt": ["unicode-math"] }, "\u{1D4E0}": { "math": "\\mathmit{Q}", "alt": ["unicode-math"] }, "\u{1D4E1}": { "math": "\\mathmit{R}", "alt": ["unicode-math"] }, "\u{1D4E2}": { "math": "\\mathmit{S}", "alt": ["unicode-math"] }, "\u{1D4E3}": { "math": "\\mathmit{T}", "alt": ["unicode-math"] }, "\u{1D4E4}": { "math": "\\mathmit{U}", "alt": ["unicode-math"] }, "\u{1D4E5}": { "math": "\\mathmit{V}", "alt": ["unicode-math"] }, "\u{1D4E6}": { "math": "\\mathmit{W}", "alt": ["unicode-math"] }, "\u{1D4E7}": { "math": "\\mathmit{X}", "alt": ["unicode-math"] }, "\u{1D4E8}": { "math": "\\mathmit{Y}", "alt": ["unicode-math"] }, "\u{1D4E9}": { "math": "\\mathmit{Z}", "alt": ["unicode-math"] }, "\u{1D4EA}": { "math": "\\mathmit{a}", "alt": ["unicode-math"] }, "\u{1D4EB}": { "math": "\\mathmit{b}", "alt": ["unicode-math"] }, "\u{1D4EC}": { "math": "\\mathmit{c}", "alt": ["unicode-math"] }, "\u{1D4ED}": { "math": "\\mathmit{d}", "alt": ["unicode-math"] }, "\u{1D4EE}": { "math": "\\mathmit{e}", "alt": ["unicode-math"] }, "\u{1D4EF}": { "math": "\\mathmit{f}", "alt": ["unicode-math"] }, "\u{1D4F0}": { "math": "\\mathmit{g}", "alt": ["unicode-math"] }, "\u{1D4F1}": { "math": "\\mathmit{h}", "alt": ["unicode-math"] }, "\u{1D4F2}": { "math": "\\mathmit{i}", "alt": ["unicode-math"] }, "\u{1D4F3}": { "math": "\\mathmit{j}", "alt": ["unicode-math"] }, "\u{1D4F4}": { "math": "\\mathmit{k}", "alt": ["unicode-math"] }, "\u{1D4F5}": { "math": "\\mathmit{l}", "alt": ["unicode-math"] }, "\u{1D4F6}": { "math": "\\mathmit{m}", "alt": ["unicode-math"] }, "\u{1D4F7}": { "math": "\\mathmit{n}", "alt": ["unicode-math"] }, "\u{1D4F8}": { "math": "\\mathmit{o}", "alt": ["unicode-math"] }, "\u{1D4F9}": { "math": "\\mathmit{p}", "alt": ["unicode-math"] }, "\u{1D4FA}": { "math": "\\mathmit{q}", "alt": ["unicode-math"] }, "\u{1D4FB}": { "math": "\\mathmit{r}", "alt": ["unicode-math"] }, "\u{1D4FC}": { "math": "\\mathmit{s}", "alt": ["unicode-math"] }, "\u{1D4FD}": { "math": "\\mathmit{t}", "alt": ["unicode-math"] }, "\u{1D4FE}": { "math": "\\mathmit{u}", "alt": ["unicode-math"] }, "\u{1D4FF}": { "math": "\\mathmit{v}", "alt": ["unicode-math"] }, "\u{1D500}": { "math": "\\mathmit{w}", "alt": ["unicode-math"] }, "\u{1D501}": { "math": "\\mathmit{x}", "alt": ["unicode-math"] }, "\u{1D502}": { "math": "\\mathmit{y}", "alt": ["unicode-math"] }, "\u{1D503}": { "math": "\\mathmit{z}", "alt": ["unicode-math"] }, "\u{1D504}": { "math": "\\mathfrak{A}", "alt": ["unicode-math"] }, "\u{1D505}": { "math": "\\mathfrak{B}", "alt": ["unicode-math"] }, "\u{1D507}": { "math": "\\mathfrak{D}", "alt": ["unicode-math"] }, "\u{1D508}": { "math": "\\mathfrak{E}", "alt": ["unicode-math"] }, "\u{1D509}": { "math": "\\mathfrak{F}", "alt": ["unicode-math"] }, "\u{1D50A}": { "math": "\\mathfrak{G}", "alt": ["unicode-math"] }, "\u{1D50D}": { "math": "\\mathfrak{J}", "alt": ["unicode-math"] }, "\u{1D50E}": { "math": "\\mathfrak{K}", "alt": ["unicode-math"] }, "\u{1D50F}": { "math": "\\mathfrak{L}", "alt": ["unicode-math"] }, "\u{1D510}": { "math": "\\mathfrak{M}", "alt": ["unicode-math"] }, "\u{1D511}": { "math": "\\mathfrak{N}", "alt": ["unicode-math"] }, "\u{1D512}": { "math": "\\mathfrak{O}", "alt": ["unicode-math"] }, "\u{1D513}": { "math": "\\mathfrak{P}", "alt": ["unicode-math"] }, "\u{1D514}": { "math": "\\mathfrak{Q}", "alt": ["unicode-math"] }, "\u{1D516}": { "math": "\\mathfrak{S}", "alt": ["unicode-math"] }, "\u{1D517}": { "math": "\\mathfrak{T}", "alt": ["unicode-math"] }, "\u{1D518}": { "math": "\\mathfrak{U}", "alt": ["unicode-math"] }, "\u{1D519}": { "math": "\\mathfrak{V}", "alt": ["unicode-math"] }, "\u{1D51A}": { "math": "\\mathfrak{W}", "alt": ["unicode-math"] }, "\u{1D51B}": { "math": "\\mathfrak{X}", "alt": ["unicode-math"] }, "\u{1D51C}": { "math": "\\mathfrak{Y}", "alt": ["unicode-math"] }, "\u{1D51E}": { "math": "\\mathfrak{a}", "alt": ["unicode-math"] }, "\u{1D51F}": { "math": "\\mathfrak{b}", "alt": ["unicode-math"] }, "\u{1D520}": { "math": "\\mathfrak{c}", "alt": ["unicode-math"] }, "\u{1D521}": { "math": "\\mathfrak{d}", "alt": ["unicode-math"] }, "\u{1D522}": { "math": "\\mathfrak{e}", "alt": ["unicode-math"] }, "\u{1D523}": { "math": "\\mathfrak{f}", "alt": ["unicode-math"] }, "\u{1D524}": { "math": "\\mathfrak{g}", "alt": ["unicode-math"] }, "\u{1D525}": { "math": "\\mathfrak{h}", "alt": ["unicode-math"] }, "\u{1D526}": { "math": "\\mathfrak{i}", "alt": ["unicode-math"] }, "\u{1D527}": { "math": "\\mathfrak{j}", "alt": ["unicode-math"] }, "\u{1D528}": { "math": "\\mathfrak{k}", "alt": ["unicode-math"] }, "\u{1D529}": { "math": "\\mathfrak{l}", "alt": ["unicode-math"] }, "\u{1D52A}": { "math": "\\mathfrak{m}", "alt": ["unicode-math"] }, "\u{1D52B}": { "math": "\\mathfrak{n}", "alt": ["unicode-math"] }, "\u{1D52C}": { "math": "\\mathfrak{o}", "alt": ["unicode-math"] }, "\u{1D52D}": { "math": "\\mathfrak{p}", "alt": ["unicode-math"] }, "\u{1D52E}": { "math": "\\mathfrak{q}", "alt": ["unicode-math"] }, "\u{1D52F}": { "math": "\\mathfrak{r}", "alt": ["unicode-math"] }, "\u{1D530}": { "math": "\\mathfrak{s}", "alt": ["unicode-math"] }, "\u{1D531}": { "math": "\\mathfrak{t}", "alt": ["unicode-math"] }, "\u{1D532}": { "math": "\\mathfrak{u}", "alt": ["unicode-math"] }, "\u{1D533}": { "math": "\\mathfrak{v}", "alt": ["unicode-math"] }, "\u{1D534}": { "math": "\\mathfrak{w}", "alt": ["unicode-math"] }, "\u{1D535}": { "math": "\\mathfrak{x}", "alt": ["unicode-math"] }, "\u{1D536}": { "math": "\\mathfrak{y}", "alt": ["unicode-math"] }, "\u{1D537}": { "math": "\\mathfrak{z}", "alt": ["unicode-math"] }, "\u{1D538}": { "math": "\\mathbb{A}", "alt": ["unicode-math"] }, "\u{1D539}": { "math": "\\mathbb{B}", "alt": ["unicode-math"] }, "\u{1D53B}": { "math": "\\mathbb{D}", "alt": ["unicode-math"] }, "\u{1D53C}": { "math": "\\mathbb{E}", "alt": ["unicode-math"] }, "\u{1D53D}": { "math": "\\mathbb{F}", "alt": ["unicode-math"] }, "\u{1D53E}": { "math": "\\mathbb{G}", "alt": ["unicode-math"] }, "\u{1D540}": { "math": "\\mathbb{I}", "alt": ["unicode-math"] }, "\u{1D541}": { "math": "\\mathbb{J}", "alt": ["unicode-math"] }, "\u{1D542}": { "math": "\\mathbb{K}", "alt": ["unicode-math"] }, "\u{1D543}": { "math": "\\mathbb{L}", "alt": ["unicode-math"] }, "\u{1D544}": { "math": "\\mathbb{M}", "alt": ["unicode-math"] }, "\u{1D546}": { "math": "\\mathbb{O}", "alt": ["unicode-math"] }, "\u{1D54A}": { "math": "\\mathbb{S}", "alt": ["unicode-math"] }, "\u{1D54B}": { "math": "\\mathbb{T}", "alt": ["unicode-math"] }, "\u{1D54C}": { "math": "\\mathbb{U}", "alt": ["unicode-math"] }, "\u{1D54D}": { "math": "\\mathbb{V}", "alt": ["unicode-math"] }, "\u{1D54E}": { "math": "\\mathbb{W}", "alt": ["unicode-math"] }, "\u{1D54F}": { "math": "\\mathbb{X}", "alt": ["unicode-math"] }, "\u{1D550}": { "math": "\\mathbb{Y}", "alt": ["unicode-math"] }, "\u{1D552}": { "math": "\\mathbb{a}", "alt": ["unicode-math"] }, "\u{1D553}": { "math": "\\mathbb{b}", "alt": ["unicode-math"] }, "\u{1D554}": { "math": "\\mathbb{c}", "alt": ["unicode-math"] }, "\u{1D555}": { "math": "\\mathbb{d}", "alt": ["unicode-math"] }, "\u{1D556}": { "math": "\\mathbb{e}", "alt": ["unicode-math"] }, "\u{1D557}": { "math": "\\mathbb{f}", "alt": ["unicode-math"] }, "\u{1D558}": { "math": "\\mathbb{g}", "alt": ["unicode-math"] }, "\u{1D559}": { "math": "\\mathbb{h}", "alt": ["unicode-math"] }, "\u{1D55A}": { "math": "\\mathbb{i}", "alt": ["unicode-math"] }, "\u{1D55B}": { "math": "\\mathbb{j}", "alt": ["unicode-math"] }, "\u{1D55C}": { "math": "\\mathbb{k}", "alt": ["unicode-math"] }, "\u{1D55D}": { "math": "\\mathbb{l}", "alt": ["unicode-math"] }, "\u{1D55E}": { "math": "\\mathbb{m}", "alt": ["unicode-math"] }, "\u{1D55F}": { "math": "\\mathbb{n}", "alt": ["unicode-math"] }, "\u{1D560}": { "math": "\\mathbb{o}", "alt": ["unicode-math"] }, "\u{1D561}": { "math": "\\mathbb{p}", "alt": ["unicode-math"] }, "\u{1D562}": { "math": "\\mathbb{q}", "alt": ["unicode-math"] }, "\u{1D563}": { "math": "\\mathbb{r}", "alt": ["unicode-math"] }, "\u{1D564}": { "math": "\\mathbb{s}", "alt": ["unicode-math"] }, "\u{1D565}": { "math": "\\mathbb{t}", "alt": ["unicode-math"] }, "\u{1D566}": { "math": "\\mathbb{u}", "alt": ["unicode-math"] }, "\u{1D567}": { "math": "\\mathbb{v}", "alt": ["unicode-math"] }, "\u{1D568}": { "math": "\\mathbb{w}", "alt": ["unicode-math"] }, "\u{1D569}": { "math": "\\mathbb{x}", "alt": ["unicode-math"] }, "\u{1D56A}": { "math": "\\mathbb{y}", "alt": ["unicode-math"] }, "\u{1D56B}": { "math": "\\mathbb{z}", "alt": ["unicode-math"] }, "\u{1D56C}": { "math": "A", "alt": ["unicode-math"] }, "\u{1D56D}": { "math": "B", "alt": ["unicode-math"] }, "\u{1D56E}": { "math": "C", "alt": ["unicode-math"] }, "\u{1D56F}": { "math": "D", "alt": ["unicode-math"] }, "\u{1D570}": { "math": "E", "alt": ["unicode-math"] }, "\u{1D571}": { "math": "F", "alt": ["unicode-math"] }, "\u{1D572}": { "math": "G", "alt": ["unicode-math"] }, "\u{1D573}": { "math": "H", "alt": ["unicode-math"] }, "\u{1D574}": { "math": "I", "alt": ["unicode-math"] }, "\u{1D575}": { "math": "J", "alt": ["unicode-math"] }, "\u{1D576}": { "math": "K", "alt": ["unicode-math"] }, "\u{1D577}": { "math": "L", "alt": ["unicode-math"] }, "\u{1D578}": { "math": "M", "alt": ["unicode-math"] }, "\u{1D579}": { "math": "N", "alt": ["unicode-math"] }, "\u{1D57A}": { "math": "O", "alt": ["unicode-math"] }, "\u{1D57B}": { "math": "P", "alt": ["unicode-math"] }, "\u{1D57C}": { "math": "Q", "alt": ["unicode-math"] }, "\u{1D57D}": { "math": "R", "alt": ["unicode-math"] }, "\u{1D57E}": { "math": "S", "alt": ["unicode-math"] }, "\u{1D57F}": { "math": "T", "alt": ["unicode-math"] }, "\u{1D580}": { "math": "U", "alt": ["unicode-math"] }, "\u{1D581}": { "math": "V", "alt": ["unicode-math"] }, "\u{1D582}": { "math": "W", "alt": ["unicode-math"] }, "\u{1D583}": { "math": "X", "alt": ["unicode-math"] }, "\u{1D584}": { "math": "Y", "alt": ["unicode-math"] }, "\u{1D585}": { "math": "Z", "alt": ["unicode-math"] }, "\u{1D586}": { "math": "a", "alt": ["unicode-math"] }, "\u{1D587}": { "math": "b", "alt": ["unicode-math"] }, "\u{1D588}": { "math": "c", "alt": ["unicode-math"] }, "\u{1D589}": { "math": "d", "alt": ["unicode-math"] }, "\u{1D58A}": { "math": "e", "alt": ["unicode-math"] }, "\u{1D58B}": { "math": "f", "alt": ["unicode-math"] }, "\u{1D58C}": { "math": "g", "alt": ["unicode-math"] }, "\u{1D58D}": { "math": "h", "alt": ["unicode-math"] }, "\u{1D58E}": { "math": "i", "alt": ["unicode-math"] }, "\u{1D58F}": { "math": "j", "alt": ["unicode-math"] }, "\u{1D590}": { "math": "k", "alt": ["unicode-math"] }, "\u{1D591}": { "math": "l", "alt": ["unicode-math"] }, "\u{1D592}": { "math": "m", "alt": ["unicode-math"] }, "\u{1D593}": { "math": "n", "alt": ["unicode-math"] }, "\u{1D594}": { "math": "o", "alt": ["unicode-math"] }, "\u{1D595}": { "math": "p", "alt": ["unicode-math"] }, "\u{1D596}": { "math": "q", "alt": ["unicode-math"] }, "\u{1D597}": { "math": "r", "alt": ["unicode-math"] }, "\u{1D598}": { "math": "s", "alt": ["unicode-math"] }, "\u{1D599}": { "math": "t", "alt": ["unicode-math"] }, "\u{1D59A}": { "math": "u", "alt": ["unicode-math"] }, "\u{1D59B}": { "math": "v", "alt": ["unicode-math"] }, "\u{1D59C}": { "math": "w", "alt": ["unicode-math"] }, "\u{1D59D}": { "math": "x", "alt": ["unicode-math"] }, "\u{1D59E}": { "math": "y", "alt": ["unicode-math"] }, "\u{1D59F}": { "math": "z", "alt": ["unicode-math"] }, "\u{1D5A0}": { "math": "\\mathsf{A}", "alt": ["unicode-math"] }, "\u{1D5A1}": { "math": "\\mathsf{B}", "alt": ["unicode-math"] }, "\u{1D5A2}": { "math": "\\mathsf{C}", "alt": ["unicode-math"] }, "\u{1D5A3}": { "math": "\\mathsf{D}", "alt": ["unicode-math"] }, "\u{1D5A4}": { "math": "\\mathsf{E}", "alt": ["unicode-math"] }, "\u{1D5A5}": { "math": "\\mathsf{F}", "alt": ["unicode-math"] }, "\u{1D5A6}": { "math": "\\mathsf{G}", "alt": ["unicode-math"] }, "\u{1D5A7}": { "math": "\\mathsf{H}", "alt": ["unicode-math"] }, "\u{1D5A8}": { "math": "\\mathsf{I}", "alt": ["unicode-math"] }, "\u{1D5A9}": { "math": "\\mathsf{J}", "alt": ["unicode-math"] }, "\u{1D5AA}": { "math": "\\mathsf{K}", "alt": ["unicode-math"] }, "\u{1D5AB}": { "math": "\\mathsf{L}", "alt": ["unicode-math"] }, "\u{1D5AC}": { "math": "\\mathsf{M}", "alt": ["unicode-math"] }, "\u{1D5AD}": { "math": "\\mathsf{N}", "alt": ["unicode-math"] }, "\u{1D5AE}": { "math": "\\mathsf{O}", "alt": ["unicode-math"] }, "\u{1D5AF}": { "math": "\\mathsf{P}", "alt": ["unicode-math"] }, "\u{1D5B0}": { "math": "\\mathsf{Q}", "alt": ["unicode-math"] }, "\u{1D5B1}": { "math": "\\mathsf{R}", "alt": ["unicode-math"] }, "\u{1D5B2}": { "math": "\\mathsf{S}", "alt": ["unicode-math"] }, "\u{1D5B3}": { "math": "\\mathsf{T}", "alt": ["unicode-math"] }, "\u{1D5B4}": { "math": "\\mathsf{U}", "alt": ["unicode-math"] }, "\u{1D5B5}": { "math": "\\mathsf{V}", "alt": ["unicode-math"] }, "\u{1D5B6}": { "math": "\\mathsf{W}", "alt": ["unicode-math"] }, "\u{1D5B7}": { "math": "\\mathsf{X}", "alt": ["unicode-math"] }, "\u{1D5B8}": { "math": "\\mathsf{Y}", "alt": ["unicode-math"] }, "\u{1D5B9}": { "math": "\\mathsf{Z}", "alt": ["unicode-math"] }, "\u{1D5BA}": { "math": "\\mathsf{a}", "alt": ["unicode-math"] }, "\u{1D5BB}": { "math": "\\mathsf{b}", "alt": ["unicode-math"] }, "\u{1D5BC}": { "math": "\\mathsf{c}", "alt": ["unicode-math"] }, "\u{1D5BD}": { "math": "\\mathsf{d}", "alt": ["unicode-math"] }, "\u{1D5BE}": { "math": "\\mathsf{e}", "alt": ["unicode-math"] }, "\u{1D5BF}": { "math": "\\mathsf{f}", "alt": ["unicode-math"] }, "\u{1D5C0}": { "math": "\\mathsf{g}", "alt": ["unicode-math"] }, "\u{1D5C1}": { "math": "\\mathsf{h}", "alt": ["unicode-math"] }, "\u{1D5C2}": { "math": "\\mathsf{i}", "alt": ["unicode-math"] }, "\u{1D5C3}": { "math": "\\mathsf{j}", "alt": ["unicode-math"] }, "\u{1D5C4}": { "math": "\\mathsf{k}", "alt": ["unicode-math"] }, "\u{1D5C5}": { "math": "\\mathsf{l}", "alt": ["unicode-math"] }, "\u{1D5C6}": { "math": "\\mathsf{m}", "alt": ["unicode-math"] }, "\u{1D5C7}": { "math": "\\mathsf{n}", "alt": ["unicode-math"] }, "\u{1D5C8}": { "math": "\\mathsf{o}", "alt": ["unicode-math"] }, "\u{1D5C9}": { "math": "\\mathsf{p}", "alt": ["unicode-math"] }, "\u{1D5CA}": { "math": "\\mathsf{q}", "alt": ["unicode-math"] }, "\u{1D5CB}": { "math": "\\mathsf{r}", "alt": ["unicode-math"] }, "\u{1D5CC}": { "math": "\\mathsf{s}", "alt": ["unicode-math"] }, "\u{1D5CD}": { "math": "\\mathsf{t}", "alt": ["unicode-math"] }, "\u{1D5CE}": { "math": "\\mathsf{u}", "alt": ["unicode-math"] }, "\u{1D5CF}": { "math": "\\mathsf{v}", "alt": ["unicode-math"] }, "\u{1D5D0}": { "math": "\\mathsf{w}", "alt": ["unicode-math"] }, "\u{1D5D1}": { "math": "\\mathsf{x}", "alt": ["unicode-math"] }, "\u{1D5D2}": { "math": "\\mathsf{y}", "alt": ["unicode-math"] }, "\u{1D5D3}": { "math": "\\mathsf{z}", "alt": ["unicode-math"] }, "\u{1D5D4}": { "math": "\\mathsfbf{A}", "alt": ["unicode-math"] }, "\u{1D5D5}": { "math": "\\mathsfbf{B}", "alt": ["unicode-math"] }, "\u{1D5D6}": { "math": "\\mathsfbf{C}", "alt": ["unicode-math"] }, "\u{1D5D7}": { "math": "\\mathsfbf{D}", "alt": ["unicode-math"] }, "\u{1D5D8}": { "math": "\\mathsfbf{E}", "alt": ["unicode-math"] }, "\u{1D5D9}": { "math": "\\mathsfbf{F}", "alt": ["unicode-math"] }, "\u{1D5DA}": { "math": "\\mathsfbf{G}", "alt": ["unicode-math"] }, "\u{1D5DB}": { "math": "\\mathsfbf{H}", "alt": ["unicode-math"] }, "\u{1D5DC}": { "math": "\\mathsfbf{I}", "alt": ["unicode-math"] }, "\u{1D5DD}": { "math": "\\mathsfbf{J}", "alt": ["unicode-math"] }, "\u{1D5DE}": { "math": "\\mathsfbf{K}", "alt": ["unicode-math"] }, "\u{1D5DF}": { "math": "\\mathsfbf{L}", "alt": ["unicode-math"] }, "\u{1D5E0}": { "math": "\\mathsfbf{M}", "alt": ["unicode-math"] }, "\u{1D5E1}": { "math": "\\mathsfbf{N}", "alt": ["unicode-math"] }, "\u{1D5E2}": { "math": "\\mathsfbf{O}", "alt": ["unicode-math"] }, "\u{1D5E3}": { "math": "\\mathsfbf{P}", "alt": ["unicode-math"] }, "\u{1D5E4}": { "math": "\\mathsfbf{Q}", "alt": ["unicode-math"] }, "\u{1D5E5}": { "math": "\\mathsfbf{R}", "alt": ["unicode-math"] }, "\u{1D5E6}": { "math": "\\mathsfbf{S}", "alt": ["unicode-math"] }, "\u{1D5E7}": { "math": "\\mathsfbf{T}", "alt": ["unicode-math"] }, "\u{1D5E8}": { "math": "\\mathsfbf{U}", "alt": ["unicode-math"] }, "\u{1D5E9}": { "math": "\\mathsfbf{V}", "alt": ["unicode-math"] }, "\u{1D5EA}": { "math": "\\mathsfbf{W}", "alt": ["unicode-math"] }, "\u{1D5EB}": { "math": "\\mathsfbf{X}", "alt": ["unicode-math"] }, "\u{1D5EC}": { "math": "\\mathsfbf{Y}", "alt": ["unicode-math"] }, "\u{1D5ED}": { "math": "\\mathsfbf{Z}", "alt": ["unicode-math"] }, "\u{1D5EE}": { "math": "\\mathsfbf{a}", "alt": ["unicode-math"] }, "\u{1D5EF}": { "math": "\\mathsfbf{b}", "alt": ["unicode-math"] }, "\u{1D5F0}": { "math": "\\mathsfbf{c}", "alt": ["unicode-math"] }, "\u{1D5F1}": { "math": "\\mathsfbf{d}", "alt": ["unicode-math"] }, "\u{1D5F2}": { "math": "\\mathsfbf{e}", "alt": ["unicode-math"] }, "\u{1D5F3}": { "math": "\\mathsfbf{f}", "alt": ["unicode-math"] }, "\u{1D5F4}": { "math": "\\mathsfbf{g}", "alt": ["unicode-math"] }, "\u{1D5F5}": { "math": "\\mathsfbf{h}", "alt": ["unicode-math"] }, "\u{1D5F6}": { "math": "\\mathsfbf{i}", "alt": ["unicode-math"] }, "\u{1D5F7}": { "math": "\\mathsfbf{j}", "alt": ["unicode-math"] }, "\u{1D5F8}": { "math": "\\mathsfbf{k}", "alt": ["unicode-math"] }, "\u{1D5F9}": { "math": "\\mathsfbf{l}", "alt": ["unicode-math"] }, "\u{1D5FA}": { "math": "\\mathsfbf{m}", "alt": ["unicode-math"] }, "\u{1D5FB}": { "math": "\\mathsfbf{n}", "alt": ["unicode-math"] }, "\u{1D5FC}": { "math": "\\mathsfbf{o}", "alt": ["unicode-math"] }, "\u{1D5FD}": { "math": "\\mathsfbf{p}", "alt": ["unicode-math"] }, "\u{1D5FE}": { "math": "\\mathsfbf{q}", "alt": ["unicode-math"] }, "\u{1D5FF}": { "math": "\\mathsfbf{r}", "alt": ["unicode-math"] }, "\u{1D600}": { "math": "\\mathsfbf{s}", "alt": ["unicode-math"] }, "\u{1D601}": { "math": "\\mathsfbf{t}", "alt": ["unicode-math"] }, "\u{1D602}": { "math": "\\mathsfbf{u}", "alt": ["unicode-math"] }, "\u{1D603}": { "math": "\\mathsfbf{v}", "alt": ["unicode-math"] }, "\u{1D604}": { "math": "\\mathsfbf{w}", "alt": ["unicode-math"] }, "\u{1D605}": { "math": "\\mathsfbf{x}", "alt": ["unicode-math"] }, "\u{1D606}": { "math": "\\mathsfbf{y}", "alt": ["unicode-math"] }, "\u{1D607}": { "math": "\\mathsfbf{z}", "alt": ["unicode-math"] }, "\u{1D608}": { "math": "\\mathsfsl{A}", "alt": ["unicode-math"] }, "\u{1D609}": { "math": "\\mathsfsl{B}", "alt": ["unicode-math"] }, "\u{1D60A}": { "math": "\\mathsfsl{C}", "alt": ["unicode-math"] }, "\u{1D60B}": { "math": "\\mathsfsl{D}", "alt": ["unicode-math"] }, "\u{1D60C}": { "math": "\\mathsfsl{E}", "alt": ["unicode-math"] }, "\u{1D60D}": { "math": "\\mathsfsl{F}", "alt": ["unicode-math"] }, "\u{1D60E}": { "math": "\\mathsfsl{G}", "alt": ["unicode-math"] }, "\u{1D60F}": { "math": "\\mathsfsl{H}", "alt": ["unicode-math"] }, "\u{1D610}": { "math": "\\mathsfsl{I}", "alt": ["unicode-math"] }, "\u{1D611}": { "math": "\\mathsfsl{J}", "alt": ["unicode-math"] }, "\u{1D612}": { "math": "\\mathsfsl{K}", "alt": ["unicode-math"] }, "\u{1D613}": { "math": "\\mathsfsl{L}", "alt": ["unicode-math"] }, "\u{1D614}": { "math": "\\mathsfsl{M}", "alt": ["unicode-math"] }, "\u{1D615}": { "math": "\\mathsfsl{N}", "alt": ["unicode-math"] }, "\u{1D616}": { "math": "\\mathsfsl{O}", "alt": ["unicode-math"] }, "\u{1D617}": { "math": "\\mathsfsl{P}", "alt": ["unicode-math"] }, "\u{1D618}": { "math": "\\mathsfsl{Q}", "alt": ["unicode-math"] }, "\u{1D619}": { "math": "\\mathsfsl{R}", "alt": ["unicode-math"] }, "\u{1D61A}": { "math": "\\mathsfsl{S}", "alt": ["unicode-math"] }, "\u{1D61B}": { "math": "\\mathsfsl{T}", "alt": ["unicode-math"] }, "\u{1D61C}": { "math": "\\mathsfsl{U}", "alt": ["unicode-math"] }, "\u{1D61D}": { "math": "\\mathsfsl{V}", "alt": ["unicode-math"] }, "\u{1D61E}": { "math": "\\mathsfsl{W}", "alt": ["unicode-math"] }, "\u{1D61F}": { "math": "\\mathsfsl{X}", "alt": ["unicode-math"] }, "\u{1D620}": { "math": "\\mathsfsl{Y}", "alt": ["unicode-math"] }, "\u{1D621}": { "math": "\\mathsfsl{Z}", "alt": ["unicode-math"] }, "\u{1D622}": { "math": "\\mathsfsl{a}", "alt": ["unicode-math"] }, "\u{1D623}": { "math": "\\mathsfsl{b}", "alt": ["unicode-math"] }, "\u{1D624}": { "math": "\\mathsfsl{c}", "alt": ["unicode-math"] }, "\u{1D625}": { "math": "\\mathsfsl{d}", "alt": ["unicode-math"] }, "\u{1D626}": { "math": "\\mathsfsl{e}", "alt": ["unicode-math"] }, "\u{1D627}": { "math": "\\mathsfsl{f}", "alt": ["unicode-math"] }, "\u{1D628}": { "math": "\\mathsfsl{g}", "alt": ["unicode-math"] }, "\u{1D629}": { "math": "\\mathsfsl{h}", "alt": ["unicode-math"] }, "\u{1D62A}": { "math": "\\mathsfsl{i}", "alt": ["unicode-math"] }, "\u{1D62B}": { "math": "\\mathsfsl{j}", "alt": ["unicode-math"] }, "\u{1D62C}": { "math": "\\mathsfsl{k}", "alt": ["unicode-math"] }, "\u{1D62D}": { "math": "\\mathsfsl{l}", "alt": ["unicode-math"] }, "\u{1D62E}": { "math": "\\mathsfsl{m}", "alt": ["unicode-math"] }, "\u{1D62F}": { "math": "\\mathsfsl{n}", "alt": ["unicode-math"] }, "\u{1D630}": { "math": "\\mathsfsl{o}", "alt": ["unicode-math"] }, "\u{1D631}": { "math": "\\mathsfsl{p}", "alt": ["unicode-math"] }, "\u{1D632}": { "math": "\\mathsfsl{q}", "alt": ["unicode-math"] }, "\u{1D633}": { "math": "\\mathsfsl{r}", "alt": ["unicode-math"] }, "\u{1D634}": { "math": "\\mathsfsl{s}", "alt": ["unicode-math"] }, "\u{1D635}": { "math": "\\mathsfsl{t}", "alt": ["unicode-math"] }, "\u{1D636}": { "math": "\\mathsfsl{u}", "alt": ["unicode-math"] }, "\u{1D637}": { "math": "\\mathsfsl{v}", "alt": ["unicode-math"] }, "\u{1D638}": { "math": "\\mathsfsl{w}", "alt": ["unicode-math"] }, "\u{1D639}": { "math": "\\mathsfsl{x}", "alt": ["unicode-math"] }, "\u{1D63A}": { "math": "\\mathsfsl{y}", "alt": ["unicode-math"] }, "\u{1D63B}": { "math": "\\mathsfsl{z}", "alt": ["unicode-math"] }, "\u{1D63C}": { "math": "\\mathsfbfsl{A}", "alt": ["unicode-math"] }, "\u{1D63D}": { "math": "\\mathsfbfsl{B}", "alt": ["unicode-math"] }, "\u{1D63E}": { "math": "\\mathsfbfsl{C}", "alt": ["unicode-math"] }, "\u{1D63F}": { "math": "\\mathsfbfsl{D}", "alt": ["unicode-math"] }, "\u{1D640}": { "math": "\\mathsfbfsl{E}", "alt": ["unicode-math"] }, "\u{1D641}": { "math": "\\mathsfbfsl{F}", "alt": ["unicode-math"] }, "\u{1D642}": { "math": "\\mathsfbfsl{G}", "alt": ["unicode-math"] }, "\u{1D643}": { "math": "\\mathsfbfsl{H}", "alt": ["unicode-math"] }, "\u{1D644}": { "math": "\\mathsfbfsl{I}", "alt": ["unicode-math"] }, "\u{1D645}": { "math": "\\mathsfbfsl{J}", "alt": ["unicode-math"] }, "\u{1D646}": { "math": "\\mathsfbfsl{K}", "alt": ["unicode-math"] }, "\u{1D647}": { "math": "\\mathsfbfsl{L}", "alt": ["unicode-math"] }, "\u{1D648}": { "math": "\\mathsfbfsl{M}", "alt": ["unicode-math"] }, "\u{1D649}": { "math": "\\mathsfbfsl{N}", "alt": ["unicode-math"] }, "\u{1D64A}": { "math": "\\mathsfbfsl{O}", "alt": ["unicode-math"] }, "\u{1D64B}": { "math": "\\mathsfbfsl{P}", "alt": ["unicode-math"] }, "\u{1D64C}": { "math": "\\mathsfbfsl{Q}", "alt": ["unicode-math"] }, "\u{1D64D}": { "math": "\\mathsfbfsl{R}", "alt": ["unicode-math"] }, "\u{1D64E}": { "math": "\\mathsfbfsl{S}", "alt": ["unicode-math"] }, "\u{1D64F}": { "math": "\\mathsfbfsl{T}", "alt": ["unicode-math"] }, "\u{1D650}": { "math": "\\mathsfbfsl{U}", "alt": ["unicode-math"] }, "\u{1D651}": { "math": "\\mathsfbfsl{V}", "alt": ["unicode-math"] }, "\u{1D652}": { "math": "\\mathsfbfsl{W}", "alt": ["unicode-math"] }, "\u{1D653}": { "math": "\\mathsfbfsl{X}", "alt": ["unicode-math"] }, "\u{1D654}": { "math": "\\mathsfbfsl{Y}", "alt": ["unicode-math"] }, "\u{1D655}": { "math": "\\mathsfbfsl{Z}", "alt": ["unicode-math"] }, "\u{1D656}": { "math": "\\mathsfbfsl{a}", "alt": ["unicode-math"] }, "\u{1D657}": { "math": "\\mathsfbfsl{b}", "alt": ["unicode-math"] }, "\u{1D658}": { "math": "\\mathsfbfsl{c}", "alt": ["unicode-math"] }, "\u{1D659}": { "math": "\\mathsfbfsl{d}", "alt": ["unicode-math"] }, "\u{1D65A}": { "math": "\\mathsfbfsl{e}", "alt": ["unicode-math"] }, "\u{1D65B}": { "math": "\\mathsfbfsl{f}", "alt": ["unicode-math"] }, "\u{1D65C}": { "math": "\\mathsfbfsl{g}", "alt": ["unicode-math"] }, "\u{1D65D}": { "math": "\\mathsfbfsl{h}", "alt": ["unicode-math"] }, "\u{1D65E}": { "math": "\\mathsfbfsl{i}", "alt": ["unicode-math"] }, "\u{1D65F}": { "math": "\\mathsfbfsl{j}", "alt": ["unicode-math"] }, "\u{1D660}": { "math": "\\mathsfbfsl{k}", "alt": ["unicode-math"] }, "\u{1D661}": { "math": "\\mathsfbfsl{l}", "alt": ["unicode-math"] }, "\u{1D662}": { "math": "\\mathsfbfsl{m}", "alt": ["unicode-math"] }, "\u{1D663}": { "math": "\\mathsfbfsl{n}", "alt": ["unicode-math"] }, "\u{1D664}": { "math": "\\mathsfbfsl{o}", "alt": ["unicode-math"] }, "\u{1D665}": { "math": "\\mathsfbfsl{p}", "alt": ["unicode-math"] }, "\u{1D666}": { "math": "\\mathsfbfsl{q}", "alt": ["unicode-math"] }, "\u{1D667}": { "math": "\\mathsfbfsl{r}", "alt": ["unicode-math"] }, "\u{1D668}": { "math": "\\mathsfbfsl{s}", "alt": ["unicode-math"] }, "\u{1D669}": { "math": "\\mathsfbfsl{t}", "alt": ["unicode-math"] }, "\u{1D66A}": { "math": "\\mathsfbfsl{u}", "alt": ["unicode-math"] }, "\u{1D66B}": { "math": "\\mathsfbfsl{v}", "alt": ["unicode-math"] }, "\u{1D66C}": { "math": "\\mathsfbfsl{w}", "alt": ["unicode-math"] }, "\u{1D66D}": { "math": "\\mathsfbfsl{x}", "alt": ["unicode-math"] }, "\u{1D66E}": { "math": "\\mathsfbfsl{y}", "alt": ["unicode-math"] }, "\u{1D66F}": { "math": "\\mathsfbfsl{z}", "alt": ["unicode-math"] }, "\u{1D670}": { "math": "\\mathtt{A}", "alt": ["unicode-math"] }, "\u{1D671}": { "math": "\\mathtt{B}", "alt": ["unicode-math"] }, "\u{1D672}": { "math": "\\mathtt{C}", "alt": ["unicode-math"] }, "\u{1D673}": { "math": "\\mathtt{D}", "alt": ["unicode-math"] }, "\u{1D674}": { "math": "\\mathtt{E}", "alt": ["unicode-math"] }, "\u{1D675}": { "math": "\\mathtt{F}", "alt": ["unicode-math"] }, "\u{1D676}": { "math": "\\mathtt{G}", "alt": ["unicode-math"] }, "\u{1D677}": { "math": "\\mathtt{H}", "alt": ["unicode-math"] }, "\u{1D678}": { "math": "\\mathtt{I}", "alt": ["unicode-math"] }, "\u{1D679}": { "math": "\\mathtt{J}", "alt": ["unicode-math"] }, "\u{1D67A}": { "math": "\\mathtt{K}", "alt": ["unicode-math"] }, "\u{1D67B}": { "math": "\\mathtt{L}", "alt": ["unicode-math"] }, "\u{1D67C}": { "math": "\\mathtt{M}", "alt": ["unicode-math"] }, "\u{1D67D}": { "math": "\\mathtt{N}", "alt": ["unicode-math"] }, "\u{1D67E}": { "math": "\\mathtt{O}", "alt": ["unicode-math"] }, "\u{1D67F}": { "math": "\\mathtt{P}", "alt": ["unicode-math"] }, "\u{1D680}": { "math": "\\mathtt{Q}", "alt": ["unicode-math"] }, "\u{1D681}": { "math": "\\mathtt{R}", "alt": ["unicode-math"] }, "\u{1D682}": { "math": "\\mathtt{S}", "alt": ["unicode-math"] }, "\u{1D683}": { "math": "\\mathtt{T}", "alt": ["unicode-math"] }, "\u{1D684}": { "math": "\\mathtt{U}", "alt": ["unicode-math"] }, "\u{1D685}": { "math": "\\mathtt{V}", "alt": ["unicode-math"] }, "\u{1D686}": { "math": "\\mathtt{W}", "alt": ["unicode-math"] }, "\u{1D687}": { "math": "\\mathtt{X}", "alt": ["unicode-math"] }, "\u{1D688}": { "math": "\\mathtt{Y}", "alt": ["unicode-math"] }, "\u{1D689}": { "math": "\\mathtt{Z}", "alt": ["unicode-math"] }, "\u{1D68A}": { "math": "\\mathtt{a}", "alt": ["unicode-math"] }, "\u{1D68B}": { "math": "\\mathtt{b}", "alt": ["unicode-math"] }, "\u{1D68C}": { "math": "\\mathtt{c}", "alt": ["unicode-math"] }, "\u{1D68D}": { "math": "\\mathtt{d}", "alt": ["unicode-math"] }, "\u{1D68E}": { "math": "\\mathtt{e}", "alt": ["unicode-math"] }, "\u{1D68F}": { "math": "\\mathtt{f}", "alt": ["unicode-math"] }, "\u{1D690}": { "math": "\\mathtt{g}", "alt": ["unicode-math"] }, "\u{1D691}": { "math": "\\mathtt{h}", "alt": ["unicode-math"] }, "\u{1D692}": { "math": "\\mathtt{i}", "alt": ["unicode-math"] }, "\u{1D693}": { "math": "\\mathtt{j}", "alt": ["unicode-math"] }, "\u{1D694}": { "math": "\\mathtt{k}", "alt": ["unicode-math"] }, "\u{1D695}": { "math": "\\mathtt{l}", "alt": ["unicode-math"] }, "\u{1D696}": { "math": "\\mathtt{m}", "alt": ["unicode-math"] }, "\u{1D697}": { "math": "\\mathtt{n}", "alt": ["unicode-math"] }, "\u{1D698}": { "math": "\\mathtt{o}", "alt": ["unicode-math"] }, "\u{1D699}": { "math": "\\mathtt{p}", "alt": ["unicode-math"] }, "\u{1D69A}": { "math": "\\mathtt{q}", "alt": ["unicode-math"] }, "\u{1D69B}": { "math": "\\mathtt{r}", "alt": ["unicode-math"] }, "\u{1D69C}": { "math": "\\mathtt{s}", "alt": ["unicode-math"] }, "\u{1D69D}": { "math": "\\mathtt{t}", "alt": ["unicode-math"] }, "\u{1D69E}": { "math": "\\mathtt{u}", "alt": ["unicode-math"] }, "\u{1D69F}": { "math": "\\mathtt{v}", "alt": ["unicode-math"] }, "\u{1D6A0}": { "math": "\\mathtt{w}", "alt": ["unicode-math"] }, "\u{1D6A1}": { "math": "\\mathtt{x}", "alt": ["unicode-math"] }, "\u{1D6A2}": { "math": "\\mathtt{y}", "alt": ["unicode-math"] }, "\u{1D6A3}": { "math": "\\mathtt{z}", "alt": ["unicode-math"] }, "\u{1D6A4}": { "math": "\\imath", "alt": ["unicode-math"] }, "\u{1D6A5}": { "math": "\\jmath", "alt": ["unicode-math"] }, "\u{1D6A8}": { "math": "\\mathbf{A}", "alt": ["unicode-math"] }, "\u{1D6A9}": { "math": "\\mathbf{B}", "alt": ["unicode-math"] }, "\u{1D6AA}": { "math": "\\mathbf{\\Gamma}", "alt": ["unicode-math"] }, "\u{1D6AB}": { "math": "\\mathbf{\\Delta}", "alt": ["unicode-math"] }, "\u{1D6AC}": { "math": "\\mathbf{E}", "alt": ["unicode-math"] }, "\u{1D6AD}": { "math": "\\mathbf{Z}", "alt": ["unicode-math"] }, "\u{1D6AE}": { "math": "\\mathbf{H}", "alt": ["unicode-math"] }, "\u{1D6AF}": { "math": "\\mathbf{\\Theta}", "alt": ["unicode-math"] }, "\u{1D6B0}": { "math": "\\mathbf{I}", "alt": ["unicode-math"] }, "\u{1D6B1}": { "math": "\\mathbf{K}", "alt": ["unicode-math"] }, "\u{1D6B2}": { "math": "\\mathbf{\\Lambda}", "alt": ["unicode-math"] }, "\u{1D6B3}": { "math": "M", "alt": ["unicode-math"] }, "\u{1D6B4}": { "math": "N", "alt": ["unicode-math"] }, "\u{1D6B5}": { "math": "\\mathbf{\\Xi}", "alt": ["unicode-math"] }, "\u{1D6B6}": { "math": "O", "alt": ["unicode-math"] }, "\u{1D6B7}": { "math": "\\mathbf{\\Pi}", "alt": ["unicode-math"] }, "\u{1D6B8}": { "math": "\\mathbf{P}", "alt": ["unicode-math"] }, "\u{1D6B9}": { "math": "\\mathbf{\\vartheta}", "alt": ["unicode-math"] }, "\u{1D6BA}": { "math": "\\mathbf{\\Sigma}", "alt": ["unicode-math"] }, "\u{1D6BB}": { "math": "\\mathbf{T}", "alt": ["unicode-math"] }, "\u{1D6BC}": { "math": "\\mathbf{\\Upsilon}", "alt": ["unicode-math"] }, "\u{1D6BD}": { "math": "\\mathbf{\\Phi}", "alt": ["unicode-math"] }, "\u{1D6BE}": { "math": "\\mathbf{X}", "alt": ["unicode-math"] }, "\u{1D6BF}": { "math": "\\mathbf{\\Psi}", "alt": ["unicode-math"] }, "\u{1D6C0}": { "math": "\\mathbf{\\Omega}", "alt": ["unicode-math"] }, "\u{1D6C1}": { "math": "\\mathbf{\\nabla}", "alt": ["unicode-math"] }, "\u{1D6C2}": { "math": "\\mathbf{\\alpha}", "alt": ["unicode-math"] }, "\u{1D6C3}": { "math": "\\mathbf{\\beta}", "alt": ["unicode-math"] }, "\u{1D6C4}": { "math": "\\mathbf{\\gamma}", "alt": ["unicode-math"] }, "\u{1D6C5}": { "math": "\\mathbf{\\delta}", "alt": ["unicode-math"] }, "\u{1D6C6}": { "math": "\\mathbf{\\epsilon}", "alt": ["unicode-math"] }, "\u{1D6C7}": { "math": "\\mathbf{\\zeta}", "alt": ["unicode-math"] }, "\u{1D6C8}": { "math": "\\mathbf{\\eta}", "alt": ["unicode-math"] }, "\u{1D6C9}": { "math": "\\mathbf{\\theta}", "alt": ["unicode-math"] }, "\u{1D6CA}": { "math": "\\mathbf{I}", "alt": ["unicode-math"] }, "\u{1D6CB}": { "math": "\\mathbf{K}", "alt": ["unicode-math"] }, "\u{1D6CC}": { "math": "\\mathbf{\\lambda}", "alt": ["unicode-math"] }, "\u{1D6CD}": { "math": "m", "alt": ["unicode-math"] }, "\u{1D6CE}": { "math": "v", "alt": ["unicode-math"] }, "\u{1D6CF}": { "math": "\\mathbf{\\xi}", "alt": ["unicode-math"] }, "\u{1D6D0}": { "math": "O", "alt": ["unicode-math"] }, "\u{1D6D1}": { "math": "\\mathbf{\\pi}", "alt": ["unicode-math"] }, "\u{1D6D2}": { "math": "\\mathbf{P}", "alt": ["unicode-math"] }, "\u{1D6D3}": { "math": "\\mathbf{\\varsigma}", "alt": ["unicode-math"] }, "\u{1D6D4}": { "math": "\\mathbf{\\sigma}", "alt": ["unicode-math"] }, "\u{1D6D5}": { "math": "\\mathbf{T}", "alt": ["unicode-math"] }, "\u{1D6D6}": { "math": "\\mathbf{\\upsilon}", "alt": ["unicode-math"] }, "\u{1D6D7}": { "math": "\\mathbf{\\phi}", "alt": ["unicode-math"] }, "\u{1D6D8}": { "math": "\\mathbf{X}", "alt": ["unicode-math"] }, "\u{1D6D9}": { "math": "\\mathbf{\\psi}", "alt": ["unicode-math"] }, "\u{1D6DA}": { "math": "\\mathbf{\\omega}", "alt": ["unicode-math"] }, "\u{1D6DB}": { "math": "\\partial", "alt": ["unicode-math"] }, "\u{1D6DC}": { "math": "\\in", "alt": ["unicode-math"] }, "\u{1D6DD}": { "math": "\\mathbf{\\vartheta}", "alt": ["unicode-math"] }, "\u{1D6DE}": { "math": "\\mathbf{\\varkappa}", "alt": ["unicode-math"] }, "\u{1D6DF}": { "math": "\\mathbf{\\phi}", "alt": ["unicode-math"] }, "\u{1D6E0}": { "math": "\\mathbf{\\varrho}", "alt": ["unicode-math"] }, "\u{1D6E1}": { "math": "\\mathbf{\\varpi}", "alt": ["unicode-math"] }, "\u{1D6E2}": { "math": "A", "alt": ["unicode-math"] }, "\u{1D6E3}": { "math": "B", "alt": ["unicode-math"] }, "\u{1D6E4}": { "math": "\\Gamma", "alt": ["unicode-math"] }, "\u{1D6E5}": { "math": "\\Delta", "alt": ["unicode-math"] }, "\u{1D6E6}": { "math": "E", "alt": ["unicode-math"] }, "\u{1D6E7}": { "math": "Z", "alt": ["unicode-math"] }, "\u{1D6E8}": { "math": "H", "alt": ["unicode-math"] }, "\u{1D6E9}": { "math": "\\Theta", "alt": ["unicode-math"] }, "\u{1D6EA}": { "math": "I", "alt": ["unicode-math"] }, "\u{1D6EB}": { "math": "K", "alt": ["unicode-math"] }, "\u{1D6EC}": { "math": "\\Lambda", "alt": ["unicode-math"] }, "\u{1D6ED}": { "math": "M", "alt": ["unicode-math"] }, "\u{1D6EE}": { "math": "N", "alt": ["unicode-math"] }, "\u{1D6EF}": { "math": "\\Xi", "alt": ["unicode-math"] }, "\u{1D6F0}": { "math": "O", "alt": ["unicode-math"] }, "\u{1D6F1}": { "math": "\\Pi", "alt": ["unicode-math"] }, "\u{1D6F2}": { "math": "P", "alt": ["unicode-math"] }, "\u{1D6F3}": { "math": "\\Theta", "alt": ["unicode-math"] }, "\u{1D6F4}": { "math": "\\Sigma", "alt": ["unicode-math"] }, "\u{1D6F5}": { "math": "T", "alt": ["unicode-math"] }, "\u{1D6F6}": { "math": "\\Upsilon", "alt": ["unicode-math"] }, "\u{1D6F7}": { "math": "\\Phi", "alt": ["unicode-math"] }, "\u{1D6F8}": { "math": "X", "alt": ["unicode-math"] }, "\u{1D6F9}": { "math": "\\Psi", "alt": ["unicode-math"] }, "\u{1D6FA}": { "math": "\\Omega", "alt": ["unicode-math"] }, "\u{1D6FB}": { "math": "\\nabla", "alt": ["unicode-math"] }, "\u{1D6FC}": { "math": "A", "alt": ["unicode-math"] }, "\u{1D6FD}": { "math": "B", "alt": ["unicode-math"] }, "\u{1D6FE}": { "math": "\\gamma", "alt": ["unicode-math"] }, "\u{1D6FF}": { "math": "\\delta", "alt": ["unicode-math"] }, "\u{1D700}": { "math": "E", "alt": ["unicode-math"] }, "\u{1D701}": { "math": "Z", "alt": ["unicode-math"] }, "\u{1D702}": { "math": "H", "alt": ["unicode-math"] }, "\u{1D703}": { "math": "\\theta", "alt": ["unicode-math"] }, "\u{1D704}": { "math": "I", "alt": ["unicode-math"] }, "\u{1D705}": { "math": "K", "alt": ["unicode-math"] }, "\u{1D706}": { "math": "\\lambda", "alt": ["unicode-math"] }, "\u{1D707}": { "math": "\\mu", "alt": ["unicode-math"] }, "\u{1D708}": { "math": "\\nu", "alt": ["unicode-math"] }, "\u{1D709}": { "math": "\\xi", "alt": ["unicode-math"] }, "\u{1D70A}": { "math": "o", "alt": ["unicode-math"] }, "\u{1D70B}": { "math": "\\pi", "alt": ["unicode-math"] }, "\u{1D70D}": { "math": "\\varsigma", "alt": ["unicode-math"] }, "\u{1D70E}": { "math": "\\sigma", "alt": ["unicode-math"] }, "\u{1D70F}": { "math": "T", "alt": ["unicode-math"] }, "\u{1D710}": { "math": "\\upsilon", "alt": ["unicode-math"] }, "\u{1D711}": { "math": "\\varphi", "alt": ["unicode-math"] }, "\u{1D712}": { "math": "X", "alt": ["unicode-math"] }, "\u{1D713}": { "math": "\\psi", "alt": ["unicode-math"] }, "\u{1D714}": { "math": "\\omega", "alt": ["unicode-math"] }, "\u{1D715}": { "math": "\\partial", "alt": ["unicode-math"] }, "\u{1D716}": { "math": "\\in", "alt": ["unicode-math"] }, "\u{1D717}": { "math": "\\vartheta", "alt": ["unicode-math"] }, "\u{1D718}": { "math": "\\varkappa", "alt": ["unicode-math"] }, "\u{1D719}": { "math": "\\phi", "alt": ["unicode-math"] }, "\u{1D71A}": { "math": "\\varrho", "alt": ["unicode-math"] }, "\u{1D71B}": { "math": "\\varpi", "alt": ["unicode-math"] }, "\u{1D71C}": { "math": "\\mathbit{A}", "alt": ["unicode-math"] }, "\u{1D71D}": { "math": "\\mathbit{B}", "alt": ["unicode-math"] }, "\u{1D71E}": { "math": "\\mathbit{\\Gamma}", "alt": ["unicode-math"] }, "\u{1D71F}": { "math": "\\mathbit{\\Delta}", "alt": ["unicode-math"] }, "\u{1D720}": { "math": "\\mathbit{E}", "alt": ["unicode-math"] }, "\u{1D721}": { "math": "\\mathbit{Z}", "alt": ["unicode-math"] }, "\u{1D722}": { "math": "\\mathbit{H}", "alt": ["unicode-math"] }, "\u{1D723}": { "math": "\\mathbit{\\Theta}", "alt": ["unicode-math"] }, "\u{1D724}": { "math": "\\mathbit{I}", "alt": ["unicode-math"] }, "\u{1D725}": { "math": "\\mathbit{K}", "alt": ["unicode-math"] }, "\u{1D726}": { "math": "\\mathbit{\\Lambda}", "alt": ["unicode-math"] }, "\u{1D727}": { "math": "M", "alt": ["unicode-math"] }, "\u{1D728}": { "math": "N", "alt": ["unicode-math"] }, "\u{1D729}": { "math": "\\mathbit{\\Xi}", "alt": ["unicode-math"] }, "\u{1D72A}": { "math": "O", "alt": ["unicode-math"] }, "\u{1D72B}": { "math": "\\mathbit{\\Pi}", "alt": ["unicode-math"] }, "\u{1D72C}": { "math": "\\mathbit{P}", "alt": ["unicode-math"] }, "\u{1D72D}": { "math": "\\mathbit{O}", "alt": ["unicode-math"] }, "\u{1D72E}": { "math": "\\mathbit{\\Sigma}", "alt": ["unicode-math"] }, "\u{1D72F}": { "math": "\\mathbit{T}", "alt": ["unicode-math"] }, "\u{1D730}": { "math": "\\mathbit{\\Upsilon}", "alt": ["unicode-math"] }, "\u{1D731}": { "math": "\\mathbit{\\Phi}", "alt": ["unicode-math"] }, "\u{1D732}": { "math": "\\mathbit{X}", "alt": ["unicode-math"] }, "\u{1D733}": { "math": "\\mathbit{\\Psi}", "alt": ["unicode-math"] }, "\u{1D734}": { "math": "\\mathbit{\\Omega}", "alt": ["unicode-math"] }, "\u{1D735}": { "math": "\\mathbit{\\nabla}", "alt": ["unicode-math"] }, "\u{1D736}": { "math": "\\mathbit{\\alpha}", "alt": ["unicode-math"] }, "\u{1D737}": { "math": "\\mathbit{\\beta}", "alt": ["unicode-math"] }, "\u{1D738}": { "math": "\\mathbit{\\gamma}", "alt": ["unicode-math"] }, "\u{1D739}": { "math": "\\mathbit{\\delta}", "alt": ["unicode-math"] }, "\u{1D73A}": { "math": "\\mathbit{\\epsilon}", "alt": ["unicode-math"] }, "\u{1D73B}": { "math": "\\mathbit{\\zeta}", "alt": ["unicode-math"] }, "\u{1D73C}": { "math": "\\mathbit{\\eta}", "alt": ["unicode-math"] }, "\u{1D73D}": { "math": "\\mathbit{\\theta}", "alt": ["unicode-math"] }, "\u{1D73E}": { "math": "\\mathbit{\\imath}", "alt": ["unicode-math"] }, "\u{1D73F}": { "math": "\\mathbit{\\kappa}", "alt": ["unicode-math"] }, "\u{1D740}": { "math": "\\mathbit{\\lambda}", "alt": ["unicode-math"] }, "\u{1D741}": { "math": "\\mu", "alt": ["unicode-math"] }, "\u{1D742}": { "math": "v", "alt": ["unicode-math"] }, "\u{1D743}": { "math": "\\mathbit{\\xi}", "alt": ["unicode-math"] }, "\u{1D744}": { "math": "O", "alt": ["unicode-math"] }, "\u{1D745}": { "math": "\\mathbit{\\pi}", "alt": ["unicode-math"] }, "\u{1D746}": { "math": "\\mathbit{\\rho}", "alt": ["unicode-math"] }, "\u{1D747}": { "math": "\\mathbit{\\varsigma}", "alt": ["unicode-math"] }, "\u{1D748}": { "math": "\\mathbit{\\sigma}", "alt": ["unicode-math"] }, "\u{1D749}": { "math": "\\mathbit{\\tau}", "alt": ["unicode-math"] }, "\u{1D74A}": { "math": "\\mathbit{\\upsilon}", "alt": ["unicode-math"] }, "\u{1D74B}": { "math": "\\mathbit{\\varphi}", "alt": ["unicode-math"] }, "\u{1D74C}": { "math": "\\mathbit{\\chi}", "alt": ["unicode-math"] }, "\u{1D74D}": { "math": "\\mathbit{\\psi}", "alt": ["unicode-math"] }, "\u{1D74E}": { "math": "\\mathbit{\\omega}", "alt": ["unicode-math"] }, "\u{1D74F}": { "math": "\\partial", "alt": ["unicode-math"] }, "\u{1D750}": { "math": "\\in", "alt": ["unicode-math"] }, "\u{1D751}": { "math": "\\mathbit{\\vartheta}", "alt": ["unicode-math"] }, "\u{1D752}": { "math": "\\mathbit{\\varkappa}", "alt": ["unicode-math"] }, "\u{1D753}": { "math": "\\mathbit{\\phi}", "alt": ["unicode-math"] }, "\u{1D754}": { "math": "\\mathbit{\\varrho}", "alt": ["unicode-math"] }, "\u{1D755}": { "math": "\\mathbit{\\varpi}", "alt": ["unicode-math"] }, "\u{1D756}": { "math": "\\mathsfbf{A}", "alt": ["unicode-math"] }, "\u{1D757}": { "math": "\\mathsfbf{B}", "alt": ["unicode-math"] }, "\u{1D758}": { "math": "\\mathsfbf{\\Gamma}", "alt": ["unicode-math"] }, "\u{1D759}": { "math": "\\mathsfbf{\\Delta}", "alt": ["unicode-math"] }, "\u{1D75A}": { "math": "\\mathsfbf{E}", "alt": ["unicode-math"] }, "\u{1D75B}": { "math": "\\mathsfbf{Z}", "alt": ["unicode-math"] }, "\u{1D75C}": { "math": "\\mathsfbf{H}", "alt": ["unicode-math"] }, "\u{1D75D}": { "math": "\\mathsfbf{\\Theta}", "alt": ["unicode-math"] }, "\u{1D75E}": { "math": "\\mathsfbf{I}", "alt": ["unicode-math"] }, "\u{1D75F}": { "math": "\\mathsfbf{K}", "alt": ["unicode-math"] }, "\u{1D760}": { "math": "\\mathsfbf{\\Lambda}", "alt": ["unicode-math"] }, "\u{1D761}": { "math": "M", "alt": ["unicode-math"] }, "\u{1D762}": { "math": "N", "alt": ["unicode-math"] }, "\u{1D763}": { "math": "\\mathsfbf{\\Xi}", "alt": ["unicode-math"] }, "\u{1D764}": { "math": "O", "alt": ["unicode-math"] }, "\u{1D765}": { "math": "\\mathsfbf{\\Pi}", "alt": ["unicode-math"] }, "\u{1D766}": { "math": "\\mathsfbf{P}", "alt": ["unicode-math"] }, "\u{1D767}": { "math": "\\mathsfbf{\\Theta}", "alt": ["unicode-math"] }, "\u{1D768}": { "math": "\\mathsfbf{\\Sigma}", "alt": ["unicode-math"] }, "\u{1D769}": { "math": "\\mathsfbf{T}", "alt": ["unicode-math"] }, "\u{1D76A}": { "math": "\\mathsfbf{\\Upsilon}", "alt": ["unicode-math"] }, "\u{1D76B}": { "math": "\\mathsfbf{\\Phi}", "alt": ["unicode-math"] }, "\u{1D76C}": { "math": "\\mathsfbf{X}", "alt": ["unicode-math"] }, "\u{1D76D}": { "math": "\\mathsfbf{\\Psi}", "alt": ["unicode-math"] }, "\u{1D76E}": { "math": "\\mathsfbf{\\Omega}", "alt": ["unicode-math"] }, "\u{1D76F}": { "math": "\\mathsfbf{\\nabla}", "alt": ["unicode-math"] }, "\u{1D770}": { "math": "\\mathsfbf{\\alpha}", "alt": ["unicode-math"] }, "\u{1D771}": { "math": "\\mathsfbf{\\beta}", "alt": ["unicode-math"] }, "\u{1D772}": { "math": "\\mathsfbf{\\gamma}", "alt": ["unicode-math"] }, "\u{1D773}": { "math": "\\mathsfbf{\\delta}", "alt": ["unicode-math"] }, "\u{1D774}": { "math": "\\mathsfbf{\\varepsilon}", "alt": ["unicode-math"] }, "\u{1D775}": { "math": "\\mathsfbf{\\zeta}", "alt": ["unicode-math"] }, "\u{1D776}": { "math": "\\mathsfbf{\\eta}", "alt": ["unicode-math"] }, "\u{1D777}": { "math": "\\mathsfbf{\\theta}", "alt": ["unicode-math"] }, "\u{1D778}": { "math": "\\mathsfbf{\\imath}", "alt": ["unicode-math"] }, "\u{1D779}": { "math": "\\mathsfbf{\\kappa}", "alt": ["unicode-math"] }, "\u{1D77A}": { "math": "\\mathsfbf{\\lambda}", "alt": ["unicode-math"] }, "\u{1D77B}": { "math": "\\mu", "alt": ["unicode-math"] }, "\u{1D77C}": { "math": "\\nu", "alt": ["unicode-math"] }, "\u{1D77D}": { "math": "\\mathsfbf{\\xi}", "alt": ["unicode-math"] }, "\u{1D77E}": { "math": "o", "alt": ["unicode-math"] }, "\u{1D77F}": { "math": "\\mathsfbf{\\pi}", "alt": ["unicode-math"] }, "\u{1D780}": { "math": "\\mathsfbf{\\rho}", "alt": ["unicode-math"] }, "\u{1D781}": { "math": "\\mathsfbf{\\varsigma}", "alt": ["unicode-math"] }, "\u{1D782}": { "math": "\\mathsfbf{\\sigma}", "alt": ["unicode-math"] }, "\u{1D783}": { "math": "\\mathsfbf{\\tau}", "alt": ["unicode-math"] }, "\u{1D784}": { "math": "\\mathsfbf{\\upsilon}", "alt": ["unicode-math"] }, "\u{1D785}": { "math": "\\mathsfbf{\\varphi}", "alt": ["unicode-math"] }, "\u{1D786}": { "math": "\\mathsfbf{\\chi}", "alt": ["unicode-math"] }, "\u{1D787}": { "math": "\\mathsfbf{\\psi}", "alt": ["unicode-math"] }, "\u{1D788}": { "math": "\\mathsfbf{\\omega}", "alt": ["unicode-math"] }, "\u{1D789}": { "math": "\\partial", "alt": ["unicode-math"] }, "\u{1D78A}": { "math": "\\in", "alt": ["unicode-math"] }, "\u{1D78B}": { "math": "\\mathsfbf{\\vartheta}", "alt": ["unicode-math"] }, "\u{1D78C}": { "math": "\\mathsfbf{\\varkappa}", "alt": ["unicode-math"] }, "\u{1D78D}": { "math": "\\mathsfbf{\\phi}", "alt": ["unicode-math"] }, "\u{1D78E}": { "math": "\\mathsfbf{\\varrho}", "alt": ["unicode-math"] }, "\u{1D78F}": { "math": "\\mathsfbf{\\varpi}", "alt": ["unicode-math"] }, "\u{1D790}": { "math": "\\mathsfbfsl{A}", "alt": ["unicode-math"] }, "\u{1D791}": { "math": "\\mathsfbfsl{B}", "alt": ["unicode-math"] }, "\u{1D792}": { "math": "\\mathsfbfsl{\\Gamma}", "alt": ["unicode-math"] }, "\u{1D793}": { "math": "\\mathsfbfsl{\\Delta}", "alt": ["unicode-math"] }, "\u{1D794}": { "math": "\\mathsfbfsl{E}", "alt": ["unicode-math"] }, "\u{1D795}": { "math": "\\mathsfbfsl{Z}", "alt": ["unicode-math"] }, "\u{1D796}": { "math": "\\mathsfbfsl{H}", "alt": ["unicode-math"] }, "\u{1D797}": { "math": "\\mathsfbfsl{\\Theta}", "alt": ["unicode-math"] }, "\u{1D798}": { "math": "\\mathsfbfsl{I}", "alt": ["unicode-math"] }, "\u{1D799}": { "math": "\\mathsfbfsl{K}", "alt": ["unicode-math"] }, "\u{1D79A}": { "math": "\\mathsfbfsl{\\Lambda}", "alt": ["unicode-math"] }, "\u{1D79B}": { "math": "\\mathsfbfsl{M}", "alt": ["unicode-math"] }, "\u{1D79C}": { "math": "\\mathsfbfsl{N}", "alt": ["unicode-math"] }, "\u{1D79D}": { "math": "\\mathsfbfsl{\\Xi}", "alt": ["unicode-math"] }, "\u{1D79E}": { "math": "\\mathsfbfsl{O}", "alt": ["unicode-math"] }, "\u{1D79F}": { "math": "\\mathsfbfsl{\\Pi}", "alt": ["unicode-math"] }, "\u{1D7A0}": { "math": "\\mathsfbfsl{P}", "alt": ["unicode-math"] }, "\u{1D7A1}": { "math": "\\mathsfbfsl{\\Theta}", "alt": ["unicode-math"] }, "\u{1D7A2}": { "math": "\\mathsfbfsl{\\Sigma}", "alt": ["unicode-math"] }, "\u{1D7A3}": { "math": "\\mathsfbfsl{T}", "alt": ["unicode-math"] }, "\u{1D7A4}": { "math": "\\mathsfbfsl{\\Upsilon}", "alt": ["unicode-math"] }, "\u{1D7A5}": { "math": "\\mathsfbfsl{\\Phi}", "alt": ["unicode-math"] }, "\u{1D7A6}": { "math": "\\mathsfbfsl{X}", "alt": ["unicode-math"] }, "\u{1D7A7}": { "math": "\\mathsfbfsl{\\Psi}", "alt": ["unicode-math"] }, "\u{1D7A8}": { "math": "\\mathsfbfsl{\\Omega}", "alt": ["unicode-math"] }, "\u{1D7A9}": { "math": "\\mathsfbfsl{\\nabla}", "alt": ["unicode-math"] }, "\u{1D7AA}": { "math": "\\mathsfbfsl{\\alpha}", "alt": ["unicode-math"] }, "\u{1D7AB}": { "math": "\\mathsfbfsl{\\beta}", "alt": ["unicode-math"] }, "\u{1D7AC}": { "math": "\\mathsfbfsl{\\gamma}", "alt": ["unicode-math"] }, "\u{1D7AD}": { "math": "\\mathsfbfsl{\\delta}", "alt": ["unicode-math"] }, "\u{1D7AE}": { "math": "\\mathsfbfsl{\\varepsilon}", "alt": ["unicode-math"] }, "\u{1D7AF}": { "math": "\\mathsfbfsl{\\zeta}", "alt": ["unicode-math"] }, "\u{1D7B0}": { "math": "\\mathsfbfsl{\\eta}", "alt": ["unicode-math"] }, "\u{1D7B1}": { "math": "\\mathsfbfsl{\\theta}", "alt": ["unicode-math"] }, "\u{1D7B2}": { "math": "\\mathsfbfsl{\\imath}", "alt": ["unicode-math"] }, "\u{1D7B3}": { "math": "\\mathsfbfsl{\\kappa}", "alt": ["unicode-math"] }, "\u{1D7B4}": { "math": "\\mathsfbfsl{\\lambda}", "alt": ["unicode-math"] }, "\u{1D7B5}": { "math": "\\mu", "alt": ["unicode-math"] }, "\u{1D7B6}": { "math": "\\nu", "alt": ["unicode-math"] }, "\u{1D7B7}": { "math": "\\mathsfbfsl{\\xi}", "alt": ["unicode-math"] }, "\u{1D7B8}": { "math": "o", "alt": ["unicode-math"] }, "\u{1D7B9}": { "math": "\\mathsfbfsl{\\pi}", "alt": ["unicode-math"] }, "\u{1D7BA}": { "math": "\\mathsfbfsl{\\rho}", "alt": ["unicode-math"] }, "\u{1D7BB}": { "math": "\\mathsfbfsl{\\varsigma}", "alt": ["unicode-math"] }, "\u{1D7BC}": { "math": "\\mathsfbfsl{\\sigma}", "alt": ["unicode-math"] }, "\u{1D7BD}": { "math": "\\mathsfbfsl{\\tau}", "alt": ["unicode-math"] }, "\u{1D7BE}": { "math": "\\mathsfbfsl{\\upsilon}", "alt": ["unicode-math"] }, "\u{1D7BF}": { "math": "\\mathsfbfsl{\\varphi}", "alt": ["unicode-math"] }, "\u{1D7C0}": { "math": "\\mathsfbfsl{\\chi}", "alt": ["unicode-math"] }, "\u{1D7C1}": { "math": "\\mathsfbfsl{\\psi}", "alt": ["unicode-math"] }, "\u{1D7C2}": { "math": "\\mathsfbfsl{\\omega}", "alt": ["unicode-math"] }, "\u{1D7C3}": { "math": "\\partial", "alt": ["unicode-math"] }, "\u{1D7C4}": { "math": "\\in", "alt": ["unicode-math"] }, "\u{1D7C5}": { "math": "\\mathsfbfsl{\\vartheta}", "alt": ["unicode-math"] }, "\u{1D7C6}": { "math": "\\mathsfbfsl{\\varkappa}", "alt": ["unicode-math"] }, "\u{1D7C7}": { "math": "\\mathsfbfsl{\\phi}", "alt": ["unicode-math"] }, "\u{1D7C8}": { "math": "\\mathsfbfsl{\\varrho}", "alt": ["unicode-math"] }, "\u{1D7C9}": { "math": "\\mathsfbfsl{\\varpi}", "alt": ["unicode-math"] }, "\u{1D7CA}": { "math": "\\mbfDigamma", "alt": ["unicode-math"] }, "\u{1D7CB}": { "math": "\\mbfdigamma", "alt": ["unicode-math"] }, "\u{1D7CE}": { "math": "\\mathbf{0}", "alt": ["unicode-math"] }, "\u{1D7CF}": { "math": "\\mathbf{1}", "alt": ["unicode-math"] }, "\u{1D7D0}": { "math": "\\mathbf{2}", "alt": ["unicode-math"] }, "\u{1D7D1}": { "math": "\\mathbf{3}", "alt": ["unicode-math"] }, "\u{1D7D2}": { "math": "\\mathbf{4}", "alt": ["unicode-math"] }, "\u{1D7D3}": { "math": "\\mathbf{5}", "alt": ["unicode-math"] }, "\u{1D7D4}": { "math": "\\mathbf{6}", "alt": ["unicode-math"] }, "\u{1D7D5}": { "math": "\\mathbf{7}", "alt": ["unicode-math"] }, "\u{1D7D6}": { "math": "\\mathbf{8}", "alt": ["unicode-math"] }, "\u{1D7D7}": { "math": "\\mathbf{9}", "alt": ["unicode-math"] }, "\u{1D7D8}": { "math": "\\mathbb{0}", "alt": ["unicode-math"] }, "\u{1D7D9}": { "math": "\\mathbb{1}", "alt": ["unicode-math"] }, "\u{1D7DA}": { "math": "\\mathbb{2}", "alt": ["unicode-math"] }, "\u{1D7DB}": { "math": "\\mathbb{3}", "alt": ["unicode-math"] }, "\u{1D7DC}": { "math": "\\mathbb{4}", "alt": ["unicode-math"] }, "\u{1D7DD}": { "math": "\\mathbb{5}", "alt": ["unicode-math"] }, "\u{1D7DE}": { "math": "\\mathbb{6}", "alt": ["unicode-math"] }, "\u{1D7DF}": { "math": "\\mathbb{7}", "alt": ["unicode-math"] }, "\u{1D7E0}": { "math": "\\mathbb{8}", "alt": ["unicode-math"] }, "\u{1D7E1}": { "math": "\\mathbb{9}", "alt": ["unicode-math"] }, "\u{1D7E2}": { "math": "\\mathsf{0}", "alt": ["unicode-math"] }, "\u{1D7E3}": { "math": "\\mathsf{1}", "alt": ["unicode-math"] }, "\u{1D7E4}": { "math": "\\mathsf{2}", "alt": ["unicode-math"] }, "\u{1D7E5}": { "math": "\\mathsf{3}", "alt": ["unicode-math"] }, "\u{1D7E6}": { "math": "\\mathsf{4}", "alt": ["unicode-math"] }, "\u{1D7E7}": { "math": "\\mathsf{5}", "alt": ["unicode-math"] }, "\u{1D7E8}": { "math": "\\mathsf{6}", "alt": ["unicode-math"] }, "\u{1D7E9}": { "math": "\\mathsf{7}", "alt": ["unicode-math"] }, "\u{1D7EA}": { "math": "\\mathsf{8}", "alt": ["unicode-math"] }, "\u{1D7EB}": { "math": "\\mathsf{9}", "alt": ["unicode-math"] }, "\u{1D7EC}": { "math": "\\mathsfbf{0}", "alt": ["unicode-math"] }, "\u{1D7ED}": { "math": "\\mathsfbf{1}", "alt": ["unicode-math"] }, "\u{1D7EE}": { "math": "\\mathsfbf{2}", "alt": ["unicode-math"] }, "\u{1D7EF}": { "math": "\\mathsfbf{3}", "alt": ["unicode-math"] }, "\u{1D7F0}": { "math": "\\mathsfbf{4}", "alt": ["unicode-math"] }, "\u{1D7F1}": { "math": "\\mathsfbf{5}", "alt": ["unicode-math"] }, "\u{1D7F2}": { "math": "\\mathsfbf{6}", "alt": ["unicode-math"] }, "\u{1D7F3}": { "math": "\\mathsfbf{7}", "alt": ["unicode-math"] }, "\u{1D7F4}": { "math": "\\mathsfbf{8}", "alt": ["unicode-math"] }, "\u{1D7F5}": { "math": "\\mathsfbf{9}", "alt": ["unicode-math"] }, "\u{1D7F6}": { "math": "\\mathtt{0}", "alt": ["unicode-math"] }, "\u{1D7F7}": { "math": "\\mathtt{1}", "alt": ["unicode-math"] }, "\u{1D7F8}": { "math": "\\mathtt{2}", "alt": ["unicode-math"] }, "\u{1D7F9}": { "math": "\\mathtt{3}", "alt": ["unicode-math"] }, "\u{1D7FA}": { "math": "\\mathtt{4}", "alt": ["unicode-math"] }, "\u{1D7FB}": { "math": "\\mathtt{5}", "alt": ["unicode-math"] }, "\u{1D7FC}": { "math": "\\mathtt{6}", "alt": ["unicode-math"] }, "\u{1D7FD}": { "math": "\\mathtt{7}", "alt": ["unicode-math"] }, "\u{1D7FE}": { "math": "\\mathtt{8}", "alt": ["unicode-math"] }, "\u{1D7FF}": { "math": "\\mathtt{9}", "alt": ["unicode-math"] }, " \u035A": { "math": "_\\infty" }, "\u2029": { "text": "\\par", "macrospacer": true }, "/\u200B": { "text": "\\slash", "macrospacer": true }, "^": { "text": "\\textasciicircum", "macrospacer": true }, "i\uFE20a\uFE21": { "text": "\\t{ia}" }, "{": { "text": "\\{" }, "}": { "text": "\\}" }, "~": { "text": "\\textasciitilde", "macrospacer": true }, "\xA1": { "text": "\\textexclamdown", "macrospacer": true }, "\u20AC": { "text": "\\texteuro", "macrospacer": true, "alt": ["unicode-math"] }, "\xA8": { "text": "\\textasciidieresis", "macrospacer": true }, "\xAB": { "text": "<<" }, "\xAE": { "text": "\\textregistered", "macrospacer": true }, "\xAF": { "text": "\\textasciimacron", "macrospacer": true }, "\xB4": { "text": "\\textasciiacute", "macrospacer": true }, "\xB5": { "text": "\\textmu", "macrospacer": true }, "\xB8": { "text": "\\c", "macrospacer": true }, "\xBB": { "text": ">>" }, "\xBF": { "text": "\\textquestiondown", "macrospacer": true }, "\xC6": { "text": "\\AE", "macrospacer": true }, "\xD0": { "text": "\\DH", "macrospacer": true }, "\xD8": { "text": "\\O", "macrospacer": true }, "\xDE": { "text": "\\TH", "macrospacer": true }, "\xDF": { "text": "\\ss", "macrospacer": true }, "a\u030A": { "text": "\\aa", "macrospacer": true }, "\xE6": { "text": "\\ae", "macrospacer": true }, "\xF0": { "text": "\\dh", "macrospacer": true, "alt": ["amssymb", "arevmath", "textcomp"] }, "\xF8": { "text": "\\o", "macrospacer": true }, "\xFE": { "text": "\\th", "macrospacer": true }, "\u0110": { "text": "\\DJ", "macrospacer": true }, "\u0111": { "text": "\\dj", "macrospacer": true }, "i\u0306": { "text": "{\\u \\i}" }, "\u0132": { "text": "\\IJ", "macrospacer": true }, "\u0133": { "text": "\\ij", "macrospacer": true }, "j\u0302": { "text": "\\^\\j", "macrospacer": true }, "\u0138": { "text": "K", "alt": ["xecjk"] }, "\u0141": { "text": "\\L", "macrospacer": true }, "\u0142": { "text": "\\l", "macrospacer": true }, "\u0149": { "text": "'n" }, "\u014A": { "text": "\\NG", "macrospacer": true }, "\u014B": { "text": "\\ng", "macrospacer": true }, "\u0152": { "text": "\\OE", "macrospacer": true }, "\u0153": { "text": "\\oe", "macrospacer": true }, "\u017F": { "text": "s" }, "\u01AA": { "text": "\\textesh", "macrospacer": true }, "\u01C2": { "text": "\\textdoublepipe", "macrospacer": true }, "\u0261": { "text": "g" }, "\u02B9": { "text": "'" }, "\u02BB": { "text": "'" }, "\u02BC": { "text": "'" }, "\u02BD": { "text": "'" }, "\u02C6": { "text": "\\textasciicircum", "macrospacer": true }, "\u02C7": { "text": "\\textasciicaron", "macrospacer": true }, "\u02C9": { "text": "-" }, "\u02D8": { "text": "\\textasciibreve", "macrospacer": true }, "\u02DA": { "text": "\\r{}" }, "\u02DB": { "text": "\\k{}" }, "\u02DC": { "text": "\\texttildelow", "macrospacer": true }, "\u02DD": { "text": "\\textacutedbl", "macrospacer": true }, "\u0300": { "text": "\\`", "macrospacer": true, "alt": ["unicode-math"] }, "\u0301": { "text": "\\'", "macrospacer": true, "alt": ["unicode-math"] }, "\u0302": { "text": "\\^", "macrospacer": true }, "\u0303": { "text": "\\~", "macrospacer": true, "alt": ["unicode-math"] }, "\u0304": { "text": "\\=", "macrospacer": true }, "\u0306": { "text": "\\u", "macrospacer": true, "alt": ["unicode-math"] }, "\u0307": { "text": "\\.", "macrospacer": true, "alt": ["unicode-math"] }, "\u0308": { "text": '\\"', "macrospacer": true, "alt": ["unicode-math"] }, "\u030B": { "text": "\\H", "macrospacer": true }, "\u030C": { "text": "\\v", "macrospacer": true, "alt": ["unicode-math"] }, "\u030F": { "text": "\\textdoublegrave", "macrospacer": true }, "\u0316": { "text": "\\textsubgrave", "macrospacer": true }, "\u0323": { "text": "\\d", "macrospacer": true }, "\u0326": { "text": "\\textcommabelow", "macrospacer": true }, "\u0327": { "text": "\\c", "macrospacer": true }, "\u0328": { "text": "\\k", "macrospacer": true }, "\u0375": { "text": "," }, ";": { "text": ";" }, "\u0399\u0301": { "text": "{\\'{}I}" }, "\u039F\u0301": { "text": "{\\'{}O}" }, "\u03D0": { "text": "\\Pisymbol{ppi022}{87}", "alt": ["MinionPro", "unicode-math"] }, "\u046B": { "text": "\\cyrchar\\cyrbyus", "macrospacer": true }, "\u0473": { "text": "\\cyrchar\\cyrfita", "macrospacer": true }, "\u0475": { "text": "\\cyrchar\\cyrizh", "macrospacer": true }, "\u04C5": { "text": "\\cyrchar\\CYRLDSC", "macrospacer": true }, "\u04C6": { "text": "\\cyrchar\\cyrldsc", "macrospacer": true }, "\u04CD": { "text": "\\cyrchar\\CYRMDSC", "macrospacer": true }, "\u04CE": { "text": "\\cyrchar\\cyrmdsc", "macrospacer": true }, "\u0463": { "text": "\\cyrchar\\cyryat", "macrospacer": true }, "\u0415\u0308": { "text": "\\cyrchar\\CYRYO", "macrospacer": true }, "\u0402": { "text": "\\cyrchar\\CYRDJE", "macrospacer": true }, "\u0413\u0301": { "text": "\\cyrchar{\\'\\CYRG}" }, "\u0404": { "text": "\\cyrchar\\CYRIE", "macrospacer": true }, "\u0405": { "text": "\\cyrchar\\CYRDZE", "macrospacer": true }, "\u0406": { "text": "\\cyrchar\\CYRII", "macrospacer": true }, "\u0406\u0308": { "text": "\\cyrchar\\CYRYI", "macrospacer": true }, "\u0408": { "text": "\\cyrchar\\CYRJE", "macrospacer": true }, "\u0409": { "text": "\\cyrchar\\CYRLJE", "macrospacer": true }, "\u040A": { "text": "\\cyrchar\\CYRNJE", "macrospacer": true }, "\u040B": { "text": "\\cyrchar\\CYRTSHE", "macrospacer": true }, "\u041A\u0301": { "text": "\\cyrchar{\\'\\CYRK}" }, "\u0423\u0306": { "text": "\\cyrchar\\CYRUSHRT", "macrospacer": true }, "\u040F": { "text": "\\cyrchar\\CYRDZHE", "macrospacer": true }, "\u0410": { "text": "\\cyrchar\\CYRA", "macrospacer": true }, "\u0411": { "text": "\\cyrchar\\CYRB", "macrospacer": true }, "\u0412": { "text": "\\cyrchar\\CYRV", "macrospacer": true }, "\u0413": { "text": "\\cyrchar\\CYRG", "macrospacer": true }, "\u0414": { "text": "\\cyrchar\\CYRD", "macrospacer": true }, "\u0415": { "text": "\\cyrchar\\CYRE", "macrospacer": true }, "\u0416": { "text": "\\cyrchar\\CYRZH", "macrospacer": true }, "\u0417": { "text": "\\cyrchar\\CYRZ", "macrospacer": true }, "\u0418": { "text": "\\cyrchar\\CYRI", "macrospacer": true }, "\u0418\u0306": { "text": "\\cyrchar\\CYRISHRT", "macrospacer": true }, "\u041A": { "text": "\\cyrchar\\CYRK", "macrospacer": true }, "\u041B": { "text": "\\cyrchar\\CYRL", "macrospacer": true }, "\u041C": { "text": "\\cyrchar\\CYRM", "macrospacer": true }, "\u041D": { "text": "\\cyrchar\\CYRN", "macrospacer": true }, "\u041E": { "text": "\\cyrchar\\CYRO", "macrospacer": true }, "\u041F": { "text": "\\cyrchar\\CYRP", "macrospacer": true }, "\u0420": { "text": "\\cyrchar\\CYRR", "macrospacer": true }, "\u0421": { "text": "\\cyrchar\\CYRS", "macrospacer": true }, "\u0422": { "text": "\\cyrchar\\CYRT", "macrospacer": true }, "\u0423": { "text": "\\cyrchar\\CYRU", "macrospacer": true }, "\u0424": { "text": "\\cyrchar\\CYRF", "macrospacer": true }, "\u0425": { "text": "\\cyrchar\\CYRH", "macrospacer": true }, "\u0426": { "text": "\\cyrchar\\CYRC", "macrospacer": true }, "\u0427": { "text": "\\cyrchar\\CYRCH", "macrospacer": true }, "\u0428": { "text": "\\cyrchar\\CYRSH", "macrospacer": true }, "\u0429": { "text": "\\cyrchar\\CYRSHCH", "macrospacer": true }, "\u042A": { "text": "\\cyrchar\\CYRHRDSN", "macrospacer": true }, "\u042B": { "text": "\\cyrchar\\CYRERY", "macrospacer": true }, "\u042C": { "text": "\\cyrchar\\CYRSFTSN", "macrospacer": true }, "\u042D": { "text": "\\cyrchar\\CYREREV", "macrospacer": true }, "\u042E": { "text": "\\cyrchar\\CYRYU", "macrospacer": true }, "\u042F": { "text": "\\cyrchar\\CYRYA", "macrospacer": true }, "\u0430": { "text": "\\cyrchar\\cyra", "macrospacer": true }, "\u0431": { "text": "\\cyrchar\\cyrb", "macrospacer": true }, "\u0432": { "text": "\\cyrchar\\cyrv", "macrospacer": true }, "\u0433": { "text": "\\cyrchar\\cyrg", "macrospacer": true }, "\u0434": { "text": "\\cyrchar\\cyrd", "macrospacer": true }, "\u0435": { "text": "\\cyrchar\\cyre", "macrospacer": true }, "\u0436": { "text": "\\cyrchar\\cyrzh", "macrospacer": true }, "\u0437": { "text": "\\cyrchar\\cyrz", "macrospacer": true }, "\u0438": { "text": "\\cyrchar\\cyri", "macrospacer": true }, "\u0438\u0306": { "text": "\\cyrchar\\cyrishrt", "macrospacer": true }, "\u043A": { "text": "\\cyrchar\\cyrk", "macrospacer": true }, "\u043B": { "text": "\\cyrchar\\cyrl", "macrospacer": true }, "\u043C": { "text": "\\cyrchar\\cyrm", "macrospacer": true }, "\u043D": { "text": "\\cyrchar\\cyrn", "macrospacer": true }, "\u043E": { "text": "\\cyrchar\\cyro", "macrospacer": true }, "\u043F": { "text": "\\cyrchar\\cyrp", "macrospacer": true }, "\u0440": { "text": "\\cyrchar\\cyrr", "macrospacer": true }, "\u0441": { "text": "\\cyrchar\\cyrs", "macrospacer": true }, "\u0442": { "text": "\\cyrchar\\cyrt", "macrospacer": true }, "\u0443": { "text": "\\cyrchar\\cyru", "macrospacer": true }, "\u0444": { "text": "\\cyrchar\\cyrf", "macrospacer": true }, "\u0445": { "text": "\\cyrchar\\cyrh", "macrospacer": true }, "\u0446": { "text": "\\cyrchar\\cyrc", "macrospacer": true }, "\u0447": { "text": "\\cyrchar\\cyrch", "macrospacer": true }, "\u0448": { "text": "\\cyrchar\\cyrsh", "macrospacer": true }, "\u0449": { "text": "\\cyrchar\\cyrshch", "macrospacer": true }, "\u044A": { "text": "\\cyrchar\\cyrhrdsn", "macrospacer": true }, "\u044B": { "text": "\\cyrchar\\cyrery", "macrospacer": true }, "\u044C": { "text": "\\cyrchar\\cyrsftsn", "macrospacer": true }, "\u044D": { "text": "\\cyrchar\\cyrerev", "macrospacer": true }, "\u044E": { "text": "\\cyrchar\\cyryu", "macrospacer": true }, "\u044F": { "text": "\\cyrchar\\cyrya", "macrospacer": true }, "\u0435\u0308": { "text": "\\cyrchar\\cyryo", "macrospacer": true }, "\u0452": { "text": "\\cyrchar\\cyrdje", "macrospacer": true }, "\u0433\u0301": { "text": "\\cyrchar{\\'\\cyrg}" }, "\u0454": { "text": "\\cyrchar\\cyrie", "macrospacer": true }, "\u0455": { "text": "\\cyrchar\\cyrdze", "macrospacer": true }, "\u0456": { "text": "\\cyrchar\\cyrii", "macrospacer": true }, "\u0456\u0308": { "text": "\\cyrchar\\cyryi", "macrospacer": true }, "\u0458": { "text": "\\cyrchar\\cyrje", "macrospacer": true }, "\u0459": { "text": "\\cyrchar\\cyrlje", "macrospacer": true }, "\u045A": { "text": "\\cyrchar\\cyrnje", "macrospacer": true }, "\u045B": { "text": "\\cyrchar\\cyrtshe", "macrospacer": true }, "\u043A\u0301": { "text": "\\cyrchar{\\'\\cyrk}" }, "\u0443\u0306": { "text": "\\cyrchar\\cyrushrt", "macrospacer": true }, "\u045F": { "text": "\\cyrchar\\cyrdzhe", "macrospacer": true }, "\u0460": { "text": "\\cyrchar\\CYROMEGA", "macrospacer": true }, "\u0461": { "text": "\\cyrchar\\cyromega", "macrospacer": true }, "\u0462": { "text": "\\cyrchar\\CYRYAT", "macrospacer": true }, "\u0464": { "text": "\\cyrchar\\CYRIOTE", "macrospacer": true }, "\u0465": { "text": "\\cyrchar\\cyriote", "macrospacer": true }, "\u0466": { "text": "\\cyrchar\\CYRLYUS", "macrospacer": true }, "\u0467": { "text": "\\cyrchar\\cyrlyus", "macrospacer": true }, "\u0468": { "text": "\\cyrchar\\CYRIOTLYUS", "macrospacer": true }, "\u0469": { "text": "\\cyrchar\\cyriotlyus", "macrospacer": true }, "\u046A": { "text": "\\cyrchar\\CYRBYUS", "macrospacer": true }, "\u046C": { "text": "\\cyrchar\\CYRIOTBYUS", "macrospacer": true }, "\u046D": { "text": "\\cyrchar\\cyriotbyus", "macrospacer": true }, "\u046E": { "text": "\\cyrchar\\CYRKSI", "macrospacer": true }, "\u046F": { "text": "\\cyrchar\\cyrksi", "macrospacer": true }, "\u0470": { "text": "\\cyrchar\\CYRPSI", "macrospacer": true }, "\u0471": { "text": "\\cyrchar\\cyrpsi", "macrospacer": true }, "\u0472": { "text": "\\cyrchar\\CYRFITA", "macrospacer": true }, "\u0474": { "text": "\\cyrchar\\CYRIZH", "macrospacer": true }, "\u0478": { "text": "\\cyrchar\\CYRUK", "macrospacer": true }, "\u0479": { "text": "\\cyrchar\\cyruk", "macrospacer": true }, "\u047A": { "text": "\\cyrchar\\CYROMEGARND", "macrospacer": true }, "\u047B": { "text": "\\cyrchar\\cyromegarnd", "macrospacer": true }, "\u047C": { "text": "\\cyrchar\\CYROMEGATITLO", "macrospacer": true }, "\u047D": { "text": "\\cyrchar\\cyromegatitlo", "macrospacer": true }, "\u047E": { "text": "\\cyrchar\\CYROT", "macrospacer": true }, "\u047F": { "text": "\\cyrchar\\cyrot", "macrospacer": true }, "\u0480": { "text": "\\cyrchar\\CYRKOPPA", "macrospacer": true }, "\u0481": { "text": "\\cyrchar\\cyrkoppa", "macrospacer": true }, "\u0482": { "text": "\\cyrchar\\cyrthousands", "macrospacer": true }, "\u0488": { "text": "\\cyrchar\\cyrhundredthousands", "macrospacer": true }, "\u0489": { "text": "\\cyrchar\\cyrmillions", "macrospacer": true }, "\u048C": { "text": "\\cyrchar\\CYRSEMISFTSN", "macrospacer": true }, "\u048D": { "text": "\\cyrchar\\cyrsemisftsn", "macrospacer": true }, "\u048E": { "text": "\\cyrchar\\CYRRTICK", "macrospacer": true }, "\u048F": { "text": "\\cyrchar\\cyrrtick", "macrospacer": true }, "\u0490": { "text": "\\cyrchar\\CYRGUP", "macrospacer": true }, "\u0491": { "text": "\\cyrchar\\cyrgup", "macrospacer": true }, "\u0492": { "text": "\\cyrchar\\CYRGHCRS", "macrospacer": true }, "\u0493": { "text": "\\cyrchar\\cyrghcrs", "macrospacer": true }, "\u0494": { "text": "\\cyrchar\\CYRGHK", "macrospacer": true }, "\u0495": { "text": "\\cyrchar\\cyrghk", "macrospacer": true }, "\u0496": { "text": "\\cyrchar\\CYRZHDSC", "macrospacer": true }, "\u0497": { "text": "\\cyrchar\\cyrzhdsc", "macrospacer": true }, "\u0498": { "text": "\\cyrchar\\CYRZDSC", "macrospacer": true }, "\u0499": { "text": "\\cyrchar\\cyrzdsc", "macrospacer": true }, "\u049A": { "text": "\\cyrchar\\CYRKDSC", "macrospacer": true }, "\u049B": { "text": "\\cyrchar\\cyrkdsc", "macrospacer": true }, "\u049C": { "text": "\\cyrchar\\CYRKVCRS", "macrospacer": true }, "\u049D": { "text": "\\cyrchar\\cyrkvcrs", "macrospacer": true }, "\u049E": { "text": "\\cyrchar\\CYRKHCRS", "macrospacer": true }, "\u049F": { "text": "\\cyrchar\\cyrkhcrs", "macrospacer": true }, "\u04A0": { "text": "\\cyrchar\\CYRKBEAK", "macrospacer": true }, "\u04A1": { "text": "\\cyrchar\\cyrkbeak", "macrospacer": true }, "\u04A2": { "text": "\\cyrchar\\CYRNDSC", "macrospacer": true }, "\u04A3": { "text": "\\cyrchar\\cyrndsc", "macrospacer": true }, "\u04A4": { "text": "\\cyrchar\\CYRNG", "macrospacer": true }, "\u04A5": { "text": "\\cyrchar\\cyrng", "macrospacer": true }, "\u04A6": { "text": "\\cyrchar\\CYRPHK", "macrospacer": true }, "\u04A7": { "text": "\\cyrchar\\cyrphk", "macrospacer": true }, "\u04A8": { "text": "\\cyrchar\\CYRABHHA", "macrospacer": true }, "\u04A9": { "text": "\\cyrchar\\cyrabhha", "macrospacer": true }, "\u04AA": { "text": "\\cyrchar\\CYRSDSC", "macrospacer": true }, "\u04AB": { "text": "\\cyrchar\\cyrsdsc", "macrospacer": true }, "\u04AC": { "text": "\\cyrchar\\CYRTDSC", "macrospacer": true }, "\u04AD": { "text": "\\cyrchar\\cyrtdsc", "macrospacer": true }, "\u04AE": { "text": "\\cyrchar\\CYRY", "macrospacer": true }, "\u04AF": { "text": "\\cyrchar\\cyry", "macrospacer": true }, "\u04B0": { "text": "\\cyrchar\\CYRYHCRS", "macrospacer": true }, "\u04B1": { "text": "\\cyrchar\\cyryhcrs", "macrospacer": true }, "\u04B2": { "text": "\\cyrchar\\CYRHDSC", "macrospacer": true }, "\u04B3": { "text": "\\cyrchar\\cyrhdsc", "macrospacer": true }, "\u04B4": { "text": "\\cyrchar\\CYRTETSE", "macrospacer": true }, "\u04B5": { "text": "\\cyrchar\\cyrtetse", "macrospacer": true }, "\u04B6": { "text": "\\cyrchar\\CYRCHRDSC", "macrospacer": true }, "\u04B7": { "text": "\\cyrchar\\cyrchrdsc", "macrospacer": true }, "\u04B8": { "text": "\\cyrchar\\CYRCHVCRS", "macrospacer": true }, "\u04B9": { "text": "\\cyrchar\\cyrchvcrs", "macrospacer": true }, "\u04BA": { "text": "\\cyrchar\\CYRSHHA", "macrospacer": true }, "\u04BB": { "text": "\\cyrchar\\cyrshha", "macrospacer": true }, "\u04BC": { "text": "\\cyrchar\\CYRABHCH", "macrospacer": true }, "\u04BD": { "text": "\\cyrchar\\cyrabhch", "macrospacer": true }, "\u04BE": { "text": "\\cyrchar\\CYRABHCHDSC", "macrospacer": true }, "\u04BF": { "text": "\\cyrchar\\cyrabhchdsc", "macrospacer": true }, "\u04C0": { "text": "\\cyrchar\\CYRpalochka", "macrospacer": true }, "\u04C3": { "text": "\\cyrchar\\CYRKHK", "macrospacer": true }, "\u04C4": { "text": "\\cyrchar\\cyrkhk", "macrospacer": true }, "\u04C7": { "text": "\\cyrchar\\CYRNHK", "macrospacer": true }, "\u04C8": { "text": "\\cyrchar\\cyrnhk", "macrospacer": true }, "\u04CB": { "text": "\\cyrchar\\CYRCHLDSC", "macrospacer": true }, "\u04CC": { "text": "\\cyrchar\\cyrchldsc", "macrospacer": true }, "\u04D4": { "text": "\\cyrchar\\CYRAE", "macrospacer": true }, "\u04D5": { "text": "\\cyrchar\\cyrae", "macrospacer": true }, "\u04D8": { "text": "\\cyrchar\\CYRSCHWA", "macrospacer": true }, "\u04D9": { "text": "\\cyrchar\\cyrschwa", "macrospacer": true }, "\u04E0": { "text": "\\cyrchar\\CYRABHDZE", "macrospacer": true }, "\u04E1": { "text": "\\cyrchar\\cyrabhdze", "macrospacer": true }, "\u04E8": { "text": "\\cyrchar\\CYROTLD", "macrospacer": true }, "\u04E9": { "text": "\\cyrchar\\cyrotld", "macrospacer": true }, "E\u0327\u0306": { "text": "\\c{\\u{E}}" }, "e\u0327\u0306": { "text": "\\c{\\u{e}}" }, "\u2002": { "text": "\\enspace", "macrospacer": true }, "\u2003\u2003": { "text": "\\qquad", "macrospacer": true }, "\u2004": { "text": "\\;" }, "\u2005": { "text": "\\>" }, "\u2006": { "text": "\\hspace{0.166em}" }, "\u2007": { "text": "\\hphantom{0}" }, "\u2008": { "text": "\\hphantom{,}" }, "\u2009": { "text": "\\," }, "\u200B": { "text": "\\hspace{0pt}" }, "\u200C": { "text": "\\null", "macrospacer": true }, "\u2010": { "text": "-", "alt": ["unicode-math"] }, "\u2011": { "text": "-" }, "\u2012": { "text": "-" }, "\u2013": { "text": "--" }, "\u2014": { "text": "---" }, "\u2015": { "text": "\\texthorizontalbar", "macrospacer": true, "alt": ["unicode-math"] }, "\u2016": { "text": "\\textbardbl", "macrospacer": true }, "\u2018": { "text": "`" }, "\u2019": { "text": "'" }, "\u201A": { "text": "\\quotesinglbase", "macrospacer": true }, "\u201C": { "text": "``" }, "\u201D": { "text": "''" }, "\u201E": { "text": ",," }, "\u201F": { "text": "\\quotedblbase", "macrospacer": true }, "\u2023": { "text": ">" }, "\u2024": { "text": "." }, "\u2025": { "text": "..", "alt": ["unicode-math"] }, "\u2027": { "text": "-" }, "\u202F": { "text": "\\," }, "\u2039": { "text": "\\guilsinglleft", "macrospacer": true }, "\u203A": { "text": "\\guilsinglright", "macrospacer": true }, "\u203E": { "text": "-" }, "\u2044": { "text": "\\textfractionsolidus", "macrospacer": true, "alt": ["unicode-math"] }, "\u2048": { "text": "?!" }, "\u2049": { "text": "!?" }, "\u204A": { "text": "7" }, "\u2060": { "text": "\\nolinebreak", "macrospacer": true }, "\u2100": { "text": "a/c" }, "\u2101": { "text": "a/s" }, "\u2103": { "text": "\\textcelsius", "macrospacer": true }, "\u2105": { "text": "c/o" }, "\u2106": { "text": "c/u" }, "\u2109": { "text": "F" }, "\u2116": { "text": "\\textnumero", "macrospacer": true }, "\u2117": { "text": "\\textcircledP", "macrospacer": true }, "\u2120": { "text": "\\textservicemark", "macrospacer": true }, "\u2121": { "text": "TEL" }, "\u2127": { "text": "\\textmho", "macrospacer": true, "alt": ["unicode-math"] }, "\u2129": { "text": "\\textriota", "macrospacer": true, "alt": ["unicode-math"] }, "\u212E": { "text": "\\textestimated", "macrospacer": true }, "\u2160": { "text": "I" }, "\u2161": { "text": "II" }, "\u2162": { "text": "III" }, "\u2163": { "text": "IV" }, "\u2164": { "text": "V" }, "\u2165": { "text": "VI" }, "\u2166": { "text": "VII" }, "\u2167": { "text": "VIII" }, "\u2168": { "text": "IX" }, "\u2169": { "text": "X" }, "\u216A": { "text": "XI" }, "\u216B": { "text": "XII" }, "\u216C": { "text": "L" }, "\u216D": { "text": "C" }, "\u216E": { "text": "D" }, "\u216F": { "text": "M" }, "\u2170": { "text": "i" }, "\u2171": { "text": "ii" }, "\u2172": { "text": "iii" }, "\u2173": { "text": "iv" }, "\u2174": { "text": "v" }, "\u2175": { "text": "vi" }, "\u2176": { "text": "vii" }, "\u2177": { "text": "viii" }, "\u2178": { "text": "ix" }, "\u2179": { "text": "x" }, "\u217A": { "text": "xi" }, "\u217B": { "text": "xii" }, "\u217C": { "text": "l" }, "\u217D": { "text": "c" }, "\u217E": { "text": "d" }, "\u217F": { "text": "m" }, "\u2215": { "text": "/", "alt": ["unicode-math"] }, "\u221A": { "text": "\\textsurd", "macrospacer": true, "alt": ["unicode-math"] }, "\u2422": { "text": "\\textblank", "macrospacer": true, "alt": ["unicode-math"] }, "\u2460": { "text": "\\ding{172}" }, "\u2461": { "text": "\\ding{173}" }, "\u2462": { "text": "\\ding{174}" }, "\u2463": { "text": "\\ding{175}" }, "\u2464": { "text": "\\ding{176}" }, "\u2465": { "text": "\\ding{177}" }, "\u2466": { "text": "\\ding{178}" }, "\u2467": { "text": "\\ding{179}" }, "\u2468": { "text": "\\ding{180}" }, "\u2469": { "text": "\\ding{181}" }, "\u246A": { "text": "(11)" }, "\u246B": { "text": "(12)" }, "\u246C": { "text": "(13)" }, "\u246D": { "text": "(14)" }, "\u246E": { "text": "(15)" }, "\u246F": { "text": "(16)" }, "\u2470": { "text": "(17)" }, "\u2471": { "text": "(18)" }, "\u2472": { "text": "(19)" }, "\u2473": { "text": "(20)" }, "\u2474": { "text": "(1)" }, "\u2475": { "text": "(2)" }, "\u2476": { "text": "(3)" }, "\u2477": { "text": "(4)" }, "\u2478": { "text": "(5)" }, "\u2479": { "text": "(6)" }, "\u247A": { "text": "(7)" }, "\u247B": { "text": "(8)" }, "\u247C": { "text": "(9)" }, "\u247D": { "text": "(10)" }, "\u247E": { "text": "(11)" }, "\u247F": { "text": "(12)" }, "\u2480": { "text": "(13)" }, "\u2481": { "text": "(14)" }, "\u2482": { "text": "(15)" }, "\u2483": { "text": "(16)" }, "\u2484": { "text": "(17)" }, "\u2485": { "text": "(18)" }, "\u2486": { "text": "(19)" }, "\u2487": { "text": "(20)" }, "\u2488": { "text": "1." }, "\u2489": { "text": "2." }, "\u248A": { "text": "3." }, "\u248B": { "text": "4." }, "\u248C": { "text": "5." }, "\u248D": { "text": "6." }, "\u248E": { "text": "7." }, "\u248F": { "text": "8." }, "\u2490": { "text": "9." }, "\u2491": { "text": "10." }, "\u2492": { "text": "11." }, "\u2493": { "text": "12." }, "\u2494": { "text": "13." }, "\u2495": { "text": "14." }, "\u2496": { "text": "15." }, "\u2497": { "text": "16." }, "\u2498": { "text": "17." }, "\u2499": { "text": "18." }, "\u249A": { "text": "19." }, "\u249B": { "text": "20." }, "\u249C": { "text": "(a)" }, "\u249D": { "text": "(b)" }, "\u249E": { "text": "(c)" }, "\u249F": { "text": "(d)" }, "\u24A0": { "text": "(e)" }, "\u24A1": { "text": "(f)" }, "\u24A2": { "text": "(g)" }, "\u24A3": { "text": "(h)" }, "\u24A4": { "text": "(i)" }, "\u24A5": { "text": "(j)" }, "\u24A6": { "text": "(k)" }, "\u24A7": { "text": "(l)" }, "\u24A8": { "text": "(m)" }, "\u24A9": { "text": "(n)" }, "\u24AA": { "text": "(o)" }, "\u24AB": { "text": "(p)" }, "\u24AC": { "text": "(q)" }, "\u24AD": { "text": "(r)" }, "\u24AE": { "text": "(s)" }, "\u24AF": { "text": "(t)" }, "\u24B0": { "text": "(u)" }, "\u24B1": { "text": "(v)" }, "\u24B2": { "text": "(w)" }, "\u24B3": { "text": "(x)" }, "\u24B4": { "text": "(y)" }, "\u24B5": { "text": "(z)" }, "\u2500": { "text": "-", "alt": ["pmboxdraw"] }, "\u2504": { "text": "-" }, "\u2508": { "text": "-" }, "\u254C": { "text": "-" }, "\u2572": { "text": "\\" }, "\u2573": { "text": "X" }, "\u257C": { "text": "-", "alt": ["pmboxdraw"] }, "\u257E": { "text": "-", "alt": ["pmboxdraw"] }, "\u25A0": { "text": "\\ding{110}", "alt": ["unicode-math"] }, "\u25B2": { "text": "\\ding{115}", "alt": ["unicode-math"] }, "\u25BC": { "text": "\\ding{116}", "alt": ["unicode-math"] }, "\u25D7": { "text": "\\ding{119}", "alt": ["unicode-math"] }, "\u25E6": { "text": "\\textopenbullet", "macrospacer": true, "alt": ["unicode-math"] }, "\u2605": { "text": "\\ding{72}", "alt": ["unicode-math"] }, "\u2606": { "text": "\\ding{73}", "alt": ["unicode-math"] }, "\u260E": { "text": "\\ding{37}" }, "\u2613": { "text": "X" }, "\u261B": { "text": "\\ding{42}" }, "\u2640": { "text": "\\venus", "macrospacer": true, "alt": ["unicode-math"] }, "\u2665": { "text": "\\ding{170}", "alt": ["unicode-math"] }, "\u2666": { "text": "\\ding{169}", "alt": ["unicode-math"] }, "\u266A": { "text": "\\textmusicalnote", "macrospacer": true, "alt": ["unicode-math"] }, "\u2701": { "text": "\\ding{33}" }, "\u2702": { "text": "\\ding{34}" }, "\u2703": { "text": "\\ding{35}" }, "\u2704": { "text": "\\ding{36}" }, "\u2706": { "text": "\\ding{38}" }, "\u2707": { "text": "\\ding{39}" }, "\u2708": { "text": "\\ding{40}" }, "\u2709": { "text": "\\ding{41}" }, "\u270C": { "text": "\\ding{44}" }, "\u270D": { "text": "\\ding{45}" }, "\u270F": { "text": "\\ding{47}" }, "\u2710": { "text": "\\ding{48}" }, "\u2711": { "text": "\\ding{49}" }, "\u2712": { "text": "\\ding{50}" }, "\u2713": { "text": "\\ding{51}", "alt": ["unicode-math"] }, "\u2714": { "text": "\\ding{52}" }, "\u2715": { "text": "\\ding{53}" }, "\u2716": { "text": "\\ding{54}" }, "\u2718": { "text": "\\ding{56}" }, "\u2719": { "text": "\\ding{57}" }, "\u271A": { "text": "\\ding{58}" }, "\u271B": { "text": "\\ding{59}" }, "\u271C": { "text": "\\ding{60}" }, "\u271D": { "text": "\\ding{61}" }, "\u271E": { "text": "\\ding{62}" }, "\u271F": { "text": "\\ding{63}" }, "\u2720": { "text": "\\ding{64}", "alt": ["unicode-math"] }, "\u2721": { "text": "\\ding{65}" }, "\u2722": { "text": "\\ding{66}" }, "\u2723": { "text": "\\ding{67}" }, "\u2724": { "text": "\\ding{68}" }, "\u2725": { "text": "\\ding{69}" }, "\u2726": { "text": "\\ding{70}" }, "\u2727": { "text": "\\ding{71}" }, "\u2729": { "text": "\\ding{73}" }, "\u272A": { "text": "\\ding{74}", "alt": ["unicode-math"] }, "\u272B": { "text": "\\ding{75}" }, "\u272C": { "text": "\\ding{76}" }, "\u272D": { "text": "\\ding{77}" }, "\u272E": { "text": "\\ding{78}" }, "\u272F": { "text": "\\ding{79}" }, "\u2730": { "text": "\\ding{80}" }, "\u2731": { "text": "\\ding{81}" }, "\u2732": { "text": "\\ding{82}" }, "\u2733": { "text": "\\ding{83}" }, "\u2734": { "text": "\\ding{84}" }, "\u2735": { "text": "\\ding{85}" }, "\u2736": { "text": "\\ding{86}", "alt": ["unicode-math"] }, "\u2737": { "text": "\\ding{87}" }, "\u2738": { "text": "\\ding{88}" }, "\u2739": { "text": "\\ding{89}" }, "\u273A": { "text": "\\ding{90}" }, "\u273B": { "text": "\\ding{91}" }, "\u273C": { "text": "\\ding{92}" }, "\u273D": { "text": "\\ding{93}", "alt": ["unicode-math"] }, "\u273E": { "text": "\\ding{94}" }, "\u273F": { "text": "\\ding{95}" }, "\u2740": { "text": "\\ding{96}" }, "\u2741": { "text": "\\ding{97}" }, "\u2742": { "text": "\\ding{98}" }, "\u2743": { "text": "\\ding{99}" }, "\u2744": { "text": "\\ding{100}" }, "\u2745": { "text": "\\ding{101}" }, "\u2746": { "text": "\\ding{102}" }, "\u2747": { "text": "\\ding{103}" }, "\u2748": { "text": "\\ding{104}" }, "\u2749": { "text": "\\ding{105}" }, "\u274A": { "text": "\\ding{106}" }, "\u274B": { "text": "\\ding{107}" }, "\u274D": { "text": "\\ding{109}" }, "\u274F": { "text": "\\ding{111}" }, "\u2750": { "text": "\\ding{112}" }, "\u2751": { "text": "\\ding{113}" }, "\u2752": { "text": "\\ding{114}" }, "\u2756": { "text": "\\ding{118}" }, "\u2758": { "text": "\\ding{120}" }, "\u2759": { "text": "\\ding{121}" }, "\u275A": { "text": "\\ding{122}" }, "\u275B": { "text": "\\ding{123}" }, "\u275C": { "text": "\\ding{124}" }, "\u275D": { "text": "\\ding{125}" }, "\u275E": { "text": "\\ding{126}" }, "\u2761": { "text": "\\ding{161}" }, "\u2762": { "text": "\\ding{162}" }, "\u2763": { "text": "\\ding{163}" }, "\u2764": { "text": "\\ding{164}" }, "\u2765": { "text": "\\ding{165}" }, "\u2766": { "text": "\\ding{166}" }, "\u2767": { "text": "\\ding{167}" }, "\u2776": { "text": "\\ding{182}" }, "\u2777": { "text": "\\ding{183}" }, "\u2778": { "text": "\\ding{184}" }, "\u2779": { "text": "\\ding{185}" }, "\u277A": { "text": "\\ding{186}" }, "\u277B": { "text": "\\ding{187}" }, "\u277C": { "text": "\\ding{188}" }, "\u277D": { "text": "\\ding{189}" }, "\u277E": { "text": "\\ding{190}" }, "\u277F": { "text": "\\ding{191}" }, "\u2780": { "text": "\\ding{192}" }, "\u2781": { "text": "\\ding{193}" }, "\u2782": { "text": "\\ding{194}" }, "\u2783": { "text": "\\ding{195}" }, "\u2784": { "text": "\\ding{196}" }, "\u2785": { "text": "\\ding{197}" }, "\u2786": { "text": "\\ding{198}" }, "\u2787": { "text": "\\ding{199}" }, "\u2788": { "text": "\\ding{200}" }, "\u2789": { "text": "\\ding{201}" }, "\u278A": { "text": "\\ding{202}" }, "\u278B": { "text": "\\ding{203}" }, "\u278C": { "text": "\\ding{204}" }, "\u278D": { "text": "\\ding{205}" }, "\u278E": { "text": "\\ding{206}" }, "\u278F": { "text": "\\ding{207}" }, "\u2790": { "text": "\\ding{208}" }, "\u2791": { "text": "\\ding{209}" }, "\u2792": { "text": "\\ding{210}" }, "\u2793": { "text": "\\ding{211}" }, "\u2794": { "text": "\\ding{212}" }, "\u2798": { "text": "\\ding{216}" }, "\u2799": { "text": "\\ding{217}" }, "\u279A": { "text": "\\ding{218}" }, "\u279B": { "text": "\\ding{219}", "alt": ["unicode-math"] }, "\u279C": { "text": "\\ding{220}" }, "\u279D": { "text": "\\ding{221}" }, "\u279E": { "text": "\\ding{222}" }, "\u279F": { "text": "\\ding{223}" }, "\u27A0": { "text": "\\ding{224}" }, "\u27A1": { "text": "\\ding{225}" }, "\u27A3": { "text": "\\ding{227}" }, "\u27A4": { "text": "\\ding{228}" }, "\u27A5": { "text": "\\ding{229}" }, "\u27A6": { "text": "\\ding{230}" }, "\u27A7": { "text": "\\ding{231}" }, "\u27A8": { "text": "\\ding{232}" }, "\u27A9": { "text": "\\ding{233}" }, "\u27AA": { "text": "\\ding{234}" }, "\u27AB": { "text": "\\ding{235}" }, "\u27AC": { "text": "\\ding{236}" }, "\u27AD": { "text": "\\ding{237}" }, "\u27AE": { "text": "\\ding{238}" }, "\u27AF": { "text": "\\ding{239}" }, "\u27B1": { "text": "\\ding{241}" }, "\u27B2": { "text": "\\ding{242}" }, "\u27B3": { "text": "\\ding{243}" }, "\u27B4": { "text": "\\ding{244}" }, "\u27B5": { "text": "\\ding{245}" }, "\u27B6": { "text": "\\ding{246}" }, "\u27B7": { "text": "\\ding{247}" }, "\u27B8": { "text": "\\ding{248}" }, "\u27B9": { "text": "\\ding{249}" }, "\u27BA": { "text": "\\ding{250}" }, "\u27BB": { "text": "\\ding{251}" }, "\u27BC": { "text": "\\ding{252}" }, "\u27BD": { "text": "\\ding{253}" }, "\u27BE": { "text": "\\ding{254}" }, "\uFB00": { "text": "ff" }, "\uFB01": { "text": "fi" }, "\uFB02": { "text": "fl" }, "\uFB03": { "text": "ffi" }, "\uFB04": { "text": "ffl" }, "\uFB05": { "text": "st" }, "\uFB06": { "text": "st" }, "\uFFFD": { "text": "\\dbend", "macrospacer": true }, "\u2052": { "text": "\\textdiscount", "macrospacer": true }, "\u203D": { "text": "\\textinterrobang", "macrospacer": true }, "\u203B": { "text": "\\textreferencemark", "macrospacer": true }, "\u0166": { "text": "\\textTstroke", "macrospacer": true }, "\u0167": { "text": "\\texttstroke", "macrospacer": true }, "\u02CB": { "text": "\\textasciigrave", "macrospacer": true }, "\u0391": { "math": "A", "alt": ["unicode-math"] }, "\u0392": { "math": "B", "alt": ["unicode-math"] }, "\u0395": { "math": "E", "alt": ["unicode-math"] }, "\u0396": { "math": "Z", "alt": ["unicode-math"] }, "\u0397": { "math": "H", "alt": ["unicode-math"] }, "\u0399": { "math": "I", "alt": ["unicode-math"] }, "\u039A": { "math": "K", "alt": ["unicode-math"] }, "\u039C": { "math": "M", "alt": ["unicode-math"] }, "\u039D": { "math": "N", "alt": ["unicode-math"] }, "\u039F": { "math": "O", "alt": ["unicode-math"] }, "\u03A1": { "math": "P", "alt": ["unicode-math"] }, "\u03A4": { "math": "T", "alt": ["unicode-math"] }, "\u03A7": { "math": "X", "alt": ["unicode-math"] }, "\u03BF": { "math": "o", "alt": ["unicode-math"] }, "\u210A": { "math": "g", "alt": ["mathrsfs"] }, "\u2110": { "math": "I", "alt": ["mathrsfs"] }, "\u2112": { "math": "L", "alt": ["mathrsfs", "unicode-math"] }, "\u211B": { "math": "R", "alt": ["mathrsfs", "unicode-math"] }, "\u212C": { "math": "B", "alt": ["mathrsfs"] }, "\u212F": { "math": "e", "alt": ["mathrsfs"] }, "\u2130": { "math": "E", "alt": ["mathrsfs"] }, "\u2131": { "math": "F", "alt": ["mathrsfs"] }, "\u2133": { "math": "M", "alt": ["mathrsfs"] }, "\u2134": { "math": "o", "alt": ["mathrsfs"] }, "\u{1D49C}": { "math": "A", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D49E}": { "math": "C", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D49F}": { "math": "D", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4A2}": { "math": "G", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4A5}": { "math": "J", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4A6}": { "math": "K", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4A9}": { "math": "N", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4AA}": { "math": "O", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4AB}": { "math": "P", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4AC}": { "math": "Q", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4AE}": { "math": "S", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4AF}": { "math": "T", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B0}": { "math": "U", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B1}": { "math": "V", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B2}": { "math": "W", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B3}": { "math": "X", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B4}": { "math": "Y", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B5}": { "math": "Z", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B6}": { "math": "a", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B7}": { "math": "b", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B8}": { "math": "c", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B9}": { "math": "d", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4BB}": { "math": "f", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4BD}": { "math": "h", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4BE}": { "math": "i", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4BF}": { "math": "j", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C0}": { "math": "k", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C1}": { "math": "l", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C2}": { "math": "m", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C3}": { "math": "n", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C5}": { "math": "p", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C6}": { "math": "q", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C7}": { "math": "r", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C8}": { "math": "s", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C9}": { "math": "t", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4CA}": { "math": "u", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4CB}": { "math": "v", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4CC}": { "math": "w", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4CD}": { "math": "x", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4CE}": { "math": "y", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4CF}": { "math": "z", "alt": ["mathrsfs", "unicode-math"] }, "\u24B6": { "text": "(A)" }, "\u24B7": { "text": "(B)" }, "\u24B8": { "text": "(C)" }, "\u24B9": { "text": "(D)" }, "\u24BA": { "text": "(E)" }, "\u24BB": { "text": "(F)" }, "\u24BC": { "text": "(G)" }, "\u24BD": { "text": "(H)" }, "\u24BE": { "text": "(I)" }, "\u24BF": { "text": "(J)" }, "\u24C0": { "text": "(K)" }, "\u24C1": { "text": "(L)" }, "\u24C2": { "text": "(M)" }, "\u24C3": { "text": "(N)" }, "\u24C4": { "text": "(O)" }, "\u24C5": { "text": "(P)" }, "\u24C6": { "text": "(Q)" }, "\u24C7": { "text": "(R)" }, "\u24C9": { "text": "(T)" }, "\u24CA": { "text": "(U)" }, "\u24CB": { "text": "(V)" }, "\u24CC": { "text": "(W)" }, "\u24CD": { "text": "(X)" }, "\u24CE": { "text": "(Y)" }, "\u24CF": { "text": "(Z)" }, "\u24D0": { "text": "(a)" }, "\u24D1": { "text": "(b)" }, "\u24D2": { "text": "(c)" }, "\u24D3": { "text": "(d)" }, "\u24D4": { "text": "(e)" }, "\u24D5": { "text": "(f)" }, "\u24D6": { "text": "(g)" }, "\u24D7": { "text": "(h)" }, "\u24D8": { "text": "(i)" }, "\u24D9": { "text": "(j)" }, "\u24DA": { "text": "(k)" }, "\u24DB": { "text": "(l)" }, "\u24DC": { "text": "(m)" }, "\u24DD": { "text": "(n)" }, "\u24DE": { "text": "(o)" }, "\u24DF": { "text": "(p)" }, "\u24E0": { "text": "(q)" }, "\u24E1": { "text": "(r)" }, "\u24E2": { "text": "(s)" }, "\u24E3": { "text": "(t)" }, "\u24E4": { "text": "(u)" }, "\u24E5": { "text": "(v)" }, "\u24E6": { "text": "(w)" }, "\u24E7": { "text": "(x)" }, "\u24E8": { "text": "(y)" }, "\u24E9": { "text": "(z)" }, "\u24EA": { "text": "(0)" }, "\u2501": { "text": "=", "alt": ["pmboxdraw"] }, "\u2502": { "text": "|", "alt": ["pmboxdraw"] }, "\u2503": { "text": "|", "alt": ["pmboxdraw"] }, "\u2505": { "text": "=" }, "\u2507": { "text": "|" }, "\u2509": { "text": "=" }, "\u250A": { "text": "|" }, "\u250B": { "text": "|" }, "\u254D": { "text": "=" }, "\u254E": { "text": "|" }, "\u254F": { "text": "|" }, "\u2550": { "text": "=", "alt": ["pmboxdraw"] }, "\u2551": { "text": "|", "alt": ["pmboxdraw"] }, "\u257D": { "text": "|", "alt": ["pmboxdraw"] }, "\u257F": { "text": "|", "alt": ["pmboxdraw"] } }, "package": { "wasysym": { "\u2653": { "text": "\\pisces", "math": "\\pisces", "macrospacer": true }, "\u263D": { "text": "\\rightmoon", "macrospacer": true }, "\u263E": { "text": "\\leftmoon", "macrospacer": true } }, "unicode-math": { "\u20AC": { "math": "\\euro" }, "\u0300": { "math": "\\grave" }, "\u0301": { "math": "\\acute" }, "\u0303": { "math": "\\tilde" }, "\u0306": { "math": "\\breve" }, "\u0307": { "math": "\\dot" }, "\u0308": { "math": "\\ddot" }, "\u0309": { "math": "\\ovhook" }, "\u030C": { "math": "\\check" }, "\u0310": { "math": "\\candra" }, "\u0312": { "math": "\\oturnedcomma" }, "\u0315": { "math": "\\ocommatopright" }, "\u031A": { "math": "\\droang" }, "\u034D": { "math": "\\underleftrightarrow" }, "\u0391": { "math": "\\mupAlpha" }, "\u0392": { "math": "\\mupBeta" }, "\u0393": { "math": "\\mupGamma" }, "\u0394": { "math": "\\mupDelta" }, "\u0395": { "math": "\\mupEpsilon" }, "\u0396": { "math": "\\mupZeta" }, "\u0397": { "math": "\\mupEta" }, "\u0398": { "math": "\\mupTheta" }, "\u0399": { "math": "\\mupIota" }, "\u039A": { "math": "\\mupKappa" }, "\u039B": { "math": "\\mupLambda" }, "\u039C": { "math": "\\mupMu" }, "\u039D": { "math": "\\mupNu" }, "\u039F": { "math": "\\mupOmicron" }, "\u03A1": { "math": "\\mupRho" }, "\u03A4": { "math": "\\mupTau" }, "\u03A7": { "math": "\\mupChi" }, "\u03BF": { "math": "\\mupomicron" }, "\u03D0": { "math": "\\varbeta" }, "\u03F0": { "math": "\\varkappa" }, "\u03F6": { "math": "\\upbackepsilon" }, "\u{1D400}": { "math": "\\mbfA" }, "\u{1D401}": { "math": "\\mbfB" }, "\u{1D402}": { "math": "\\mbfC" }, "\u{1D403}": { "math": "\\mbfD" }, "\u{1D404}": { "math": "\\mbfE" }, "\u{1D405}": { "math": "\\mbfF" }, "\u{1D406}": { "math": "\\mbfG" }, "\u{1D407}": { "math": "\\mbfH" }, "\u{1D408}": { "math": "\\mbfI" }, "\u{1D409}": { "math": "\\mbfJ" }, "\u{1D40A}": { "math": "\\mbfK" }, "\u{1D40B}": { "math": "\\mbfL" }, "\u{1D40C}": { "math": "\\mbfM" }, "\u{1D40D}": { "math": "\\mbfN" }, "\u{1D40E}": { "math": "\\mbfO" }, "\u{1D40F}": { "math": "\\mbfP" }, "\u{1D410}": { "math": "\\mbfQ" }, "\u{1D411}": { "math": "\\mbfR" }, "\u{1D412}": { "math": "\\mbfS" }, "\u{1D413}": { "math": "\\mbfT" }, "\u{1D414}": { "math": "\\mbfU" }, "\u{1D415}": { "math": "\\mbfV" }, "\u{1D416}": { "math": "\\mbfW" }, "\u{1D417}": { "math": "\\mbfX" }, "\u{1D418}": { "math": "\\mbfY" }, "\u{1D419}": { "math": "\\mbfZ" }, "\u{1D41A}": { "math": "\\mbfa" }, "\u{1D41B}": { "math": "\\mbfb" }, "\u{1D41C}": { "math": "\\mbfc" }, "\u{1D41D}": { "math": "\\mbfd" }, "\u{1D41E}": { "math": "\\mbfe" }, "\u{1D41F}": { "math": "\\mbff" }, "\u{1D420}": { "math": "\\mbfg" }, "\u{1D421}": { "math": "\\mbfh" }, "\u{1D422}": { "math": "\\mbfi" }, "\u{1D423}": { "math": "\\mbfj" }, "\u{1D424}": { "math": "\\mbfk" }, "\u{1D425}": { "math": "\\mbfl" }, "\u{1D426}": { "math": "\\mbfm" }, "\u{1D427}": { "math": "\\mbfn" }, "\u{1D428}": { "math": "\\mbfo" }, "\u{1D429}": { "math": "\\mbfp" }, "\u{1D42A}": { "math": "\\mbfq" }, "\u{1D42B}": { "math": "\\mbfr" }, "\u{1D42C}": { "math": "\\mbfs" }, "\u{1D42D}": { "math": "\\mbft" }, "\u{1D42E}": { "math": "\\mbfu" }, "\u{1D42F}": { "math": "\\mbfv" }, "\u{1D430}": { "math": "\\mbfw" }, "\u{1D431}": { "math": "\\mbfx" }, "\u{1D432}": { "math": "\\mbfy" }, "\u{1D433}": { "math": "\\mbfz" }, "\u{1D434}": { "math": "\\mitA" }, "\u{1D435}": { "math": "\\mitB" }, "\u{1D436}": { "math": "\\mitC" }, "\u{1D437}": { "math": "\\mitD" }, "\u{1D438}": { "math": "\\mitE" }, "\u{1D439}": { "math": "\\mitF" }, "\u{1D43A}": { "math": "\\mitG" }, "\u{1D43B}": { "math": "\\mitH" }, "\u{1D43C}": { "math": "\\mitI" }, "\u{1D43D}": { "math": "\\mitJ" }, "\u{1D43E}": { "math": "\\mitK" }, "\u{1D43F}": { "math": "\\mitL" }, "\u{1D440}": { "math": "\\mitM" }, "\u{1D441}": { "math": "\\mitN" }, "\u{1D442}": { "math": "\\mitO" }, "\u{1D443}": { "math": "\\mitP" }, "\u{1D444}": { "math": "\\mitQ" }, "\u{1D445}": { "math": "\\mitR" }, "\u{1D446}": { "math": "\\mitS" }, "\u{1D447}": { "math": "\\mitT" }, "\u{1D448}": { "math": "\\mitU" }, "\u{1D449}": { "math": "\\mitV" }, "\u{1D44A}": { "math": "\\mitW" }, "\u{1D44B}": { "math": "\\mitX" }, "\u{1D44C}": { "math": "\\mitY" }, "\u{1D44D}": { "math": "\\mitZ" }, "\u{1D44E}": { "math": "\\mita" }, "\u{1D44F}": { "math": "\\mitb" }, "\u{1D450}": { "math": "\\mitc" }, "\u{1D451}": { "math": "\\mitd" }, "\u{1D452}": { "math": "\\mite" }, "\u{1D453}": { "math": "\\mitf" }, "\u{1D454}": { "math": "\\mitg" }, "\u{1D456}": { "math": "\\miti" }, "\u{1D457}": { "math": "\\mitj" }, "\u{1D458}": { "math": "\\mitk" }, "\u{1D459}": { "math": "\\mitl" }, "\u{1D45A}": { "math": "\\mitm" }, "\u{1D45B}": { "math": "\\mitn" }, "\u{1D45C}": { "math": "\\mito" }, "\u{1D45D}": { "math": "\\mitp" }, "\u{1D45E}": { "math": "\\mitq" }, "\u{1D45F}": { "math": "\\mitr" }, "\u{1D460}": { "math": "\\mits" }, "\u{1D461}": { "math": "\\mitt" }, "\u{1D462}": { "math": "\\mitu" }, "\u{1D463}": { "math": "\\mitv" }, "\u{1D464}": { "math": "\\mitw" }, "\u{1D465}": { "math": "\\mitx" }, "\u{1D466}": { "math": "\\mity" }, "\u{1D467}": { "math": "\\mitz" }, "\u{1D468}": { "math": "\\mbfitA" }, "\u{1D469}": { "math": "\\mbfitB" }, "\u{1D46A}": { "math": "\\mbfitC" }, "\u{1D46B}": { "math": "\\mbfitD" }, "\u{1D46C}": { "math": "\\mbfitE" }, "\u{1D46D}": { "math": "\\mbfitF" }, "\u{1D46E}": { "math": "\\mbfitG" }, "\u{1D46F}": { "math": "\\mbfitH" }, "\u{1D470}": { "math": "\\mbfitI" }, "\u{1D471}": { "math": "\\mbfitJ" }, "\u{1D472}": { "math": "\\mbfitK" }, "\u{1D473}": { "math": "\\mbfitL" }, "\u{1D474}": { "math": "\\mbfitM" }, "\u{1D475}": { "math": "\\mbfitN" }, "\u{1D476}": { "math": "\\mbfitO" }, "\u{1D477}": { "math": "\\mbfitP" }, "\u{1D478}": { "math": "\\mbfitQ" }, "\u{1D479}": { "math": "\\mbfitR" }, "\u{1D47A}": { "math": "\\mbfitS" }, "\u{1D47B}": { "math": "\\mbfitT" }, "\u{1D47C}": { "math": "\\mbfitU" }, "\u{1D47D}": { "math": "\\mbfitV" }, "\u{1D47E}": { "math": "\\mbfitW" }, "\u{1D47F}": { "math": "\\mbfitX" }, "\u{1D480}": { "math": "\\mbfitY" }, "\u{1D481}": { "math": "\\mbfitZ" }, "\u{1D482}": { "math": "\\mbfita" }, "\u{1D483}": { "math": "\\mbfitb" }, "\u{1D484}": { "math": "\\mbfitc" }, "\u{1D485}": { "math": "\\mbfitd" }, "\u{1D486}": { "math": "\\mbfite" }, "\u{1D487}": { "math": "\\mbfitf" }, "\u{1D488}": { "math": "\\mbfitg" }, "\u{1D489}": { "math": "\\mbfith" }, "\u{1D48A}": { "math": "\\mbfiti" }, "\u{1D48B}": { "math": "\\mbfitj" }, "\u{1D48C}": { "math": "\\mbfitk" }, "\u{1D48D}": { "math": "\\mbfitl" }, "\u{1D48E}": { "math": "\\mbfitm" }, "\u{1D48F}": { "math": "\\mbfitn" }, "\u{1D490}": { "math": "\\mbfito" }, "\u{1D491}": { "math": "\\mbfitp" }, "\u{1D492}": { "math": "\\mbfitq" }, "\u{1D493}": { "math": "\\mbfitr" }, "\u{1D494}": { "math": "\\mbfits" }, "\u{1D495}": { "math": "\\mbfitt" }, "\u{1D496}": { "math": "\\mbfitu" }, "\u{1D497}": { "math": "\\mbfitv" }, "\u{1D498}": { "math": "\\mbfitw" }, "\u{1D499}": { "math": "\\mbfitx" }, "\u{1D49A}": { "math": "\\mbfity" }, "\u{1D49B}": { "math": "\\mbfitz" }, "\u{1D49C}": { "math": "\\mscrA" }, "\u{1D49E}": { "math": "\\mscrC" }, "\u{1D49F}": { "math": "\\mscrD" }, "\u{1D4A2}": { "math": "\\mscrG" }, "\u{1D4A5}": { "math": "\\mscrJ" }, "\u{1D4A6}": { "math": "\\mscrK" }, "\u{1D4A9}": { "math": "\\mscrN" }, "\u{1D4AA}": { "math": "\\mscrO" }, "\u{1D4AB}": { "math": "\\mscrP" }, "\u{1D4AC}": { "math": "\\mscrQ" }, "\u{1D4AE}": { "math": "\\mscrS" }, "\u{1D4AF}": { "math": "\\mscrT" }, "\u{1D4B0}": { "math": "\\mscrU" }, "\u{1D4B1}": { "math": "\\mscrV" }, "\u{1D4B2}": { "math": "\\mscrW" }, "\u{1D4B3}": { "math": "\\mscrX" }, "\u{1D4B4}": { "math": "\\mscrY" }, "\u{1D4B5}": { "math": "\\mscrZ" }, "\u{1D4B6}": { "math": "\\mscra" }, "\u{1D4B7}": { "math": "\\mscrb" }, "\u{1D4B8}": { "math": "\\mscrc" }, "\u{1D4B9}": { "math": "\\mscrd" }, "\u{1D4BB}": { "math": "\\mscrf" }, "\u{1D4BD}": { "math": "\\mscrh" }, "\u{1D4BE}": { "math": "\\mscri" }, "\u{1D4BF}": { "math": "\\mscrj" }, "\u{1D4C0}": { "math": "\\mscrk" }, "\u{1D4C1}": { "math": "\\mscrl" }, "\u{1D4C2}": { "math": "\\mscrm" }, "\u{1D4C3}": { "math": "\\mscrn" }, "\u{1D4C5}": { "math": "\\mscrp" }, "\u{1D4C6}": { "math": "\\mscrq" }, "\u{1D4C7}": { "math": "\\mscrr" }, "\u{1D4C8}": { "math": "\\mscrs" }, "\u{1D4C9}": { "math": "\\mscrt" }, "\u{1D4CA}": { "math": "\\mscru" }, "\u{1D4CB}": { "math": "\\mscrv" }, "\u{1D4CC}": { "math": "\\mscrw" }, "\u{1D4CD}": { "math": "\\mscrx" }, "\u{1D4CE}": { "math": "\\mscry" }, "\u{1D4CF}": { "math": "\\mscrz" }, "\u{1D4D0}": { "math": "\\mbfscrA" }, "\u{1D4D1}": { "math": "\\mbfscrB" }, "\u{1D4D2}": { "math": "\\mbfscrC" }, "\u{1D4D3}": { "math": "\\mbfscrD" }, "\u{1D4D4}": { "math": "\\mbfscrE" }, "\u{1D4D5}": { "math": "\\mbfscrF" }, "\u{1D4D6}": { "math": "\\mbfscrG" }, "\u{1D4D7}": { "math": "\\mbfscrH" }, "\u{1D4D8}": { "math": "\\mbfscrI" }, "\u{1D4D9}": { "math": "\\mbfscrJ" }, "\u{1D4DA}": { "math": "\\mbfscrK" }, "\u{1D4DB}": { "math": "\\mbfscrL" }, "\u{1D4DC}": { "math": "\\mbfscrM" }, "\u{1D4DD}": { "math": "\\mbfscrN" }, "\u{1D4DE}": { "math": "\\mbfscrO" }, "\u{1D4DF}": { "math": "\\mbfscrP" }, "\u{1D4E0}": { "math": "\\mbfscrQ" }, "\u{1D4E1}": { "math": "\\mbfscrR" }, "\u{1D4E2}": { "math": "\\mbfscrS" }, "\u{1D4E3}": { "math": "\\mbfscrT" }, "\u{1D4E4}": { "math": "\\mbfscrU" }, "\u{1D4E5}": { "math": "\\mbfscrV" }, "\u{1D4E6}": { "math": "\\mbfscrW" }, "\u{1D4E7}": { "math": "\\mbfscrX" }, "\u{1D4E8}": { "math": "\\mbfscrY" }, "\u{1D4E9}": { "math": "\\mbfscrZ" }, "\u{1D4EA}": { "math": "\\mbfscra" }, "\u{1D4EB}": { "math": "\\mbfscrb" }, "\u{1D4EC}": { "math": "\\mbfscrc" }, "\u{1D4ED}": { "math": "\\mbfscrd" }, "\u{1D4EE}": { "math": "\\mbfscre" }, "\u{1D4EF}": { "math": "\\mbfscrf" }, "\u{1D4F0}": { "math": "\\mbfscrg" }, "\u{1D4F1}": { "math": "\\mbfscrh" }, "\u{1D4F2}": { "math": "\\mbfscri" }, "\u{1D4F3}": { "math": "\\mbfscrj" }, "\u{1D4F4}": { "math": "\\mbfscrk" }, "\u{1D4F5}": { "math": "\\mbfscrl" }, "\u{1D4F6}": { "math": "\\mbfscrm" }, "\u{1D4F7}": { "math": "\\mbfscrn" }, "\u{1D4F8}": { "math": "\\mbfscro" }, "\u{1D4F9}": { "math": "\\mbfscrp" }, "\u{1D4FA}": { "math": "\\mbfscrq" }, "\u{1D4FB}": { "math": "\\mbfscrr" }, "\u{1D4FC}": { "math": "\\mbfscrs" }, "\u{1D4FD}": { "math": "\\mbfscrt" }, "\u{1D4FE}": { "math": "\\mbfscru" }, "\u{1D4FF}": { "math": "\\mbfscrv" }, "\u{1D500}": { "math": "\\mbfscrw" }, "\u{1D501}": { "math": "\\mbfscrx" }, "\u{1D502}": { "math": "\\mbfscry" }, "\u{1D503}": { "math": "\\mbfscrz" }, "\u{1D504}": { "math": "\\mfrakA" }, "\u{1D505}": { "math": "\\mfrakB" }, "\u{1D507}": { "math": "\\mfrakD" }, "\u{1D508}": { "math": "\\mfrakE" }, "\u{1D509}": { "math": "\\mfrakF" }, "\u{1D50A}": { "math": "\\mfrakG" }, "\u{1D50D}": { "math": "\\mfrakJ" }, "\u{1D50E}": { "math": "\\mfrakK" }, "\u{1D50F}": { "math": "\\mfrakL" }, "\u{1D510}": { "math": "\\mfrakM" }, "\u{1D511}": { "math": "\\mfrakN" }, "\u{1D512}": { "math": "\\mfrakO" }, "\u{1D513}": { "math": "\\mfrakP" }, "\u{1D514}": { "math": "\\mfrakQ" }, "\u{1D516}": { "math": "\\mfrakS" }, "\u{1D517}": { "math": "\\mfrakT" }, "\u{1D518}": { "math": "\\mfrakU" }, "\u{1D519}": { "math": "\\mfrakV" }, "\u{1D51A}": { "math": "\\mfrakW" }, "\u{1D51B}": { "math": "\\mfrakX" }, "\u{1D51C}": { "math": "\\mfrakY" }, "\u{1D51E}": { "math": "\\mfraka" }, "\u{1D51F}": { "math": "\\mfrakb" }, "\u{1D520}": { "math": "\\mfrakc" }, "\u{1D521}": { "math": "\\mfrakd" }, "\u{1D522}": { "math": "\\mfrake" }, "\u{1D523}": { "math": "\\mfrakf" }, "\u{1D524}": { "math": "\\mfrakg" }, "\u{1D525}": { "math": "\\mfrakh" }, "\u{1D526}": { "math": "\\mfraki" }, "\u{1D527}": { "math": "\\mfrakj" }, "\u{1D528}": { "math": "\\mfrakk" }, "\u{1D529}": { "math": "\\mfrakl" }, "\u{1D52A}": { "math": "\\mfrakm" }, "\u{1D52B}": { "math": "\\mfrakn" }, "\u{1D52C}": { "math": "\\mfrako" }, "\u{1D52D}": { "math": "\\mfrakp" }, "\u{1D52E}": { "math": "\\mfrakq" }, "\u{1D52F}": { "math": "\\mfrakr" }, "\u{1D530}": { "math": "\\mfraks" }, "\u{1D531}": { "math": "\\mfrakt" }, "\u{1D532}": { "math": "\\mfraku" }, "\u{1D533}": { "math": "\\mfrakv" }, "\u{1D534}": { "math": "\\mfrakw" }, "\u{1D535}": { "math": "\\mfrakx" }, "\u{1D536}": { "math": "\\mfraky" }, "\u{1D537}": { "math": "\\mfrakz" }, "\u{1D538}": { "math": "\\BbbA" }, "\u{1D539}": { "math": "\\BbbB" }, "\u{1D53B}": { "math": "\\BbbD" }, "\u{1D53C}": { "math": "\\BbbE" }, "\u{1D53D}": { "math": "\\BbbF" }, "\u{1D53E}": { "math": "\\BbbG" }, "\u{1D540}": { "math": "\\BbbI" }, "\u{1D541}": { "math": "\\BbbJ" }, "\u{1D542}": { "math": "\\BbbK" }, "\u{1D543}": { "math": "\\BbbL" }, "\u{1D544}": { "math": "\\BbbM" }, "\u{1D546}": { "math": "\\BbbO" }, "\u{1D54A}": { "math": "\\BbbS" }, "\u{1D54B}": { "math": "\\BbbT" }, "\u{1D54C}": { "math": "\\BbbU" }, "\u{1D54D}": { "math": "\\BbbV" }, "\u{1D54E}": { "math": "\\BbbW" }, "\u{1D54F}": { "math": "\\BbbX" }, "\u{1D550}": { "math": "\\BbbY" }, "\u{1D552}": { "math": "\\Bbba" }, "\u{1D553}": { "math": "\\Bbbb" }, "\u{1D554}": { "math": "\\Bbbc" }, "\u{1D555}": { "math": "\\Bbbd" }, "\u{1D556}": { "math": "\\Bbbe" }, "\u{1D557}": { "math": "\\Bbbf" }, "\u{1D558}": { "math": "\\Bbbg" }, "\u{1D559}": { "math": "\\Bbbh" }, "\u{1D55A}": { "math": "\\Bbbi" }, "\u{1D55B}": { "math": "\\Bbbj" }, "\u{1D55C}": { "math": "\\Bbbk" }, "\u{1D55D}": { "math": "\\Bbbl" }, "\u{1D55E}": { "math": "\\Bbbm" }, "\u{1D55F}": { "math": "\\Bbbn" }, "\u{1D560}": { "math": "\\Bbbo" }, "\u{1D561}": { "math": "\\Bbbp" }, "\u{1D562}": { "math": "\\Bbbq" }, "\u{1D563}": { "math": "\\Bbbr" }, "\u{1D564}": { "math": "\\Bbbs" }, "\u{1D565}": { "math": "\\Bbbt" }, "\u{1D566}": { "math": "\\Bbbu" }, "\u{1D567}": { "math": "\\Bbbv" }, "\u{1D568}": { "math": "\\Bbbw" }, "\u{1D569}": { "math": "\\Bbbx" }, "\u{1D56A}": { "math": "\\Bbby" }, "\u{1D56B}": { "math": "\\Bbbz" }, "\u{1D56C}": { "math": "\\mbffrakA" }, "\u{1D56D}": { "math": "\\mbffrakB" }, "\u{1D56E}": { "math": "\\mbffrakC" }, "\u{1D56F}": { "math": "\\mbffrakD" }, "\u{1D570}": { "math": "\\mbffrakE" }, "\u{1D571}": { "math": "\\mbffrakF" }, "\u{1D572}": { "math": "\\mbffrakG" }, "\u{1D573}": { "math": "\\mbffrakH" }, "\u{1D574}": { "math": "\\mbffrakI" }, "\u{1D575}": { "math": "\\mbffrakJ" }, "\u{1D576}": { "math": "\\mbffrakK" }, "\u{1D577}": { "math": "\\mbffrakL" }, "\u{1D578}": { "math": "\\mbffrakM" }, "\u{1D579}": { "math": "\\mbffrakN" }, "\u{1D57A}": { "math": "\\mbffrakO" }, "\u{1D57B}": { "math": "\\mbffrakP" }, "\u{1D57C}": { "math": "\\mbffrakQ" }, "\u{1D57D}": { "math": "\\mbffrakR" }, "\u{1D57E}": { "math": "\\mbffrakS" }, "\u{1D57F}": { "math": "\\mbffrakT" }, "\u{1D580}": { "math": "\\mbffrakU" }, "\u{1D581}": { "math": "\\mbffrakV" }, "\u{1D582}": { "math": "\\mbffrakW" }, "\u{1D583}": { "math": "\\mbffrakX" }, "\u{1D584}": { "math": "\\mbffrakY" }, "\u{1D585}": { "math": "\\mbffrakZ" }, "\u{1D586}": { "math": "\\mbffraka" }, "\u{1D587}": { "math": "\\mbffrakb" }, "\u{1D588}": { "math": "\\mbffrakc" }, "\u{1D589}": { "math": "\\mbffrakd" }, "\u{1D58A}": { "math": "\\mbffrake" }, "\u{1D58B}": { "math": "\\mbffrakf" }, "\u{1D58C}": { "math": "\\mbffrakg" }, "\u{1D58D}": { "math": "\\mbffrakh" }, "\u{1D58E}": { "math": "\\mbffraki" }, "\u{1D58F}": { "math": "\\mbffrakj" }, "\u{1D590}": { "math": "\\mbffrakk" }, "\u{1D591}": { "math": "\\mbffrakl" }, "\u{1D592}": { "math": "\\mbffrakm" }, "\u{1D593}": { "math": "\\mbffrakn" }, "\u{1D594}": { "math": "\\mbffrako" }, "\u{1D595}": { "math": "\\mbffrakp" }, "\u{1D596}": { "math": "\\mbffrakq" }, "\u{1D597}": { "math": "\\mbffrakr" }, "\u{1D598}": { "math": "\\mbffraks" }, "\u{1D599}": { "math": "\\mbffrakt" }, "\u{1D59A}": { "math": "\\mbffraku" }, "\u{1D59B}": { "math": "\\mbffrakv" }, "\u{1D59C}": { "math": "\\mbffrakw" }, "\u{1D59D}": { "math": "\\mbffrakx" }, "\u{1D59E}": { "math": "\\mbffraky" }, "\u{1D59F}": { "math": "\\mbffrakz" }, "\u{1D5A0}": { "math": "\\msansA" }, "\u{1D5A1}": { "math": "\\msansB" }, "\u{1D5A2}": { "math": "\\msansC" }, "\u{1D5A3}": { "math": "\\msansD" }, "\u{1D5A4}": { "math": "\\msansE" }, "\u{1D5A5}": { "math": "\\msansF" }, "\u{1D5A6}": { "math": "\\msansG" }, "\u{1D5A7}": { "math": "\\msansH" }, "\u{1D5A8}": { "math": "\\msansI" }, "\u{1D5A9}": { "math": "\\msansJ" }, "\u{1D5AA}": { "math": "\\msansK" }, "\u{1D5AB}": { "math": "\\msansL" }, "\u{1D5AC}": { "math": "\\msansM" }, "\u{1D5AD}": { "math": "\\msansN" }, "\u{1D5AE}": { "math": "\\msansO" }, "\u{1D5AF}": { "math": "\\msansP" }, "\u{1D5B0}": { "math": "\\msansQ" }, "\u{1D5B1}": { "math": "\\msansR" }, "\u{1D5B2}": { "math": "\\msansS" }, "\u{1D5B3}": { "math": "\\msansT" }, "\u{1D5B4}": { "math": "\\msansU" }, "\u{1D5B5}": { "math": "\\msansV" }, "\u{1D5B6}": { "math": "\\msansW" }, "\u{1D5B7}": { "math": "\\msansX" }, "\u{1D5B8}": { "math": "\\msansY" }, "\u{1D5B9}": { "math": "\\msansZ" }, "\u{1D5BA}": { "math": "\\msansa" }, "\u{1D5BB}": { "math": "\\msansb" }, "\u{1D5BC}": { "math": "\\msansc" }, "\u{1D5BD}": { "math": "\\msansd" }, "\u{1D5BE}": { "math": "\\msanse" }, "\u{1D5BF}": { "math": "\\msansf" }, "\u{1D5C0}": { "math": "\\msansg" }, "\u{1D5C1}": { "math": "\\msansh" }, "\u{1D5C2}": { "math": "\\msansi" }, "\u{1D5C3}": { "math": "\\msansj" }, "\u{1D5C4}": { "math": "\\msansk" }, "\u{1D5C5}": { "math": "\\msansl" }, "\u{1D5C6}": { "math": "\\msansm" }, "\u{1D5C7}": { "math": "\\msansn" }, "\u{1D5C8}": { "math": "\\msanso" }, "\u{1D5C9}": { "math": "\\msansp" }, "\u{1D5CA}": { "math": "\\msansq" }, "\u{1D5CB}": { "math": "\\msansr" }, "\u{1D5CC}": { "math": "\\msanss" }, "\u{1D5CD}": { "math": "\\msanst" }, "\u{1D5CE}": { "math": "\\msansu" }, "\u{1D5CF}": { "math": "\\msansv" }, "\u{1D5D0}": { "math": "\\msansw" }, "\u{1D5D1}": { "math": "\\msansx" }, "\u{1D5D2}": { "math": "\\msansy" }, "\u{1D5D3}": { "math": "\\msansz" }, "\u{1D5D4}": { "math": "\\mbfsansA" }, "\u{1D5D5}": { "math": "\\mbfsansB" }, "\u{1D5D6}": { "math": "\\mbfsansC" }, "\u{1D5D7}": { "math": "\\mbfsansD" }, "\u{1D5D8}": { "math": "\\mbfsansE" }, "\u{1D5D9}": { "math": "\\mbfsansF" }, "\u{1D5DA}": { "math": "\\mbfsansG" }, "\u{1D5DB}": { "math": "\\mbfsansH" }, "\u{1D5DC}": { "math": "\\mbfsansI" }, "\u{1D5DD}": { "math": "\\mbfsansJ" }, "\u{1D5DE}": { "math": "\\mbfsansK" }, "\u{1D5DF}": { "math": "\\mbfsansL" }, "\u{1D5E0}": { "math": "\\mbfsansM" }, "\u{1D5E1}": { "math": "\\mbfsansN" }, "\u{1D5E2}": { "math": "\\mbfsansO" }, "\u{1D5E3}": { "math": "\\mbfsansP" }, "\u{1D5E4}": { "math": "\\mbfsansQ" }, "\u{1D5E5}": { "math": "\\mbfsansR" }, "\u{1D5E6}": { "math": "\\mbfsansS" }, "\u{1D5E7}": { "math": "\\mbfsansT" }, "\u{1D5E8}": { "math": "\\mbfsansU" }, "\u{1D5E9}": { "math": "\\mbfsansV" }, "\u{1D5EA}": { "math": "\\mbfsansW" }, "\u{1D5EB}": { "math": "\\mbfsansX" }, "\u{1D5EC}": { "math": "\\mbfsansY" }, "\u{1D5ED}": { "math": "\\mbfsansZ" }, "\u{1D5EE}": { "math": "\\mbfsansa" }, "\u{1D5EF}": { "math": "\\mbfsansb" }, "\u{1D5F0}": { "math": "\\mbfsansc" }, "\u{1D5F1}": { "math": "\\mbfsansd" }, "\u{1D5F2}": { "math": "\\mbfsanse" }, "\u{1D5F3}": { "math": "\\mbfsansf" }, "\u{1D5F4}": { "math": "\\mbfsansg" }, "\u{1D5F5}": { "math": "\\mbfsansh" }, "\u{1D5F6}": { "math": "\\mbfsansi" }, "\u{1D5F7}": { "math": "\\mbfsansj" }, "\u{1D5F8}": { "math": "\\mbfsansk" }, "\u{1D5F9}": { "math": "\\mbfsansl" }, "\u{1D5FA}": { "math": "\\mbfsansm" }, "\u{1D5FB}": { "math": "\\mbfsansn" }, "\u{1D5FC}": { "math": "\\mbfsanso" }, "\u{1D5FD}": { "math": "\\mbfsansp" }, "\u{1D5FE}": { "math": "\\mbfsansq" }, "\u{1D5FF}": { "math": "\\mbfsansr" }, "\u{1D600}": { "math": "\\mbfsanss" }, "\u{1D601}": { "math": "\\mbfsanst" }, "\u{1D602}": { "math": "\\mbfsansu" }, "\u{1D603}": { "math": "\\mbfsansv" }, "\u{1D604}": { "math": "\\mbfsansw" }, "\u{1D605}": { "math": "\\mbfsansx" }, "\u{1D606}": { "math": "\\mbfsansy" }, "\u{1D607}": { "math": "\\mbfsansz" }, "\u{1D608}": { "math": "\\mitsansA" }, "\u{1D609}": { "math": "\\mitsansB" }, "\u{1D60A}": { "math": "\\mitsansC" }, "\u{1D60B}": { "math": "\\mitsansD" }, "\u{1D60C}": { "math": "\\mitsansE" }, "\u{1D60D}": { "math": "\\mitsansF" }, "\u{1D60E}": { "math": "\\mitsansG" }, "\u{1D60F}": { "math": "\\mitsansH" }, "\u{1D610}": { "math": "\\mitsansI" }, "\u{1D611}": { "math": "\\mitsansJ" }, "\u{1D612}": { "math": "\\mitsansK" }, "\u{1D613}": { "math": "\\mitsansL" }, "\u{1D614}": { "math": "\\mitsansM" }, "\u{1D615}": { "math": "\\mitsansN" }, "\u{1D616}": { "math": "\\mitsansO" }, "\u{1D617}": { "math": "\\mitsansP" }, "\u{1D618}": { "math": "\\mitsansQ" }, "\u{1D619}": { "math": "\\mitsansR" }, "\u{1D61A}": { "math": "\\mitsansS" }, "\u{1D61B}": { "math": "\\mitsansT" }, "\u{1D61C}": { "math": "\\mitsansU" }, "\u{1D61D}": { "math": "\\mitsansV" }, "\u{1D61E}": { "math": "\\mitsansW" }, "\u{1D61F}": { "math": "\\mitsansX" }, "\u{1D620}": { "math": "\\mitsansY" }, "\u{1D621}": { "math": "\\mitsansZ" }, "\u{1D622}": { "math": "\\mitsansa" }, "\u{1D623}": { "math": "\\mitsansb" }, "\u{1D624}": { "math": "\\mitsansc" }, "\u{1D625}": { "math": "\\mitsansd" }, "\u{1D626}": { "math": "\\mitsanse" }, "\u{1D627}": { "math": "\\mitsansf" }, "\u{1D628}": { "math": "\\mitsansg" }, "\u{1D629}": { "math": "\\mitsansh" }, "\u{1D62A}": { "math": "\\mitsansi" }, "\u{1D62B}": { "math": "\\mitsansj" }, "\u{1D62C}": { "math": "\\mitsansk" }, "\u{1D62D}": { "math": "\\mitsansl" }, "\u{1D62E}": { "math": "\\mitsansm" }, "\u{1D62F}": { "math": "\\mitsansn" }, "\u{1D630}": { "math": "\\mitsanso" }, "\u{1D631}": { "math": "\\mitsansp" }, "\u{1D632}": { "math": "\\mitsansq" }, "\u{1D633}": { "math": "\\mitsansr" }, "\u{1D634}": { "math": "\\mitsanss" }, "\u{1D635}": { "math": "\\mitsanst" }, "\u{1D636}": { "math": "\\mitsansu" }, "\u{1D637}": { "math": "\\mitsansv" }, "\u{1D638}": { "math": "\\mitsansw" }, "\u{1D639}": { "math": "\\mitsansx" }, "\u{1D63A}": { "math": "\\mitsansy" }, "\u{1D63B}": { "math": "\\mitsansz" }, "\u{1D63C}": { "math": "\\mbfitsansA" }, "\u{1D63D}": { "math": "\\mbfitsansB" }, "\u{1D63E}": { "math": "\\mbfitsansC" }, "\u{1D63F}": { "math": "\\mbfitsansD" }, "\u{1D640}": { "math": "\\mbfitsansE" }, "\u{1D641}": { "math": "\\mbfitsansF" }, "\u{1D642}": { "math": "\\mbfitsansG" }, "\u{1D643}": { "math": "\\mbfitsansH" }, "\u{1D644}": { "math": "\\mbfitsansI" }, "\u{1D645}": { "math": "\\mbfitsansJ" }, "\u{1D646}": { "math": "\\mbfitsansK" }, "\u{1D647}": { "math": "\\mbfitsansL" }, "\u{1D648}": { "math": "\\mbfitsansM" }, "\u{1D649}": { "math": "\\mbfitsansN" }, "\u{1D64A}": { "math": "\\mbfitsansO" }, "\u{1D64B}": { "math": "\\mbfitsansP" }, "\u{1D64C}": { "math": "\\mbfitsansQ" }, "\u{1D64D}": { "math": "\\mbfitsansR" }, "\u{1D64E}": { "math": "\\mbfitsansS" }, "\u{1D64F}": { "math": "\\mbfitsansT" }, "\u{1D650}": { "math": "\\mbfitsansU" }, "\u{1D651}": { "math": "\\mbfitsansV" }, "\u{1D652}": { "math": "\\mbfitsansW" }, "\u{1D653}": { "math": "\\mbfitsansX" }, "\u{1D654}": { "math": "\\mbfitsansY" }, "\u{1D655}": { "math": "\\mbfitsansZ" }, "\u{1D656}": { "math": "\\mbfitsansa" }, "\u{1D657}": { "math": "\\mbfitsansb" }, "\u{1D658}": { "math": "\\mbfitsansc" }, "\u{1D659}": { "math": "\\mbfitsansd" }, "\u{1D65A}": { "math": "\\mbfitsanse" }, "\u{1D65B}": { "math": "\\mbfitsansf" }, "\u{1D65C}": { "math": "\\mbfitsansg" }, "\u{1D65D}": { "math": "\\mbfitsansh" }, "\u{1D65E}": { "math": "\\mbfitsansi" }, "\u{1D65F}": { "math": "\\mbfitsansj" }, "\u{1D660}": { "math": "\\mbfitsansk" }, "\u{1D661}": { "math": "\\mbfitsansl" }, "\u{1D662}": { "math": "\\mbfitsansm" }, "\u{1D663}": { "math": "\\mbfitsansn" }, "\u{1D664}": { "math": "\\mbfitsanso" }, "\u{1D665}": { "math": "\\mbfitsansp" }, "\u{1D666}": { "math": "\\mbfitsansq" }, "\u{1D667}": { "math": "\\mbfitsansr" }, "\u{1D668}": { "math": "\\mbfitsanss" }, "\u{1D669}": { "math": "\\mbfitsanst" }, "\u{1D66A}": { "math": "\\mbfitsansu" }, "\u{1D66B}": { "math": "\\mbfitsansv" }, "\u{1D66C}": { "math": "\\mbfitsansw" }, "\u{1D66D}": { "math": "\\mbfitsansx" }, "\u{1D66E}": { "math": "\\mbfitsansy" }, "\u{1D66F}": { "math": "\\mbfitsansz" }, "\u{1D670}": { "math": "\\mttA" }, "\u{1D671}": { "math": "\\mttB" }, "\u{1D672}": { "math": "\\mttC" }, "\u{1D673}": { "math": "\\mttD" }, "\u{1D674}": { "math": "\\mttE" }, "\u{1D675}": { "math": "\\mttF" }, "\u{1D676}": { "math": "\\mttG" }, "\u{1D677}": { "math": "\\mttH" }, "\u{1D678}": { "math": "\\mttI" }, "\u{1D679}": { "math": "\\mttJ" }, "\u{1D67A}": { "math": "\\mttK" }, "\u{1D67B}": { "math": "\\mttL" }, "\u{1D67C}": { "math": "\\mttM" }, "\u{1D67D}": { "math": "\\mttN" }, "\u{1D67E}": { "math": "\\mttO" }, "\u{1D67F}": { "math": "\\mttP" }, "\u{1D680}": { "math": "\\mttQ" }, "\u{1D681}": { "math": "\\mttR" }, "\u{1D682}": { "math": "\\mttS" }, "\u{1D683}": { "math": "\\mttT" }, "\u{1D684}": { "math": "\\mttU" }, "\u{1D685}": { "math": "\\mttV" }, "\u{1D686}": { "math": "\\mttW" }, "\u{1D687}": { "math": "\\mttX" }, "\u{1D688}": { "math": "\\mttY" }, "\u{1D689}": { "math": "\\mttZ" }, "\u{1D68A}": { "math": "\\mtta" }, "\u{1D68B}": { "math": "\\mttb" }, "\u{1D68C}": { "math": "\\mttc" }, "\u{1D68D}": { "math": "\\mttd" }, "\u{1D68E}": { "math": "\\mtte" }, "\u{1D68F}": { "math": "\\mttf" }, "\u{1D690}": { "math": "\\mttg" }, "\u{1D691}": { "math": "\\mtth" }, "\u{1D692}": { "math": "\\mtti" }, "\u{1D693}": { "math": "\\mttj" }, "\u{1D694}": { "math": "\\mttk" }, "\u{1D695}": { "math": "\\mttl" }, "\u{1D696}": { "math": "\\mttm" }, "\u{1D697}": { "math": "\\mttn" }, "\u{1D698}": { "math": "\\mtto" }, "\u{1D699}": { "math": "\\mttp" }, "\u{1D69A}": { "math": "\\mttq" }, "\u{1D69B}": { "math": "\\mttr" }, "\u{1D69C}": { "math": "\\mtts" }, "\u{1D69D}": { "math": "\\mttt" }, "\u{1D69E}": { "math": "\\mttu" }, "\u{1D69F}": { "math": "\\mttv" }, "\u{1D6A0}": { "math": "\\mttw" }, "\u{1D6A1}": { "math": "\\mttx" }, "\u{1D6A2}": { "math": "\\mtty" }, "\u{1D6A3}": { "math": "\\mttz" }, "\u{1D6A4}": { "math": "\\imath" }, "\u{1D6A5}": { "math": "\\jmath" }, "\u{1D6A8}": { "math": "\\mbfAlpha" }, "\u{1D6A9}": { "math": "\\mbfBeta" }, "\u{1D6AA}": { "math": "\\mbfGamma" }, "\u{1D6AB}": { "math": "\\mbfDelta" }, "\u{1D6AC}": { "math": "\\mbfEpsilon" }, "\u{1D6AD}": { "math": "\\mbfZeta" }, "\u{1D6AE}": { "math": "\\mbfEta" }, "\u{1D6AF}": { "math": "\\mbfTheta" }, "\u{1D6B0}": { "math": "\\mbfIota" }, "\u{1D6B1}": { "math": "\\mbfKappa" }, "\u{1D6B2}": { "math": "\\mbfLambda" }, "\u{1D6B3}": { "math": "\\mbfMu" }, "\u{1D6B4}": { "math": "\\mbfNu" }, "\u{1D6B5}": { "math": "\\mbfXi" }, "\u{1D6B6}": { "math": "\\mbfOmicron" }, "\u{1D6B7}": { "math": "\\mbfPi" }, "\u{1D6B8}": { "math": "\\mbfRho" }, "\u{1D6B9}": { "math": "\\mbfvarTheta" }, "\u{1D6BA}": { "math": "\\mbfSigma" }, "\u{1D6BB}": { "math": "\\mbfTau" }, "\u{1D6BC}": { "math": "\\mbfUpsilon" }, "\u{1D6BD}": { "math": "\\mbfPhi" }, "\u{1D6BE}": { "math": "\\mbfChi" }, "\u{1D6BF}": { "math": "\\mbfPsi" }, "\u{1D6C0}": { "math": "\\mbfOmega" }, "\u{1D6C1}": { "math": "\\mbfnabla" }, "\u{1D6C2}": { "math": "\\mbfalpha" }, "\u{1D6C3}": { "math": "\\mbfbeta" }, "\u{1D6C4}": { "math": "\\mbfgamma" }, "\u{1D6C5}": { "math": "\\mbfdelta" }, "\u{1D6C6}": { "math": "\\mbfvarepsilon" }, "\u{1D6C7}": { "math": "\\mbfzeta" }, "\u{1D6C8}": { "math": "\\mbfeta" }, "\u{1D6C9}": { "math": "\\mbftheta" }, "\u{1D6CA}": { "math": "\\mbfiota" }, "\u{1D6CB}": { "math": "\\mbfkappa" }, "\u{1D6CC}": { "math": "\\mbflambda" }, "\u{1D6CD}": { "math": "\\mbfmu" }, "\u{1D6CE}": { "math": "\\mbfnu" }, "\u{1D6CF}": { "math": "\\mbfxi" }, "\u{1D6D0}": { "math": "\\mbfomicron" }, "\u{1D6D1}": { "math": "\\mbfpi" }, "\u{1D6D2}": { "math": "\\mbfrho" }, "\u{1D6D3}": { "math": "\\mbfvarsigma" }, "\u{1D6D4}": { "math": "\\mbfsigma" }, "\u{1D6D5}": { "math": "\\mbftau" }, "\u{1D6D6}": { "math": "\\mbfupsilon" }, "\u{1D6D7}": { "math": "\\mbfvarphi" }, "\u{1D6D8}": { "math": "\\mbfchi" }, "\u{1D6D9}": { "math": "\\mbfpsi" }, "\u{1D6DA}": { "math": "\\mbfomega" }, "\u{1D6DB}": { "math": "\\mbfpartial" }, "\u{1D6DC}": { "math": "\\mbfepsilon" }, "\u{1D6DD}": { "math": "\\mbfvartheta" }, "\u{1D6DE}": { "math": "\\mbfvarkappa" }, "\u{1D6DF}": { "math": "\\mbfphi" }, "\u{1D6E0}": { "math": "\\mbfvarrho" }, "\u{1D6E1}": { "math": "\\mbfvarpi" }, "\u{1D6E2}": { "math": "\\mitAlpha" }, "\u{1D6E3}": { "math": "\\mitBeta" }, "\u{1D6E4}": { "math": "\\mitGamma" }, "\u{1D6E5}": { "math": "\\mitDelta" }, "\u{1D6E6}": { "math": "\\mitEpsilon" }, "\u{1D6E7}": { "math": "\\mitZeta" }, "\u{1D6E8}": { "math": "\\mitEta" }, "\u{1D6E9}": { "math": "\\mitTheta" }, "\u{1D6EA}": { "math": "\\mitIota" }, "\u{1D6EB}": { "math": "\\mitKappa" }, "\u{1D6EC}": { "math": "\\mitLambda" }, "\u{1D6ED}": { "math": "\\mitMu" }, "\u{1D6EE}": { "math": "\\mitNu" }, "\u{1D6EF}": { "math": "\\mitXi" }, "\u{1D6F0}": { "math": "\\mitOmicron" }, "\u{1D6F1}": { "math": "\\mitPi" }, "\u{1D6F2}": { "math": "\\mitRho" }, "\u{1D6F3}": { "math": "\\mitvarTheta" }, "\u{1D6F4}": { "math": "\\mitSigma" }, "\u{1D6F5}": { "math": "\\mitTau" }, "\u{1D6F6}": { "math": "\\mitUpsilon" }, "\u{1D6F7}": { "math": "\\mitPhi" }, "\u{1D6F8}": { "math": "\\mitChi" }, "\u{1D6F9}": { "math": "\\mitPsi" }, "\u{1D6FA}": { "math": "\\mitOmega" }, "\u{1D6FB}": { "math": "\\mitnabla" }, "\u{1D6FC}": { "math": "\\mitalpha" }, "\u{1D6FD}": { "math": "\\mitbeta" }, "\u{1D6FE}": { "math": "\\mitgamma" }, "\u{1D6FF}": { "math": "\\mitdelta" }, "\u{1D700}": { "math": "\\mitvarepsilon" }, "\u{1D701}": { "math": "\\mitzeta" }, "\u{1D702}": { "math": "\\miteta" }, "\u{1D703}": { "math": "\\mittheta" }, "\u{1D704}": { "math": "\\mitiota" }, "\u{1D705}": { "math": "\\mitkappa" }, "\u{1D706}": { "math": "\\mitlambda" }, "\u{1D707}": { "math": "\\mitmu" }, "\u{1D708}": { "math": "\\mitnu" }, "\u{1D709}": { "math": "\\mitxi" }, "\u{1D70A}": { "math": "\\mitomicron" }, "\u{1D70B}": { "math": "\\mitpi" }, "\u{1D70C}": { "math": "\\mitrho" }, "\u{1D70D}": { "math": "\\mitvarsigma" }, "\u{1D70E}": { "math": "\\mitsigma" }, "\u{1D70F}": { "math": "\\mittau" }, "\u{1D710}": { "math": "\\mitupsilon" }, "\u{1D711}": { "math": "\\mitvarphi" }, "\u{1D712}": { "math": "\\mitchi" }, "\u{1D713}": { "math": "\\mitpsi" }, "\u{1D714}": { "math": "\\mitomega" }, "\u{1D715}": { "math": "\\mitpartial" }, "\u{1D716}": { "math": "\\mitepsilon" }, "\u{1D717}": { "math": "\\mitvartheta" }, "\u{1D718}": { "math": "\\mitvarkappa" }, "\u{1D719}": { "math": "\\mitphi" }, "\u{1D71A}": { "math": "\\mitvarrho" }, "\u{1D71B}": { "math": "\\mitvarpi" }, "\u{1D71C}": { "math": "\\mbfitAlpha" }, "\u{1D71D}": { "math": "\\mbfitBeta" }, "\u{1D71E}": { "math": "\\mbfitGamma" }, "\u{1D71F}": { "math": "\\mbfitDelta" }, "\u{1D720}": { "math": "\\mbfitEpsilon" }, "\u{1D721}": { "math": "\\mbfitZeta" }, "\u{1D722}": { "math": "\\mbfitEta" }, "\u{1D723}": { "math": "\\mbfitTheta" }, "\u{1D724}": { "math": "\\mbfitIota" }, "\u{1D725}": { "math": "\\mbfitKappa" }, "\u{1D726}": { "math": "\\mbfitLambda" }, "\u{1D727}": { "math": "\\mbfitMu" }, "\u{1D728}": { "math": "\\mbfitNu" }, "\u{1D729}": { "math": "\\mbfitXi" }, "\u{1D72A}": { "math": "\\mbfitOmicron" }, "\u{1D72B}": { "math": "\\mbfitPi" }, "\u{1D72C}": { "math": "\\mbfitRho" }, "\u{1D72D}": { "math": "\\mbfitvarTheta" }, "\u{1D72E}": { "math": "\\mbfitSigma" }, "\u{1D72F}": { "math": "\\mbfitTau" }, "\u{1D730}": { "math": "\\mbfitUpsilon" }, "\u{1D731}": { "math": "\\mbfitPhi" }, "\u{1D732}": { "math": "\\mbfitChi" }, "\u{1D733}": { "math": "\\mbfitPsi" }, "\u{1D734}": { "math": "\\mbfitOmega" }, "\u{1D735}": { "math": "\\mbfitnabla" }, "\u{1D736}": { "math": "\\mbfitalpha" }, "\u{1D737}": { "math": "\\mbfitbeta" }, "\u{1D738}": { "math": "\\mbfitgamma" }, "\u{1D739}": { "math": "\\mbfitdelta" }, "\u{1D73A}": { "math": "\\mbfitvarepsilon" }, "\u{1D73B}": { "math": "\\mbfitzeta" }, "\u{1D73C}": { "math": "\\mbfiteta" }, "\u{1D73D}": { "math": "\\mbfittheta" }, "\u{1D73E}": { "math": "\\mbfitiota" }, "\u{1D73F}": { "math": "\\mbfitkappa" }, "\u{1D740}": { "math": "\\mbfitlambda" }, "\u{1D741}": { "math": "\\mbfitmu" }, "\u{1D742}": { "math": "\\mbfitnu" }, "\u{1D743}": { "math": "\\mbfitxi" }, "\u{1D744}": { "math": "\\mbfitomicron" }, "\u{1D745}": { "math": "\\mbfitpi" }, "\u{1D746}": { "math": "\\mbfitrho" }, "\u{1D747}": { "math": "\\mbfitvarsigma" }, "\u{1D748}": { "math": "\\mbfitsigma" }, "\u{1D749}": { "math": "\\mbfittau" }, "\u{1D74A}": { "math": "\\mbfitupsilon" }, "\u{1D74B}": { "math": "\\mbfitvarphi" }, "\u{1D74C}": { "math": "\\mbfitchi" }, "\u{1D74D}": { "math": "\\mbfitpsi" }, "\u{1D74E}": { "math": "\\mbfitomega" }, "\u{1D74F}": { "math": "\\mbfitpartial" }, "\u{1D750}": { "math": "\\mbfitepsilon" }, "\u{1D751}": { "math": "\\mbfitvartheta" }, "\u{1D752}": { "math": "\\mbfitvarkappa" }, "\u{1D753}": { "math": "\\mbfitphi" }, "\u{1D754}": { "math": "\\mbfitvarrho" }, "\u{1D755}": { "math": "\\mbfitvarpi" }, "\u{1D756}": { "math": "\\mbfsansAlpha" }, "\u{1D757}": { "math": "\\mbfsansBeta" }, "\u{1D758}": { "math": "\\mbfsansGamma" }, "\u{1D759}": { "math": "\\mbfsansDelta" }, "\u{1D75A}": { "math": "\\mbfsansEpsilon" }, "\u{1D75B}": { "math": "\\mbfsansZeta" }, "\u{1D75C}": { "math": "\\mbfsansEta" }, "\u{1D75D}": { "math": "\\mbfsansTheta" }, "\u{1D75E}": { "math": "\\mbfsansIota" }, "\u{1D75F}": { "math": "\\mbfsansKappa" }, "\u{1D760}": { "math": "\\mbfsansLambda" }, "\u{1D761}": { "math": "\\mbfsansMu" }, "\u{1D762}": { "math": "\\mbfsansNu" }, "\u{1D763}": { "math": "\\mbfsansXi" }, "\u{1D764}": { "math": "\\mbfsansOmicron" }, "\u{1D765}": { "math": "\\mbfsansPi" }, "\u{1D766}": { "math": "\\mbfsansRho" }, "\u{1D767}": { "math": "\\mbfsansvarTheta" }, "\u{1D768}": { "math": "\\mbfsansSigma" }, "\u{1D769}": { "math": "\\mbfsansTau" }, "\u{1D76A}": { "math": "\\mbfsansUpsilon" }, "\u{1D76B}": { "math": "\\mbfsansPhi" }, "\u{1D76C}": { "math": "\\mbfsansChi" }, "\u{1D76D}": { "math": "\\mbfsansPsi" }, "\u{1D76E}": { "math": "\\mbfsansOmega" }, "\u{1D76F}": { "math": "\\mbfsansnabla" }, "\u{1D770}": { "math": "\\mbfsansalpha" }, "\u{1D771}": { "math": "\\mbfsansbeta" }, "\u{1D772}": { "math": "\\mbfsansgamma" }, "\u{1D773}": { "math": "\\mbfsansdelta" }, "\u{1D774}": { "math": "\\mbfsansvarepsilon" }, "\u{1D775}": { "math": "\\mbfsanszeta" }, "\u{1D776}": { "math": "\\mbfsanseta" }, "\u{1D777}": { "math": "\\mbfsanstheta" }, "\u{1D778}": { "math": "\\mbfsansiota" }, "\u{1D779}": { "math": "\\mbfsanskappa" }, "\u{1D77A}": { "math": "\\mbfsanslambda" }, "\u{1D77B}": { "math": "\\mbfsansmu" }, "\u{1D77C}": { "math": "\\mbfsansnu" }, "\u{1D77D}": { "math": "\\mbfsansxi" }, "\u{1D77E}": { "math": "\\mbfsansomicron" }, "\u{1D77F}": { "math": "\\mbfsanspi" }, "\u{1D780}": { "math": "\\mbfsansrho" }, "\u{1D781}": { "math": "\\mbfsansvarsigma" }, "\u{1D782}": { "math": "\\mbfsanssigma" }, "\u{1D783}": { "math": "\\mbfsanstau" }, "\u{1D784}": { "math": "\\mbfsansupsilon" }, "\u{1D785}": { "math": "\\mbfsansvarphi" }, "\u{1D786}": { "math": "\\mbfsanschi" }, "\u{1D787}": { "math": "\\mbfsanspsi" }, "\u{1D788}": { "math": "\\mbfsansomega" }, "\u{1D789}": { "math": "\\mbfsanspartial" }, "\u{1D78A}": { "math": "\\mbfsansepsilon" }, "\u{1D78B}": { "math": "\\mbfsansvartheta" }, "\u{1D78C}": { "math": "\\mbfsansvarkappa" }, "\u{1D78D}": { "math": "\\mbfsansphi" }, "\u{1D78E}": { "math": "\\mbfsansvarrho" }, "\u{1D78F}": { "math": "\\mbfsansvarpi" }, "\u{1D790}": { "math": "\\mbfitsansAlpha" }, "\u{1D791}": { "math": "\\mbfitsansBeta" }, "\u{1D792}": { "math": "\\mbfitsansGamma" }, "\u{1D793}": { "math": "\\mbfitsansDelta" }, "\u{1D794}": { "math": "\\mbfitsansEpsilon" }, "\u{1D795}": { "math": "\\mbfitsansZeta" }, "\u{1D796}": { "math": "\\mbfitsansEta" }, "\u{1D797}": { "math": "\\mbfitsansTheta" }, "\u{1D798}": { "math": "\\mbfitsansIota" }, "\u{1D799}": { "math": "\\mbfitsansKappa" }, "\u{1D79A}": { "math": "\\mbfitsansLambda" }, "\u{1D79B}": { "math": "\\mbfitsansMu" }, "\u{1D79C}": { "math": "\\mbfitsansNu" }, "\u{1D79D}": { "math": "\\mbfitsansXi" }, "\u{1D79E}": { "math": "\\mbfitsansOmicron" }, "\u{1D79F}": { "math": "\\mbfitsansPi" }, "\u{1D7A0}": { "math": "\\mbfitsansRho" }, "\u{1D7A1}": { "math": "\\mbfitsansvarTheta" }, "\u{1D7A2}": { "math": "\\mbfitsansSigma" }, "\u{1D7A3}": { "math": "\\mbfitsansTau" }, "\u{1D7A4}": { "math": "\\mbfitsansUpsilon" }, "\u{1D7A5}": { "math": "\\mbfitsansPhi" }, "\u{1D7A6}": { "math": "\\mbfitsansChi" }, "\u{1D7A7}": { "math": "\\mbfitsansPsi" }, "\u{1D7A8}": { "math": "\\mbfitsansOmega" }, "\u{1D7A9}": { "math": "\\mbfitsansnabla" }, "\u{1D7AA}": { "math": "\\mbfitsansalpha" }, "\u{1D7AB}": { "math": "\\mbfitsansbeta" }, "\u{1D7AC}": { "math": "\\mbfitsansgamma" }, "\u{1D7AD}": { "math": "\\mbfitsansdelta" }, "\u{1D7AE}": { "math": "\\mbfitsansvarepsilon" }, "\u{1D7AF}": { "math": "\\mbfitsanszeta" }, "\u{1D7B0}": { "math": "\\mbfitsanseta" }, "\u{1D7B1}": { "math": "\\mbfitsanstheta" }, "\u{1D7B2}": { "math": "\\mbfitsansiota" }, "\u{1D7B3}": { "math": "\\mbfitsanskappa" }, "\u{1D7B4}": { "math": "\\mbfitsanslambda" }, "\u{1D7B5}": { "math": "\\mbfitsansmu" }, "\u{1D7B6}": { "math": "\\mbfitsansnu" }, "\u{1D7B7}": { "math": "\\mbfitsansxi" }, "\u{1D7B8}": { "math": "\\mbfitsansomicron" }, "\u{1D7B9}": { "math": "\\mbfitsanspi" }, "\u{1D7BA}": { "math": "\\mbfitsansrho" }, "\u{1D7BB}": { "math": "\\mbfitsansvarsigma" }, "\u{1D7BC}": { "math": "\\mbfitsanssigma" }, "\u{1D7BD}": { "math": "\\mbfitsanstau" }, "\u{1D7BE}": { "math": "\\mbfitsansupsilon" }, "\u{1D7BF}": { "math": "\\mbfitsansvarphi" }, "\u{1D7C0}": { "math": "\\mbfitsanschi" }, "\u{1D7C1}": { "math": "\\mbfitsanspsi" }, "\u{1D7C2}": { "math": "\\mbfitsansomega" }, "\u{1D7C3}": { "math": "\\mbfitsanspartial" }, "\u{1D7C4}": { "math": "\\mbfitsansepsilon" }, "\u{1D7C5}": { "math": "\\mbfitsansvartheta" }, "\u{1D7C6}": { "math": "\\mbfitsansvarkappa" }, "\u{1D7C7}": { "math": "\\mbfitsansphi" }, "\u{1D7C8}": { "math": "\\mbfitsansvarrho" }, "\u{1D7C9}": { "math": "\\mbfitsansvarpi" }, "\u{1D7CA}": { "math": "\\mbfDigamma" }, "\u{1D7CB}": { "math": "\\mbfdigamma" }, "\u{1D7CE}": { "math": "\\mbfzero" }, "\u{1D7CF}": { "math": "\\mbfone" }, "\u{1D7D0}": { "math": "\\mbftwo" }, "\u{1D7D1}": { "math": "\\mbfthree" }, "\u{1D7D2}": { "math": "\\mbffour" }, "\u{1D7D3}": { "math": "\\mbffive" }, "\u{1D7D4}": { "math": "\\mbfsix" }, "\u{1D7D5}": { "math": "\\mbfseven" }, "\u{1D7D6}": { "math": "\\mbfeight" }, "\u{1D7D7}": { "math": "\\mbfnine" }, "\u{1D7D8}": { "math": "\\Bbbzero" }, "\u{1D7D9}": { "math": "\\Bbbone" }, "\u{1D7DA}": { "math": "\\Bbbtwo" }, "\u{1D7DB}": { "math": "\\Bbbthree" }, "\u{1D7DC}": { "math": "\\Bbbfour" }, "\u{1D7DD}": { "math": "\\Bbbfive" }, "\u{1D7DE}": { "math": "\\Bbbsix" }, "\u{1D7DF}": { "math": "\\Bbbseven" }, "\u{1D7E0}": { "math": "\\Bbbeight" }, "\u{1D7E1}": { "math": "\\Bbbnine" }, "\u{1D7E2}": { "math": "\\msanszero" }, "\u{1D7E3}": { "math": "\\msansone" }, "\u{1D7E4}": { "math": "\\msanstwo" }, "\u{1D7E5}": { "math": "\\msansthree" }, "\u{1D7E6}": { "math": "\\msansfour" }, "\u{1D7E7}": { "math": "\\msansfive" }, "\u{1D7E8}": { "math": "\\msanssix" }, "\u{1D7E9}": { "math": "\\msansseven" }, "\u{1D7EA}": { "math": "\\msanseight" }, "\u{1D7EB}": { "math": "\\msansnine" }, "\u{1D7EC}": { "math": "\\mbfsanszero" }, "\u{1D7ED}": { "math": "\\mbfsansone" }, "\u{1D7EE}": { "math": "\\mbfsanstwo" }, "\u{1D7EF}": { "math": "\\mbfsansthree" }, "\u{1D7F0}": { "math": "\\mbfsansfour" }, "\u{1D7F1}": { "math": "\\mbfsansfive" }, "\u{1D7F2}": { "math": "\\mbfsanssix" }, "\u{1D7F3}": { "math": "\\mbfsansseven" }, "\u{1D7F4}": { "math": "\\mbfsanseight" }, "\u{1D7F5}": { "math": "\\mbfsansnine" }, "\u{1D7F6}": { "math": "\\mttzero" }, "\u{1D7F7}": { "math": "\\mttone" }, "\u{1D7F8}": { "math": "\\mtttwo" }, "\u{1D7F9}": { "math": "\\mttthree" }, "\u{1D7FA}": { "math": "\\mttfour" }, "\u{1D7FB}": { "math": "\\mttfive" }, "\u{1D7FC}": { "math": "\\mttsix" }, "\u{1D7FD}": { "math": "\\mttseven" }, "\u{1D7FE}": { "math": "\\mtteight" }, "\u{1D7FF}": { "math": "\\mttnine" }, "u\u031B\u03030": { "math": "\\arabicmaj" }, "u\u031B\u03031": { "math": "\\arabichad" }, "\u2010": { "math": "\\mathhyphen" }, "\u2015": { "math": "\\horizbar" }, "\u2017": { "math": "\\twolowline" }, "\u2025": { "math": "\\enleadertwodots" }, "\u2033": { "math": "\\dprime" }, "\u2034": { "math": "\\trprime" }, "\u2035": { "math": "\\backprime" }, "\u2036": { "math": "\\backdprime" }, "\u2037": { "math": "\\backtrprime" }, "\u2038": { "math": "\\caretinsert" }, "\u203C": { "math": "\\Exclam" }, "\u2040": { "math": "\\tieconcat" }, "\u2043": { "math": "\\hyphenbullet" }, "\u2044": { "math": "\\fracslash" }, "\u2047": { "math": "\\Question" }, "\u2050": { "math": "\\closure" }, "\u2057": { "math": "\\qprime" }, "\u20D2": { "math": "\\vertoverlay" }, "\u20D7": { "math": "\\vec" }, "\u20DB": { "math": "\\dddot" }, "\u20DC": { "math": "\\ddddot" }, "\u20DD": { "math": "\\enclosecircle" }, "\u20DE": { "math": "\\enclosesquare" }, "\u20DF": { "math": "\\enclosediamond" }, "\u20E1": { "math": "\\overleftrightarrow" }, "\u20E4": { "math": "\\enclosetriangle" }, "\u20E7": { "math": "\\annuity" }, "\u20E8": { "math": "\\threeunderdot" }, "\u20E9": { "math": "\\widebridgeabove" }, "\u20EC": { "math": "\\underrightharpoondown" }, "\u20ED": { "math": "\\underleftharpoondown" }, "\u20EE": { "math": "\\underleftarrow" }, "\u20EF": { "math": "\\underrightarrow" }, "\u20F0": { "math": "\\asteraccent" }, "\u210E": { "math": "\\Planckconst" }, "\u210F": { "math": "\\hslash" }, "\u2112": { "math": "\\mscrL" }, "\u211B": { "math": "\\mscrR" }, "\u2127": { "math": "\\mho" }, "\u2129": { "math": "\\turnediota" }, "\u2132": { "math": "\\Finv" }, "\u2136": { "math": "\\beth" }, "\u2137": { "math": "\\gimel" }, "\u2138": { "math": "\\daleth" }, "\u2141": { "math": "\\Game" }, "\u2142": { "math": "\\sansLturned" }, "\u2143": { "math": "\\sansLmirrored" }, "\u2144": { "math": "\\Yup" }, "\u2145": { "math": "\\CapitalDifferentialD" }, "\u214A": { "math": "\\PropertyLine" }, "\u2190\u0338": { "math": "\\nleftarrow" }, "\u2192\u0338": { "math": "\\nrightarrow" }, "\u219E": { "math": "\\twoheadleftarrow" }, "\u219F": { "math": "\\twoheaduparrow" }, "\u21A0": { "math": "\\twoheadrightarrow" }, "\u21A1": { "math": "\\twoheaddownarrow" }, "\u21A2": { "math": "\\leftarrowtail" }, "\u21A3": { "math": "\\rightarrowtail" }, "\u21A4": { "math": "\\mapsfrom" }, "\u21A5": { "math": "\\mapsup" }, "\u21A7": { "math": "\\mapsdown" }, "\u21A8": { "math": "\\updownarrowbar" }, "\u21AB": { "math": "\\looparrowleft" }, "\u21AC": { "math": "\\looparrowright" }, "\u21AD": { "math": "\\leftrightsquigarrow" }, "\u2194\u0338": { "math": "\\nleftrightarrow" }, "\u21B0": { "math": "\\Lsh" }, "\u21B1": { "math": "\\Rsh" }, "\u21B3": { "text": "\\reflectbox{\\carriagereturn}", "math": "\\Rdsh" }, "\u21B4": { "math": "\\linefeed" }, "\u21B5": { "math": "\\carriagereturn" }, "\u21B6": { "math": "\\curvearrowleft" }, "\u21B7": { "math": "\\curvearrowright" }, "\u21B8": { "math": "\\barovernorthwestarrow" }, "\u21B9": { "math": "\\barleftarrowrightarrowbar" }, "\u21BA": { "math": "\\circlearrowleft" }, "\u21BE": { "math": "\\upharpoonright" }, "\u21BF": { "math": "\\upharpoonleft" }, "\u21C1": { "math": "\\rightharpoondown" }, "\u21C2": { "math": "\\downharpoonright" }, "\u21C3": { "math": "\\downharpoonleft" }, "\u21C4": { "math": "\\rightleftarrows" }, "\u21C6": { "math": "\\leftrightarrows" }, "\u21C7": { "math": "\\leftleftarrows" }, "\u21C8": { "math": "\\upuparrows" }, "\u21C9": { "math": "\\rightrightarrows" }, "\u21CA": { "math": "\\downdownarrows" }, "\u21CB": { "math": "\\leftrightharpoons" }, "\u21D0\u0338": { "math": "\\nLeftarrow" }, "\u21D4\u0338": { "math": "\\nLeftrightarrow" }, "\u21D2\u0338": { "math": "\\nRightarrow" }, "\u21D6": { "math": "\\Nwarrow" }, "\u21D7": { "math": "\\Nearrow" }, "\u21D8": { "math": "\\Searrow" }, "\u21D9": { "math": "\\Swarrow" }, "\u21DA": { "math": "\\Lleftarrow" }, "\u21DB": { "math": "\\Rrightarrow" }, "\u21DC": { "math": "\\leftsquigarrow" }, "\u21DD": { "math": "\\rightsquigarrow" }, "\u21DE": { "math": "\\nHuparrow" }, "\u21DF": { "math": "\\nHdownarrow" }, "\u21E1": { "math": "\\updasharrow" }, "\u21E3": { "math": "\\downdasharrow" }, "\u21E6": { "math": "\\leftwhitearrow" }, "\u21E7": { "math": "\\upwhitearrow" }, "\u21E8": { "math": "\\rightwhitearrow" }, "\u21E9": { "math": "\\downwhitearrow" }, "\u21EA": { "math": "\\whitearrowupfrombar" }, "\u21F4": { "math": "\\circleonrightarrow" }, "\u21F6": { "math": "\\rightthreearrows" }, "\u21F7": { "math": "\\nvleftarrow" }, "\u21F9": { "math": "\\nvleftrightarrow" }, "\u21FA": { "math": "\\nVleftarrow" }, "\u21FC": { "math": "\\nVleftrightarrow" }, "\u21FD": { "math": "\\leftarrowtriangle" }, "\u21FE": { "math": "\\rightarrowtriangle" }, "\u21FF": { "math": "\\leftrightarrowtriangle" }, "\u2201": { "math": "\\complement" }, "\u2203\u0338": { "math": "\\nexists" }, "\u2205": { "math": "\\varnothing" }, "\u2206": { "math": "\\increment" }, "\u2207": { "math": "\\nabla" }, "\u220A": { "math": "\\smallin" }, "\u220D": { "math": "\\smallni" }, "\u220E": { "math": "\\QED" }, "\u2214": { "math": "\\dotplus" }, "\u2215": { "math": "\\divslash" }, "\u221A": { "math": "\\sqrt" }, "\u221F": { "math": "\\rightangle" }, "\u2221": { "math": "\\measuredangle" }, "\u2222": { "math": "\\sphericalangle" }, "\u2223\u0338": { "math": "\\nmid" }, "\u2225\u0338": { "math": "\\nparallel" }, "\u2232": { "math": "\\lcirclerightint" }, "\u2234": { "math": "\\therefore" }, "\u2235": { "math": "\\because" }, "\u2237": { "math": "\\Colon" }, "\u2239": { "math": "\\eqcolon" }, "\u223D": { "math": "\\backsim" }, "\u224A": { "math": "\\approxeq" }, "\u224E": { "math": "\\Bumpeq" }, "\u224F": { "math": "\\bumpeq" }, "\u2252": { "math": "\\fallingdotseq" }, "\u2253": { "math": "\\risingdotseq" }, "\u2254": { "math": "\\coloneq" }, "\u2256": { "math": "\\eqcirc" }, "\u2257": { "math": "\\circeq" }, "\u2258": { "math": "\\arceq" }, "\u225A": { "math": "\\veeeq" }, "\u225C": { "math": "\\triangleq" }, "\u225D": { "math": "\\eqdef" }, "\u225E": { "math": "\\measeq" }, "\u225F": { "math": "\\questeq" }, "\u2263": { "math": "\\Equiv" }, "\u2268": { "math": "\\lneqq" }, "\u2269": { "math": "\\gneqq" }, "\u226C": { "math": "\\between" }, "\u224D\u0338": { "math": "\\nasymp" }, "\u2272\u0338": { "math": "\\nlesssim" }, "\u2273\u0338": { "math": "\\ngtrsim" }, "\u2276": { "math": "\\lessgtr" }, "\u2277": { "math": "\\gtrless" }, "\u227C": { "math": "\\preccurlyeq" }, "\u227D": { "math": "\\succcurlyeq" }, "\u228A": { "math": "\\subsetneq" }, "\u228B": { "math": "\\supsetneq" }, "\u228C": { "math": "\\cupleftarrow" }, "\u228D": { "math": "\\cupdot" }, "\u228F": { "math": "\\sqsubset" }, "\u2290": { "math": "\\sqsupset" }, "\u229A": { "math": "\\circledcirc" }, "\u229B": { "math": "\\circledast" }, "\u229C": { "math": "\\circledequal" }, "\u229D": { "math": "\\circleddash" }, "\u229E": { "math": "\\boxplus" }, "\u229F": { "math": "\\boxminus" }, "\u22A0": { "math": "\\boxtimes" }, "\u22A1": { "math": "\\boxdot" }, "\u22A6": { "math": "\\assert" }, "\u22A9": { "math": "\\Vdash" }, "\u22AA": { "math": "\\Vvdash" }, "\u22AB": { "math": "\\VDash" }, "\u22A2\u0338": { "math": "\\nvdash" }, "\u22A8\u0338": { "math": "\\nvDash" }, "\u22A9\u0338": { "math": "\\nVdash" }, "\u22AB\u0338": { "math": "\\nVDash" }, "\u22B0": { "math": "\\prurel" }, "\u22B1": { "math": "\\scurel" }, "\u22B2": { "math": "\\vartriangleleft" }, "\u22B3": { "math": "\\vartriangleright" }, "\u22B4": { "math": "\\trianglelefteq" }, "\u22B5": { "math": "\\trianglerighteq" }, "\u22B8": { "math": "\\multimap" }, "\u22BA": { "math": "\\intercal" }, "\u22BB": { "math": "\\veebar" }, "\u22BC": { "math": "\\barwedge" }, "\u22BD": { "math": "\\barvee" }, "\u22BF": { "math": "\\varlrtriangle" }, "\u22C7": { "math": "\\divideontimes" }, "\u22C9": { "math": "\\ltimes" }, "\u22CA": { "math": "\\rtimes" }, "\u22CB": { "math": "\\leftthreetimes" }, "\u22CC": { "math": "\\rightthreetimes" }, "\u22CD": { "math": "\\backsimeq" }, "\u22CE": { "math": "\\curlyvee" }, "\u22CF": { "math": "\\curlywedge" }, "\u22D0": { "math": "\\Subset" }, "\u22D1": { "math": "\\Supset" }, "\u22D2": { "math": "\\Cap" }, "\u22D3": { "math": "\\Cup" }, "\u22D4": { "math": "\\pitchfork" }, "\u22D5": { "math": "\\hash" }, "\u22D6": { "math": "\\lessdot" }, "\u22D7": { "math": "\\gtrdot" }, "\u22DA": { "math": "\\lesseqgtr" }, "\u22DB": { "math": "\\gtreqless" }, "\u22DC": { "math": "\\eqless" }, "\u22DD": { "math": "\\eqgtr" }, "\u22DE": { "math": "\\curlyeqprec" }, "\u22DF": { "math": "\\curlyeqsucc" }, "\u227C\u0338": { "math": "\\npreceq" }, "\u227D\u0338": { "math": "\\nsucceq" }, "\u22E4": { "math": "\\sqsubsetneq" }, "\u22E5": { "math": "\\sqsupsetneq" }, "\u22E6": { "math": "\\lnsim" }, "\u22E7": { "math": "\\gnsim" }, "\u22E8": { "math": "\\precedesnotsimilar" }, "\u22E9": { "math": "\\succnsim" }, "\u22B4\u0338": { "math": "\\ntrianglelefteq" }, "\u22B5\u0338": { "math": "\\ntrianglerighteq" }, "\u22F2": { "math": "\\disin" }, "\u22F3": { "math": "\\varisins" }, "\u22F4": { "math": "\\isins" }, "\u22F5": { "math": "\\isindot" }, "\u22F7": { "math": "\\isinobar" }, "\u22F8": { "math": "\\isinvb" }, "\u22F9": { "math": "\\isinE" }, "\u22FA": { "math": "\\nisd" }, "\u22FB": { "math": "\\varnis" }, "\u22FC": { "math": "\\nis" }, "\u22FD": { "math": "\\varniobar" }, "\u22FE": { "math": "\\niobar" }, "\u22FF": { "math": "\\bagmember" }, "\u2300": { "math": "\\diameter" }, "\u2302": { "math": "\\house" }, "\u2305": { "text": "\\barwedge", "math": "\\varbarwedge", "macrospacer": true }, "\u2310": { "math": "\\invneg" }, "\u2312": { "math": "\\profline" }, "\u2313": { "math": "\\profsurf" }, "\u2317": { "math": "\\viewdata" }, "\u2319": { "math": "\\turnednot" }, "\u231C": { "math": "\\ulcorner" }, "\u231D": { "math": "\\urcorner" }, "\u231E": { "math": "\\llcorner" }, "\u231F": { "math": "\\lrcorner" }, "\u2320": { "math": "\\inttop" }, "\u2321": { "math": "\\intbottom" }, "\u232C": { "math": "\\varhexagonlrbonds" }, "\u2332": { "math": "\\conictaper" }, "\u2336": { "math": "\\topbot" }, "\u233D": { "math": "\\obar" }, "\u2353": { "math": "\\APLboxupcaret" }, "\u2370": { "math": "\\APLboxquestion" }, "\u237C": { "math": "\\rangledownzigzagarrow" }, "\u2394": { "math": "\\hexagon" }, "\u239B": { "math": "\\lparenuend" }, "\u239C": { "math": "\\lparenextender" }, "\u239D": { "math": "\\lparenlend" }, "\u239E": { "math": "\\rparenuend" }, "\u239F": { "math": "\\rparenextender" }, "\u23A0": { "math": "\\rparenlend" }, "\u23A1": { "math": "\\lbrackuend" }, "\u23A2": { "math": "\\lbrackextender" }, "\u23A3": { "math": "\\lbracklend" }, "\u23A4": { "math": "\\rbrackuend" }, "\u23A5": { "math": "\\rbrackextender" }, "\u23A6": { "math": "\\rbracklend" }, "\u23A7": { "math": "\\lbraceuend" }, "\u23A8": { "math": "\\lbracemid" }, "\u23A9": { "math": "\\lbracelend" }, "\u23AA": { "math": "\\vbraceextender" }, "\u23AB": { "math": "\\rbraceuend" }, "\u23AC": { "math": "\\rbracemid" }, "\u23AD": { "math": "\\rbracelend" }, "\u23AE": { "math": "\\intextender" }, "\u23AF": { "math": "\\harrowextender" }, "\u23B2": { "math": "\\sumtop" }, "\u23B3": { "math": "\\sumbottom" }, "\u23B4": { "math": "\\overbracket" }, "\u23B5": { "math": "\\underbracket" }, "\u23B6": { "math": "\\bbrktbrk" }, "\u23B7": { "math": "\\sqrtbottom" }, "\u23B8": { "math": "\\lvboxline" }, "\u23B9": { "math": "\\rvboxline" }, "\u23CE": { "math": "\\varcarriagereturn" }, "\u23DC": { "math": "\\overparen" }, "\u23DD": { "math": "\\underparen" }, "\u23DE": { "math": "\\overbrace" }, "\u23DF": { "math": "\\underbrace" }, "\u23E0": { "math": "\\obrbrak" }, "\u23E1": { "math": "\\ubrbrak" }, "\u23E2": { "math": "\\trapezium" }, "\u23E3": { "math": "\\benzenr" }, "\u23E4": { "math": "\\strns" }, "\u23E5": { "math": "\\fltns" }, "\u23E6": { "math": "\\accurrent" }, "\u23E7": { "math": "\\elinters" }, "\u2422": { "math": "\\blanksymbol" }, "\u2423": { "math": "\\mathvisiblespace" }, "\u2506": { "math": "\\bdtriplevdash" }, "\u2580": { "math": "\\blockuphalf" }, "\u2584": { "math": "\\blocklowhalf" }, "\u2588": { "math": "\\blockfull" }, "\u258C": { "math": "\\blocklefthalf" }, "\u2590": { "math": "\\blockrighthalf" }, "\u2591": { "math": "\\blockqtrshaded" }, "\u2592": { "math": "\\blockhalfshaded" }, "\u2593": { "math": "\\blockthreeqtrshaded" }, "\u25A0": { "math": "\\mdlgblksquare" }, "\u25A2": { "math": "\\squoval" }, "\u25A3": { "math": "\\blackinwhitesquare" }, "\u25A4": { "math": "\\squarehfill" }, "\u25A5": { "math": "\\squarevfill" }, "\u25A6": { "math": "\\squarehvfill" }, "\u25A7": { "math": "\\squarenwsefill" }, "\u25A8": { "math": "\\squareneswfill" }, "\u25A9": { "math": "\\squarecrossfill" }, "\u25AA": { "math": "\\smblksquare" }, "\u25AB": { "math": "\\smwhtsquare" }, "\u25AC": { "math": "\\hrectangleblack" }, "\u25AD": { "math": "\\hrectangle" }, "\u25AE": { "math": "\\vrectangleblack" }, "\u25AF": { "math": "\\vrectangle" }, "\u25B0": { "math": "\\parallelogramblack" }, "\u25B1": { "math": "\\parallelogram" }, "\u25B2": { "math": "\\bigblacktriangleup" }, "\u25B3": { "math": "\\bigtriangleup" }, "\u25B4": { "math": "\\blacktriangle" }, "\u25B5": { "math": "\\vartriangle" }, "\u25B8": { "math": "\\smallblacktriangleright" }, "\u25B9": { "math": "\\smalltriangleright" }, "\u25BA": { "math": "\\blackpointerright" }, "\u25BB": { "math": "\\whitepointerright" }, "\u25BC": { "math": "\\bigblacktriangledown" }, "\u25BE": { "math": "\\blacktriangledown" }, "\u25BF": { "math": "\\triangledown" }, "\u25C2": { "math": "\\smallblacktriangleleft" }, "\u25C3": { "math": "\\smalltriangleleft" }, "\u25C4": { "math": "\\blackpointerleft" }, "\u25C5": { "math": "\\whitepointerleft" }, "\u25C8": { "math": "\\blackinwhitediamond" }, "\u25C9": { "math": "\\fisheye" }, "\u25CA": { "math": "\\lozenge" }, "\u25CC": { "math": "\\dottedcircle" }, "\u25CD": { "math": "\\circlevertfill" }, "\u25CE": { "math": "\\bullseye" }, "\u25D0": { "math": "\\circlelefthalfblack" }, "\u25D1": { "math": "\\circlerighthalfblack" }, "\u25D2": { "math": "\\circlebottomhalfblack" }, "\u25D3": { "math": "\\circletophalfblack" }, "\u25D4": { "math": "\\circleurquadblack" }, "\u25D5": { "math": "\\blackcircleulquadwhite" }, "\u25D6": { "math": "\\blacklefthalfcircle" }, "\u25D7": { "math": "\\blackrighthalfcircle" }, "\u25D8": { "math": "\\inversebullet" }, "\u25D9": { "math": "\\inversewhitecircle" }, "\u25DA": { "math": "\\invwhiteupperhalfcircle" }, "\u25DB": { "math": "\\invwhitelowerhalfcircle" }, "\u25DC": { "math": "\\ularc" }, "\u25DD": { "math": "\\urarc" }, "\u25DE": { "math": "\\lrarc" }, "\u25DF": { "math": "\\llarc" }, "\u25E0": { "math": "\\topsemicircle" }, "\u25E1": { "math": "\\botsemicircle" }, "\u25E2": { "math": "\\lrblacktriangle" }, "\u25E3": { "math": "\\llblacktriangle" }, "\u25E4": { "math": "\\ulblacktriangle" }, "\u25E5": { "math": "\\urblacktriangle" }, "\u25E6": { "math": "\\smwhtcircle" }, "\u25E7": { "math": "\\squareleftblack" }, "\u25E8": { "math": "\\squarerightblack" }, "\u25E9": { "math": "\\squareulblack" }, "\u25EA": { "math": "\\squarelrblack" }, "\u25EB": { "math": "\\boxbar" }, "\u25EC": { "math": "\\trianglecdot" }, "\u25ED": { "math": "\\triangleleftblack" }, "\u25EE": { "math": "\\trianglerightblack" }, "\u25F0": { "math": "\\squareulquad" }, "\u25F1": { "math": "\\squarellquad" }, "\u25F2": { "math": "\\squarelrquad" }, "\u25F3": { "math": "\\squareurquad" }, "\u25F4": { "math": "\\circleulquad" }, "\u25F5": { "math": "\\circlellquad" }, "\u25F6": { "math": "\\circlelrquad" }, "\u25F7": { "math": "\\circleurquad" }, "\u25F8": { "math": "\\ultriangle" }, "\u25F9": { "math": "\\urtriangle" }, "\u25FA": { "math": "\\lltriangle" }, "\u25FB": { "math": "\\mdwhtsquare" }, "\u25FC": { "math": "\\mdblksquare" }, "\u25FD": { "math": "\\mdsmwhtsquare" }, "\u25FE": { "math": "\\mdsmblksquare" }, "\u25FF": { "math": "\\lrtriangle" }, "\u2605": { "math": "\\bigstar" }, "\u2606": { "math": "\\bigwhitestar" }, "\u2621": { "math": "\\danger" }, "\u263B": { "math": "\\blacksmiley" }, "\u263C": { "math": "\\sun" }, "\u263D": { "math": "\\rightmoon" }, "\u263E": { "math": "\\leftmoon" }, "\u2640": { "math": "\\female" }, "\u2642": { "math": "\\male" }, "\u2664": { "math": "\\varspadesuit" }, "\u2665": { "math": "\\varheartsuit" }, "\u2666": { "math": "\\vardiamondsuit" }, "\u2667": { "math": "\\varclubsuit" }, "\u2669": { "math": "\\quarternote" }, "\u266A": { "math": "\\eighthnote" }, "\u266B": { "math": "\\twonotes" }, "\u266C": { "math": "\\sixteenthnote" }, "\u267E": { "math": "\\acidfree" }, "\u2680": { "math": "\\dicei" }, "\u2681": { "math": "\\diceii" }, "\u2682": { "math": "\\diceiii" }, "\u2683": { "math": "\\diceiv" }, "\u2684": { "math": "\\dicev" }, "\u2685": { "math": "\\dicevi" }, "\u2686": { "math": "\\circledrightdot" }, "\u2687": { "math": "\\circledtwodots" }, "\u2688": { "math": "\\blackcircledrightdot" }, "\u2689": { "math": "\\blackcircledtwodots" }, "\u26A5": { "math": "\\Hermaphrodite" }, "\u26AC": { "math": "\\mdsmwhtcircle" }, "\u26B2": { "math": "\\neuter" }, "\u2713": { "math": "\\checkmark" }, "\u2720": { "math": "\\maltese" }, "\u272A": { "math": "\\circledstar" }, "\u2736": { "math": "\\varstar" }, "\u273D": { "math": "\\dingasterisk" }, "\u2772": { "math": "\\lbrbrak" }, "\u2773": { "math": "\\rbrbrak" }, "\u279B": { "math": "\\draftingarrow" }, "\u27C0": { "math": "\\threedangle" }, "\u27C1": { "math": "\\whiteinwhitetriangle" }, "\u27C3": { "math": "\\subsetcirc" }, "\u27C4": { "math": "\\supsetcirc" }, "\u27C7": { "math": "\\veedot" }, "\u27C8": { "math": "\\bsolhsub" }, "\u27C9": { "math": "\\suphsol" }, "\u27CB": { "math": "\\diagup" }, "\u27CC": { "math": "\\longdivision" }, "\u27CD": { "math": "\\diagdown" }, "\u27D1": { "math": "\\wedgedot" }, "\u27D2": { "math": "\\upin" }, "\u27D3": { "math": "\\pullback" }, "\u27D4": { "math": "\\pushout" }, "\u27D5": { "math": "\\leftouterjoin" }, "\u27D6": { "math": "\\rightouterjoin" }, "\u27D7": { "math": "\\fullouterjoin" }, "\u27D8": { "math": "\\bigbot" }, "\u27D9": { "math": "\\bigtop" }, "\u27DA": { "math": "\\DashVDash" }, "\u27DB": { "math": "\\dashVdash" }, "\u27DC": { "math": "\\multimapinv" }, "\u27DD": { "math": "\\vlongdash" }, "\u27DE": { "math": "\\longdashv" }, "\u27DF": { "math": "\\cirbot" }, "\u27E0": { "math": "\\lozengeminus" }, "\u27E1": { "math": "\\concavediamond" }, "\u27E2": { "math": "\\concavediamondtickleft" }, "\u27E3": { "math": "\\concavediamondtickright" }, "\u27E4": { "math": "\\whitesquaretickleft" }, "\u27E5": { "math": "\\whitesquaretickright" }, "\u27EB": { "math": "\\rang" }, "\u27EC": { "math": "\\Lbrbrak" }, "\u27ED": { "math": "\\Rbrbrak" }, "\u27F0": { "math": "\\UUparrow" }, "\u27F1": { "math": "\\DDownarrow" }, "\u27F2": { "math": "\\acwgapcirclearrow" }, "\u27F3": { "math": "\\cwgapcirclearrow" }, "\u27F4": { "math": "\\rightarrowonoplus" }, "\u27FB": { "math": "\\longmapsfrom" }, "\u27FD": { "math": "\\Longmapsfrom" }, "\u27FE": { "math": "\\Longmapsto" }, "\u27FF": { "math": "\\longrightsquigarrow" }, "\u2901": { "math": "\\nVtwoheadrightarrow" }, "\u2902": { "math": "\\nvLeftarrow" }, "\u2903": { "math": "\\nvRightarrow" }, "\u2904": { "math": "\\nvLeftrightarrow" }, "\u2905": { "math": "\\twoheadmapsto" }, "\u2906": { "math": "\\Mapsfrom" }, "\u2907": { "math": "\\Mapsto" }, "\u2908": { "math": "\\downarrowbarred" }, "\u2909": { "math": "\\uparrowbarred" }, "\u290A": { "math": "\\Uuparrow" }, "\u290B": { "math": "\\Ddownarrow" }, "\u290C": { "math": "\\leftbkarrow" }, "\u290D": { "math": "\\rightbkarrow" }, "\u290E": { "math": "\\leftdbkarrow" }, "\u290F": { "math": "\\dbkarrow" }, "\u2910": { "math": "\\drbkarrow" }, "\u2911": { "math": "\\rightdotarrow" }, "\u2917": { "math": "\\nvtwoheadrightarrowtail" }, "\u2918": { "math": "\\nVtwoheadrightarrowtail" }, "\u2919": { "math": "\\lefttail" }, "\u291A": { "math": "\\righttail" }, "\u291B": { "math": "\\leftdbltail" }, "\u291C": { "math": "\\rightdbltail" }, "\u291D": { "math": "\\diamondleftarrow" }, "\u291E": { "math": "\\rightarrowdiamond" }, "\u291F": { "math": "\\diamondleftarrowbar" }, "\u2920": { "math": "\\barrightarrowdiamond" }, "\u2921": { "math": "\\nwsearrow" }, "\u2922": { "math": "\\neswarrow" }, "\u2923": { "math": "\\hknwarrow" }, "\u2924": { "math": "\\hknearrow" }, "\u2925": { "math": "\\hksearrow" }, "\u2926": { "math": "\\hkswarrow" }, "\u2927": { "math": "\\tona" }, "\u2928": { "math": "\\toea" }, "\u2929": { "math": "\\tosa" }, "\u292A": { "math": "\\towa" }, "\u292B": { "math": "\\rdiagovfdiag" }, "\u292C": { "math": "\\fdiagovrdiag" }, "\u292D": { "math": "\\seovnearrow" }, "\u292E": { "math": "\\neovsearrow" }, "\u292F": { "math": "\\fdiagovnearrow" }, "\u2930": { "math": "\\rdiagovsearrow" }, "\u2931": { "math": "\\neovnwarrow" }, "\u2932": { "math": "\\nwovnearrow" }, "\u2933": { "math": "\\rightcurvedarrow" }, "\u2934": { "math": "\\uprightcurvearrow" }, "\u2935": { "math": "\\downrightcurvedarrow" }, "\u2936": { "math": "\\leftdowncurvedarrow" }, "\u2937": { "math": "\\rightdowncurvedarrow" }, "\u2938": { "math": "\\cwrightarcarrow" }, "\u2939": { "math": "\\acwleftarcarrow" }, "\u293A": { "math": "\\acwoverarcarrow" }, "\u293B": { "math": "\\acwunderarcarrow" }, "\u293C": { "math": "\\curvearrowrightminus" }, "\u293D": { "math": "\\curvearrowleftplus" }, "\u293E": { "math": "\\cwundercurvearrow" }, "\u293F": { "math": "\\ccwundercurvearrow" }, "\u2942": { "math": "\\rightarrowshortleftarrow" }, "\u2943": { "math": "\\leftarrowshortrightarrow" }, "\u2944": { "math": "\\shortrightarrowleftarrow" }, "\u2945": { "math": "\\rightarrowplus" }, "\u2946": { "math": "\\leftarrowplus" }, "\u2947": { "math": "\\rightarrowx" }, "\u2948": { "math": "\\leftrightarrowcircle" }, "\u2949": { "math": "\\twoheaduparrowcircle" }, "\u294C": { "math": "\\updownharpoonrightleft" }, "\u294D": { "math": "\\updownharpoonleftright" }, "\u294E": { "math": "\\leftrightharpoonupup" }, "\u2950": { "math": "\\DownLeftRightVector" }, "\u2966": { "math": "\\leftrightharpoonsup" }, "\u2967": { "math": "\\leftrightharpoonsdown" }, "\u2968": { "math": "\\rightleftharpoonsup" }, "\u2969": { "math": "\\rightleftharpoonsdown" }, "\u2971": { "math": "\\equalrightarrow" }, "\u2972": { "math": "\\similarrightarrow" }, "\u2973": { "math": "\\leftarrowsimilar" }, "\u2974": { "math": "\\rightarrowsimilar" }, "\u2975": { "math": "\\rightarrowapprox" }, "\u2976": { "math": "\\ltlarr" }, "\u2977": { "math": "\\leftarrowless" }, "\u2978": { "math": "\\gtrarr" }, "\u2979": { "math": "\\subrarr" }, "\u297A": { "math": "\\leftarrowsubset" }, "\u297B": { "math": "\\suplarr" }, "\u297C": { "math": "\\leftfishtail" }, "\u297D": { "math": "\\rightfishtail" }, "\u297E": { "math": "\\upfishtail" }, "\u297F": { "math": "\\downfishtail" }, "\u2980": { "math": "\\Vvert" }, "\u2981": { "math": "\\spot" }, "\u2982": { "math": "\\typecolon" }, "\u2983": { "math": "\\lBrace" }, "\u2984": { "math": "\\rBrace" }, "\u2985": { "math": "\\lParen" }, "\u2986": { "math": "\\Elroang" }, "\u2987": { "math": "\\limg" }, "\u298B": { "math": "\\lbrackubar" }, "\u298C": { "math": "\\rbrackubar" }, "\u298D": { "math": "\\lbrackultick" }, "\u298E": { "math": "\\rbracklrtick" }, "\u298F": { "math": "\\lbracklltick" }, "\u2990": { "math": "\\rbrackurtick" }, "\u2991": { "math": "\\langledot" }, "\u2992": { "math": "\\rangledot" }, "\u2993": { "math": "\\lparenless" }, "\u2994": { "math": "\\rparengtr" }, "\u2995": { "math": "\\Lparengtr" }, "\u2996": { "math": "\\Rparenless" }, "\u2997": { "math": "\\lblkbrbrak" }, "\u2998": { "math": "\\rblkbrbrak" }, "\u2999": { "math": "\\fourvdots" }, "\u299A": { "math": "\\vzigzag" }, "\u299B": { "math": "\\measuredangleleft" }, "\u299D": { "math": "\\rightanglemdot" }, "\u299E": { "math": "\\angles" }, "\u299F": { "math": "\\angdnr" }, "\u29A0": { "math": "\\gtlpar" }, "\u29A1": { "math": "\\sphericalangleup" }, "\u29A2": { "math": "\\turnangle" }, "\u29A3": { "math": "\\revangle" }, "\u29A4": { "math": "\\angleubar" }, "\u29A5": { "math": "\\revangleubar" }, "\u29A6": { "math": "\\wideangledown" }, "\u29A7": { "math": "\\wideangleup" }, "\u29A8": { "math": "\\measanglerutone" }, "\u29A9": { "math": "\\measanglelutonw" }, "\u29AA": { "math": "\\measanglerdtose" }, "\u29AB": { "math": "\\measangleldtosw" }, "\u29AC": { "math": "\\measangleurtone" }, "\u29AD": { "math": "\\measangleultonw" }, "\u29AE": { "math": "\\measangledrtose" }, "\u29AF": { "math": "\\measangledltosw" }, "\u29B0": { "math": "\\revemptyset" }, "\u29B1": { "math": "\\emptysetobar" }, "\u29B2": { "math": "\\emptysetocirc" }, "\u29B3": { "math": "\\emptysetoarr" }, "\u29B4": { "math": "\\emptysetoarrl" }, "\u29B5": { "math": "\\circlehbar" }, "\u29B6": { "math": "\\circledvert" }, "\u29B7": { "math": "\\circledparallel" }, "\u29B8": { "math": "\\circledbslash" }, "\u29B9": { "math": "\\operp" }, "\u29BA": { "math": "\\obot" }, "\u29BB": { "math": "\\olcross" }, "\u29BC": { "math": "\\odotslashdot" }, "\u29BD": { "math": "\\uparrowoncircle" }, "\u29BE": { "math": "\\circledwhitebullet" }, "\u29BF": { "math": "\\circledbullet" }, "\u29C0": { "math": "\\circledless" }, "\u29C1": { "math": "\\circledgtr" }, "\u29C2": { "math": "\\cirscir" }, "\u29C3": { "math": "\\cirE" }, "\u29C5": { "math": "\\boxbslash" }, "\u29C6": { "math": "\\boxast" }, "\u29C7": { "math": "\\boxcircle" }, "\u29C8": { "math": "\\boxbox" }, "\u29C9": { "math": "\\boxonbox" }, "\u29CA": { "math": "\\triangleodot" }, "\u29CB": { "math": "\\triangleubar" }, "\u29CC": { "math": "\\triangles" }, "\u29CD": { "math": "\\triangleserifs" }, "\u29CE": { "math": "\\rtriltri" }, "\u29D1": { "math": "\\lfbowtie" }, "\u29D2": { "math": "\\rfbowtie" }, "\u29D3": { "math": "\\fbowtie" }, "\u29D4": { "math": "\\lftimes" }, "\u29D5": { "math": "\\rftimes" }, "\u29D6": { "math": "\\hourglass" }, "\u29D7": { "math": "\\blackhourglass" }, "\u29D8": { "math": "\\lvzigzag" }, "\u29D9": { "math": "\\rvzigzag" }, "\u29DA": { "math": "\\Lvzigzag" }, "\u29DB": { "math": "\\Rvzigzag" }, "\u29DC": { "math": "\\iinfin" }, "\u29DD": { "math": "\\tieinfty" }, "\u29DE": { "math": "\\nvinfty" }, "\u29E0": { "math": "\\laplac" }, "\u29E1": { "math": "\\lrtriangleeq" }, "\u29E2": { "math": "\\shuffle" }, "\u29E3": { "math": "\\eparsl" }, "\u29E4": { "math": "\\smeparsl" }, "\u29E5": { "math": "\\eqvparsl" }, "\u29E6": { "math": "\\gleichstark" }, "\u29E7": { "math": "\\thermod" }, "\u29E8": { "math": "\\downtriangleleftblack" }, "\u29E9": { "math": "\\downtrianglerightblack" }, "\u29EA": { "math": "\\blackdiamonddownarrow" }, "\u29EB": { "math": "\\blacklozenge" }, "\u29EC": { "math": "\\circledownarrow" }, "\u29ED": { "math": "\\blackcircledownarrow" }, "\u29EE": { "math": "\\errbarsquare" }, "\u29EF": { "math": "\\errbarblacksquare" }, "\u29F0": { "math": "\\errbardiamond" }, "\u29F1": { "math": "\\errbarblackdiamond" }, "\u29F2": { "math": "\\errbarcircle" }, "\u29F3": { "math": "\\errbarblackcircle" }, "\u29F4": { "math": "\\RuleDelayed" }, "\u29F6": { "math": "\\dsol" }, "\u29F7": { "math": "\\rsolbar" }, "\u29F8": { "math": "\\xsol" }, "\u29FA": { "math": "\\doubleplus" }, "\u29FB": { "math": "\\tripleplus" }, "\u29FC": { "math": "\\lcurvyangle" }, "\u29FD": { "math": "\\rcurvyangle" }, "\u29FE": { "math": "\\tplus" }, "\u29FF": { "math": "\\tminus" }, "\u2A03": { "math": "\\bigcupdot" }, "\u2A04": { "math": "\\Elxuplus" }, "\u2A05": { "math": "\\bigsqcap" }, "\u2A07": { "math": "\\conjquant" }, "\u2A08": { "math": "\\disjquant" }, "\u2A0A": { "math": "\\modtwosum" }, "\u2A0B": { "math": "\\sumint" }, "\u2A0C": { "math": "\\iiiint" }, "\u2A0D": { "math": "\\intbar" }, "\u2A0E": { "math": "\\intBar" }, "\u2A10": { "math": "\\cirfnint" }, "\u2A11": { "math": "\\awint" }, "\u2A12": { "math": "\\rppolint" }, "\u2A13": { "math": "\\scpolint" }, "\u2A14": { "math": "\\npolint" }, "\u2A15": { "math": "\\pointint" }, "\u2A17": { "math": "\\intlarhk" }, "\u2A18": { "math": "\\intx" }, "\u2A19": { "math": "\\intcap" }, "\u2A1A": { "math": "\\intcup" }, "\u2A1B": { "math": "\\upint" }, "\u2A1C": { "math": "\\lowint" }, "\u2A1D": { "math": "\\Join" }, "\u2A1E": { "math": "\\bigtriangleleft" }, "\u2A1F": { "math": "\\zcmp" }, "\u2A20": { "math": "\\zpipe" }, "\u2A21": { "math": "\\zproject" }, "\u2A22": { "math": "\\ringplus" }, "\u2A23": { "math": "\\plushat" }, "\u2A24": { "math": "\\simplus" }, "\u2A25": { "math": "\\plusdot" }, "\u2A26": { "math": "\\plussim" }, "\u2A27": { "math": "\\plussubtwo" }, "\u2A28": { "math": "\\plustrif" }, "\u2A29": { "math": "\\commaminus" }, "\u2A2A": { "math": "\\minusdot" }, "\u2A2B": { "math": "\\minusfdots" }, "\u2A2C": { "math": "\\minusrdots" }, "\u2A2D": { "math": "\\opluslhrim" }, "\u2A2E": { "math": "\\oplusrhrim" }, "\u2A2F": { "math": "\\vectimes" }, "\u2A30": { "math": "\\dottimes" }, "\u2A31": { "math": "\\timesbar" }, "\u2A32": { "math": "\\btimes" }, "\u2A33": { "math": "\\smashtimes" }, "\u2A34": { "math": "\\otimeslhrim" }, "\u2A35": { "math": "\\otimesrhrim" }, "\u2A36": { "math": "\\otimeshat" }, "\u2A37": { "math": "\\Otimes" }, "\u2A38": { "math": "\\odiv" }, "\u2A39": { "math": "\\triangleplus" }, "\u2A3A": { "math": "\\triangleminus" }, "\u2A3B": { "math": "\\triangletimes" }, "\u2A3C": { "math": "\\intprod" }, "\u2A3D": { "math": "\\intprodr" }, "\u2A3E": { "math": "\\fcmp" }, "\u2A40": { "math": "\\capdot" }, "\u2A41": { "math": "\\uminus" }, "\u2A42": { "math": "\\barcup" }, "\u2A43": { "math": "\\barcap" }, "\u2A44": { "math": "\\capwedge" }, "\u2A45": { "math": "\\cupvee" }, "\u2A46": { "math": "\\cupovercap" }, "\u2A47": { "math": "\\capovercup" }, "\u2A48": { "math": "\\cupbarcap" }, "\u2A49": { "math": "\\capbarcup" }, "\u2A4A": { "math": "\\twocups" }, "\u2A4B": { "math": "\\twocaps" }, "\u2A4C": { "math": "\\closedvarcup" }, "\u2A4D": { "math": "\\closedvarcap" }, "\u2A4E": { "math": "\\Sqcap" }, "\u2A4F": { "math": "\\Sqcup" }, "\u2A50": { "math": "\\closedvarcupsmashprod" }, "\u2A51": { "math": "\\wedgeodot" }, "\u2A52": { "math": "\\veeodot" }, "\u2A53": { "math": "\\Wedge" }, "\u2A54": { "math": "\\Vee" }, "\u2A55": { "math": "\\wedgeonwedge" }, "\u2A57": { "math": "\\bigslopedvee" }, "\u2A58": { "math": "\\bigslopedwedge" }, "\u2A59": { "math": "\\veeonwedge" }, "\u2A5A": { "math": "\\wedgemidvert" }, "\u2A5B": { "math": "\\veemidvert" }, "\u2A5C": { "math": "\\midbarwedge" }, "\u2A5D": { "math": "\\midbarvee" }, "\u2A5F": { "math": "\\wedgebar" }, "\u2A60": { "math": "\\wedgedoublebar" }, "\u2A61": { "math": "\\varveebar" }, "\u2A62": { "math": "\\doublebarvee" }, "\u2A63": { "math": "\\veedoublebar" }, "\u2A64": { "math": "\\dsub" }, "\u2A65": { "math": "\\rsub" }, "\u2A66": { "math": "\\eqdot" }, "\u2A67": { "math": "\\dotequiv" }, "\u2A68": { "math": "\\equivVert" }, "\u2A69": { "math": "\\equivVvert" }, "\u2A6A": { "math": "\\dotsim" }, "\u2A6B": { "math": "\\simrdots" }, "\u2A6C": { "math": "\\simminussim" }, "\u2A6D": { "math": "\\congdot" }, "\u2A6F": { "math": "\\hatapprox" }, "\u2A70": { "math": "\\approxeqq" }, "\u2A71": { "math": "\\eqqplus" }, "\u2A72": { "math": "\\pluseqq" }, "\u2A73": { "math": "\\eqqsim" }, "\u2A74": { "math": "\\Coloneqq" }, "\u2A77": { "math": "\\ddotseq" }, "\u2A78": { "math": "\\equivDD" }, "\u2A79": { "math": "\\ltcir" }, "\u2A7A": { "math": "\\gtcir" }, "\u2A7B": { "math": "\\ltquest" }, "\u2A7C": { "math": "\\gtquest" }, "\u2A7D": { "math": "\\leqslant" }, "\u2A7E": { "math": "\\geqslant" }, "\u2A7F": { "math": "\\lesdot" }, "\u2A80": { "math": "\\gesdot" }, "\u2A81": { "math": "\\lesdoto" }, "\u2A82": { "math": "\\gesdoto" }, "\u2A83": { "math": "\\lesdotor" }, "\u2A84": { "math": "\\gesdotol" }, "\u2A85": { "math": "\\lessapprox" }, "\u2A86": { "math": "\\gtrapprox" }, "\u2A87": { "math": "\\lneq" }, "\u2A88": { "math": "\\gneq" }, "\u2A89": { "math": "\\lnapprox" }, "\u2A8A": { "math": "\\gnapprox" }, "\u2A8B": { "math": "\\lesseqqgtr" }, "\u2A8C": { "math": "\\gtreqqless" }, "\u2A8D": { "math": "\\lsime" }, "\u2A8E": { "math": "\\gsime" }, "\u2A8F": { "math": "\\lsimg" }, "\u2A90": { "math": "\\gsiml" }, "\u2A91": { "math": "\\lgE" }, "\u2A92": { "math": "\\glE" }, "\u2A93": { "math": "\\lesges" }, "\u2A94": { "math": "\\gesles" }, "\u2A95": { "math": "\\eqslantless" }, "\u2A96": { "math": "\\eqslantgtr" }, "\u2A97": { "math": "\\elsdot" }, "\u2A98": { "math": "\\egsdot" }, "\u2A99": { "math": "\\eqqless" }, "\u2A9A": { "math": "\\eqqgtr" }, "\u2A9B": { "math": "\\eqqslantless" }, "\u2A9C": { "math": "\\eqqslantgtr" }, "\u2A9D": { "math": "\\simless" }, "\u2A9E": { "math": "\\simgtr" }, "\u2A9F": { "math": "\\simlE" }, "\u2AA0": { "math": "\\simgE" }, "\u2AA3": { "math": "\\partialmeetcontraction" }, "\u2AA4": { "math": "\\glj" }, "\u2AA5": { "math": "\\gla" }, "\u2AA8": { "math": "\\lescc" }, "\u2AA9": { "math": "\\gescc" }, "\u2AAA": { "math": "\\smt" }, "\u2AAB": { "math": "\\lat" }, "\u2AAC": { "math": "\\smte" }, "\u2AAD": { "math": "\\late" }, "\u2AAE": { "math": "\\bumpeqq" }, "\u2AB1": { "math": "\\precneq" }, "\u2AB2": { "math": "\\succneq" }, "\u2AB3": { "math": "\\preceqq" }, "\u2AB4": { "math": "\\succeqq" }, "\u2AB5": { "math": "\\precneqq" }, "\u2AB6": { "math": "\\succneqq" }, "\u2AB7": { "math": "\\precapprox" }, "\u2AB8": { "math": "\\succapprox" }, "\u2AB9": { "math": "\\precnapprox" }, "\u2ABA": { "math": "\\succnapprox" }, "\u2ABD": { "math": "\\subsetdot" }, "\u2ABE": { "math": "\\supsetdot" }, "\u2ABF": { "math": "\\subsetplus" }, "\u2AC0": { "math": "\\supsetplus" }, "\u2AC1": { "math": "\\submult" }, "\u2AC2": { "math": "\\supmult" }, "\u2AC3": { "math": "\\subedot" }, "\u2AC4": { "math": "\\supedot" }, "\u2AC5": { "math": "\\subseteqq" }, "\u2AC6": { "math": "\\supseteqq" }, "\u2AC7": { "math": "\\subsim" }, "\u2AC8": { "math": "\\supsim" }, "\u2AC9": { "math": "\\subsetapprox" }, "\u2ACA": { "math": "\\supsetapprox" }, "\u2ACB": { "math": "\\subsetneqq" }, "\u2ACC": { "math": "\\supsetneqq" }, "\u2ACD": { "math": "\\lsqhook" }, "\u2ACE": { "math": "\\rsqhook" }, "\u2ACF": { "math": "\\csub" }, "\u2AD0": { "math": "\\csup" }, "\u2AD1": { "math": "\\csube" }, "\u2AD2": { "math": "\\csupe" }, "\u2AD3": { "math": "\\subsup" }, "\u2AD4": { "math": "\\supsub" }, "\u2AD5": { "math": "\\subsub" }, "\u2AD6": { "math": "\\supsup" }, "\u2AD7": { "math": "\\suphsub" }, "\u2AD8": { "math": "\\supdsub" }, "\u2AD9": { "math": "\\forkv" }, "\u2ADA": { "math": "\\topfork" }, "\u2ADB": { "math": "\\mlcp" }, "\u2ADD\u0338": { "math": "\\forks" }, "\u2ADD": { "math": "\\forksnot" }, "\u2ADE": { "math": "\\shortlefttack" }, "\u2ADF": { "math": "\\shortdowntack" }, "\u2AE0": { "math": "\\shortuptack" }, "\u2AE1": { "math": "\\perps" }, "\u2AE2": { "math": "\\vDdash" }, "\u2AE3": { "math": "\\dashV" }, "\u2AE4": { "math": "\\Dashv" }, "\u2AE5": { "math": "\\DashV" }, "\u2AE6": { "math": "\\varVdash" }, "\u2AE7": { "math": "\\Barv" }, "\u2AE8": { "math": "\\vBar" }, "\u2AE9": { "math": "\\vBarv" }, "\u2AEB": { "math": "\\Vbar" }, "\u2AEC": { "math": "\\Not" }, "\u2AED": { "math": "\\bNot" }, "\u2AEE": { "math": "\\revnmid" }, "\u2AEF": { "math": "\\cirmid" }, "\u2AF0": { "math": "\\midcir" }, "\u2AF1": { "math": "\\topcir" }, "\u2AF2": { "math": "\\nhpar" }, "\u2AF3": { "math": "\\parsim" }, "\u2AF4": { "math": "\\interleave" }, "\u2AF5": { "math": "\\nhVvert" }, "\u2AF6": { "math": "\\threedotcolon" }, "\u2AF7": { "math": "\\lllnest" }, "\u2AF8": { "math": "\\gggnest" }, "\u2AF9": { "math": "\\leqqslant" }, "\u2AFA": { "math": "\\geqqslant" }, "\u2AFB": { "math": "\\trslash" }, "\u2AFC": { "math": "\\biginterleave" }, "\u2AFE": { "math": "\\talloblong" }, "\u2AFF": { "math": "\\bigtalloblong" }, "\u2B12": { "math": "\\squaretopblack" }, "\u2B13": { "math": "\\squarebotblack" }, "\u2B14": { "math": "\\squareurblack" }, "\u2B15": { "math": "\\squarellblack" }, "\u2B16": { "math": "\\diamondleftblack" }, "\u2B17": { "math": "\\diamondrightblack" }, "\u2B18": { "math": "\\diamondtopblack" }, "\u2B19": { "math": "\\diamondbotblack" }, "\u2B1A": { "math": "\\dottedsquare" }, "\u2B1B": { "math": "\\lgblksquare" }, "\u2B1C": { "math": "\\lgwhtsquare" }, "\u2B1D": { "math": "\\vysmblksquare" }, "\u2B1E": { "math": "\\vysmwhtsquare" }, "\u2B1F": { "math": "\\pentagonblack" }, "\u2B20": { "math": "\\pentagon" }, "\u2B21": { "math": "\\varhexagon" }, "\u2B22": { "math": "\\varhexagonblack" }, "\u2B23": { "math": "\\hexagonblack" }, "\u2B24": { "math": "\\lgblkcircle" }, "\u2B25": { "math": "\\mdblkdiamond" }, "\u2B26": { "math": "\\mdwhtdiamond" }, "\u2B27": { "math": "\\mdblklozenge" }, "\u2B28": { "math": "\\mdwhtlozenge" }, "\u2B29": { "math": "\\smblkdiamond" }, "\u2B2A": { "math": "\\smblklozenge" }, "\u2B2B": { "math": "\\smwhtlozenge" }, "\u2B2C": { "math": "\\blkhorzoval" }, "\u2B2D": { "math": "\\whthorzoval" }, "\u2B2E": { "math": "\\blkvertoval" }, "\u2B2F": { "math": "\\whtvertoval" }, "\u2B30": { "math": "\\circleonleftarrow" }, "\u2B31": { "math": "\\leftthreearrows" }, "\u2B32": { "math": "\\leftarrowonoplus" }, "\u2B33": { "math": "\\longleftsquigarrow" }, "\u2B34": { "math": "\\nvtwoheadleftarrow" }, "\u2B35": { "math": "\\nVtwoheadleftarrow" }, "\u2B36": { "math": "\\twoheadmapsfrom" }, "\u2B37": { "math": "\\twoheadleftdbkarrow" }, "\u2B38": { "math": "\\leftdotarrow" }, "\u2B39": { "math": "\\nvleftarrowtail" }, "\u2B3A": { "math": "\\nVleftarrowtail" }, "\u2B3B": { "math": "\\twoheadleftarrowtail" }, "\u2B3C": { "math": "\\nvtwoheadleftarrowtail" }, "\u2B3D": { "math": "\\nVtwoheadleftarrowtail" }, "\u2B3E": { "math": "\\leftarrowx" }, "\u2B3F": { "math": "\\leftcurvedarrow" }, "\u2B40": { "math": "\\equalleftarrow" }, "\u2B41": { "math": "\\bsimilarleftarrow" }, "\u2B42": { "math": "\\leftarrowbackapprox" }, "\u2B43": { "math": "\\rightarrowgtr" }, "\u2B44": { "math": "\\rightarrowsupset" }, "\u2B45": { "math": "\\LLeftarrow" }, "\u2B46": { "math": "\\RRightarrow" }, "\u2B47": { "math": "\\bsimilarrightarrow" }, "\u2B48": { "math": "\\rightarrowbackapprox" }, "\u2B49": { "math": "\\similarleftarrow" }, "\u2B4A": { "math": "\\leftarrowapprox" }, "\u2B4B": { "math": "\\leftarrowbsimilar" }, "\u2B4C": { "math": "\\rightarrowbsimilar" }, "\u2B50": { "math": "\\medwhitestar" }, "\u2B51": { "math": "\\medblackstar" }, "\u2B52": { "math": "\\smwhitestar" }, "\u2B53": { "math": "\\rightpentagonblack" }, "\u2B54": { "math": "\\rightpentagon" }, "\u3012": { "math": "\\postalmark" }, "\u3030": { "math": "\\hzigzag" } }, "amssymb": { "\xF0": { "math": "\\eth" }, "\u2A7D": { "math": "\\leqslant" }, "\u2A7D\u0338": { "math": "\\nleqslant" }, "\u2A7E": { "math": "\\geqslant" }, "\u2A7E\u0338": { "math": "\\ngeqslant" } }, "arevmath": { "\xF0": { "math": "\\eth" } }, "MinionPro": { "\u03D0": { "math": "\\varbeta" }, "\u03F0": { "math": "\\varkappa" } }, "mathrsfs": { "\u210A": { "math": "\\mathscr{g}" }, "\u210B": { "math": "\\mathscr{H}" }, "\u2110": { "math": "\\mathscr{I}" }, "\u2112": { "math": "\\mathscr{L}" }, "\u211B": { "math": "\\mathscr{R}" }, "\u212C": { "math": "\\mathscr{B}" }, "\u212F": { "math": "\\mathscr{e}" }, "\u2130": { "math": "\\mathscr{E}" }, "\u2131": { "math": "\\mathscr{F}" }, "\u2133": { "math": "\\mathscr{M}" }, "\u2134": { "math": "\\mathscr{o}" }, "\u{1D49C}": { "math": "\\mathscr{A}" }, "\u{1D49E}": { "math": "\\mathscr{C}" }, "\u{1D49F}": { "math": "\\mathscr{D}" }, "\u{1D4A2}": { "math": "\\mathscr{G}" }, "\u{1D4A5}": { "math": "\\mathscr{J}" }, "\u{1D4A6}": { "math": "\\mathscr{K}" }, "\u{1D4A9}": { "math": "\\mathscr{N}" }, "\u{1D4AA}": { "math": "\\mathscr{O}" }, "\u{1D4AB}": { "math": "\\mathscr{P}" }, "\u{1D4AC}": { "math": "\\mathscr{Q}" }, "\u{1D4AE}": { "math": "\\mathscr{S}" }, "\u{1D4AF}": { "math": "\\mathscr{T}" }, "\u{1D4B0}": { "math": "\\mathscr{U}" }, "\u{1D4B1}": { "math": "\\mathscr{V}" }, "\u{1D4B2}": { "math": "\\mathscr{W}" }, "\u{1D4B3}": { "math": "\\mathscr{X}" }, "\u{1D4B4}": { "math": "\\mathscr{Y}" }, "\u{1D4B5}": { "math": "\\mathscr{Z}" }, "\u{1D4B6}": { "math": "\\mathscr{a}" }, "\u{1D4B7}": { "math": "\\mathscr{b}" }, "\u{1D4B8}": { "math": "\\mathscr{c}" }, "\u{1D4B9}": { "math": "\\mathscr{d}" }, "\u{1D4BB}": { "math": "\\mathscr{f}" }, "\u{1D4BD}": { "math": "\\mathscr{h}" }, "\u{1D4BE}": { "math": "\\mathscr{i}" }, "\u{1D4BF}": { "math": "\\mathscr{j}" }, "\u{1D4C0}": { "math": "\\mathscr{k}" }, "\u{1D4C1}": { "math": "\\mathscr{l}" }, "\u{1D4C2}": { "math": "\\mathscr{m}" }, "\u{1D4C3}": { "math": "\\mathscr{n}" }, "\u{1D4C5}": { "math": "\\mathscr{p}" }, "\u{1D4C6}": { "math": "\\mathscr{q}" }, "\u{1D4C7}": { "math": "\\mathscr{r}" }, "\u{1D4C8}": { "math": "\\mathscr{s}" }, "\u{1D4C9}": { "math": "\\mathscr{t}" }, "\u{1D4CA}": { "math": "\\mathscr{u}" }, "\u{1D4CB}": { "math": "\\mathscr{v}" }, "\u{1D4CC}": { "math": "\\mathscr{w}" }, "\u{1D4CD}": { "math": "\\mathscr{x}" }, "\u{1D4CE}": { "math": "\\mathscr{y}" }, "\u{1D4CF}": { "math": "\\mathscr{z}" } }, "MnSymbol": { "\u2232": { "math": "\\lcirclerightint" }, "\u2233": { "math": "\\rcirclerightint" } }, "mathabx": { "\u2238": { "math": "\\dotdiv" } }, "xecjk": { "\u2242": { "math": "\\texteqsim" }, "\u05D0": { "text": "\\hebalef", "macrospacer": true }, "\u05E2": { "text": "\\hebayin", "macrospacer": true }, "\u05D1": { "text": "\\hebbet", "macrospacer": true }, "\u05D3": { "text": "\\hebdalet", "macrospacer": true }, "\u05DA": { "text": "\\hebfinalkaf", "macrospacer": true }, "\u05DD": { "text": "\\hebfinalmem", "macrospacer": true }, "\u05DF": { "text": "\\hebfinalnun", "macrospacer": true }, "\u05E3": { "text": "\\hebfinalpe", "macrospacer": true }, "\u05E5": { "text": "\\hebfinaltsadi", "macrospacer": true }, "\u05D2": { "text": "\\hebgimel", "macrospacer": true }, "\u05D4": { "text": "\\hebhe", "macrospacer": true }, "\u05D7": { "text": "\\hebhet", "macrospacer": true }, "\u05DB": { "text": "\\hebkaf", "macrospacer": true }, "\u05DC": { "text": "\\heblamed", "macrospacer": true }, "\u05DE": { "text": "\\hebmem", "macrospacer": true }, "\u05E0": { "text": "\\hebnun", "macrospacer": true }, "\u05E4": { "text": "\\hebpe", "macrospacer": true }, "\u05E7": { "text": "\\hebqof", "macrospacer": true }, "\u05E8": { "text": "\\hebresh", "macrospacer": true }, "\u05E1": { "text": "\\hebsamekh", "macrospacer": true }, "\u05E9": { "text": "\\hebshin", "macrospacer": true }, "\u05EA": { "text": "\\hebtav", "macrospacer": true }, "\u05D8": { "text": "\\hebtet", "macrospacer": true }, "\u05E6": { "text": "\\hebtsadi", "macrospacer": true }, "\u05D5": { "text": "\\hebvav", "macrospacer": true }, "\u05D9": { "text": "\\hebyod", "macrospacer": true }, "\u05D6": { "text": "\\hebzayin", "macrospacer": true }, "\u0138": { "text": "\\textkra", "macrospacer": true } }, "textcomp": { "\xA2": { "text": "\\textcent", "macrospacer": true }, "\xA4": { "text": "\\textcurrency", "macrospacer": true }, "\xA5": { "text": "\\textyen", "macrospacer": true }, "\u0E3F": { "text": "\\textbaht", "macrospacer": true }, "\u20A1": { "text": "\\textcolonmonetary", "macrospacer": true }, "\u20A4": { "text": "\\textlira", "macrospacer": true }, "\u20A6": { "text": "\\textnaira", "macrospacer": true }, "\u20A7": { "text": "\\textpeseta", "macrospacer": true }, "\u20A9": { "text": "\\textwon", "macrospacer": true }, "\u20AB": { "text": "\\textdong", "macrospacer": true }, "\u20B1": { "text": "\\textpeso", "macrospacer": true }, "\xA6": { "text": "\\textbrokenbar", "macrospacer": true }, "\xA9": { "text": "\\textcopyright", "macrospacer": true }, "\xAA": { "text": "\\textordfeminine", "macrospacer": true }, "\xB0": { "text": "\\textdegree", "macrospacer": true }, "\xB6": { "text": "\\textparagraph", "macrospacer": true }, "\xBA": { "text": "\\textordmasculine", "macrospacer": true }, "\xF0": { "text": "\\textdh", "macrospacer": true }, "\u02D9": { "text": "\\textperiodcentered", "macrospacer": true }, "\u2022": { "text": "\\textbullet", "macrospacer": true }, "\u2030": { "text": "\\textperthousand", "macrospacer": true }, "\u2031": { "text": "\\textpertenthousand", "macrospacer": true }, "\u211E": { "text": "\\textrecipe", "macrospacer": true }, "\u2122": { "text": "\\texttrademark", "macrospacer": true }, "\u2191": { "text": "\\textuparrow", "macrospacer": true }, "\u2192": { "text": "\\textrightarrow", "macrospacer": true } }, "inputenx": { "\u0126": { "text": "\\textmalteseH", "macrospacer": true }, "\u0278": { "text": "\\textphi", "macrospacer": true }, "\u2248": { "text": "\\textapproxequal", "macrospacer": true } }, "tipa": { "\u0127": { "text": "\\textcrh", "macrospacer": true }, "\u0195": { "text": "\\texthvlig", "macrospacer": true }, "\u019E": { "text": "\\textipa{\\textnrleg}" }, "\u0250": { "text": "\\textipa{\\textturna}" }, "\u0252": { "text": "textipa{\\textopeno}" }, "\u0254": { "text": "\\textipa{O}" }, "\u0256": { "text": "\\textrtaild", "macrospacer": true }, "\u0259": { "text": "\\textschwa", "macrospacer": true }, "\u0263": { "text": "\\textipa{G}" }, "\u0264": { "text": "\\textrevscripta", "macrospacer": true }, "\u0278": { "text": "\\textphi", "macrospacer": true }, "\u029E": { "text": "\\textturnk", "macrospacer": true }, "\u02E5": { "text": "\\tone{55}" }, "\u02E6": { "text": "\\tone{44}" }, "\u02E7": { "text": "\\tone{33}" }, "\u02E8": { "text": "\\tone{22}" }, "\u02E9": { "text": "\\tone{11}" }, "\u0300\u0304": { "text": "\\textgravemacron", "macrospacer": true }, "\u0300\u0307": { "text": "\\textgravedot", "macrospacer": true }, "\u0301\u0304": { "text": "\\textacutemacron", "macrospacer": true }, "\u0301\u030C": { "text": "\\textacutewedge", "macrospacer": true }, "\u0302\u0307": { "text": "\\textcircumdot", "macrospacer": true }, "\u0303\u0307": { "text": "\\texttildedot", "macrospacer": true }, "\u0304\u0300": { "text": "\\textgravemacron", "macrospacer": true }, "\u0306\u0304": { "text": "\\textbrevemacron", "macrospacer": true }, "\u0307\u0301": { "text": "\\textdotacute", "macrospacer": true }, "\u0307\u0306": { "text": "\\textdotbreve", "macrospacer": true }, "\u030A\u0304": { "text": "\\textringmacron", "macrospacer": true }, "\u030D": { "text": "\\textvbaraccent", "macrospacer": true }, "\u030E": { "text": "\\textdoublevbaraccent", "macrospacer": true }, "\u0310": { "text": "\\textdotbreve", "macrospacer": true }, "\u0318": { "text": "\\textadvancing", "macrospacer": true }, "\u0319": { "text": "\\textretracting", "macrospacer": true }, "\u031A": { "text": "\\textcorner", "macrospacer": true }, "\u031C": { "text": "\\textsublhalfring", "macrospacer": true }, "\u031D": { "text": "\\textraising", "macrospacer": true }, "\u031E": { "text": "\\textlowering", "macrospacer": true }, "\u031F": { "text": "\\textsubplus", "macrospacer": true }, "\u0324": { "text": "\\textsubumlaut", "macrospacer": true }, "\u0325": { "text": "\\textsubring", "macrospacer": true }, "\u0329": { "text": "\\textsyllabic", "macrospacer": true }, "\u032A": { "text": "\\textsubbridge", "macrospacer": true }, "\u032C": { "text": "\\textsubwedge", "macrospacer": true }, "\u032F": { "text": "\\textsubarch", "macrospacer": true }, "\u0330": { "text": "\\textsubtilde", "macrospacer": true }, "\u0331": { "text": "\\textsubbar", "macrospacer": true }, "\u0334": { "text": "\\textsuperimposetilde", "macrospacer": true }, "\u0339": { "text": "\\textsubrhalfring", "macrospacer": true }, "\u033A": { "text": "\\textinvsubbridge", "macrospacer": true }, "\u033B": { "text": "\\textsubsquare", "macrospacer": true }, "\u033C": { "text": "\\textseagull", "macrospacer": true }, "\u033D": { "text": "\\textovercross", "macrospacer": true }, "\u2094": { "text": "\\textsubscript{\\textschwa}" } }, "ipa": { "\u026F": { "text": "\\textturnm", "macrospacer": true } }, "mathscinet": { "\u02BF": { "text": "\\lasp", "macrospacer": true } }, "textalpha": { "\u03B1": { "text": "\\textalpha", "macrospacer": true } }, "graphics": { "\u21B3": { "text": "\\reflectbox{\\carriagereturn}" } }, "pmboxdraw": { "\u2500": { "text": "\\textSFx", "macrospacer": true }, "\u2501": { "text": "\\pmboxdrawuni{2501}" }, "\u2502": { "text": "\\textSFxi", "macrospacer": true }, "\u2503": { "text": "\\pmboxdrawuni{2503}" }, "\u250C": { "text": "\\textSFi", "macrospacer": true }, "\u250D": { "text": "\\pmboxdrawuni{250D}" }, "\u250E": { "text": "\\pmboxdrawuni{250E}" }, "\u250F": { "text": "\\pmboxdrawuni{250F}" }, "\u2510": { "text": "\\textSFiii", "macrospacer": true }, "\u2511": { "text": "\\pmboxdrawuni{2511}" }, "\u2512": { "text": "\\pmboxdrawuni{2512}" }, "\u2513": { "text": "\\pmboxdrawuni{2513}" }, "\u2514": { "text": "\\textSFii", "macrospacer": true }, "\u2515": { "text": "\\pmboxdrawuni{2515}" }, "\u2516": { "text": "\\pmboxdrawuni{2516}" }, "\u2517": { "text": "\\pmboxdrawuni{2517}" }, "\u2518": { "text": "\\textSFiv", "macrospacer": true }, "\u2519": { "text": "\\pmboxdrawuni{2519}" }, "\u251A": { "text": "\\pmboxdrawuni{251A}" }, "\u251B": { "text": "\\pmboxdrawuni{251B}" }, "\u251C": { "text": "\\textSFviii", "macrospacer": true }, "\u251D": { "text": "\\pmboxdrawuni{251D}" }, "\u251E": { "text": "\\pmboxdrawuni{251E}" }, "\u251F": { "text": "\\pmboxdrawuni{251F}" }, "\u2520": { "text": "\\pmboxdrawuni{2520}" }, "\u2521": { "text": "\\pmboxdrawuni{2521}" }, "\u2522": { "text": "\\pmboxdrawuni{2522}" }, "\u2523": { "text": "\\pmboxdrawuni{2523}" }, "\u2524": { "text": "\\textSFix", "macrospacer": true }, "\u2525": { "text": "\\pmboxdrawuni{2525}" }, "\u2526": { "text": "\\pmboxdrawuni{2526}" }, "\u2527": { "text": "\\pmboxdrawuni{2527}" }, "\u2528": { "text": "\\pmboxdrawuni{2528}" }, "\u2529": { "text": "\\pmboxdrawuni{2529}" }, "\u252A": { "text": "\\pmboxdrawuni{252A}" }, "\u252B": { "text": "\\pmboxdrawuni{252B}" }, "\u252C": { "text": "\\textSFvi", "macrospacer": true }, "\u252D": { "text": "\\pmboxdrawuni{252D}" }, "\u252E": { "text": "\\pmboxdrawuni{252E}" }, "\u252F": { "text": "\\pmboxdrawuni{252F}" }, "\u2530": { "text": "\\pmboxdrawuni{2530}" }, "\u2531": { "text": "\\pmboxdrawuni{2531}" }, "\u2532": { "text": "\\pmboxdrawuni{2532}" }, "\u2533": { "text": "\\pmboxdrawuni{2533}" }, "\u2534": { "text": "\\textSFvii", "macrospacer": true }, "\u2535": { "text": "\\pmboxdrawuni{2535}" }, "\u2536": { "text": "\\pmboxdrawuni{2536}" }, "\u2537": { "text": "\\pmboxdrawuni{2537}" }, "\u2538": { "text": "\\pmboxdrawuni{2538}" }, "\u2539": { "text": "\\pmboxdrawuni{2539}" }, "\u253A": { "text": "\\pmboxdrawuni{253A}" }, "\u253B": { "text": "\\pmboxdrawuni{253B}" }, "\u253C": { "text": "\\textSFv", "macrospacer": true }, "\u253D": { "text": "\\pmboxdrawuni{253D}" }, "\u253E": { "text": "\\pmboxdrawuni{253E}" }, "\u253F": { "text": "\\pmboxdrawuni{253F}" }, "\u2540": { "text": "\\pmboxdrawuni{2540}" }, "\u2541": { "text": "\\pmboxdrawuni{2541}" }, "\u2542": { "text": "\\pmboxdrawuni{2542}" }, "\u2543": { "text": "\\pmboxdrawuni{2543}" }, "\u2544": { "text": "\\pmboxdrawuni{2544}" }, "\u2545": { "text": "\\pmboxdrawuni{2545}" }, "\u2546": { "text": "\\pmboxdrawuni{2546}" }, "\u2547": { "text": "\\pmboxdrawuni{2547}" }, "\u2548": { "text": "\\pmboxdrawuni{2548}" }, "\u2549": { "text": "\\pmboxdrawuni{2549}" }, "\u254A": { "text": "\\pmboxdrawuni{254A}" }, "\u254B": { "text": "\\pmboxdrawuni{254B}" }, "\u2550": { "text": "\\textSFxliii", "macrospacer": true }, "\u2551": { "text": "\\textSFxxiv", "macrospacer": true }, "\u2552": { "text": "\\textSFli", "macrospacer": true }, "\u2553": { "text": "\\textSFlii", "macrospacer": true }, "\u2554": { "text": "\\textSFxxxix", "macrospacer": true }, "\u2555": { "text": "\\textSFxxii", "macrospacer": true }, "\u2556": { "text": "\\textSFxxi", "macrospacer": true }, "\u2557": { "text": "\\textSFxxv", "macrospacer": true }, "\u2558": { "text": "\\textSFl", "macrospacer": true }, "\u2559": { "text": "\\textSFxlix", "macrospacer": true }, "\u255A": { "text": "\\textSFxxxviii", "macrospacer": true }, "\u255B": { "text": "\\textSFxxviii", "macrospacer": true }, "\u255C": { "text": "\\textSFxxvii", "macrospacer": true }, "\u255D": { "text": "\\textSFxxvi", "macrospacer": true }, "\u255E": { "text": "\\textSFxxxvi", "macrospacer": true }, "\u255F": { "text": "\\textSFxxxvii", "macrospacer": true }, "\u2560": { "text": "\\textSFxlii", "macrospacer": true }, "\u2561": { "text": "\\textSFxix", "macrospacer": true }, "\u2562": { "text": "\\textSFxx", "macrospacer": true }, "\u2563": { "text": "\\textSFxxiii", "macrospacer": true }, "\u2564": { "text": "\\textSFxlvii", "macrospacer": true }, "\u2565": { "text": "\\textSFxlviii", "macrospacer": true }, "\u2566": { "text": "\\textSFxli", "macrospacer": true }, "\u2567": { "text": "\\textSFxlv", "macrospacer": true }, "\u2568": { "text": "\\textSFxlvi", "macrospacer": true }, "\u2569": { "text": "\\textSFxl", "macrospacer": true }, "\u256A": { "text": "\\textSFliv", "macrospacer": true }, "\u256B": { "text": "\\textSFliii", "macrospacer": true }, "\u256C": { "text": "\\textSFxliv", "macrospacer": true }, "\u2574": { "text": "\\pmboxdrawuni{2574}" }, "\u2575": { "text": "\\pmboxdrawuni{2575}" }, "\u2576": { "text": "\\pmboxdrawuni{2576}" }, "\u2577": { "text": "\\pmboxdrawuni{2577}" }, "\u2578": { "text": "\\pmboxdrawuni{2578}" }, "\u2579": { "text": "\\pmboxdrawuni{2579}" }, "\u257A": { "text": "\\pmboxdrawuni{257A}" }, "\u257B": { "text": "\\pmboxdrawuni{257B}" }, "\u257C": { "text": "\\pmboxdrawuni{257C}" }, "\u257D": { "text": "\\pmboxdrawuni{257D}" }, "\u257E": { "text": "\\pmboxdrawuni{257E}" }, "\u257F": { "text": "\\pmboxdrawuni{257F}" }, "\u2580": { "text": "\\textupblock", "macrospacer": true }, "\u2581": { "text": "\\pmboxdrawuni{2581}" }, "\u2582": { "text": "\\pmboxdrawuni{2582}" }, "\u2583": { "text": "\\pmboxdrawuni{2583}" }, "\u2584": { "text": "\\textdnblock", "macrospacer": true }, "\u2585": { "text": "\\pmboxdrawuni{2585}" }, "\u2586": { "text": "\\pmboxdrawuni{2586}" }, "\u2587": { "text": "\\pmboxdrawuni{2587}" }, "\u2588": { "text": "\\textblock", "macrospacer": true }, "\u2589": { "text": "\\pmboxdrawuni{2589}" }, "\u258A": { "text": "\\pmboxdrawuni{258A}" }, "\u258B": { "text": "\\pmboxdrawuni{258B}" }, "\u258C": { "text": "\\textlfblock", "macrospacer": true }, "\u258D": { "text": "\\pmboxdrawuni{258D}" }, "\u258E": { "text": "\\pmboxdrawuni{258E}" }, "\u258F": { "text": "\\pmboxdrawuni{258F}" }, "\u2590": { "text": "\\textrtblock", "macrospacer": true }, "\u2591": { "text": "\\textltshade", "macrospacer": true }, "\u2592": { "text": "\\textshade", "macrospacer": true }, "\u2593": { "text": "\\textdkshade", "macrospacer": true }, "\u2594": { "text": "\\pmboxdrawuni{2594}" }, "\u2595": { "text": "\\pmboxdrawuni{2595}" }, "\u2596": { "text": "\\pmboxdrawuni{2596}" }, "\u2597": { "text": "\\pmboxdrawuni{2597}" }, "\u2598": { "text": "\\pmboxdrawuni{2598}" }, "\u2599": { "text": "\\pmboxdrawuni{2599}" }, "\u259A": { "text": "\\pmboxdrawuni{259A}" }, "\u259B": { "text": "\\pmboxdrawuni{259B}" }, "\u259C": { "text": "\\pmboxdrawuni{259C}" }, "\u259D": { "text": "\\pmboxdrawuni{259D}" }, "\u259E": { "text": "\\pmboxdrawuni{259E}" }, "\u259F": { "text": "\\pmboxdrawuni{259F}" } } } };
    }
  });

  // node_modules/unicode2latex/tables/bibtex.json
  var require_bibtex = __commonJS({
    "node_modules/unicode2latex/tables/bibtex.json"(exports, module) {
      module.exports = { "base": { "#": { "text": "\\#", "math": "\\#" }, "$": { "text": "\\$", "math": "\\$" }, "%": { "text": "\\%", "math": "\\%" }, "&": { "text": "\\&", "math": "\\&" }, "_": { "text": "\\_", "math": "\\_" }, "\xA0": { "text": "~", "math": "~" }, "\xA3": { "text": "{\\pounds}", "math": "\\pounds" }, "\xA7": { "text": "{\\S}", "math": "\\S" }, "\xA9": { "text": "{\\copyright}", "math": "\\copyright", "alt": ["textcomp"] }, "\xAD": { "text": "\\-", "math": "\\-" }, "\xB6": { "text": "{\\P}", "math": "\\P", "alt": ["textcomp"] }, "\u2020": { "text": "{\\dag}", "math": "\\dag" }, "\u2021": { "text": "{\\ddag}", "math": "\\ddag" }, "\u2026": { "text": "{\\dots}", "math": "\\dots" }, "\u205F": { "text": "\\:", "math": "\\:" }, "\u2212": { "text": "-", "math": "-" }, "\u263F": { "text": "{\\mercury}", "math": "\\mercury" }, "\u2643": { "text": "{\\jupiter}", "math": "\\jupiter" }, "\u2644": { "text": "{\\saturn}", "math": "\\saturn" }, "\u2645": { "text": "{\\uranus}", "math": "\\uranus" }, "\u2646": { "text": "{\\neptune}", "math": "\\neptune" }, "\u2647": { "text": "{\\pluto}", "math": "\\pluto" }, "\u2648": { "text": "{\\aries}", "math": "\\aries" }, "\u2649": { "text": "{\\taurus}", "math": "\\taurus" }, "\u264A": { "text": "{\\gemini}", "math": "\\gemini" }, "\u264B": { "text": "{\\cancer}", "math": "\\cancer" }, "\u264C": { "text": "{\\leo}", "math": "\\leo" }, "\u264D": { "text": "{\\virgo}", "math": "\\virgo" }, "\u264E": { "text": "{\\libra}", "math": "\\libra" }, "\u264F": { "text": "{\\scorpio}", "math": "\\scorpio" }, "\u2650": { "text": "{\\sagittarius}", "math": "\\sagittarius" }, "\u2651": { "text": "{\\capricornus}", "math": "\\capricornus" }, "\u2652": { "text": "{\\aquarius}", "math": "\\aquarius" }, "<": { "math": "<" }, ">": { "math": ">" }, "\\": { "text": "{\\textbackslash}", "math": "\\backslash" }, "|": { "text": "{\\textbar}", "math": "\\vert" }, "\xAC": { "text": "{\\textlnot}", "math": "\\lnot" }, "\xB0": { "math": "^\\circ", "alt": ["textcomp"] }, "\xB1": { "text": "{\\textpm}", "math": "\\pm" }, "\xB2": { "math": "^{2}" }, "\xB3": { "math": "^{3}" }, "\xB7": { "math": "\\cdot" }, "\xB9": { "math": "^{1}" }, "\xBC": { "math": "\\frac{1}{4}" }, "\xBD": { "math": "\\frac{1}{2}" }, "\xBE": { "math": "\\frac{3}{4}" }, "\xD7": { "text": "{\\texttimes}", "math": "\\times" }, "\xF7": { "text": "{\\textdiv}", "math": "\\div" }, "\u0127": { "math": "\\hbar", "alt": ["tipa"] }, "\u0131": { "text": "{\\i}", "math": "\\imath" }, "\u0192": { "text": "{\\textflorin}", "math": "f" }, "\u0237": { "math": "\\jmath" }, "\u025B": { "math": "\\varepsilon" }, "\u0263": { "math": "\\gamma", "alt": ["tipa"] }, "\u02B0": { "text": "\\textsuperscript{h}", "math": "^{h}" }, "\u02B2": { "text": "\\textsuperscript{j}", "math": "^{j}" }, "\u02B3": { "text": "\\textsuperscript{r}", "math": "^{r}" }, "\u02B7": { "text": "\\textsuperscript{w}", "math": "^{w}" }, "\u02B8": { "text": "\\textsuperscript{y}", "math": "^{y}" }, "\u02E1": { "text": "\\textsuperscript{l}", "math": "^{l}" }, "\u02E2": { "text": "\\textsuperscript{s}", "math": "^{s}" }, "\u02E3": { "text": "\\textsuperscript{x}", "math": "^{x}" }, "\u0305": { "math": "\\overline" }, "\u030A": { "text": "{\\r}", "math": "\\mathring" }, "\u0331": { "math": "\\underbar", "alt": ["tipa"] }, "\u0332": { "math": "\\underline" }, "\u0338": { "math": "\\not" }, "\u03A5\u0301": { "math": "\\mathrm{'Y}" }, "\u03A9\u0301": { "math": "\\mathrm{'\\Omega}" }, "\u03B9\u0308\u0301": { "math": "\\acute{\\ddot{\\iota}}" }, "\u0393": { "math": "\\Gamma", "alt": ["unicode-math"] }, "\u0394": { "math": "\\Delta", "alt": ["unicode-math"] }, "\u0398": { "math": "\\Theta", "alt": ["unicode-math"] }, "\u039B": { "math": "\\Lambda", "alt": ["unicode-math"] }, "\u039E": { "math": "\\Xi" }, "\u03A0": { "math": "\\Pi" }, "\u03A3": { "math": "\\Sigma" }, "\u03A5": { "math": "\\Upsilon" }, "\u03A6": { "math": "\\Phi" }, "\u03A8": { "math": "\\Psi" }, "\u03A9": { "text": "{\\textohm}", "math": "\\Omega" }, "\u0399\u0308": { "math": "\\mathrm{\\ddot{I}}" }, "\u03A5\u0308": { "math": "\\mathrm{\\ddot{Y}}" }, "\u03B1\u0301": { "math": "\\acute{\\alpha}" }, "\u03B5\u0301": { "math": "\\acute{\\epsilon}" }, "\u03B7\u0301": { "math": "\\acute{\\eta}" }, "\u03B9\u0301": { "math": "\\acute{\\iota}" }, "\u03C5\u0308\u0301": { "math": "\\acute{\\ddot{\\upsilon}}" }, "\u03B1": { "math": "\\alpha", "alt": ["textalpha"] }, "\u03B2": { "math": "\\beta" }, "\u03B3": { "math": "\\gamma" }, "\u03B4": { "math": "\\delta" }, "\u03B5": { "math": "\\varepsilon" }, "\u03B6": { "math": "\\zeta" }, "\u03B7": { "math": "\\eta" }, "\u03B8": { "text": "{\\texttheta}", "math": "\\theta" }, "\u03B9": { "math": "\\iota" }, "\u03BA": { "math": "\\kappa" }, "\u03BB": { "math": "\\lambda" }, "\u03BC": { "math": "\\mu" }, "\u03BD": { "math": "\\nu" }, "\u03BE": { "math": "\\xi" }, "\u03C0": { "math": "\\pi" }, "\u{1D70C}": { "math": "\\rho", "alt": ["unicode-math"] }, "\u03C1": { "math": "\\rho" }, "\u03C2": { "math": "\\varsigma" }, "\u03C3": { "math": "\\sigma" }, "\u03C4": { "math": "\\tau" }, "\u03C5": { "math": "\\upsilon" }, "\u03C6": { "math": "\\varphi" }, "\u03C7": { "math": "\\chi" }, "\u03C8": { "math": "\\psi" }, "\u03C9": { "math": "\\omega" }, "\u03B9\u0308": { "math": "\\ddot{\\iota}" }, "\u03C5\u0308": { "math": "\\ddot{\\upsilon}" }, "\u03C5\u0301": { "math": "\\acute{\\upsilon}" }, "\u03C9\u0301": { "math": "\\acute{\\omega}" }, "\u03D1": { "text": "{\\textvartheta}", "math": "\\vartheta" }, "\u03D2": { "math": "\\Upsilon" }, "\u03D5": { "math": "\\phi" }, "\u03D6": { "math": "\\varpi" }, "\u03D8": { "math": "\\Qoppa" }, "\u03D9": { "math": "\\qoppa" }, "\u03DA": { "math": "\\Stigma" }, "\u03DB": { "math": "\\stigma" }, "\u03DC": { "math": "\\Digamma" }, "\u03DD": { "math": "\\digamma" }, "\u03DE": { "math": "\\Koppa" }, "\u03DF": { "math": "\\koppa" }, "\u03E0": { "math": "\\Sampi" }, "\u03E1": { "math": "\\sampi" }, "\u03F1": { "math": "\\varrho" }, "\u03F4": { "text": "{\\textTheta}", "math": "\\upvarTheta" }, "\u03F5": { "math": "\\epsilon" }, "\u03F6": { "math": "\\backepsilon", "alt": ["unicode-math"] }, "\u0871": { "math": "\\\\backslash" }, "\u1D43": { "text": "\\textsuperscript{a}", "math": "^{a}" }, "\u1D2C": { "text": "\\textsuperscript{A}", "math": "^{A}" }, "\u1D47": { "text": "\\textsuperscript{b}", "math": "^{b}" }, "\u1D48": { "text": "\\textsuperscript{d}", "math": "^{d}" }, "\u1D49": { "text": "\\textsuperscript{e}", "math": "^{e}" }, "\u1D4D": { "text": "\\textsuperscript{g}", "math": "^{g}" }, "\u1D4F": { "text": "\\textsuperscript{k}", "math": "^{k}" }, "\u1D50": { "text": "\\textsuperscript{m}", "math": "^{m}" }, "\u1D52": { "text": "\\textsuperscript{o}", "math": "^{o}" }, "\u1D56": { "text": "\\textsuperscript{p}", "math": "^{p}" }, "\u1D57": { "text": "\\textsuperscript{t}", "math": "^{t}" }, "\u1D58": { "text": "\\textsuperscript{u}", "math": "^{u}" }, "\u1D5B": { "text": "\\textsuperscript{v}", "math": "^{v}" }, "\u1D9C": { "text": "\\textsuperscript{c}", "math": "^{c}" }, "\u1DA0": { "text": "\\textsuperscript{f}", "math": "^{f}" }, "\u1DBB": { "text": "\\textsuperscript{z}", "math": "^{z}" }, "\u2003": { "math": "\\quad" }, "\u200A": { "math": "\\mkern1mu" }, "\u2022": { "math": "\\bullet", "alt": ["textcomp"] }, "\u2032": { "math": "\\prime" }, "\u2033": { "math": "{''}", "alt": ["unicode-math"] }, "\u2034": { "math": "{'''}", "alt": ["unicode-math"] }, "\u2057": { "math": "''''", "alt": ["unicode-math"] }, "\u2070": { "math": "^{0}" }, "\u2071": { "text": "\\textsuperscript{i}", "math": "^{i}" }, "\u2074": { "math": "^{4}" }, "\u2075": { "math": "^{5}" }, "\u2076": { "math": "^{6}" }, "\u2077": { "math": "^{7}" }, "\u2078": { "math": "^{8}" }, "\u2079": { "math": "^{9}" }, "\u207A": { "math": "^{+}" }, "\u207B": { "math": "^{-}" }, "\u207C": { "math": "^{=}" }, "\u207D": { "math": "^{(}" }, "\u207E": { "math": "^{)}" }, "\u207F": { "math": "^{n}" }, "\u2080": { "math": "_{0}" }, "\u2081": { "math": "_{1}" }, "\u2082": { "math": "_{2}" }, "\u2083": { "math": "_{3}" }, "\u2084": { "math": "_{4}" }, "\u2085": { "math": "_{5}" }, "\u2086": { "math": "_{6}" }, "\u2087": { "math": "_{7}" }, "\u2088": { "math": "_{8}" }, "\u2089": { "math": "_{9}" }, "\u208A": { "math": "_{+}" }, "\u208B": { "math": "_{-}" }, "\u208C": { "math": "_{=}" }, "\u208D": { "math": "_{(}" }, "\u208E": { "math": "_{)}" }, "\u2090": { "text": "\\textsubscript{a}", "math": "_{a}" }, "\u2091": { "text": "\\textsubscript{e}", "math": "_{e}" }, "\u2092": { "text": "\\textsubscript{o}", "math": "_{o}" }, "\u2093": { "text": "\\textsubscript{x}", "math": "_{x}" }, "\u2095": { "text": "\\textsubscript{h}", "math": "_{h}" }, "\u2096": { "text": "\\textsubscript{k}", "math": "_{k}" }, "\u2097": { "text": "\\textsubscript{l}", "math": "_{l}" }, "\u2098": { "text": "\\textsubscript{m}", "math": "_{m}" }, "\u2099": { "text": "\\textsubscript{n}", "math": "_{n}" }, "\u209A": { "text": "\\textsubscript{p}", "math": "_{p}" }, "\u209B": { "text": "\\textsubscript{s}", "math": "_{s}" }, "\u209C": { "text": "\\textsubscript{t}", "math": "_{t}" }, "\u20D0": { "math": "\\lvec" }, "\u20D6": { "math": "\\LVec" }, "\u2102": { "math": "\\mathbb{C}" }, "\u2107": { "math": "\\Euler" }, "\u210B": { "math": "\\mathcal{H}", "alt": ["mathrsfs"] }, "\u210C": { "math": "\\mathfrak{H}" }, "\u210D": { "math": "\\mathbb{H}" }, "\u2111": { "math": "\\mathfrak{I}" }, "\u2113": { "math": "\\ell" }, "\u2115": { "math": "\\mathbb{N}" }, "\u2118": { "math": "\\wp" }, "\u2119": { "math": "\\mathbb{P}" }, "\u211A": { "math": "\\mathbb{Q}" }, "\u211C": { "math": "\\mathfrak{R}" }, "\u211D": { "math": "\\mathbb{R}" }, "\u2124": { "math": "\\mathbb{Z}" }, "\u2128": { "math": "\\mathfrak{Z}" }, "A\u030A": { "text": "{\\AA}", "math": "\\Angstroem" }, "\u212D": { "math": "\\mathfrak{C}" }, "\u2135": { "math": "\\aleph" }, "\u213C": { "math": "\\mathbb{\\pi}" }, "\u213D": { "math": "\\mathbb{\\gamma}" }, "\u213E": { "math": "\\mathbb{\\Gamma}" }, "\u213F": { "math": "\\mathbb{\\Pi}" }, "\u2140": { "math": "\\mathbb{\\Sigma}" }, "\u2146": { "math": "\\DifferentialD" }, "\u2147": { "math": "\\ExponetialE" }, "\u2148": { "math": "\\ComplexI" }, "\u2149": { "math": "\\ComplexJ" }, "\u214B": { "math": "\\invamp" }, "\u2150": { "math": "\\frac{1}{7}" }, "\u2151": { "math": "\\frac{1}{9}" }, "\u2152": { "math": "\\frac{1}{10}" }, "\u2153": { "math": "\\frac{1}{3}" }, "\u2154": { "math": "\\frac{2}{3}" }, "\u2155": { "math": "\\frac{1}{5}" }, "\u2156": { "math": "\\frac{2}{5}" }, "\u2157": { "math": "\\frac{3}{5}" }, "\u2158": { "math": "\\frac{4}{5}" }, "\u2159": { "math": "\\frac{1}{6}" }, "\u215A": { "math": "\\frac{5}{6}" }, "\u215B": { "math": "\\frac{1}{8}" }, "\u215C": { "math": "\\frac{3}{8}" }, "\u215D": { "math": "\\frac{5}{8}" }, "\u215E": { "math": "\\frac{7}{8}" }, "\u215F": { "math": "\\frac{1}" }, "\u2189": { "math": "\\frac{0}{3}" }, "\u2190": { "text": "{\\textleftarrow}", "math": "\\leftarrow" }, "\u2191": { "math": "\\uparrow", "alt": ["textcomp"] }, "\u2192": { "math": "\\rightarrow", "alt": ["textcomp"] }, "\u2193": { "text": "{\\textdownarrow}", "math": "\\downarrow" }, "\u2194": { "math": "\\leftrightarrow" }, "\u2195": { "math": "\\updownarrow" }, "\u2196": { "math": "\\nwarrow" }, "\u2197": { "math": "\\nearrow" }, "\u2198": { "math": "\\searrow" }, "\u2199": { "math": "\\swarrow" }, "\u219C": { "math": "\\arrowwaveleft" }, "\u219D": { "math": "\\arrowwaveright" }, "\u21A6": { "math": "\\mapsto" }, "\u21A9": { "math": "\\hookleftarrow" }, "\u21AA": { "math": "\\hookrightarrow" }, "\u21AF": { "math": "\\lightning" }, "\u21B2": { "math": "\\dlsh" }, "\u21BB": { "math": "\\circlearrowright" }, "\u21BC": { "math": "\\leftharpoonup" }, "\u21BD": { "math": "\\leftharpoondown" }, "\u21C0": { "math": "\\rightharpoonup" }, "\u21C5": { "math": "\\dblarrowupdown" }, "\u21CC": { "math": "\\rightleftharpoons" }, "\u21D0": { "math": "\\Leftarrow" }, "\u21D1": { "math": "\\Uparrow" }, "\u21D2": { "math": "\\Rightarrow" }, "\u21D3": { "math": "\\Downarrow" }, "\u21D4": { "math": "\\Leftrightarrow" }, "\u21D5": { "math": "\\Updownarrow" }, "\u21E0": { "math": "\\dashleftarrow" }, "\u21E2": { "math": "\\dashrightarrow" }, "\u21E4": { "math": "\\LeftArrowBar" }, "\u21E5": { "math": "\\RightArrowBar" }, "\u21F5": { "math": "\\DownArrowUpArrow" }, "\u21F8": { "math": "\\pfun" }, "\u21FB": { "math": "\\ffun" }, "\u2200": { "math": "\\forall" }, "\u2202": { "math": "\\partial" }, "\u2203": { "math": "\\exists" }, "\u2208": { "math": "\\in" }, "\u2208\u0338": { "math": "\\notin" }, "\u220B": { "math": "\\ni" }, "\u220B\u0338": { "math": "\\not\\ni" }, "\u220F": { "math": "\\prod" }, "\u2210": { "math": "\\coprod" }, "\u2211": { "math": "\\sum" }, "\u2213": { "math": "\\mp" }, "\u2217": { "math": "\\ast" }, "\u2218": { "math": "\\circ" }, "\u2219": { "math": "\\bullet" }, "\u221B": { "math": "\\sqrt[3]" }, "\u221C": { "math": "\\sqrt[4]" }, "\u221D": { "math": "\\propto" }, "\u221E": { "math": "\\infty" }, "\u2220": { "math": "\\angle" }, "\u2223": { "math": "\\mid" }, "\u2225": { "math": "\\parallel" }, "\u2227": { "math": "\\wedge" }, "\u2228": { "math": "\\vee" }, "\u2229": { "math": "\\cap" }, "\u222A": { "math": "\\cup" }, "\u222B": { "math": "\\int" }, "\u222C": { "math": "{\\int\\!\\int}" }, "\u222D": { "math": "{\\int\\!\\int\\!\\int}" }, "\u222E": { "math": "\\oint" }, "\u222F": { "math": "\\surfintegral" }, "\u2230": { "math": "\\volintegral" }, "\u2231": { "math": "\\clwintegral" }, "\u2236": { "math": ":" }, "\u223A": { "math": "\\mathbin{{:}\\!\\!{-}\\!\\!{:}}" }, "\u223B": { "math": "\\homothetic" }, "\u223C": { "math": "\\sim" }, "\u223E": { "math": "\\lazysinv" }, "\u223F": { "math": "\\AC" }, "\u2240": { "math": "\\wr" }, "\u223C\u0338": { "math": "\\not\\sim" }, "\u2242\u0338": { "math": "\\NotEqualTilde" }, "\u2243": { "math": "\\simeq" }, "\u2243\u0338": { "math": "\\not\\simeq" }, "\u2245": { "math": "\\cong" }, "\u2246": { "math": "\\approxnotequal" }, "\u2245\u0338": { "math": "\\not\\cong" }, "\u2248": { "math": "\\approx", "alt": ["inputenx"] }, "\u2248\u0338": { "math": "\\not\\approx" }, "\u224B": { "math": "\\tildetrpl" }, "\u224B\u0338": { "math": "\\not\\apid" }, "\u224C": { "math": "\\allequal" }, "\u224D": { "math": "\\asymp" }, "\u224E\u0338": { "math": "\\NotHumpDownHump" }, "\u224F\u0338": { "math": "\\NotHumpEqual" }, "\u2250": { "math": "\\doteq" }, "\u2250\u0338": { "math": "\\not\\doteq" }, "\u2251": { "math": "\\doteqdot" }, "\u2254": { "text": ":=", "math": ":=", "alt": ["unicode-math"] }, "\u2255": { "math": "=:" }, "\u2259": { "math": "\\estimates" }, "\u225B": { "math": "\\starequal" }, "=\u0338": { "math": "\\neq" }, "\u2261": { "math": "\\equiv" }, "\u2261\u0338": { "math": "\\not\\equiv" }, "\u2264": { "math": "\\leq" }, "\u2265": { "math": "\\geq" }, "\u2266": { "math": "\\leqq" }, "\u2267": { "math": "\\geqq" }, "\u2268\uFE00": { "math": "\\lvertneqq" }, "\u2269\uFE00": { "math": "\\gvertneqq" }, "\u226A": { "math": "\\ll" }, "\u226A\u0338": { "math": "\\NotLessLess" }, "\u226B": { "math": "\\gg" }, "\u226B\u0338": { "math": "\\NotGreaterGreater" }, "\u224D\u0338": { "math": "{\\not\\kern-0.3em\\times}", "alt": ["unicode-math"] }, "<\u0338": { "math": "\\not<" }, ">\u0338": { "math": "\\not>" }, "\u2264\u0338": { "math": "\\not\\leq" }, "\u2265\u0338": { "math": "\\not\\geq" }, "\u2272": { "math": "\\lessequivlnt" }, "\u2273": { "math": "\\greaterequivlnt" }, "\u2276\u0338": { "math": "\\notlessgreater" }, "\u2277\u0338": { "math": "\\notgreaterless" }, "\u227A": { "math": "\\prec" }, "\u227B": { "math": "\\succ" }, "\u227E": { "math": "\\precapprox" }, "\u227E\u0338": { "math": "\\NotPrecedesTilde" }, "\u227F": { "math": "\\succapprox" }, "\u227F\u0338": { "math": "\\NotSucceedsTilde" }, "\u227A\u0338": { "math": "\\not\\prec" }, "\u227B\u0338": { "math": "\\not\\succ" }, "\u2282": { "math": "\\subset" }, "\u2283": { "math": "\\supset" }, "\u2282\u0338": { "math": "\\not\\subset" }, "\u2283\u0338": { "math": "\\not\\supset" }, "\u2286": { "math": "\\subseteq" }, "\u2287": { "math": "\\supseteq" }, "\u2286\u0338": { "math": "\\not\\subseteq" }, "\u2287\u0338": { "math": "\\not\\supseteq" }, "\u228A\uFE00": { "math": "\\varsubsetneqq" }, "\u228B\uFE00": { "math": "\\varsupsetneq" }, "\u228E": { "math": "\\uplus" }, "\u228F\u0338": { "math": "\\NotSquareSubset" }, "\u2290\u0338": { "math": "\\NotSquareSuperset" }, "\u2291": { "math": "\\sqsubseteq" }, "\u2292": { "math": "\\sqsupseteq" }, "\u2293": { "math": "\\sqcap" }, "\u2294": { "math": "\\sqcup" }, "\u2295": { "math": "\\oplus" }, "\u2296": { "math": "\\ominus" }, "\u2297": { "math": "\\otimes" }, "\u2298": { "math": "\\oslash" }, "\u2299": { "math": "\\odot" }, "\u22A2": { "math": "\\vdash" }, "\u22A3": { "math": "\\dashv" }, "\u22A4": { "math": "\\top" }, "\u22A5": { "math": "\\perp" }, "\u22A7": { "math": "\\truestate" }, "\u22A8": { "math": "\\forcesextra" }, "\u22B6": { "math": "\\original" }, "\u22B7": { "math": "\\image" }, "\u22B9": { "math": "\\hermitconjmatrix" }, "\u22BE": { "math": "\\rightanglearc" }, "\u22C0": { "math": "\\bigwedge" }, "\u22C1": { "math": "\\bigvee" }, "\u22C2": { "math": "\\bigcap" }, "\u22C3": { "math": "\\bigcup" }, "\u22C4": { "math": "\\diamond" }, "\u22C5": { "math": "\\cdot" }, "\u22C6": { "math": "\\star" }, "\u22C8": { "math": "\\bowtie" }, "\u22D8": { "math": "\\verymuchless" }, "\u22D9": { "math": "\\verymuchgreater" }, "\u2291\u0338": { "math": "\\not\\sqsubseteq" }, "\u2292\u0338": { "math": "\\not\\sqsupseteq" }, "\u22B2\u0338": { "math": "\\ntriangleleft" }, "\u22B3\u0338": { "math": "\\ntriangleright" }, "\u22EE": { "math": "\\vdots" }, "\u22EF": { "math": "\\cdots" }, "\u22F0": { "math": "\\upslopeellipsis" }, "\u22F1": { "math": "\\ddots" }, "\u22F6": { "math": "\\barin" }, "\u2306": { "math": "\\perspcorrespond" }, "\u2308": { "math": "\\lceil" }, "\u2309": { "math": "\\rceil" }, "\u230A": { "math": "\\lfloor" }, "\u230B": { "math": "\\rfloor" }, "\u2311": { "math": "\\wasylozenge" }, "\u2315": { "math": "\\recorder" }, "\u2316": { "math": '{\\mathchar"2208}' }, "\u2322": { "math": "\\frown" }, "\u2323": { "math": "\\smile" }, "\u3008": { "text": "{\\textlangle}", "math": "\\langle" }, "\u3009": { "text": "{\\textrangle}", "math": "\\rangle" }, "\u2339": { "math": "\\APLinv" }, "\u233F": { "math": "\\notslash" }, "\u2340": { "math": "\\notbackslash" }, "\u2347": { "math": "\\APLleftarrowbox" }, "\u2348": { "math": "\\APLrightarrowbox" }, "\u2349": { "math": "\\invdiameter" }, "\u2350": { "math": "\\APLuparrowbox" }, "\u2357": { "math": "\\APLdownarrowbox" }, "\u235D": { "math": "\\APLcomment" }, "\u235E": { "math": "\\APLinput" }, "\u235F": { "math": "\\APLlog" }, "\u23B0": { "math": "\\lmoustache" }, "\u23B1": { "math": "\\rmoustache" }, "\u24C8": { "math": "\\circledS" }, "\u2571": { "math": "\\diagup" }, "\u25A1": { "math": "\\square" }, "\u25B6": { "math": "\\RHD" }, "\u25B7": { "math": "\\rhd" }, "\u25BD": { "math": "\\bigtriangledown" }, "\u25C0": { "math": "\\LHD" }, "\u25C1": { "math": "\\lhd" }, "\u25C6": { "text": "\\ding{117}", "math": "\\Diamondblack" }, "\u25C7": { "math": "\\Diamond" }, "\u25CB": { "math": "\\bigcirc" }, "\u25CF": { "text": "\\ding{108}", "math": "\\CIRCLE" }, "\u25EF": { "text": "{\\textbigcircle}", "math": "\\bigcirc" }, "\u2609": { "math": "\\Sun" }, "\u2610": { "math": "\\Square" }, "\u2611": { "math": "\\CheckedBox" }, "\u2612": { "math": "\\XBox" }, "\u2615": { "math": "\\steaming" }, "\u261E": { "text": "\\ding{43}", "math": "\\pointright" }, "\u2620": { "math": "\\skull" }, "\u2622": { "math": "\\radiation" }, "\u2623": { "math": "\\biohazard" }, "\u262F": { "math": "\\yinyang" }, "\u2639": { "math": "\\frownie" }, "\u263A": { "math": "\\smiley" }, "\u2641": { "math": "\\earth" }, "\u2660": { "text": "\\ding{171}", "math": "\\spadesuit" }, "\u2661": { "math": "\\heartsuit" }, "\u2662": { "math": "\\diamondsuit" }, "\u2663": { "math": "\\clubsuit" }, "\u266D": { "math": "\\flat" }, "\u266E": { "math": "\\natural" }, "\u266F": { "math": "\\sharp" }, "\u267B": { "math": "\\recycle" }, "\u2693": { "math": "\\anchor" }, "\u2694": { "math": "\\swords" }, "\u26A0": { "math": "\\warning" }, "\u26AA": { "math": "\\medcirc" }, "\u26AB": { "math": "\\medbullet" }, "\u270E": { "text": "\\ding{46}", "math": "\\pencil" }, "\u2717": { "text": "\\ding{55}", "math": "\\ballotx" }, "\u27A2": { "text": "\\ding{226}", "math": "\\arrowbullet" }, "\u27C2": { "math": "\\perp" }, "\u27C5": { "math": "\\Lbag" }, "\u27C6": { "math": "\\Rbag" }, "\u27D0": { "math": "\\Diamonddot" }, "\u27E6": { "math": "\\llbracket" }, "\u27E7": { "math": "\\rrbracket" }, "\u27E8": { "math": "\\langle" }, "\u27E9": { "math": "\\rangle" }, "\u27EA": { "math": "\\lang" }, "\u27EE": { "math": "\\lgroup" }, "\u27EF": { "math": "\\rgroup" }, "\u27F5": { "math": "\\longleftarrow" }, "\u27F6": { "math": "\\longrightarrow" }, "\u27F7": { "math": "\\longleftrightarrow" }, "\u27F8": { "math": "\\Longleftarrow" }, "\u27F9": { "math": "\\Longrightarrow" }, "\u27FA": { "math": "\\Longleftrightarrow" }, "\u27FC": { "math": "\\longmapsto" }, "\u2900": { "math": "\\psur" }, "\u2912": { "math": "\\UpArrowBar" }, "\u2913": { "math": "\\DownArrowBar" }, "\u2914": { "math": "\\pinj" }, "\u2915": { "math": "\\finj" }, "\u2916": { "math": "\\bij" }, "\u2940": { "math": "\\Elolarr" }, "\u2941": { "math": "\\Elorarr" }, "\u294A": { "math": "\\leftrightharpoon" }, "\u294B": { "math": "\\rightleftharpoon" }, "\u294F": { "math": "\\RightUpDownVector" }, "\u2951": { "math": "\\LeftUpDownVector" }, "\u2952": { "math": "\\LeftVectorBar" }, "\u2953": { "math": "\\RightVectorBar" }, "\u2954": { "math": "\\RightUpVectorBar" }, "\u2955": { "math": "\\RightDownVectorBar" }, "\u2956": { "math": "\\DownLeftVectorBar" }, "\u2957": { "math": "\\DownRightVectorBar" }, "\u2958": { "math": "\\LeftUpVectorBar" }, "\u2959": { "math": "\\LeftDownVectorBar" }, "\u295A": { "math": "\\LeftTeeVector" }, "\u295B": { "math": "\\RightTeeVector" }, "\u295C": { "math": "\\RightUpTeeVector" }, "\u295D": { "math": "\\RightDownTeeVector" }, "\u295E": { "math": "\\DownLeftTeeVector" }, "\u295F": { "math": "\\DownRightTeeVector" }, "\u2960": { "math": "\\LeftUpTeeVector" }, "\u2961": { "math": "\\LeftDownTeeVector" }, "\u2962": { "math": "\\leftleftharpoons" }, "\u2963": { "math": "\\upupharpoons" }, "\u2964": { "math": "\\rightrightharpoons" }, "\u2965": { "math": "\\downdownharpoons" }, "\u296A": { "math": "\\leftbarharpoon" }, "\u296B": { "math": "\\barleftharpoon" }, "\u296C": { "math": "\\rightbarharpoon" }, "\u296D": { "math": "\\barrightharpoon" }, "\u296E": { "math": "\\UpEquilibrium" }, "\u296F": { "math": "\\ReverseUpEquilibrium" }, "\u2970": { "math": "\\RoundImplies" }, "\u2988": { "math": "\\rimg" }, "\u2989": { "math": "\\lblot" }, "\u298A": { "math": "\\rblot" }, "\u299C": { "math": "\\Angle" }, "\u29C4": { "math": "\\boxslash" }, "\u29CF": { "math": "\\LeftTriangleBar" }, "\u29CF\u0338": { "math": "\\NotLeftTriangleBar" }, "\u29D0": { "math": "\\RightTriangleBar" }, "\u29D0\u0338": { "math": "\\NotRightTriangleBar" }, "\u29DF": { "math": "\\multimapboth" }, "\u29F5": { "math": "\\setminus" }, "\u29F9": { "math": "\\zhide" }, "\u2A00": { "math": "\\bigodot" }, "\u2A01": { "math": "\\bigoplus" }, "\u2A02": { "math": "\\bigotimes" }, "\u2A06": { "math": "\\Elxsqcup" }, "\u2A09": { "math": "\\varprod" }, "\u2A0F": { "math": "\\clockoint" }, "\u2A16": { "math": "\\sqrint" }, "\u2A3F": { "math": "\\amalg" }, "\u2A56": { "math": "\\ElOr" }, "\u2A6E": { "math": "\\stackrel{*}{=}" }, "\u2A75": { "math": "\\Equal" }, "\u2A76": { "math": "\\Same" }, "\u2A7D": { "math": "\\leq", "alt": ["amssymb", "unicode-math"] }, "\u2AA1": { "math": "\\NestedLessLess" }, "\u2AA1\u0338": { "math": "\\NotNestedLessLess" }, "\u2AA2": { "math": "\\NestedGreaterGreater" }, "\u2AA2\u0338": { "math": "\\NotNestedGreaterGreater" }, "\u2AA6": { "math": "\\leftslice" }, "\u2AA7": { "math": "\\rightslice" }, "\u2AAF": { "math": "\\preceq" }, "\u2AAF\u0338": { "math": "\\not\\preceq" }, "\u2AB0": { "math": "\\succeq" }, "\u2AB0\u0338": { "math": "\\not\\succeq" }, "\u2ABB": { "math": "\\llcurly" }, "\u2ABC": { "math": "\\ggcurly" }, "\u2AC5\u0338": { "math": "\\nsubseteqq" }, "\u2AC6\u0338": { "math": "\\nsupseteqq" }, "\u2ADD\u0338": { "math": "\\forks", "alt": ["unicode-math"] }, "\u2AEA": { "math": "\\Top" }, "\u2AFD": { "math": "{{/}\\!\\!{/}}" }, "\u2AFD\u20E5": { "math": "{\\rlap{\\textbackslash}{{/}\\!\\!{/}}}" }, "\u3014": { "math": "\\lbrbrak" }, "\u3015": { "math": "\\rbrbrak" }, "\u301A": { "math": "\\openbracketleft" }, "\u301B": { "math": "\\openbracketright" }, "\u{1D400}": { "math": "\\mathbf{A}", "alt": ["unicode-math"] }, "\u{1D401}": { "math": "\\mathbf{B}", "alt": ["unicode-math"] }, "\u{1D402}": { "math": "\\mathbf{C}", "alt": ["unicode-math"] }, "\u{1D403}": { "math": "\\mathbf{D}", "alt": ["unicode-math"] }, "\u{1D404}": { "math": "\\mathbf{E}", "alt": ["unicode-math"] }, "\u{1D405}": { "math": "\\mathbf{F}", "alt": ["unicode-math"] }, "\u{1D406}": { "math": "\\mathbf{G}", "alt": ["unicode-math"] }, "\u{1D407}": { "math": "\\mathbf{H}", "alt": ["unicode-math"] }, "\u{1D408}": { "math": "\\mathbf{I}", "alt": ["unicode-math"] }, "\u{1D409}": { "math": "\\mathbf{J}", "alt": ["unicode-math"] }, "\u{1D40A}": { "math": "\\mathbf{K}", "alt": ["unicode-math"] }, "\u{1D40B}": { "math": "\\mathbf{L}", "alt": ["unicode-math"] }, "\u{1D40C}": { "math": "\\mathbf{M}", "alt": ["unicode-math"] }, "\u{1D40D}": { "math": "\\mathbf{N}", "alt": ["unicode-math"] }, "\u{1D40E}": { "math": "\\mathbf{O}", "alt": ["unicode-math"] }, "\u{1D40F}": { "math": "\\mathbf{P}", "alt": ["unicode-math"] }, "\u{1D410}": { "math": "\\mathbf{Q}", "alt": ["unicode-math"] }, "\u{1D411}": { "math": "\\mathbf{R}", "alt": ["unicode-math"] }, "\u{1D412}": { "math": "\\mathbf{S}", "alt": ["unicode-math"] }, "\u{1D413}": { "math": "\\mathbf{T}", "alt": ["unicode-math"] }, "\u{1D414}": { "math": "\\mathbf{U}", "alt": ["unicode-math"] }, "\u{1D415}": { "math": "\\mathbf{V}", "alt": ["unicode-math"] }, "\u{1D416}": { "math": "\\mathbf{W}", "alt": ["unicode-math"] }, "\u{1D417}": { "math": "\\mathbf{X}", "alt": ["unicode-math"] }, "\u{1D418}": { "math": "\\mathbf{Y}", "alt": ["unicode-math"] }, "\u{1D419}": { "math": "\\mathbf{Z}", "alt": ["unicode-math"] }, "\u{1D41A}": { "math": "\\mathbf{a}", "alt": ["unicode-math"] }, "\u{1D41B}": { "math": "\\mathbf{b}", "alt": ["unicode-math"] }, "\u{1D41C}": { "math": "\\mathbf{c}", "alt": ["unicode-math"] }, "\u{1D41D}": { "math": "\\mathbf{d}", "alt": ["unicode-math"] }, "\u{1D41E}": { "math": "\\mathbf{e}", "alt": ["unicode-math"] }, "\u{1D41F}": { "math": "\\mathbf{f}", "alt": ["unicode-math"] }, "\u{1D420}": { "math": "\\mathbf{g}", "alt": ["unicode-math"] }, "\u{1D421}": { "math": "\\mathbf{h}", "alt": ["unicode-math"] }, "\u{1D422}": { "math": "\\mathbf{i}", "alt": ["unicode-math"] }, "\u{1D423}": { "math": "\\mathbf{j}", "alt": ["unicode-math"] }, "\u{1D424}": { "math": "\\mathbf{k}", "alt": ["unicode-math"] }, "\u{1D425}": { "math": "\\mathbf{l}", "alt": ["unicode-math"] }, "\u{1D426}": { "math": "\\mathbf{m}", "alt": ["unicode-math"] }, "\u{1D427}": { "math": "\\mathbf{n}", "alt": ["unicode-math"] }, "\u{1D428}": { "math": "\\mathbf{o}", "alt": ["unicode-math"] }, "\u{1D429}": { "math": "\\mathbf{p}", "alt": ["unicode-math"] }, "\u{1D42A}": { "math": "\\mathbf{q}", "alt": ["unicode-math"] }, "\u{1D42B}": { "math": "\\mathbf{r}", "alt": ["unicode-math"] }, "\u{1D42C}": { "math": "\\mathbf{s}", "alt": ["unicode-math"] }, "\u{1D42D}": { "math": "\\mathbf{t}", "alt": ["unicode-math"] }, "\u{1D42E}": { "math": "\\mathbf{u}", "alt": ["unicode-math"] }, "\u{1D42F}": { "math": "\\mathbf{v}", "alt": ["unicode-math"] }, "\u{1D430}": { "math": "\\mathbf{w}", "alt": ["unicode-math"] }, "\u{1D431}": { "math": "\\mathbf{x}", "alt": ["unicode-math"] }, "\u{1D432}": { "math": "\\mathbf{y}", "alt": ["unicode-math"] }, "\u{1D433}": { "math": "\\mathbf{z}", "alt": ["unicode-math"] }, "\u{1D434}": { "math": "A", "alt": ["unicode-math"] }, "\u{1D435}": { "math": "B", "alt": ["unicode-math"] }, "\u{1D436}": { "math": "C", "alt": ["unicode-math"] }, "\u{1D437}": { "math": "D", "alt": ["unicode-math"] }, "\u{1D438}": { "math": "E", "alt": ["unicode-math"] }, "\u{1D439}": { "math": "F", "alt": ["unicode-math"] }, "\u{1D43A}": { "math": "G", "alt": ["unicode-math"] }, "\u{1D43B}": { "math": "H", "alt": ["unicode-math"] }, "\u{1D43C}": { "math": "I", "alt": ["unicode-math"] }, "\u{1D43D}": { "math": "J", "alt": ["unicode-math"] }, "\u{1D43E}": { "math": "K", "alt": ["unicode-math"] }, "\u{1D43F}": { "math": "L", "alt": ["unicode-math"] }, "\u{1D440}": { "math": "M", "alt": ["unicode-math"] }, "\u{1D441}": { "math": "N", "alt": ["unicode-math"] }, "\u{1D442}": { "math": "O", "alt": ["unicode-math"] }, "\u{1D443}": { "math": "P", "alt": ["unicode-math"] }, "\u{1D444}": { "math": "Q", "alt": ["unicode-math"] }, "\u{1D445}": { "math": "R", "alt": ["unicode-math"] }, "\u{1D446}": { "math": "S", "alt": ["unicode-math"] }, "\u{1D447}": { "math": "T", "alt": ["unicode-math"] }, "\u{1D448}": { "math": "U", "alt": ["unicode-math"] }, "\u{1D449}": { "math": "V", "alt": ["unicode-math"] }, "\u{1D44A}": { "math": "W", "alt": ["unicode-math"] }, "\u{1D44B}": { "math": "X", "alt": ["unicode-math"] }, "\u{1D44C}": { "math": "Y", "alt": ["unicode-math"] }, "\u{1D44D}": { "math": "Z", "alt": ["unicode-math"] }, "\u{1D44E}": { "math": "a", "alt": ["unicode-math"] }, "\u{1D44F}": { "math": "b", "alt": ["unicode-math"] }, "\u{1D450}": { "math": "c", "alt": ["unicode-math"] }, "\u{1D451}": { "math": "d", "alt": ["unicode-math"] }, "\u{1D452}": { "math": "e", "alt": ["unicode-math"] }, "\u{1D453}": { "math": "f", "alt": ["unicode-math"] }, "\u{1D454}": { "math": "g", "alt": ["unicode-math"] }, "\u{1D456}": { "math": "i", "alt": ["unicode-math"] }, "\u{1D457}": { "math": "j", "alt": ["unicode-math"] }, "\u{1D458}": { "math": "k", "alt": ["unicode-math"] }, "\u{1D459}": { "math": "l", "alt": ["unicode-math"] }, "\u{1D45A}": { "math": "m", "alt": ["unicode-math"] }, "\u{1D45B}": { "math": "n", "alt": ["unicode-math"] }, "\u{1D45C}": { "math": "o", "alt": ["unicode-math"] }, "\u{1D45D}": { "math": "p", "alt": ["unicode-math"] }, "\u{1D45E}": { "math": "q", "alt": ["unicode-math"] }, "\u{1D45F}": { "math": "r", "alt": ["unicode-math"] }, "\u{1D460}": { "math": "s", "alt": ["unicode-math"] }, "\u{1D461}": { "math": "t", "alt": ["unicode-math"] }, "\u{1D462}": { "math": "u", "alt": ["unicode-math"] }, "\u{1D463}": { "math": "v", "alt": ["unicode-math"] }, "\u{1D464}": { "math": "w", "alt": ["unicode-math"] }, "\u{1D465}": { "math": "x", "alt": ["unicode-math"] }, "\u{1D466}": { "math": "y", "alt": ["unicode-math"] }, "\u{1D467}": { "math": "z", "alt": ["unicode-math"] }, "\u{1D468}": { "math": "\\mathbit{A}", "alt": ["unicode-math"] }, "\u{1D469}": { "math": "\\mathbit{B}", "alt": ["unicode-math"] }, "\u{1D46A}": { "math": "\\mathbit{C}", "alt": ["unicode-math"] }, "\u{1D46B}": { "math": "\\mathbit{D}", "alt": ["unicode-math"] }, "\u{1D46C}": { "math": "\\mathbit{E}", "alt": ["unicode-math"] }, "\u{1D46D}": { "math": "\\mathbit{F}", "alt": ["unicode-math"] }, "\u{1D46E}": { "math": "\\mathbit{G}", "alt": ["unicode-math"] }, "\u{1D46F}": { "math": "\\mathbit{H}", "alt": ["unicode-math"] }, "\u{1D470}": { "math": "\\mathbit{I}", "alt": ["unicode-math"] }, "\u{1D471}": { "math": "\\mathbit{J}", "alt": ["unicode-math"] }, "\u{1D472}": { "math": "\\mathbit{K}", "alt": ["unicode-math"] }, "\u{1D473}": { "math": "\\mathbit{L}", "alt": ["unicode-math"] }, "\u{1D474}": { "math": "\\mathbit{M}", "alt": ["unicode-math"] }, "\u{1D475}": { "math": "\\mathbit{N}", "alt": ["unicode-math"] }, "\u{1D476}": { "math": "\\mathbit{O}", "alt": ["unicode-math"] }, "\u{1D477}": { "math": "\\mathbit{P}", "alt": ["unicode-math"] }, "\u{1D478}": { "math": "\\mathbit{Q}", "alt": ["unicode-math"] }, "\u{1D479}": { "math": "\\mathbit{R}", "alt": ["unicode-math"] }, "\u{1D47A}": { "math": "\\mathbit{S}", "alt": ["unicode-math"] }, "\u{1D47B}": { "math": "\\mathbit{T}", "alt": ["unicode-math"] }, "\u{1D47C}": { "math": "\\mathbit{U}", "alt": ["unicode-math"] }, "\u{1D47D}": { "math": "\\mathbit{V}", "alt": ["unicode-math"] }, "\u{1D47E}": { "math": "\\mathbit{W}", "alt": ["unicode-math"] }, "\u{1D47F}": { "math": "\\mathbit{X}", "alt": ["unicode-math"] }, "\u{1D480}": { "math": "\\mathbit{Y}", "alt": ["unicode-math"] }, "\u{1D481}": { "math": "\\mathbit{Z}", "alt": ["unicode-math"] }, "\u{1D482}": { "math": "\\mathbit{a}", "alt": ["unicode-math"] }, "\u{1D483}": { "math": "\\mathbit{b}", "alt": ["unicode-math"] }, "\u{1D484}": { "math": "\\mathbit{c}", "alt": ["unicode-math"] }, "\u{1D485}": { "math": "\\mathbit{d}", "alt": ["unicode-math"] }, "\u{1D486}": { "math": "\\mathbit{e}", "alt": ["unicode-math"] }, "\u{1D487}": { "math": "\\mathbit{f}", "alt": ["unicode-math"] }, "\u{1D488}": { "math": "\\mathbit{g}", "alt": ["unicode-math"] }, "\u{1D489}": { "math": "\\mathbit{h}", "alt": ["unicode-math"] }, "\u{1D48A}": { "math": "\\mathbit{i}", "alt": ["unicode-math"] }, "\u{1D48B}": { "math": "\\mathbit{j}", "alt": ["unicode-math"] }, "\u{1D48C}": { "math": "\\mathbit{k}", "alt": ["unicode-math"] }, "\u{1D48D}": { "math": "\\mathbit{l}", "alt": ["unicode-math"] }, "\u{1D48E}": { "math": "\\mathbit{m}", "alt": ["unicode-math"] }, "\u{1D48F}": { "math": "\\mathbit{n}", "alt": ["unicode-math"] }, "\u{1D490}": { "math": "\\mathbit{o}", "alt": ["unicode-math"] }, "\u{1D491}": { "math": "\\mathbit{p}", "alt": ["unicode-math"] }, "\u{1D492}": { "math": "\\mathbit{q}", "alt": ["unicode-math"] }, "\u{1D493}": { "math": "\\mathbit{r}", "alt": ["unicode-math"] }, "\u{1D494}": { "math": "\\mathbit{s}", "alt": ["unicode-math"] }, "\u{1D495}": { "math": "\\mathbit{t}", "alt": ["unicode-math"] }, "\u{1D496}": { "math": "\\mathbit{u}", "alt": ["unicode-math"] }, "\u{1D497}": { "math": "\\mathbit{v}", "alt": ["unicode-math"] }, "\u{1D498}": { "math": "\\mathbit{w}", "alt": ["unicode-math"] }, "\u{1D499}": { "math": "\\mathbit{x}", "alt": ["unicode-math"] }, "\u{1D49A}": { "math": "\\mathbit{y}", "alt": ["unicode-math"] }, "\u{1D49B}": { "math": "\\mathbit{z}", "alt": ["unicode-math"] }, "\u{1D4D0}": { "math": "\\mathmit{A}", "alt": ["unicode-math"] }, "\u{1D4D1}": { "math": "\\mathmit{B}", "alt": ["unicode-math"] }, "\u{1D4D2}": { "math": "\\mathmit{C}", "alt": ["unicode-math"] }, "\u{1D4D3}": { "math": "\\mathmit{D}", "alt": ["unicode-math"] }, "\u{1D4D4}": { "math": "\\mathmit{E}", "alt": ["unicode-math"] }, "\u{1D4D5}": { "math": "\\mathmit{F}", "alt": ["unicode-math"] }, "\u{1D4D6}": { "math": "\\mathmit{G}", "alt": ["unicode-math"] }, "\u{1D4D7}": { "math": "\\mathmit{H}", "alt": ["unicode-math"] }, "\u{1D4D8}": { "math": "\\mathmit{I}", "alt": ["unicode-math"] }, "\u{1D4D9}": { "math": "\\mathmit{J}", "alt": ["unicode-math"] }, "\u{1D4DA}": { "math": "\\mathmit{K}", "alt": ["unicode-math"] }, "\u{1D4DB}": { "math": "\\mathmit{L}", "alt": ["unicode-math"] }, "\u{1D4DC}": { "math": "\\mathmit{M}", "alt": ["unicode-math"] }, "\u{1D4DD}": { "math": "\\mathmit{N}", "alt": ["unicode-math"] }, "\u{1D4DE}": { "math": "\\mathmit{O}", "alt": ["unicode-math"] }, "\u{1D4DF}": { "math": "\\mathmit{P}", "alt": ["unicode-math"] }, "\u{1D4E0}": { "math": "\\mathmit{Q}", "alt": ["unicode-math"] }, "\u{1D4E1}": { "math": "\\mathmit{R}", "alt": ["unicode-math"] }, "\u{1D4E2}": { "math": "\\mathmit{S}", "alt": ["unicode-math"] }, "\u{1D4E3}": { "math": "\\mathmit{T}", "alt": ["unicode-math"] }, "\u{1D4E4}": { "math": "\\mathmit{U}", "alt": ["unicode-math"] }, "\u{1D4E5}": { "math": "\\mathmit{V}", "alt": ["unicode-math"] }, "\u{1D4E6}": { "math": "\\mathmit{W}", "alt": ["unicode-math"] }, "\u{1D4E7}": { "math": "\\mathmit{X}", "alt": ["unicode-math"] }, "\u{1D4E8}": { "math": "\\mathmit{Y}", "alt": ["unicode-math"] }, "\u{1D4E9}": { "math": "\\mathmit{Z}", "alt": ["unicode-math"] }, "\u{1D4EA}": { "math": "\\mathmit{a}", "alt": ["unicode-math"] }, "\u{1D4EB}": { "math": "\\mathmit{b}", "alt": ["unicode-math"] }, "\u{1D4EC}": { "math": "\\mathmit{c}", "alt": ["unicode-math"] }, "\u{1D4ED}": { "math": "\\mathmit{d}", "alt": ["unicode-math"] }, "\u{1D4EE}": { "math": "\\mathmit{e}", "alt": ["unicode-math"] }, "\u{1D4EF}": { "math": "\\mathmit{f}", "alt": ["unicode-math"] }, "\u{1D4F0}": { "math": "\\mathmit{g}", "alt": ["unicode-math"] }, "\u{1D4F1}": { "math": "\\mathmit{h}", "alt": ["unicode-math"] }, "\u{1D4F2}": { "math": "\\mathmit{i}", "alt": ["unicode-math"] }, "\u{1D4F3}": { "math": "\\mathmit{j}", "alt": ["unicode-math"] }, "\u{1D4F4}": { "math": "\\mathmit{k}", "alt": ["unicode-math"] }, "\u{1D4F5}": { "math": "\\mathmit{l}", "alt": ["unicode-math"] }, "\u{1D4F6}": { "math": "\\mathmit{m}", "alt": ["unicode-math"] }, "\u{1D4F7}": { "math": "\\mathmit{n}", "alt": ["unicode-math"] }, "\u{1D4F8}": { "math": "\\mathmit{o}", "alt": ["unicode-math"] }, "\u{1D4F9}": { "math": "\\mathmit{p}", "alt": ["unicode-math"] }, "\u{1D4FA}": { "math": "\\mathmit{q}", "alt": ["unicode-math"] }, "\u{1D4FB}": { "math": "\\mathmit{r}", "alt": ["unicode-math"] }, "\u{1D4FC}": { "math": "\\mathmit{s}", "alt": ["unicode-math"] }, "\u{1D4FD}": { "math": "\\mathmit{t}", "alt": ["unicode-math"] }, "\u{1D4FE}": { "math": "\\mathmit{u}", "alt": ["unicode-math"] }, "\u{1D4FF}": { "math": "\\mathmit{v}", "alt": ["unicode-math"] }, "\u{1D500}": { "math": "\\mathmit{w}", "alt": ["unicode-math"] }, "\u{1D501}": { "math": "\\mathmit{x}", "alt": ["unicode-math"] }, "\u{1D502}": { "math": "\\mathmit{y}", "alt": ["unicode-math"] }, "\u{1D503}": { "math": "\\mathmit{z}", "alt": ["unicode-math"] }, "\u{1D504}": { "math": "\\mathfrak{A}", "alt": ["unicode-math"] }, "\u{1D505}": { "math": "\\mathfrak{B}", "alt": ["unicode-math"] }, "\u{1D507}": { "math": "\\mathfrak{D}", "alt": ["unicode-math"] }, "\u{1D508}": { "math": "\\mathfrak{E}", "alt": ["unicode-math"] }, "\u{1D509}": { "math": "\\mathfrak{F}", "alt": ["unicode-math"] }, "\u{1D50A}": { "math": "\\mathfrak{G}", "alt": ["unicode-math"] }, "\u{1D50D}": { "math": "\\mathfrak{J}", "alt": ["unicode-math"] }, "\u{1D50E}": { "math": "\\mathfrak{K}", "alt": ["unicode-math"] }, "\u{1D50F}": { "math": "\\mathfrak{L}", "alt": ["unicode-math"] }, "\u{1D510}": { "math": "\\mathfrak{M}", "alt": ["unicode-math"] }, "\u{1D511}": { "math": "\\mathfrak{N}", "alt": ["unicode-math"] }, "\u{1D512}": { "math": "\\mathfrak{O}", "alt": ["unicode-math"] }, "\u{1D513}": { "math": "\\mathfrak{P}", "alt": ["unicode-math"] }, "\u{1D514}": { "math": "\\mathfrak{Q}", "alt": ["unicode-math"] }, "\u{1D516}": { "math": "\\mathfrak{S}", "alt": ["unicode-math"] }, "\u{1D517}": { "math": "\\mathfrak{T}", "alt": ["unicode-math"] }, "\u{1D518}": { "math": "\\mathfrak{U}", "alt": ["unicode-math"] }, "\u{1D519}": { "math": "\\mathfrak{V}", "alt": ["unicode-math"] }, "\u{1D51A}": { "math": "\\mathfrak{W}", "alt": ["unicode-math"] }, "\u{1D51B}": { "math": "\\mathfrak{X}", "alt": ["unicode-math"] }, "\u{1D51C}": { "math": "\\mathfrak{Y}", "alt": ["unicode-math"] }, "\u{1D51E}": { "math": "\\mathfrak{a}", "alt": ["unicode-math"] }, "\u{1D51F}": { "math": "\\mathfrak{b}", "alt": ["unicode-math"] }, "\u{1D520}": { "math": "\\mathfrak{c}", "alt": ["unicode-math"] }, "\u{1D521}": { "math": "\\mathfrak{d}", "alt": ["unicode-math"] }, "\u{1D522}": { "math": "\\mathfrak{e}", "alt": ["unicode-math"] }, "\u{1D523}": { "math": "\\mathfrak{f}", "alt": ["unicode-math"] }, "\u{1D524}": { "math": "\\mathfrak{g}", "alt": ["unicode-math"] }, "\u{1D525}": { "math": "\\mathfrak{h}", "alt": ["unicode-math"] }, "\u{1D526}": { "math": "\\mathfrak{i}", "alt": ["unicode-math"] }, "\u{1D527}": { "math": "\\mathfrak{j}", "alt": ["unicode-math"] }, "\u{1D528}": { "math": "\\mathfrak{k}", "alt": ["unicode-math"] }, "\u{1D529}": { "math": "\\mathfrak{l}", "alt": ["unicode-math"] }, "\u{1D52A}": { "math": "\\mathfrak{m}", "alt": ["unicode-math"] }, "\u{1D52B}": { "math": "\\mathfrak{n}", "alt": ["unicode-math"] }, "\u{1D52C}": { "math": "\\mathfrak{o}", "alt": ["unicode-math"] }, "\u{1D52D}": { "math": "\\mathfrak{p}", "alt": ["unicode-math"] }, "\u{1D52E}": { "math": "\\mathfrak{q}", "alt": ["unicode-math"] }, "\u{1D52F}": { "math": "\\mathfrak{r}", "alt": ["unicode-math"] }, "\u{1D530}": { "math": "\\mathfrak{s}", "alt": ["unicode-math"] }, "\u{1D531}": { "math": "\\mathfrak{t}", "alt": ["unicode-math"] }, "\u{1D532}": { "math": "\\mathfrak{u}", "alt": ["unicode-math"] }, "\u{1D533}": { "math": "\\mathfrak{v}", "alt": ["unicode-math"] }, "\u{1D534}": { "math": "\\mathfrak{w}", "alt": ["unicode-math"] }, "\u{1D535}": { "math": "\\mathfrak{x}", "alt": ["unicode-math"] }, "\u{1D536}": { "math": "\\mathfrak{y}", "alt": ["unicode-math"] }, "\u{1D537}": { "math": "\\mathfrak{z}", "alt": ["unicode-math"] }, "\u{1D538}": { "math": "\\mathbb{A}", "alt": ["unicode-math"] }, "\u{1D539}": { "math": "\\mathbb{B}", "alt": ["unicode-math"] }, "\u{1D53B}": { "math": "\\mathbb{D}", "alt": ["unicode-math"] }, "\u{1D53C}": { "math": "\\mathbb{E}", "alt": ["unicode-math"] }, "\u{1D53D}": { "math": "\\mathbb{F}", "alt": ["unicode-math"] }, "\u{1D53E}": { "math": "\\mathbb{G}", "alt": ["unicode-math"] }, "\u{1D540}": { "math": "\\mathbb{I}", "alt": ["unicode-math"] }, "\u{1D541}": { "math": "\\mathbb{J}", "alt": ["unicode-math"] }, "\u{1D542}": { "math": "\\mathbb{K}", "alt": ["unicode-math"] }, "\u{1D543}": { "math": "\\mathbb{L}", "alt": ["unicode-math"] }, "\u{1D544}": { "math": "\\mathbb{M}", "alt": ["unicode-math"] }, "\u{1D546}": { "math": "\\mathbb{O}", "alt": ["unicode-math"] }, "\u{1D54A}": { "math": "\\mathbb{S}", "alt": ["unicode-math"] }, "\u{1D54B}": { "math": "\\mathbb{T}", "alt": ["unicode-math"] }, "\u{1D54C}": { "math": "\\mathbb{U}", "alt": ["unicode-math"] }, "\u{1D54D}": { "math": "\\mathbb{V}", "alt": ["unicode-math"] }, "\u{1D54E}": { "math": "\\mathbb{W}", "alt": ["unicode-math"] }, "\u{1D54F}": { "math": "\\mathbb{X}", "alt": ["unicode-math"] }, "\u{1D550}": { "math": "\\mathbb{Y}", "alt": ["unicode-math"] }, "\u{1D552}": { "math": "\\mathbb{a}", "alt": ["unicode-math"] }, "\u{1D553}": { "math": "\\mathbb{b}", "alt": ["unicode-math"] }, "\u{1D554}": { "math": "\\mathbb{c}", "alt": ["unicode-math"] }, "\u{1D555}": { "math": "\\mathbb{d}", "alt": ["unicode-math"] }, "\u{1D556}": { "math": "\\mathbb{e}", "alt": ["unicode-math"] }, "\u{1D557}": { "math": "\\mathbb{f}", "alt": ["unicode-math"] }, "\u{1D558}": { "math": "\\mathbb{g}", "alt": ["unicode-math"] }, "\u{1D559}": { "math": "\\mathbb{h}", "alt": ["unicode-math"] }, "\u{1D55A}": { "math": "\\mathbb{i}", "alt": ["unicode-math"] }, "\u{1D55B}": { "math": "\\mathbb{j}", "alt": ["unicode-math"] }, "\u{1D55C}": { "math": "\\mathbb{k}", "alt": ["unicode-math"] }, "\u{1D55D}": { "math": "\\mathbb{l}", "alt": ["unicode-math"] }, "\u{1D55E}": { "math": "\\mathbb{m}", "alt": ["unicode-math"] }, "\u{1D55F}": { "math": "\\mathbb{n}", "alt": ["unicode-math"] }, "\u{1D560}": { "math": "\\mathbb{o}", "alt": ["unicode-math"] }, "\u{1D561}": { "math": "\\mathbb{p}", "alt": ["unicode-math"] }, "\u{1D562}": { "math": "\\mathbb{q}", "alt": ["unicode-math"] }, "\u{1D563}": { "math": "\\mathbb{r}", "alt": ["unicode-math"] }, "\u{1D564}": { "math": "\\mathbb{s}", "alt": ["unicode-math"] }, "\u{1D565}": { "math": "\\mathbb{t}", "alt": ["unicode-math"] }, "\u{1D566}": { "math": "\\mathbb{u}", "alt": ["unicode-math"] }, "\u{1D567}": { "math": "\\mathbb{v}", "alt": ["unicode-math"] }, "\u{1D568}": { "math": "\\mathbb{w}", "alt": ["unicode-math"] }, "\u{1D569}": { "math": "\\mathbb{x}", "alt": ["unicode-math"] }, "\u{1D56A}": { "math": "\\mathbb{y}", "alt": ["unicode-math"] }, "\u{1D56B}": { "math": "\\mathbb{z}", "alt": ["unicode-math"] }, "\u{1D56C}": { "math": "A", "alt": ["unicode-math"] }, "\u{1D56D}": { "math": "B", "alt": ["unicode-math"] }, "\u{1D56E}": { "math": "C", "alt": ["unicode-math"] }, "\u{1D56F}": { "math": "D", "alt": ["unicode-math"] }, "\u{1D570}": { "math": "E", "alt": ["unicode-math"] }, "\u{1D571}": { "math": "F", "alt": ["unicode-math"] }, "\u{1D572}": { "math": "G", "alt": ["unicode-math"] }, "\u{1D573}": { "math": "H", "alt": ["unicode-math"] }, "\u{1D574}": { "math": "I", "alt": ["unicode-math"] }, "\u{1D575}": { "math": "J", "alt": ["unicode-math"] }, "\u{1D576}": { "math": "K", "alt": ["unicode-math"] }, "\u{1D577}": { "math": "L", "alt": ["unicode-math"] }, "\u{1D578}": { "math": "M", "alt": ["unicode-math"] }, "\u{1D579}": { "math": "N", "alt": ["unicode-math"] }, "\u{1D57A}": { "math": "O", "alt": ["unicode-math"] }, "\u{1D57B}": { "math": "P", "alt": ["unicode-math"] }, "\u{1D57C}": { "math": "Q", "alt": ["unicode-math"] }, "\u{1D57D}": { "math": "R", "alt": ["unicode-math"] }, "\u{1D57E}": { "math": "S", "alt": ["unicode-math"] }, "\u{1D57F}": { "math": "T", "alt": ["unicode-math"] }, "\u{1D580}": { "math": "U", "alt": ["unicode-math"] }, "\u{1D581}": { "math": "V", "alt": ["unicode-math"] }, "\u{1D582}": { "math": "W", "alt": ["unicode-math"] }, "\u{1D583}": { "math": "X", "alt": ["unicode-math"] }, "\u{1D584}": { "math": "Y", "alt": ["unicode-math"] }, "\u{1D585}": { "math": "Z", "alt": ["unicode-math"] }, "\u{1D586}": { "math": "a", "alt": ["unicode-math"] }, "\u{1D587}": { "math": "b", "alt": ["unicode-math"] }, "\u{1D588}": { "math": "c", "alt": ["unicode-math"] }, "\u{1D589}": { "math": "d", "alt": ["unicode-math"] }, "\u{1D58A}": { "math": "e", "alt": ["unicode-math"] }, "\u{1D58B}": { "math": "f", "alt": ["unicode-math"] }, "\u{1D58C}": { "math": "g", "alt": ["unicode-math"] }, "\u{1D58D}": { "math": "h", "alt": ["unicode-math"] }, "\u{1D58E}": { "math": "i", "alt": ["unicode-math"] }, "\u{1D58F}": { "math": "j", "alt": ["unicode-math"] }, "\u{1D590}": { "math": "k", "alt": ["unicode-math"] }, "\u{1D591}": { "math": "l", "alt": ["unicode-math"] }, "\u{1D592}": { "math": "m", "alt": ["unicode-math"] }, "\u{1D593}": { "math": "n", "alt": ["unicode-math"] }, "\u{1D594}": { "math": "o", "alt": ["unicode-math"] }, "\u{1D595}": { "math": "p", "alt": ["unicode-math"] }, "\u{1D596}": { "math": "q", "alt": ["unicode-math"] }, "\u{1D597}": { "math": "r", "alt": ["unicode-math"] }, "\u{1D598}": { "math": "s", "alt": ["unicode-math"] }, "\u{1D599}": { "math": "t", "alt": ["unicode-math"] }, "\u{1D59A}": { "math": "u", "alt": ["unicode-math"] }, "\u{1D59B}": { "math": "v", "alt": ["unicode-math"] }, "\u{1D59C}": { "math": "w", "alt": ["unicode-math"] }, "\u{1D59D}": { "math": "x", "alt": ["unicode-math"] }, "\u{1D59E}": { "math": "y", "alt": ["unicode-math"] }, "\u{1D59F}": { "math": "z", "alt": ["unicode-math"] }, "\u{1D5A0}": { "math": "\\mathsf{A}", "alt": ["unicode-math"] }, "\u{1D5A1}": { "math": "\\mathsf{B}", "alt": ["unicode-math"] }, "\u{1D5A2}": { "math": "\\mathsf{C}", "alt": ["unicode-math"] }, "\u{1D5A3}": { "math": "\\mathsf{D}", "alt": ["unicode-math"] }, "\u{1D5A4}": { "math": "\\mathsf{E}", "alt": ["unicode-math"] }, "\u{1D5A5}": { "math": "\\mathsf{F}", "alt": ["unicode-math"] }, "\u{1D5A6}": { "math": "\\mathsf{G}", "alt": ["unicode-math"] }, "\u{1D5A7}": { "math": "\\mathsf{H}", "alt": ["unicode-math"] }, "\u{1D5A8}": { "math": "\\mathsf{I}", "alt": ["unicode-math"] }, "\u{1D5A9}": { "math": "\\mathsf{J}", "alt": ["unicode-math"] }, "\u{1D5AA}": { "math": "\\mathsf{K}", "alt": ["unicode-math"] }, "\u{1D5AB}": { "math": "\\mathsf{L}", "alt": ["unicode-math"] }, "\u{1D5AC}": { "math": "\\mathsf{M}", "alt": ["unicode-math"] }, "\u{1D5AD}": { "math": "\\mathsf{N}", "alt": ["unicode-math"] }, "\u{1D5AE}": { "math": "\\mathsf{O}", "alt": ["unicode-math"] }, "\u{1D5AF}": { "math": "\\mathsf{P}", "alt": ["unicode-math"] }, "\u{1D5B0}": { "math": "\\mathsf{Q}", "alt": ["unicode-math"] }, "\u{1D5B1}": { "math": "\\mathsf{R}", "alt": ["unicode-math"] }, "\u{1D5B2}": { "math": "\\mathsf{S}", "alt": ["unicode-math"] }, "\u{1D5B3}": { "math": "\\mathsf{T}", "alt": ["unicode-math"] }, "\u{1D5B4}": { "math": "\\mathsf{U}", "alt": ["unicode-math"] }, "\u{1D5B5}": { "math": "\\mathsf{V}", "alt": ["unicode-math"] }, "\u{1D5B6}": { "math": "\\mathsf{W}", "alt": ["unicode-math"] }, "\u{1D5B7}": { "math": "\\mathsf{X}", "alt": ["unicode-math"] }, "\u{1D5B8}": { "math": "\\mathsf{Y}", "alt": ["unicode-math"] }, "\u{1D5B9}": { "math": "\\mathsf{Z}", "alt": ["unicode-math"] }, "\u{1D5BA}": { "math": "\\mathsf{a}", "alt": ["unicode-math"] }, "\u{1D5BB}": { "math": "\\mathsf{b}", "alt": ["unicode-math"] }, "\u{1D5BC}": { "math": "\\mathsf{c}", "alt": ["unicode-math"] }, "\u{1D5BD}": { "math": "\\mathsf{d}", "alt": ["unicode-math"] }, "\u{1D5BE}": { "math": "\\mathsf{e}", "alt": ["unicode-math"] }, "\u{1D5BF}": { "math": "\\mathsf{f}", "alt": ["unicode-math"] }, "\u{1D5C0}": { "math": "\\mathsf{g}", "alt": ["unicode-math"] }, "\u{1D5C1}": { "math": "\\mathsf{h}", "alt": ["unicode-math"] }, "\u{1D5C2}": { "math": "\\mathsf{i}", "alt": ["unicode-math"] }, "\u{1D5C3}": { "math": "\\mathsf{j}", "alt": ["unicode-math"] }, "\u{1D5C4}": { "math": "\\mathsf{k}", "alt": ["unicode-math"] }, "\u{1D5C5}": { "math": "\\mathsf{l}", "alt": ["unicode-math"] }, "\u{1D5C6}": { "math": "\\mathsf{m}", "alt": ["unicode-math"] }, "\u{1D5C7}": { "math": "\\mathsf{n}", "alt": ["unicode-math"] }, "\u{1D5C8}": { "math": "\\mathsf{o}", "alt": ["unicode-math"] }, "\u{1D5C9}": { "math": "\\mathsf{p}", "alt": ["unicode-math"] }, "\u{1D5CA}": { "math": "\\mathsf{q}", "alt": ["unicode-math"] }, "\u{1D5CB}": { "math": "\\mathsf{r}", "alt": ["unicode-math"] }, "\u{1D5CC}": { "math": "\\mathsf{s}", "alt": ["unicode-math"] }, "\u{1D5CD}": { "math": "\\mathsf{t}", "alt": ["unicode-math"] }, "\u{1D5CE}": { "math": "\\mathsf{u}", "alt": ["unicode-math"] }, "\u{1D5CF}": { "math": "\\mathsf{v}", "alt": ["unicode-math"] }, "\u{1D5D0}": { "math": "\\mathsf{w}", "alt": ["unicode-math"] }, "\u{1D5D1}": { "math": "\\mathsf{x}", "alt": ["unicode-math"] }, "\u{1D5D2}": { "math": "\\mathsf{y}", "alt": ["unicode-math"] }, "\u{1D5D3}": { "math": "\\mathsf{z}", "alt": ["unicode-math"] }, "\u{1D5D4}": { "math": "\\mathsfbf{A}", "alt": ["unicode-math"] }, "\u{1D5D5}": { "math": "\\mathsfbf{B}", "alt": ["unicode-math"] }, "\u{1D5D6}": { "math": "\\mathsfbf{C}", "alt": ["unicode-math"] }, "\u{1D5D7}": { "math": "\\mathsfbf{D}", "alt": ["unicode-math"] }, "\u{1D5D8}": { "math": "\\mathsfbf{E}", "alt": ["unicode-math"] }, "\u{1D5D9}": { "math": "\\mathsfbf{F}", "alt": ["unicode-math"] }, "\u{1D5DA}": { "math": "\\mathsfbf{G}", "alt": ["unicode-math"] }, "\u{1D5DB}": { "math": "\\mathsfbf{H}", "alt": ["unicode-math"] }, "\u{1D5DC}": { "math": "\\mathsfbf{I}", "alt": ["unicode-math"] }, "\u{1D5DD}": { "math": "\\mathsfbf{J}", "alt": ["unicode-math"] }, "\u{1D5DE}": { "math": "\\mathsfbf{K}", "alt": ["unicode-math"] }, "\u{1D5DF}": { "math": "\\mathsfbf{L}", "alt": ["unicode-math"] }, "\u{1D5E0}": { "math": "\\mathsfbf{M}", "alt": ["unicode-math"] }, "\u{1D5E1}": { "math": "\\mathsfbf{N}", "alt": ["unicode-math"] }, "\u{1D5E2}": { "math": "\\mathsfbf{O}", "alt": ["unicode-math"] }, "\u{1D5E3}": { "math": "\\mathsfbf{P}", "alt": ["unicode-math"] }, "\u{1D5E4}": { "math": "\\mathsfbf{Q}", "alt": ["unicode-math"] }, "\u{1D5E5}": { "math": "\\mathsfbf{R}", "alt": ["unicode-math"] }, "\u{1D5E6}": { "math": "\\mathsfbf{S}", "alt": ["unicode-math"] }, "\u{1D5E7}": { "math": "\\mathsfbf{T}", "alt": ["unicode-math"] }, "\u{1D5E8}": { "math": "\\mathsfbf{U}", "alt": ["unicode-math"] }, "\u{1D5E9}": { "math": "\\mathsfbf{V}", "alt": ["unicode-math"] }, "\u{1D5EA}": { "math": "\\mathsfbf{W}", "alt": ["unicode-math"] }, "\u{1D5EB}": { "math": "\\mathsfbf{X}", "alt": ["unicode-math"] }, "\u{1D5EC}": { "math": "\\mathsfbf{Y}", "alt": ["unicode-math"] }, "\u{1D5ED}": { "math": "\\mathsfbf{Z}", "alt": ["unicode-math"] }, "\u{1D5EE}": { "math": "\\mathsfbf{a}", "alt": ["unicode-math"] }, "\u{1D5EF}": { "math": "\\mathsfbf{b}", "alt": ["unicode-math"] }, "\u{1D5F0}": { "math": "\\mathsfbf{c}", "alt": ["unicode-math"] }, "\u{1D5F1}": { "math": "\\mathsfbf{d}", "alt": ["unicode-math"] }, "\u{1D5F2}": { "math": "\\mathsfbf{e}", "alt": ["unicode-math"] }, "\u{1D5F3}": { "math": "\\mathsfbf{f}", "alt": ["unicode-math"] }, "\u{1D5F4}": { "math": "\\mathsfbf{g}", "alt": ["unicode-math"] }, "\u{1D5F5}": { "math": "\\mathsfbf{h}", "alt": ["unicode-math"] }, "\u{1D5F6}": { "math": "\\mathsfbf{i}", "alt": ["unicode-math"] }, "\u{1D5F7}": { "math": "\\mathsfbf{j}", "alt": ["unicode-math"] }, "\u{1D5F8}": { "math": "\\mathsfbf{k}", "alt": ["unicode-math"] }, "\u{1D5F9}": { "math": "\\mathsfbf{l}", "alt": ["unicode-math"] }, "\u{1D5FA}": { "math": "\\mathsfbf{m}", "alt": ["unicode-math"] }, "\u{1D5FB}": { "math": "\\mathsfbf{n}", "alt": ["unicode-math"] }, "\u{1D5FC}": { "math": "\\mathsfbf{o}", "alt": ["unicode-math"] }, "\u{1D5FD}": { "math": "\\mathsfbf{p}", "alt": ["unicode-math"] }, "\u{1D5FE}": { "math": "\\mathsfbf{q}", "alt": ["unicode-math"] }, "\u{1D5FF}": { "math": "\\mathsfbf{r}", "alt": ["unicode-math"] }, "\u{1D600}": { "math": "\\mathsfbf{s}", "alt": ["unicode-math"] }, "\u{1D601}": { "math": "\\mathsfbf{t}", "alt": ["unicode-math"] }, "\u{1D602}": { "math": "\\mathsfbf{u}", "alt": ["unicode-math"] }, "\u{1D603}": { "math": "\\mathsfbf{v}", "alt": ["unicode-math"] }, "\u{1D604}": { "math": "\\mathsfbf{w}", "alt": ["unicode-math"] }, "\u{1D605}": { "math": "\\mathsfbf{x}", "alt": ["unicode-math"] }, "\u{1D606}": { "math": "\\mathsfbf{y}", "alt": ["unicode-math"] }, "\u{1D607}": { "math": "\\mathsfbf{z}", "alt": ["unicode-math"] }, "\u{1D608}": { "math": "\\mathsfsl{A}", "alt": ["unicode-math"] }, "\u{1D609}": { "math": "\\mathsfsl{B}", "alt": ["unicode-math"] }, "\u{1D60A}": { "math": "\\mathsfsl{C}", "alt": ["unicode-math"] }, "\u{1D60B}": { "math": "\\mathsfsl{D}", "alt": ["unicode-math"] }, "\u{1D60C}": { "math": "\\mathsfsl{E}", "alt": ["unicode-math"] }, "\u{1D60D}": { "math": "\\mathsfsl{F}", "alt": ["unicode-math"] }, "\u{1D60E}": { "math": "\\mathsfsl{G}", "alt": ["unicode-math"] }, "\u{1D60F}": { "math": "\\mathsfsl{H}", "alt": ["unicode-math"] }, "\u{1D610}": { "math": "\\mathsfsl{I}", "alt": ["unicode-math"] }, "\u{1D611}": { "math": "\\mathsfsl{J}", "alt": ["unicode-math"] }, "\u{1D612}": { "math": "\\mathsfsl{K}", "alt": ["unicode-math"] }, "\u{1D613}": { "math": "\\mathsfsl{L}", "alt": ["unicode-math"] }, "\u{1D614}": { "math": "\\mathsfsl{M}", "alt": ["unicode-math"] }, "\u{1D615}": { "math": "\\mathsfsl{N}", "alt": ["unicode-math"] }, "\u{1D616}": { "math": "\\mathsfsl{O}", "alt": ["unicode-math"] }, "\u{1D617}": { "math": "\\mathsfsl{P}", "alt": ["unicode-math"] }, "\u{1D618}": { "math": "\\mathsfsl{Q}", "alt": ["unicode-math"] }, "\u{1D619}": { "math": "\\mathsfsl{R}", "alt": ["unicode-math"] }, "\u{1D61A}": { "math": "\\mathsfsl{S}", "alt": ["unicode-math"] }, "\u{1D61B}": { "math": "\\mathsfsl{T}", "alt": ["unicode-math"] }, "\u{1D61C}": { "math": "\\mathsfsl{U}", "alt": ["unicode-math"] }, "\u{1D61D}": { "math": "\\mathsfsl{V}", "alt": ["unicode-math"] }, "\u{1D61E}": { "math": "\\mathsfsl{W}", "alt": ["unicode-math"] }, "\u{1D61F}": { "math": "\\mathsfsl{X}", "alt": ["unicode-math"] }, "\u{1D620}": { "math": "\\mathsfsl{Y}", "alt": ["unicode-math"] }, "\u{1D621}": { "math": "\\mathsfsl{Z}", "alt": ["unicode-math"] }, "\u{1D622}": { "math": "\\mathsfsl{a}", "alt": ["unicode-math"] }, "\u{1D623}": { "math": "\\mathsfsl{b}", "alt": ["unicode-math"] }, "\u{1D624}": { "math": "\\mathsfsl{c}", "alt": ["unicode-math"] }, "\u{1D625}": { "math": "\\mathsfsl{d}", "alt": ["unicode-math"] }, "\u{1D626}": { "math": "\\mathsfsl{e}", "alt": ["unicode-math"] }, "\u{1D627}": { "math": "\\mathsfsl{f}", "alt": ["unicode-math"] }, "\u{1D628}": { "math": "\\mathsfsl{g}", "alt": ["unicode-math"] }, "\u{1D629}": { "math": "\\mathsfsl{h}", "alt": ["unicode-math"] }, "\u{1D62A}": { "math": "\\mathsfsl{i}", "alt": ["unicode-math"] }, "\u{1D62B}": { "math": "\\mathsfsl{j}", "alt": ["unicode-math"] }, "\u{1D62C}": { "math": "\\mathsfsl{k}", "alt": ["unicode-math"] }, "\u{1D62D}": { "math": "\\mathsfsl{l}", "alt": ["unicode-math"] }, "\u{1D62E}": { "math": "\\mathsfsl{m}", "alt": ["unicode-math"] }, "\u{1D62F}": { "math": "\\mathsfsl{n}", "alt": ["unicode-math"] }, "\u{1D630}": { "math": "\\mathsfsl{o}", "alt": ["unicode-math"] }, "\u{1D631}": { "math": "\\mathsfsl{p}", "alt": ["unicode-math"] }, "\u{1D632}": { "math": "\\mathsfsl{q}", "alt": ["unicode-math"] }, "\u{1D633}": { "math": "\\mathsfsl{r}", "alt": ["unicode-math"] }, "\u{1D634}": { "math": "\\mathsfsl{s}", "alt": ["unicode-math"] }, "\u{1D635}": { "math": "\\mathsfsl{t}", "alt": ["unicode-math"] }, "\u{1D636}": { "math": "\\mathsfsl{u}", "alt": ["unicode-math"] }, "\u{1D637}": { "math": "\\mathsfsl{v}", "alt": ["unicode-math"] }, "\u{1D638}": { "math": "\\mathsfsl{w}", "alt": ["unicode-math"] }, "\u{1D639}": { "math": "\\mathsfsl{x}", "alt": ["unicode-math"] }, "\u{1D63A}": { "math": "\\mathsfsl{y}", "alt": ["unicode-math"] }, "\u{1D63B}": { "math": "\\mathsfsl{z}", "alt": ["unicode-math"] }, "\u{1D63C}": { "math": "\\mathsfbfsl{A}", "alt": ["unicode-math"] }, "\u{1D63D}": { "math": "\\mathsfbfsl{B}", "alt": ["unicode-math"] }, "\u{1D63E}": { "math": "\\mathsfbfsl{C}", "alt": ["unicode-math"] }, "\u{1D63F}": { "math": "\\mathsfbfsl{D}", "alt": ["unicode-math"] }, "\u{1D640}": { "math": "\\mathsfbfsl{E}", "alt": ["unicode-math"] }, "\u{1D641}": { "math": "\\mathsfbfsl{F}", "alt": ["unicode-math"] }, "\u{1D642}": { "math": "\\mathsfbfsl{G}", "alt": ["unicode-math"] }, "\u{1D643}": { "math": "\\mathsfbfsl{H}", "alt": ["unicode-math"] }, "\u{1D644}": { "math": "\\mathsfbfsl{I}", "alt": ["unicode-math"] }, "\u{1D645}": { "math": "\\mathsfbfsl{J}", "alt": ["unicode-math"] }, "\u{1D646}": { "math": "\\mathsfbfsl{K}", "alt": ["unicode-math"] }, "\u{1D647}": { "math": "\\mathsfbfsl{L}", "alt": ["unicode-math"] }, "\u{1D648}": { "math": "\\mathsfbfsl{M}", "alt": ["unicode-math"] }, "\u{1D649}": { "math": "\\mathsfbfsl{N}", "alt": ["unicode-math"] }, "\u{1D64A}": { "math": "\\mathsfbfsl{O}", "alt": ["unicode-math"] }, "\u{1D64B}": { "math": "\\mathsfbfsl{P}", "alt": ["unicode-math"] }, "\u{1D64C}": { "math": "\\mathsfbfsl{Q}", "alt": ["unicode-math"] }, "\u{1D64D}": { "math": "\\mathsfbfsl{R}", "alt": ["unicode-math"] }, "\u{1D64E}": { "math": "\\mathsfbfsl{S}", "alt": ["unicode-math"] }, "\u{1D64F}": { "math": "\\mathsfbfsl{T}", "alt": ["unicode-math"] }, "\u{1D650}": { "math": "\\mathsfbfsl{U}", "alt": ["unicode-math"] }, "\u{1D651}": { "math": "\\mathsfbfsl{V}", "alt": ["unicode-math"] }, "\u{1D652}": { "math": "\\mathsfbfsl{W}", "alt": ["unicode-math"] }, "\u{1D653}": { "math": "\\mathsfbfsl{X}", "alt": ["unicode-math"] }, "\u{1D654}": { "math": "\\mathsfbfsl{Y}", "alt": ["unicode-math"] }, "\u{1D655}": { "math": "\\mathsfbfsl{Z}", "alt": ["unicode-math"] }, "\u{1D656}": { "math": "\\mathsfbfsl{a}", "alt": ["unicode-math"] }, "\u{1D657}": { "math": "\\mathsfbfsl{b}", "alt": ["unicode-math"] }, "\u{1D658}": { "math": "\\mathsfbfsl{c}", "alt": ["unicode-math"] }, "\u{1D659}": { "math": "\\mathsfbfsl{d}", "alt": ["unicode-math"] }, "\u{1D65A}": { "math": "\\mathsfbfsl{e}", "alt": ["unicode-math"] }, "\u{1D65B}": { "math": "\\mathsfbfsl{f}", "alt": ["unicode-math"] }, "\u{1D65C}": { "math": "\\mathsfbfsl{g}", "alt": ["unicode-math"] }, "\u{1D65D}": { "math": "\\mathsfbfsl{h}", "alt": ["unicode-math"] }, "\u{1D65E}": { "math": "\\mathsfbfsl{i}", "alt": ["unicode-math"] }, "\u{1D65F}": { "math": "\\mathsfbfsl{j}", "alt": ["unicode-math"] }, "\u{1D660}": { "math": "\\mathsfbfsl{k}", "alt": ["unicode-math"] }, "\u{1D661}": { "math": "\\mathsfbfsl{l}", "alt": ["unicode-math"] }, "\u{1D662}": { "math": "\\mathsfbfsl{m}", "alt": ["unicode-math"] }, "\u{1D663}": { "math": "\\mathsfbfsl{n}", "alt": ["unicode-math"] }, "\u{1D664}": { "math": "\\mathsfbfsl{o}", "alt": ["unicode-math"] }, "\u{1D665}": { "math": "\\mathsfbfsl{p}", "alt": ["unicode-math"] }, "\u{1D666}": { "math": "\\mathsfbfsl{q}", "alt": ["unicode-math"] }, "\u{1D667}": { "math": "\\mathsfbfsl{r}", "alt": ["unicode-math"] }, "\u{1D668}": { "math": "\\mathsfbfsl{s}", "alt": ["unicode-math"] }, "\u{1D669}": { "math": "\\mathsfbfsl{t}", "alt": ["unicode-math"] }, "\u{1D66A}": { "math": "\\mathsfbfsl{u}", "alt": ["unicode-math"] }, "\u{1D66B}": { "math": "\\mathsfbfsl{v}", "alt": ["unicode-math"] }, "\u{1D66C}": { "math": "\\mathsfbfsl{w}", "alt": ["unicode-math"] }, "\u{1D66D}": { "math": "\\mathsfbfsl{x}", "alt": ["unicode-math"] }, "\u{1D66E}": { "math": "\\mathsfbfsl{y}", "alt": ["unicode-math"] }, "\u{1D66F}": { "math": "\\mathsfbfsl{z}", "alt": ["unicode-math"] }, "\u{1D670}": { "math": "\\mathtt{A}", "alt": ["unicode-math"] }, "\u{1D671}": { "math": "\\mathtt{B}", "alt": ["unicode-math"] }, "\u{1D672}": { "math": "\\mathtt{C}", "alt": ["unicode-math"] }, "\u{1D673}": { "math": "\\mathtt{D}", "alt": ["unicode-math"] }, "\u{1D674}": { "math": "\\mathtt{E}", "alt": ["unicode-math"] }, "\u{1D675}": { "math": "\\mathtt{F}", "alt": ["unicode-math"] }, "\u{1D676}": { "math": "\\mathtt{G}", "alt": ["unicode-math"] }, "\u{1D677}": { "math": "\\mathtt{H}", "alt": ["unicode-math"] }, "\u{1D678}": { "math": "\\mathtt{I}", "alt": ["unicode-math"] }, "\u{1D679}": { "math": "\\mathtt{J}", "alt": ["unicode-math"] }, "\u{1D67A}": { "math": "\\mathtt{K}", "alt": ["unicode-math"] }, "\u{1D67B}": { "math": "\\mathtt{L}", "alt": ["unicode-math"] }, "\u{1D67C}": { "math": "\\mathtt{M}", "alt": ["unicode-math"] }, "\u{1D67D}": { "math": "\\mathtt{N}", "alt": ["unicode-math"] }, "\u{1D67E}": { "math": "\\mathtt{O}", "alt": ["unicode-math"] }, "\u{1D67F}": { "math": "\\mathtt{P}", "alt": ["unicode-math"] }, "\u{1D680}": { "math": "\\mathtt{Q}", "alt": ["unicode-math"] }, "\u{1D681}": { "math": "\\mathtt{R}", "alt": ["unicode-math"] }, "\u{1D682}": { "math": "\\mathtt{S}", "alt": ["unicode-math"] }, "\u{1D683}": { "math": "\\mathtt{T}", "alt": ["unicode-math"] }, "\u{1D684}": { "math": "\\mathtt{U}", "alt": ["unicode-math"] }, "\u{1D685}": { "math": "\\mathtt{V}", "alt": ["unicode-math"] }, "\u{1D686}": { "math": "\\mathtt{W}", "alt": ["unicode-math"] }, "\u{1D687}": { "math": "\\mathtt{X}", "alt": ["unicode-math"] }, "\u{1D688}": { "math": "\\mathtt{Y}", "alt": ["unicode-math"] }, "\u{1D689}": { "math": "\\mathtt{Z}", "alt": ["unicode-math"] }, "\u{1D68A}": { "math": "\\mathtt{a}", "alt": ["unicode-math"] }, "\u{1D68B}": { "math": "\\mathtt{b}", "alt": ["unicode-math"] }, "\u{1D68C}": { "math": "\\mathtt{c}", "alt": ["unicode-math"] }, "\u{1D68D}": { "math": "\\mathtt{d}", "alt": ["unicode-math"] }, "\u{1D68E}": { "math": "\\mathtt{e}", "alt": ["unicode-math"] }, "\u{1D68F}": { "math": "\\mathtt{f}", "alt": ["unicode-math"] }, "\u{1D690}": { "math": "\\mathtt{g}", "alt": ["unicode-math"] }, "\u{1D691}": { "math": "\\mathtt{h}", "alt": ["unicode-math"] }, "\u{1D692}": { "math": "\\mathtt{i}", "alt": ["unicode-math"] }, "\u{1D693}": { "math": "\\mathtt{j}", "alt": ["unicode-math"] }, "\u{1D694}": { "math": "\\mathtt{k}", "alt": ["unicode-math"] }, "\u{1D695}": { "math": "\\mathtt{l}", "alt": ["unicode-math"] }, "\u{1D696}": { "math": "\\mathtt{m}", "alt": ["unicode-math"] }, "\u{1D697}": { "math": "\\mathtt{n}", "alt": ["unicode-math"] }, "\u{1D698}": { "math": "\\mathtt{o}", "alt": ["unicode-math"] }, "\u{1D699}": { "math": "\\mathtt{p}", "alt": ["unicode-math"] }, "\u{1D69A}": { "math": "\\mathtt{q}", "alt": ["unicode-math"] }, "\u{1D69B}": { "math": "\\mathtt{r}", "alt": ["unicode-math"] }, "\u{1D69C}": { "math": "\\mathtt{s}", "alt": ["unicode-math"] }, "\u{1D69D}": { "math": "\\mathtt{t}", "alt": ["unicode-math"] }, "\u{1D69E}": { "math": "\\mathtt{u}", "alt": ["unicode-math"] }, "\u{1D69F}": { "math": "\\mathtt{v}", "alt": ["unicode-math"] }, "\u{1D6A0}": { "math": "\\mathtt{w}", "alt": ["unicode-math"] }, "\u{1D6A1}": { "math": "\\mathtt{x}", "alt": ["unicode-math"] }, "\u{1D6A2}": { "math": "\\mathtt{y}", "alt": ["unicode-math"] }, "\u{1D6A3}": { "math": "\\mathtt{z}", "alt": ["unicode-math"] }, "\u{1D6A4}": { "math": "\\imath", "alt": ["unicode-math"] }, "\u{1D6A5}": { "math": "\\jmath", "alt": ["unicode-math"] }, "\u{1D6A8}": { "math": "\\mathbf{A}", "alt": ["unicode-math"] }, "\u{1D6A9}": { "math": "\\mathbf{B}", "alt": ["unicode-math"] }, "\u{1D6AA}": { "math": "\\mathbf{\\Gamma}", "alt": ["unicode-math"] }, "\u{1D6AB}": { "math": "\\mathbf{\\Delta}", "alt": ["unicode-math"] }, "\u{1D6AC}": { "math": "\\mathbf{E}", "alt": ["unicode-math"] }, "\u{1D6AD}": { "math": "\\mathbf{Z}", "alt": ["unicode-math"] }, "\u{1D6AE}": { "math": "\\mathbf{H}", "alt": ["unicode-math"] }, "\u{1D6AF}": { "math": "\\mathbf{\\Theta}", "alt": ["unicode-math"] }, "\u{1D6B0}": { "math": "\\mathbf{I}", "alt": ["unicode-math"] }, "\u{1D6B1}": { "math": "\\mathbf{K}", "alt": ["unicode-math"] }, "\u{1D6B2}": { "math": "\\mathbf{\\Lambda}", "alt": ["unicode-math"] }, "\u{1D6B3}": { "math": "M", "alt": ["unicode-math"] }, "\u{1D6B4}": { "math": "N", "alt": ["unicode-math"] }, "\u{1D6B5}": { "math": "\\mathbf{\\Xi}", "alt": ["unicode-math"] }, "\u{1D6B6}": { "math": "O", "alt": ["unicode-math"] }, "\u{1D6B7}": { "math": "\\mathbf{\\Pi}", "alt": ["unicode-math"] }, "\u{1D6B8}": { "math": "\\mathbf{P}", "alt": ["unicode-math"] }, "\u{1D6B9}": { "math": "\\mathbf{\\vartheta}", "alt": ["unicode-math"] }, "\u{1D6BA}": { "math": "\\mathbf{\\Sigma}", "alt": ["unicode-math"] }, "\u{1D6BB}": { "math": "\\mathbf{T}", "alt": ["unicode-math"] }, "\u{1D6BC}": { "math": "\\mathbf{\\Upsilon}", "alt": ["unicode-math"] }, "\u{1D6BD}": { "math": "\\mathbf{\\Phi}", "alt": ["unicode-math"] }, "\u{1D6BE}": { "math": "\\mathbf{X}", "alt": ["unicode-math"] }, "\u{1D6BF}": { "math": "\\mathbf{\\Psi}", "alt": ["unicode-math"] }, "\u{1D6C0}": { "math": "\\mathbf{\\Omega}", "alt": ["unicode-math"] }, "\u{1D6C1}": { "math": "\\mathbf{\\nabla}", "alt": ["unicode-math"] }, "\u{1D6C2}": { "math": "\\mathbf{\\alpha}", "alt": ["unicode-math"] }, "\u{1D6C3}": { "math": "\\mathbf{\\beta}", "alt": ["unicode-math"] }, "\u{1D6C4}": { "math": "\\mathbf{\\gamma}", "alt": ["unicode-math"] }, "\u{1D6C5}": { "math": "\\mathbf{\\delta}", "alt": ["unicode-math"] }, "\u{1D6C6}": { "math": "\\mathbf{\\epsilon}", "alt": ["unicode-math"] }, "\u{1D6C7}": { "math": "\\mathbf{\\zeta}", "alt": ["unicode-math"] }, "\u{1D6C8}": { "math": "\\mathbf{\\eta}", "alt": ["unicode-math"] }, "\u{1D6C9}": { "math": "\\mathbf{\\theta}", "alt": ["unicode-math"] }, "\u{1D6CA}": { "math": "\\mathbf{I}", "alt": ["unicode-math"] }, "\u{1D6CB}": { "math": "\\mathbf{K}", "alt": ["unicode-math"] }, "\u{1D6CC}": { "math": "\\mathbf{\\lambda}", "alt": ["unicode-math"] }, "\u{1D6CD}": { "math": "m", "alt": ["unicode-math"] }, "\u{1D6CE}": { "math": "v", "alt": ["unicode-math"] }, "\u{1D6CF}": { "math": "\\mathbf{\\xi}", "alt": ["unicode-math"] }, "\u{1D6D0}": { "math": "O", "alt": ["unicode-math"] }, "\u{1D6D1}": { "math": "\\mathbf{\\pi}", "alt": ["unicode-math"] }, "\u{1D6D2}": { "math": "\\mathbf{P}", "alt": ["unicode-math"] }, "\u{1D6D3}": { "math": "\\mathbf{\\varsigma}", "alt": ["unicode-math"] }, "\u{1D6D4}": { "math": "\\mathbf{\\sigma}", "alt": ["unicode-math"] }, "\u{1D6D5}": { "math": "\\mathbf{T}", "alt": ["unicode-math"] }, "\u{1D6D6}": { "math": "\\mathbf{\\upsilon}", "alt": ["unicode-math"] }, "\u{1D6D7}": { "math": "\\mathbf{\\phi}", "alt": ["unicode-math"] }, "\u{1D6D8}": { "math": "\\mathbf{X}", "alt": ["unicode-math"] }, "\u{1D6D9}": { "math": "\\mathbf{\\psi}", "alt": ["unicode-math"] }, "\u{1D6DA}": { "math": "\\mathbf{\\omega}", "alt": ["unicode-math"] }, "\u{1D6DB}": { "math": "\\partial", "alt": ["unicode-math"] }, "\u{1D6DC}": { "math": "\\in", "alt": ["unicode-math"] }, "\u{1D6DD}": { "math": "\\mathbf{\\vartheta}", "alt": ["unicode-math"] }, "\u{1D6DE}": { "math": "\\mathbf{\\varkappa}", "alt": ["unicode-math"] }, "\u{1D6DF}": { "math": "\\mathbf{\\phi}", "alt": ["unicode-math"] }, "\u{1D6E0}": { "math": "\\mathbf{\\varrho}", "alt": ["unicode-math"] }, "\u{1D6E1}": { "math": "\\mathbf{\\varpi}", "alt": ["unicode-math"] }, "\u{1D6E2}": { "math": "A", "alt": ["unicode-math"] }, "\u{1D6E3}": { "math": "B", "alt": ["unicode-math"] }, "\u{1D6E4}": { "math": "\\Gamma", "alt": ["unicode-math"] }, "\u{1D6E5}": { "math": "\\Delta", "alt": ["unicode-math"] }, "\u{1D6E6}": { "math": "E", "alt": ["unicode-math"] }, "\u{1D6E7}": { "math": "Z", "alt": ["unicode-math"] }, "\u{1D6E8}": { "math": "H", "alt": ["unicode-math"] }, "\u{1D6E9}": { "math": "\\Theta", "alt": ["unicode-math"] }, "\u{1D6EA}": { "math": "I", "alt": ["unicode-math"] }, "\u{1D6EB}": { "math": "K", "alt": ["unicode-math"] }, "\u{1D6EC}": { "math": "\\Lambda", "alt": ["unicode-math"] }, "\u{1D6ED}": { "math": "M", "alt": ["unicode-math"] }, "\u{1D6EE}": { "math": "N", "alt": ["unicode-math"] }, "\u{1D6EF}": { "math": "\\Xi", "alt": ["unicode-math"] }, "\u{1D6F0}": { "math": "O", "alt": ["unicode-math"] }, "\u{1D6F1}": { "math": "\\Pi", "alt": ["unicode-math"] }, "\u{1D6F2}": { "math": "P", "alt": ["unicode-math"] }, "\u{1D6F3}": { "math": "\\Theta", "alt": ["unicode-math"] }, "\u{1D6F4}": { "math": "\\Sigma", "alt": ["unicode-math"] }, "\u{1D6F5}": { "math": "T", "alt": ["unicode-math"] }, "\u{1D6F6}": { "math": "\\Upsilon", "alt": ["unicode-math"] }, "\u{1D6F7}": { "math": "\\Phi", "alt": ["unicode-math"] }, "\u{1D6F8}": { "math": "X", "alt": ["unicode-math"] }, "\u{1D6F9}": { "math": "\\Psi", "alt": ["unicode-math"] }, "\u{1D6FA}": { "math": "\\Omega", "alt": ["unicode-math"] }, "\u{1D6FB}": { "math": "\\nabla", "alt": ["unicode-math"] }, "\u{1D6FC}": { "math": "A", "alt": ["unicode-math"] }, "\u{1D6FD}": { "math": "B", "alt": ["unicode-math"] }, "\u{1D6FE}": { "math": "\\gamma", "alt": ["unicode-math"] }, "\u{1D6FF}": { "math": "\\delta", "alt": ["unicode-math"] }, "\u{1D700}": { "math": "E", "alt": ["unicode-math"] }, "\u{1D701}": { "math": "Z", "alt": ["unicode-math"] }, "\u{1D702}": { "math": "H", "alt": ["unicode-math"] }, "\u{1D703}": { "math": "\\theta", "alt": ["unicode-math"] }, "\u{1D704}": { "math": "I", "alt": ["unicode-math"] }, "\u{1D705}": { "math": "K", "alt": ["unicode-math"] }, "\u{1D706}": { "math": "\\lambda", "alt": ["unicode-math"] }, "\u{1D707}": { "math": "\\mu", "alt": ["unicode-math"] }, "\u{1D708}": { "math": "\\nu", "alt": ["unicode-math"] }, "\u{1D709}": { "math": "\\xi", "alt": ["unicode-math"] }, "\u{1D70A}": { "math": "o", "alt": ["unicode-math"] }, "\u{1D70B}": { "math": "\\pi", "alt": ["unicode-math"] }, "\u{1D70D}": { "math": "\\varsigma", "alt": ["unicode-math"] }, "\u{1D70E}": { "math": "\\sigma", "alt": ["unicode-math"] }, "\u{1D70F}": { "math": "T", "alt": ["unicode-math"] }, "\u{1D710}": { "math": "\\upsilon", "alt": ["unicode-math"] }, "\u{1D711}": { "math": "\\varphi", "alt": ["unicode-math"] }, "\u{1D712}": { "math": "X", "alt": ["unicode-math"] }, "\u{1D713}": { "math": "\\psi", "alt": ["unicode-math"] }, "\u{1D714}": { "math": "\\omega", "alt": ["unicode-math"] }, "\u{1D715}": { "math": "\\partial", "alt": ["unicode-math"] }, "\u{1D716}": { "math": "\\in", "alt": ["unicode-math"] }, "\u{1D717}": { "math": "\\vartheta", "alt": ["unicode-math"] }, "\u{1D718}": { "math": "\\varkappa", "alt": ["unicode-math"] }, "\u{1D719}": { "math": "\\phi", "alt": ["unicode-math"] }, "\u{1D71A}": { "math": "\\varrho", "alt": ["unicode-math"] }, "\u{1D71B}": { "math": "\\varpi", "alt": ["unicode-math"] }, "\u{1D71C}": { "math": "\\mathbit{A}", "alt": ["unicode-math"] }, "\u{1D71D}": { "math": "\\mathbit{B}", "alt": ["unicode-math"] }, "\u{1D71E}": { "math": "\\mathbit{\\Gamma}", "alt": ["unicode-math"] }, "\u{1D71F}": { "math": "\\mathbit{\\Delta}", "alt": ["unicode-math"] }, "\u{1D720}": { "math": "\\mathbit{E}", "alt": ["unicode-math"] }, "\u{1D721}": { "math": "\\mathbit{Z}", "alt": ["unicode-math"] }, "\u{1D722}": { "math": "\\mathbit{H}", "alt": ["unicode-math"] }, "\u{1D723}": { "math": "\\mathbit{\\Theta}", "alt": ["unicode-math"] }, "\u{1D724}": { "math": "\\mathbit{I}", "alt": ["unicode-math"] }, "\u{1D725}": { "math": "\\mathbit{K}", "alt": ["unicode-math"] }, "\u{1D726}": { "math": "\\mathbit{\\Lambda}", "alt": ["unicode-math"] }, "\u{1D727}": { "math": "M", "alt": ["unicode-math"] }, "\u{1D728}": { "math": "N", "alt": ["unicode-math"] }, "\u{1D729}": { "math": "\\mathbit{\\Xi}", "alt": ["unicode-math"] }, "\u{1D72A}": { "math": "O", "alt": ["unicode-math"] }, "\u{1D72B}": { "math": "\\mathbit{\\Pi}", "alt": ["unicode-math"] }, "\u{1D72C}": { "math": "\\mathbit{P}", "alt": ["unicode-math"] }, "\u{1D72D}": { "math": "\\mathbit{O}", "alt": ["unicode-math"] }, "\u{1D72E}": { "math": "\\mathbit{\\Sigma}", "alt": ["unicode-math"] }, "\u{1D72F}": { "math": "\\mathbit{T}", "alt": ["unicode-math"] }, "\u{1D730}": { "math": "\\mathbit{\\Upsilon}", "alt": ["unicode-math"] }, "\u{1D731}": { "math": "\\mathbit{\\Phi}", "alt": ["unicode-math"] }, "\u{1D732}": { "math": "\\mathbit{X}", "alt": ["unicode-math"] }, "\u{1D733}": { "math": "\\mathbit{\\Psi}", "alt": ["unicode-math"] }, "\u{1D734}": { "math": "\\mathbit{\\Omega}", "alt": ["unicode-math"] }, "\u{1D735}": { "math": "\\mathbit{\\nabla}", "alt": ["unicode-math"] }, "\u{1D736}": { "math": "\\mathbit{\\alpha}", "alt": ["unicode-math"] }, "\u{1D737}": { "math": "\\mathbit{\\beta}", "alt": ["unicode-math"] }, "\u{1D738}": { "math": "\\mathbit{\\gamma}", "alt": ["unicode-math"] }, "\u{1D739}": { "math": "\\mathbit{\\delta}", "alt": ["unicode-math"] }, "\u{1D73A}": { "math": "\\mathbit{\\epsilon}", "alt": ["unicode-math"] }, "\u{1D73B}": { "math": "\\mathbit{\\zeta}", "alt": ["unicode-math"] }, "\u{1D73C}": { "math": "\\mathbit{\\eta}", "alt": ["unicode-math"] }, "\u{1D73D}": { "math": "\\mathbit{\\theta}", "alt": ["unicode-math"] }, "\u{1D73E}": { "math": "\\mathbit{\\imath}", "alt": ["unicode-math"] }, "\u{1D73F}": { "math": "\\mathbit{\\kappa}", "alt": ["unicode-math"] }, "\u{1D740}": { "math": "\\mathbit{\\lambda}", "alt": ["unicode-math"] }, "\u{1D741}": { "math": "\\mu", "alt": ["unicode-math"] }, "\u{1D742}": { "math": "v", "alt": ["unicode-math"] }, "\u{1D743}": { "math": "\\mathbit{\\xi}", "alt": ["unicode-math"] }, "\u{1D744}": { "math": "O", "alt": ["unicode-math"] }, "\u{1D745}": { "math": "\\mathbit{\\pi}", "alt": ["unicode-math"] }, "\u{1D746}": { "math": "\\mathbit{\\rho}", "alt": ["unicode-math"] }, "\u{1D747}": { "math": "\\mathbit{\\varsigma}", "alt": ["unicode-math"] }, "\u{1D748}": { "math": "\\mathbit{\\sigma}", "alt": ["unicode-math"] }, "\u{1D749}": { "math": "\\mathbit{\\tau}", "alt": ["unicode-math"] }, "\u{1D74A}": { "math": "\\mathbit{\\upsilon}", "alt": ["unicode-math"] }, "\u{1D74B}": { "math": "\\mathbit{\\varphi}", "alt": ["unicode-math"] }, "\u{1D74C}": { "math": "\\mathbit{\\chi}", "alt": ["unicode-math"] }, "\u{1D74D}": { "math": "\\mathbit{\\psi}", "alt": ["unicode-math"] }, "\u{1D74E}": { "math": "\\mathbit{\\omega}", "alt": ["unicode-math"] }, "\u{1D74F}": { "math": "\\partial", "alt": ["unicode-math"] }, "\u{1D750}": { "math": "\\in", "alt": ["unicode-math"] }, "\u{1D751}": { "math": "\\mathbit{\\vartheta}", "alt": ["unicode-math"] }, "\u{1D752}": { "math": "\\mathbit{\\varkappa}", "alt": ["unicode-math"] }, "\u{1D753}": { "math": "\\mathbit{\\phi}", "alt": ["unicode-math"] }, "\u{1D754}": { "math": "\\mathbit{\\varrho}", "alt": ["unicode-math"] }, "\u{1D755}": { "math": "\\mathbit{\\varpi}", "alt": ["unicode-math"] }, "\u{1D756}": { "math": "\\mathsfbf{A}", "alt": ["unicode-math"] }, "\u{1D757}": { "math": "\\mathsfbf{B}", "alt": ["unicode-math"] }, "\u{1D758}": { "math": "\\mathsfbf{\\Gamma}", "alt": ["unicode-math"] }, "\u{1D759}": { "math": "\\mathsfbf{\\Delta}", "alt": ["unicode-math"] }, "\u{1D75A}": { "math": "\\mathsfbf{E}", "alt": ["unicode-math"] }, "\u{1D75B}": { "math": "\\mathsfbf{Z}", "alt": ["unicode-math"] }, "\u{1D75C}": { "math": "\\mathsfbf{H}", "alt": ["unicode-math"] }, "\u{1D75D}": { "math": "\\mathsfbf{\\Theta}", "alt": ["unicode-math"] }, "\u{1D75E}": { "math": "\\mathsfbf{I}", "alt": ["unicode-math"] }, "\u{1D75F}": { "math": "\\mathsfbf{K}", "alt": ["unicode-math"] }, "\u{1D760}": { "math": "\\mathsfbf{\\Lambda}", "alt": ["unicode-math"] }, "\u{1D761}": { "math": "M", "alt": ["unicode-math"] }, "\u{1D762}": { "math": "N", "alt": ["unicode-math"] }, "\u{1D763}": { "math": "\\mathsfbf{\\Xi}", "alt": ["unicode-math"] }, "\u{1D764}": { "math": "O", "alt": ["unicode-math"] }, "\u{1D765}": { "math": "\\mathsfbf{\\Pi}", "alt": ["unicode-math"] }, "\u{1D766}": { "math": "\\mathsfbf{P}", "alt": ["unicode-math"] }, "\u{1D767}": { "math": "\\mathsfbf{\\Theta}", "alt": ["unicode-math"] }, "\u{1D768}": { "math": "\\mathsfbf{\\Sigma}", "alt": ["unicode-math"] }, "\u{1D769}": { "math": "\\mathsfbf{T}", "alt": ["unicode-math"] }, "\u{1D76A}": { "math": "\\mathsfbf{\\Upsilon}", "alt": ["unicode-math"] }, "\u{1D76B}": { "math": "\\mathsfbf{\\Phi}", "alt": ["unicode-math"] }, "\u{1D76C}": { "math": "\\mathsfbf{X}", "alt": ["unicode-math"] }, "\u{1D76D}": { "math": "\\mathsfbf{\\Psi}", "alt": ["unicode-math"] }, "\u{1D76E}": { "math": "\\mathsfbf{\\Omega}", "alt": ["unicode-math"] }, "\u{1D76F}": { "math": "\\mathsfbf{\\nabla}", "alt": ["unicode-math"] }, "\u{1D770}": { "math": "\\mathsfbf{\\alpha}", "alt": ["unicode-math"] }, "\u{1D771}": { "math": "\\mathsfbf{\\beta}", "alt": ["unicode-math"] }, "\u{1D772}": { "math": "\\mathsfbf{\\gamma}", "alt": ["unicode-math"] }, "\u{1D773}": { "math": "\\mathsfbf{\\delta}", "alt": ["unicode-math"] }, "\u{1D774}": { "math": "\\mathsfbf{\\varepsilon}", "alt": ["unicode-math"] }, "\u{1D775}": { "math": "\\mathsfbf{\\zeta}", "alt": ["unicode-math"] }, "\u{1D776}": { "math": "\\mathsfbf{\\eta}", "alt": ["unicode-math"] }, "\u{1D777}": { "math": "\\mathsfbf{\\theta}", "alt": ["unicode-math"] }, "\u{1D778}": { "math": "\\mathsfbf{\\imath}", "alt": ["unicode-math"] }, "\u{1D779}": { "math": "\\mathsfbf{\\kappa}", "alt": ["unicode-math"] }, "\u{1D77A}": { "math": "\\mathsfbf{\\lambda}", "alt": ["unicode-math"] }, "\u{1D77B}": { "math": "\\mu", "alt": ["unicode-math"] }, "\u{1D77C}": { "math": "\\nu", "alt": ["unicode-math"] }, "\u{1D77D}": { "math": "\\mathsfbf{\\xi}", "alt": ["unicode-math"] }, "\u{1D77E}": { "math": "o", "alt": ["unicode-math"] }, "\u{1D77F}": { "math": "\\mathsfbf{\\pi}", "alt": ["unicode-math"] }, "\u{1D780}": { "math": "\\mathsfbf{\\rho}", "alt": ["unicode-math"] }, "\u{1D781}": { "math": "\\mathsfbf{\\varsigma}", "alt": ["unicode-math"] }, "\u{1D782}": { "math": "\\mathsfbf{\\sigma}", "alt": ["unicode-math"] }, "\u{1D783}": { "math": "\\mathsfbf{\\tau}", "alt": ["unicode-math"] }, "\u{1D784}": { "math": "\\mathsfbf{\\upsilon}", "alt": ["unicode-math"] }, "\u{1D785}": { "math": "\\mathsfbf{\\varphi}", "alt": ["unicode-math"] }, "\u{1D786}": { "math": "\\mathsfbf{\\chi}", "alt": ["unicode-math"] }, "\u{1D787}": { "math": "\\mathsfbf{\\psi}", "alt": ["unicode-math"] }, "\u{1D788}": { "math": "\\mathsfbf{\\omega}", "alt": ["unicode-math"] }, "\u{1D789}": { "math": "\\partial", "alt": ["unicode-math"] }, "\u{1D78A}": { "math": "\\in", "alt": ["unicode-math"] }, "\u{1D78B}": { "math": "\\mathsfbf{\\vartheta}", "alt": ["unicode-math"] }, "\u{1D78C}": { "math": "\\mathsfbf{\\varkappa}", "alt": ["unicode-math"] }, "\u{1D78D}": { "math": "\\mathsfbf{\\phi}", "alt": ["unicode-math"] }, "\u{1D78E}": { "math": "\\mathsfbf{\\varrho}", "alt": ["unicode-math"] }, "\u{1D78F}": { "math": "\\mathsfbf{\\varpi}", "alt": ["unicode-math"] }, "\u{1D790}": { "math": "\\mathsfbfsl{A}", "alt": ["unicode-math"] }, "\u{1D791}": { "math": "\\mathsfbfsl{B}", "alt": ["unicode-math"] }, "\u{1D792}": { "math": "\\mathsfbfsl{\\Gamma}", "alt": ["unicode-math"] }, "\u{1D793}": { "math": "\\mathsfbfsl{\\Delta}", "alt": ["unicode-math"] }, "\u{1D794}": { "math": "\\mathsfbfsl{E}", "alt": ["unicode-math"] }, "\u{1D795}": { "math": "\\mathsfbfsl{Z}", "alt": ["unicode-math"] }, "\u{1D796}": { "math": "\\mathsfbfsl{H}", "alt": ["unicode-math"] }, "\u{1D797}": { "math": "\\mathsfbfsl{\\Theta}", "alt": ["unicode-math"] }, "\u{1D798}": { "math": "\\mathsfbfsl{I}", "alt": ["unicode-math"] }, "\u{1D799}": { "math": "\\mathsfbfsl{K}", "alt": ["unicode-math"] }, "\u{1D79A}": { "math": "\\mathsfbfsl{\\Lambda}", "alt": ["unicode-math"] }, "\u{1D79B}": { "math": "\\mathsfbfsl{M}", "alt": ["unicode-math"] }, "\u{1D79C}": { "math": "\\mathsfbfsl{N}", "alt": ["unicode-math"] }, "\u{1D79D}": { "math": "\\mathsfbfsl{\\Xi}", "alt": ["unicode-math"] }, "\u{1D79E}": { "math": "\\mathsfbfsl{O}", "alt": ["unicode-math"] }, "\u{1D79F}": { "math": "\\mathsfbfsl{\\Pi}", "alt": ["unicode-math"] }, "\u{1D7A0}": { "math": "\\mathsfbfsl{P}", "alt": ["unicode-math"] }, "\u{1D7A1}": { "math": "\\mathsfbfsl{\\Theta}", "alt": ["unicode-math"] }, "\u{1D7A2}": { "math": "\\mathsfbfsl{\\Sigma}", "alt": ["unicode-math"] }, "\u{1D7A3}": { "math": "\\mathsfbfsl{T}", "alt": ["unicode-math"] }, "\u{1D7A4}": { "math": "\\mathsfbfsl{\\Upsilon}", "alt": ["unicode-math"] }, "\u{1D7A5}": { "math": "\\mathsfbfsl{\\Phi}", "alt": ["unicode-math"] }, "\u{1D7A6}": { "math": "\\mathsfbfsl{X}", "alt": ["unicode-math"] }, "\u{1D7A7}": { "math": "\\mathsfbfsl{\\Psi}", "alt": ["unicode-math"] }, "\u{1D7A8}": { "math": "\\mathsfbfsl{\\Omega}", "alt": ["unicode-math"] }, "\u{1D7A9}": { "math": "\\mathsfbfsl{\\nabla}", "alt": ["unicode-math"] }, "\u{1D7AA}": { "math": "\\mathsfbfsl{\\alpha}", "alt": ["unicode-math"] }, "\u{1D7AB}": { "math": "\\mathsfbfsl{\\beta}", "alt": ["unicode-math"] }, "\u{1D7AC}": { "math": "\\mathsfbfsl{\\gamma}", "alt": ["unicode-math"] }, "\u{1D7AD}": { "math": "\\mathsfbfsl{\\delta}", "alt": ["unicode-math"] }, "\u{1D7AE}": { "math": "\\mathsfbfsl{\\varepsilon}", "alt": ["unicode-math"] }, "\u{1D7AF}": { "math": "\\mathsfbfsl{\\zeta}", "alt": ["unicode-math"] }, "\u{1D7B0}": { "math": "\\mathsfbfsl{\\eta}", "alt": ["unicode-math"] }, "\u{1D7B1}": { "math": "\\mathsfbfsl{\\theta}", "alt": ["unicode-math"] }, "\u{1D7B2}": { "math": "\\mathsfbfsl{\\imath}", "alt": ["unicode-math"] }, "\u{1D7B3}": { "math": "\\mathsfbfsl{\\kappa}", "alt": ["unicode-math"] }, "\u{1D7B4}": { "math": "\\mathsfbfsl{\\lambda}", "alt": ["unicode-math"] }, "\u{1D7B5}": { "math": "\\mu", "alt": ["unicode-math"] }, "\u{1D7B6}": { "math": "\\nu", "alt": ["unicode-math"] }, "\u{1D7B7}": { "math": "\\mathsfbfsl{\\xi}", "alt": ["unicode-math"] }, "\u{1D7B8}": { "math": "o", "alt": ["unicode-math"] }, "\u{1D7B9}": { "math": "\\mathsfbfsl{\\pi}", "alt": ["unicode-math"] }, "\u{1D7BA}": { "math": "\\mathsfbfsl{\\rho}", "alt": ["unicode-math"] }, "\u{1D7BB}": { "math": "\\mathsfbfsl{\\varsigma}", "alt": ["unicode-math"] }, "\u{1D7BC}": { "math": "\\mathsfbfsl{\\sigma}", "alt": ["unicode-math"] }, "\u{1D7BD}": { "math": "\\mathsfbfsl{\\tau}", "alt": ["unicode-math"] }, "\u{1D7BE}": { "math": "\\mathsfbfsl{\\upsilon}", "alt": ["unicode-math"] }, "\u{1D7BF}": { "math": "\\mathsfbfsl{\\varphi}", "alt": ["unicode-math"] }, "\u{1D7C0}": { "math": "\\mathsfbfsl{\\chi}", "alt": ["unicode-math"] }, "\u{1D7C1}": { "math": "\\mathsfbfsl{\\psi}", "alt": ["unicode-math"] }, "\u{1D7C2}": { "math": "\\mathsfbfsl{\\omega}", "alt": ["unicode-math"] }, "\u{1D7C3}": { "math": "\\partial", "alt": ["unicode-math"] }, "\u{1D7C4}": { "math": "\\in", "alt": ["unicode-math"] }, "\u{1D7C5}": { "math": "\\mathsfbfsl{\\vartheta}", "alt": ["unicode-math"] }, "\u{1D7C6}": { "math": "\\mathsfbfsl{\\varkappa}", "alt": ["unicode-math"] }, "\u{1D7C7}": { "math": "\\mathsfbfsl{\\phi}", "alt": ["unicode-math"] }, "\u{1D7C8}": { "math": "\\mathsfbfsl{\\varrho}", "alt": ["unicode-math"] }, "\u{1D7C9}": { "math": "\\mathsfbfsl{\\varpi}", "alt": ["unicode-math"] }, "\u{1D7CA}": { "math": "\\mbfDigamma", "alt": ["unicode-math"] }, "\u{1D7CB}": { "math": "\\mbfdigamma", "alt": ["unicode-math"] }, "\u{1D7CE}": { "math": "\\mathbf{0}", "alt": ["unicode-math"] }, "\u{1D7CF}": { "math": "\\mathbf{1}", "alt": ["unicode-math"] }, "\u{1D7D0}": { "math": "\\mathbf{2}", "alt": ["unicode-math"] }, "\u{1D7D1}": { "math": "\\mathbf{3}", "alt": ["unicode-math"] }, "\u{1D7D2}": { "math": "\\mathbf{4}", "alt": ["unicode-math"] }, "\u{1D7D3}": { "math": "\\mathbf{5}", "alt": ["unicode-math"] }, "\u{1D7D4}": { "math": "\\mathbf{6}", "alt": ["unicode-math"] }, "\u{1D7D5}": { "math": "\\mathbf{7}", "alt": ["unicode-math"] }, "\u{1D7D6}": { "math": "\\mathbf{8}", "alt": ["unicode-math"] }, "\u{1D7D7}": { "math": "\\mathbf{9}", "alt": ["unicode-math"] }, "\u{1D7D8}": { "math": "\\mathbb{0}", "alt": ["unicode-math"] }, "\u{1D7D9}": { "math": "\\mathbb{1}", "alt": ["unicode-math"] }, "\u{1D7DA}": { "math": "\\mathbb{2}", "alt": ["unicode-math"] }, "\u{1D7DB}": { "math": "\\mathbb{3}", "alt": ["unicode-math"] }, "\u{1D7DC}": { "math": "\\mathbb{4}", "alt": ["unicode-math"] }, "\u{1D7DD}": { "math": "\\mathbb{5}", "alt": ["unicode-math"] }, "\u{1D7DE}": { "math": "\\mathbb{6}", "alt": ["unicode-math"] }, "\u{1D7DF}": { "math": "\\mathbb{7}", "alt": ["unicode-math"] }, "\u{1D7E0}": { "math": "\\mathbb{8}", "alt": ["unicode-math"] }, "\u{1D7E1}": { "math": "\\mathbb{9}", "alt": ["unicode-math"] }, "\u{1D7E2}": { "math": "\\mathsf{0}", "alt": ["unicode-math"] }, "\u{1D7E3}": { "math": "\\mathsf{1}", "alt": ["unicode-math"] }, "\u{1D7E4}": { "math": "\\mathsf{2}", "alt": ["unicode-math"] }, "\u{1D7E5}": { "math": "\\mathsf{3}", "alt": ["unicode-math"] }, "\u{1D7E6}": { "math": "\\mathsf{4}", "alt": ["unicode-math"] }, "\u{1D7E7}": { "math": "\\mathsf{5}", "alt": ["unicode-math"] }, "\u{1D7E8}": { "math": "\\mathsf{6}", "alt": ["unicode-math"] }, "\u{1D7E9}": { "math": "\\mathsf{7}", "alt": ["unicode-math"] }, "\u{1D7EA}": { "math": "\\mathsf{8}", "alt": ["unicode-math"] }, "\u{1D7EB}": { "math": "\\mathsf{9}", "alt": ["unicode-math"] }, "\u{1D7EC}": { "math": "\\mathsfbf{0}", "alt": ["unicode-math"] }, "\u{1D7ED}": { "math": "\\mathsfbf{1}", "alt": ["unicode-math"] }, "\u{1D7EE}": { "math": "\\mathsfbf{2}", "alt": ["unicode-math"] }, "\u{1D7EF}": { "math": "\\mathsfbf{3}", "alt": ["unicode-math"] }, "\u{1D7F0}": { "math": "\\mathsfbf{4}", "alt": ["unicode-math"] }, "\u{1D7F1}": { "math": "\\mathsfbf{5}", "alt": ["unicode-math"] }, "\u{1D7F2}": { "math": "\\mathsfbf{6}", "alt": ["unicode-math"] }, "\u{1D7F3}": { "math": "\\mathsfbf{7}", "alt": ["unicode-math"] }, "\u{1D7F4}": { "math": "\\mathsfbf{8}", "alt": ["unicode-math"] }, "\u{1D7F5}": { "math": "\\mathsfbf{9}", "alt": ["unicode-math"] }, "\u{1D7F6}": { "math": "\\mathtt{0}", "alt": ["unicode-math"] }, "\u{1D7F7}": { "math": "\\mathtt{1}", "alt": ["unicode-math"] }, "\u{1D7F8}": { "math": "\\mathtt{2}", "alt": ["unicode-math"] }, "\u{1D7F9}": { "math": "\\mathtt{3}", "alt": ["unicode-math"] }, "\u{1D7FA}": { "math": "\\mathtt{4}", "alt": ["unicode-math"] }, "\u{1D7FB}": { "math": "\\mathtt{5}", "alt": ["unicode-math"] }, "\u{1D7FC}": { "math": "\\mathtt{6}", "alt": ["unicode-math"] }, "\u{1D7FD}": { "math": "\\mathtt{7}", "alt": ["unicode-math"] }, "\u{1D7FE}": { "math": "\\mathtt{8}", "alt": ["unicode-math"] }, "\u{1D7FF}": { "math": "\\mathtt{9}", "alt": ["unicode-math"] }, " \u035A": { "math": "_\\infty" }, "\u2029": { "text": "{\\par}" }, "/\u200B": { "text": "{\\slash}" }, "^": { "text": "{\\textasciicircum}" }, "i\uFE20a\uFE21": { "text": "\\t{ia}" }, "{": { "text": "\\{" }, "}": { "text": "\\}" }, "~": { "text": "{\\textasciitilde}" }, "\xA1": { "text": "{\\textexclamdown}" }, "\u20AC": { "text": "{\\texteuro}", "alt": ["unicode-math"] }, "\xA8": { "text": "{\\textasciidieresis}" }, "\xAB": { "text": "<<" }, "\xAE": { "text": "{\\textregistered}" }, "\xAF": { "text": "{\\textasciimacron}" }, "\xB4": { "text": "{\\textasciiacute}" }, "\xB5": { "text": "{\\textmu}" }, "\xB8": { "text": "{\\c}" }, "\xBB": { "text": ">>" }, "\xBF": { "text": "{\\textquestiondown}" }, "\xC6": { "text": "{\\AE}" }, "\xD0": { "text": "{\\DH}" }, "\xD8": { "text": "{\\O}" }, "\xDE": { "text": "{\\TH}" }, "\xDF": { "text": "{\\ss}" }, "a\u030A": { "text": "{\\aa}" }, "\xE6": { "text": "{\\ae}" }, "\xF0": { "text": "{\\dh}", "alt": ["amssymb", "arevmath", "textcomp"] }, "\xF8": { "text": "{\\o}" }, "\xFE": { "text": "{\\th}" }, "\u0110": { "text": "{\\DJ}" }, "\u0111": { "text": "{\\dj}" }, "i\u0306": { "text": "{\\u \\i}" }, "\u0132": { "text": "{\\IJ}" }, "\u0133": { "text": "{\\ij}" }, "j\u0302": { "text": "{\\^\\j}" }, "\u0138": { "text": "K", "alt": ["xecjk"] }, "\u0141": { "text": "{\\L}" }, "\u0142": { "text": "{\\l}" }, "\u0149": { "text": "'n" }, "\u014A": { "text": "{\\NG}" }, "\u014B": { "text": "{\\ng}" }, "\u0152": { "text": "{\\OE}" }, "\u0153": { "text": "{\\oe}" }, "\u017F": { "text": "s" }, "\u01AA": { "text": "{\\textesh}" }, "\u01C2": { "text": "{\\textdoublepipe}" }, "\u0261": { "text": "g" }, "\u02B9": { "text": "'" }, "\u02BB": { "text": "'" }, "\u02BC": { "text": "'" }, "\u02BD": { "text": "'" }, "\u02C6": { "text": "{\\textasciicircum}" }, "\u02C7": { "text": "{\\textasciicaron}" }, "\u02C9": { "text": "-" }, "\u02D8": { "text": "{\\textasciibreve}" }, "\u02DA": { "text": "{\\r{}}" }, "\u02DB": { "text": "{\\k{}}" }, "\u02DC": { "text": "{\\texttildelow}" }, "\u02DD": { "text": "{\\textacutedbl}" }, "\u0300": { "text": "{\\`}", "alt": ["unicode-math"] }, "\u0301": { "text": "{\\'}", "alt": ["unicode-math"] }, "\u0302": { "text": "{\\^}" }, "\u0303": { "text": "{\\~}", "alt": ["unicode-math"] }, "\u0304": { "text": "{\\=}" }, "\u0306": { "text": "{\\u}", "alt": ["unicode-math"] }, "\u0307": { "text": "{\\.}", "alt": ["unicode-math"] }, "\u0308": { "text": '{\\"}', "alt": ["unicode-math"] }, "\u030B": { "text": "{\\H}" }, "\u030C": { "text": "{\\v}", "alt": ["unicode-math"] }, "\u030F": { "text": "{\\textdoublegrave}" }, "\u0316": { "text": "{\\textsubgrave}" }, "\u0323": { "text": "{\\d}" }, "\u0326": { "text": "{\\textcommabelow}" }, "\u0327": { "text": "{\\c}" }, "\u0328": { "text": "{\\k}" }, "\u0375": { "text": "," }, ";": { "text": ";" }, "\u0399\u0301": { "text": "{\\'{}I}" }, "\u039F\u0301": { "text": "{\\'{}O}" }, "\u03D0": { "text": "\\Pisymbol{ppi022}{87}", "alt": ["MinionPro", "unicode-math"] }, "\u046B": { "text": "{\\cyrchar\\cyrbyus}" }, "\u0473": { "text": "{\\cyrchar\\cyrfita}" }, "\u0475": { "text": "{\\cyrchar\\cyrizh}" }, "\u04C5": { "text": "{\\cyrchar\\CYRLDSC}" }, "\u04C6": { "text": "{\\cyrchar\\cyrldsc}" }, "\u04CD": { "text": "{\\cyrchar\\CYRMDSC}" }, "\u04CE": { "text": "{\\cyrchar\\cyrmdsc}" }, "\u0463": { "text": "{\\cyrchar\\cyryat}" }, "\u0415\u0308": { "text": "{\\cyrchar\\CYRYO}" }, "\u0402": { "text": "{\\cyrchar\\CYRDJE}" }, "\u0413\u0301": { "text": "\\cyrchar{\\'\\CYRG}" }, "\u0404": { "text": "{\\cyrchar\\CYRIE}" }, "\u0405": { "text": "{\\cyrchar\\CYRDZE}" }, "\u0406": { "text": "{\\cyrchar\\CYRII}" }, "\u0406\u0308": { "text": "{\\cyrchar\\CYRYI}" }, "\u0408": { "text": "{\\cyrchar\\CYRJE}" }, "\u0409": { "text": "{\\cyrchar\\CYRLJE}" }, "\u040A": { "text": "{\\cyrchar\\CYRNJE}" }, "\u040B": { "text": "{\\cyrchar\\CYRTSHE}" }, "\u041A\u0301": { "text": "\\cyrchar{\\'\\CYRK}" }, "\u0423\u0306": { "text": "{\\cyrchar\\CYRUSHRT}" }, "\u040F": { "text": "{\\cyrchar\\CYRDZHE}" }, "\u0410": { "text": "{\\cyrchar\\CYRA}" }, "\u0411": { "text": "{\\cyrchar\\CYRB}" }, "\u0412": { "text": "{\\cyrchar\\CYRV}" }, "\u0413": { "text": "{\\cyrchar\\CYRG}" }, "\u0414": { "text": "{\\cyrchar\\CYRD}" }, "\u0415": { "text": "{\\cyrchar\\CYRE}" }, "\u0416": { "text": "{\\cyrchar\\CYRZH}" }, "\u0417": { "text": "{\\cyrchar\\CYRZ}" }, "\u0418": { "text": "{\\cyrchar\\CYRI}" }, "\u0418\u0306": { "text": "{\\cyrchar\\CYRISHRT}" }, "\u041A": { "text": "{\\cyrchar\\CYRK}" }, "\u041B": { "text": "{\\cyrchar\\CYRL}" }, "\u041C": { "text": "{\\cyrchar\\CYRM}" }, "\u041D": { "text": "{\\cyrchar\\CYRN}" }, "\u041E": { "text": "{\\cyrchar\\CYRO}" }, "\u041F": { "text": "{\\cyrchar\\CYRP}" }, "\u0420": { "text": "{\\cyrchar\\CYRR}" }, "\u0421": { "text": "{\\cyrchar\\CYRS}" }, "\u0422": { "text": "{\\cyrchar\\CYRT}" }, "\u0423": { "text": "{\\cyrchar\\CYRU}" }, "\u0424": { "text": "{\\cyrchar\\CYRF}" }, "\u0425": { "text": "{\\cyrchar\\CYRH}" }, "\u0426": { "text": "{\\cyrchar\\CYRC}" }, "\u0427": { "text": "{\\cyrchar\\CYRCH}" }, "\u0428": { "text": "{\\cyrchar\\CYRSH}" }, "\u0429": { "text": "{\\cyrchar\\CYRSHCH}" }, "\u042A": { "text": "{\\cyrchar\\CYRHRDSN}" }, "\u042B": { "text": "{\\cyrchar\\CYRERY}" }, "\u042C": { "text": "{\\cyrchar\\CYRSFTSN}" }, "\u042D": { "text": "{\\cyrchar\\CYREREV}" }, "\u042E": { "text": "{\\cyrchar\\CYRYU}" }, "\u042F": { "text": "{\\cyrchar\\CYRYA}" }, "\u0430": { "text": "{\\cyrchar\\cyra}" }, "\u0431": { "text": "{\\cyrchar\\cyrb}" }, "\u0432": { "text": "{\\cyrchar\\cyrv}" }, "\u0433": { "text": "{\\cyrchar\\cyrg}" }, "\u0434": { "text": "{\\cyrchar\\cyrd}" }, "\u0435": { "text": "{\\cyrchar\\cyre}" }, "\u0436": { "text": "{\\cyrchar\\cyrzh}" }, "\u0437": { "text": "{\\cyrchar\\cyrz}" }, "\u0438": { "text": "{\\cyrchar\\cyri}" }, "\u0438\u0306": { "text": "{\\cyrchar\\cyrishrt}" }, "\u043A": { "text": "{\\cyrchar\\cyrk}" }, "\u043B": { "text": "{\\cyrchar\\cyrl}" }, "\u043C": { "text": "{\\cyrchar\\cyrm}" }, "\u043D": { "text": "{\\cyrchar\\cyrn}" }, "\u043E": { "text": "{\\cyrchar\\cyro}" }, "\u043F": { "text": "{\\cyrchar\\cyrp}" }, "\u0440": { "text": "{\\cyrchar\\cyrr}" }, "\u0441": { "text": "{\\cyrchar\\cyrs}" }, "\u0442": { "text": "{\\cyrchar\\cyrt}" }, "\u0443": { "text": "{\\cyrchar\\cyru}" }, "\u0444": { "text": "{\\cyrchar\\cyrf}" }, "\u0445": { "text": "{\\cyrchar\\cyrh}" }, "\u0446": { "text": "{\\cyrchar\\cyrc}" }, "\u0447": { "text": "{\\cyrchar\\cyrch}" }, "\u0448": { "text": "{\\cyrchar\\cyrsh}" }, "\u0449": { "text": "{\\cyrchar\\cyrshch}" }, "\u044A": { "text": "{\\cyrchar\\cyrhrdsn}" }, "\u044B": { "text": "{\\cyrchar\\cyrery}" }, "\u044C": { "text": "{\\cyrchar\\cyrsftsn}" }, "\u044D": { "text": "{\\cyrchar\\cyrerev}" }, "\u044E": { "text": "{\\cyrchar\\cyryu}" }, "\u044F": { "text": "{\\cyrchar\\cyrya}" }, "\u0435\u0308": { "text": "{\\cyrchar\\cyryo}" }, "\u0452": { "text": "{\\cyrchar\\cyrdje}" }, "\u0433\u0301": { "text": "\\cyrchar{\\'\\cyrg}" }, "\u0454": { "text": "{\\cyrchar\\cyrie}" }, "\u0455": { "text": "{\\cyrchar\\cyrdze}" }, "\u0456": { "text": "{\\cyrchar\\cyrii}" }, "\u0456\u0308": { "text": "{\\cyrchar\\cyryi}" }, "\u0458": { "text": "{\\cyrchar\\cyrje}" }, "\u0459": { "text": "{\\cyrchar\\cyrlje}" }, "\u045A": { "text": "{\\cyrchar\\cyrnje}" }, "\u045B": { "text": "{\\cyrchar\\cyrtshe}" }, "\u043A\u0301": { "text": "\\cyrchar{\\'\\cyrk}" }, "\u0443\u0306": { "text": "{\\cyrchar\\cyrushrt}" }, "\u045F": { "text": "{\\cyrchar\\cyrdzhe}" }, "\u0460": { "text": "{\\cyrchar\\CYROMEGA}" }, "\u0461": { "text": "{\\cyrchar\\cyromega}" }, "\u0462": { "text": "{\\cyrchar\\CYRYAT}" }, "\u0464": { "text": "{\\cyrchar\\CYRIOTE}" }, "\u0465": { "text": "{\\cyrchar\\cyriote}" }, "\u0466": { "text": "{\\cyrchar\\CYRLYUS}" }, "\u0467": { "text": "{\\cyrchar\\cyrlyus}" }, "\u0468": { "text": "{\\cyrchar\\CYRIOTLYUS}" }, "\u0469": { "text": "{\\cyrchar\\cyriotlyus}" }, "\u046A": { "text": "{\\cyrchar\\CYRBYUS}" }, "\u046C": { "text": "{\\cyrchar\\CYRIOTBYUS}" }, "\u046D": { "text": "{\\cyrchar\\cyriotbyus}" }, "\u046E": { "text": "{\\cyrchar\\CYRKSI}" }, "\u046F": { "text": "{\\cyrchar\\cyrksi}" }, "\u0470": { "text": "{\\cyrchar\\CYRPSI}" }, "\u0471": { "text": "{\\cyrchar\\cyrpsi}" }, "\u0472": { "text": "{\\cyrchar\\CYRFITA}" }, "\u0474": { "text": "{\\cyrchar\\CYRIZH}" }, "\u0478": { "text": "{\\cyrchar\\CYRUK}" }, "\u0479": { "text": "{\\cyrchar\\cyruk}" }, "\u047A": { "text": "{\\cyrchar\\CYROMEGARND}" }, "\u047B": { "text": "{\\cyrchar\\cyromegarnd}" }, "\u047C": { "text": "{\\cyrchar\\CYROMEGATITLO}" }, "\u047D": { "text": "{\\cyrchar\\cyromegatitlo}" }, "\u047E": { "text": "{\\cyrchar\\CYROT}" }, "\u047F": { "text": "{\\cyrchar\\cyrot}" }, "\u0480": { "text": "{\\cyrchar\\CYRKOPPA}" }, "\u0481": { "text": "{\\cyrchar\\cyrkoppa}" }, "\u0482": { "text": "{\\cyrchar\\cyrthousands}" }, "\u0488": { "text": "{\\cyrchar\\cyrhundredthousands}" }, "\u0489": { "text": "{\\cyrchar\\cyrmillions}" }, "\u048C": { "text": "{\\cyrchar\\CYRSEMISFTSN}" }, "\u048D": { "text": "{\\cyrchar\\cyrsemisftsn}" }, "\u048E": { "text": "{\\cyrchar\\CYRRTICK}" }, "\u048F": { "text": "{\\cyrchar\\cyrrtick}" }, "\u0490": { "text": "{\\cyrchar\\CYRGUP}" }, "\u0491": { "text": "{\\cyrchar\\cyrgup}" }, "\u0492": { "text": "{\\cyrchar\\CYRGHCRS}" }, "\u0493": { "text": "{\\cyrchar\\cyrghcrs}" }, "\u0494": { "text": "{\\cyrchar\\CYRGHK}" }, "\u0495": { "text": "{\\cyrchar\\cyrghk}" }, "\u0496": { "text": "{\\cyrchar\\CYRZHDSC}" }, "\u0497": { "text": "{\\cyrchar\\cyrzhdsc}" }, "\u0498": { "text": "{\\cyrchar\\CYRZDSC}" }, "\u0499": { "text": "{\\cyrchar\\cyrzdsc}" }, "\u049A": { "text": "{\\cyrchar\\CYRKDSC}" }, "\u049B": { "text": "{\\cyrchar\\cyrkdsc}" }, "\u049C": { "text": "{\\cyrchar\\CYRKVCRS}" }, "\u049D": { "text": "{\\cyrchar\\cyrkvcrs}" }, "\u049E": { "text": "{\\cyrchar\\CYRKHCRS}" }, "\u049F": { "text": "{\\cyrchar\\cyrkhcrs}" }, "\u04A0": { "text": "{\\cyrchar\\CYRKBEAK}" }, "\u04A1": { "text": "{\\cyrchar\\cyrkbeak}" }, "\u04A2": { "text": "{\\cyrchar\\CYRNDSC}" }, "\u04A3": { "text": "{\\cyrchar\\cyrndsc}" }, "\u04A4": { "text": "{\\cyrchar\\CYRNG}" }, "\u04A5": { "text": "{\\cyrchar\\cyrng}" }, "\u04A6": { "text": "{\\cyrchar\\CYRPHK}" }, "\u04A7": { "text": "{\\cyrchar\\cyrphk}" }, "\u04A8": { "text": "{\\cyrchar\\CYRABHHA}" }, "\u04A9": { "text": "{\\cyrchar\\cyrabhha}" }, "\u04AA": { "text": "{\\cyrchar\\CYRSDSC}" }, "\u04AB": { "text": "{\\cyrchar\\cyrsdsc}" }, "\u04AC": { "text": "{\\cyrchar\\CYRTDSC}" }, "\u04AD": { "text": "{\\cyrchar\\cyrtdsc}" }, "\u04AE": { "text": "{\\cyrchar\\CYRY}" }, "\u04AF": { "text": "{\\cyrchar\\cyry}" }, "\u04B0": { "text": "{\\cyrchar\\CYRYHCRS}" }, "\u04B1": { "text": "{\\cyrchar\\cyryhcrs}" }, "\u04B2": { "text": "{\\cyrchar\\CYRHDSC}" }, "\u04B3": { "text": "{\\cyrchar\\cyrhdsc}" }, "\u04B4": { "text": "{\\cyrchar\\CYRTETSE}" }, "\u04B5": { "text": "{\\cyrchar\\cyrtetse}" }, "\u04B6": { "text": "{\\cyrchar\\CYRCHRDSC}" }, "\u04B7": { "text": "{\\cyrchar\\cyrchrdsc}" }, "\u04B8": { "text": "{\\cyrchar\\CYRCHVCRS}" }, "\u04B9": { "text": "{\\cyrchar\\cyrchvcrs}" }, "\u04BA": { "text": "{\\cyrchar\\CYRSHHA}" }, "\u04BB": { "text": "{\\cyrchar\\cyrshha}" }, "\u04BC": { "text": "{\\cyrchar\\CYRABHCH}" }, "\u04BD": { "text": "{\\cyrchar\\cyrabhch}" }, "\u04BE": { "text": "{\\cyrchar\\CYRABHCHDSC}" }, "\u04BF": { "text": "{\\cyrchar\\cyrabhchdsc}" }, "\u04C0": { "text": "{\\cyrchar\\CYRpalochka}" }, "\u04C3": { "text": "{\\cyrchar\\CYRKHK}" }, "\u04C4": { "text": "{\\cyrchar\\cyrkhk}" }, "\u04C7": { "text": "{\\cyrchar\\CYRNHK}" }, "\u04C8": { "text": "{\\cyrchar\\cyrnhk}" }, "\u04CB": { "text": "{\\cyrchar\\CYRCHLDSC}" }, "\u04CC": { "text": "{\\cyrchar\\cyrchldsc}" }, "\u04D4": { "text": "{\\cyrchar\\CYRAE}" }, "\u04D5": { "text": "{\\cyrchar\\cyrae}" }, "\u04D8": { "text": "{\\cyrchar\\CYRSCHWA}" }, "\u04D9": { "text": "{\\cyrchar\\cyrschwa}" }, "\u04E0": { "text": "{\\cyrchar\\CYRABHDZE}" }, "\u04E1": { "text": "{\\cyrchar\\cyrabhdze}" }, "\u04E8": { "text": "{\\cyrchar\\CYROTLD}" }, "\u04E9": { "text": "{\\cyrchar\\cyrotld}" }, "E\u0327\u0306": { "text": "\\c{\\u{E}}" }, "e\u0327\u0306": { "text": "\\c{\\u{e}}" }, "\u2002": { "text": "{\\enspace}" }, "\u2003\u2003": { "text": "{\\qquad}" }, "\u2004": { "text": "\\;" }, "\u2005": { "text": "\\>" }, "\u2006": { "text": "\\hspace{0.166em}" }, "\u2007": { "text": "\\hphantom{0}" }, "\u2008": { "text": "\\hphantom{,}" }, "\u2009": { "text": "\\," }, "\u200B": { "text": "\\hspace{0pt}" }, "\u200C": { "text": "{\\null}" }, "\u2010": { "text": "-", "alt": ["unicode-math"] }, "\u2011": { "text": "-" }, "\u2012": { "text": "-" }, "\u2013": { "text": "--" }, "\u2014": { "text": "---" }, "\u2015": { "text": "{\\texthorizontalbar}", "alt": ["unicode-math"] }, "\u2016": { "text": "{\\textbardbl}" }, "\u2018": { "text": "`" }, "\u2019": { "text": "'" }, "\u201A": { "text": "{\\quotesinglbase}" }, "\u201C": { "text": "``" }, "\u201D": { "text": "''" }, "\u201E": { "text": ",," }, "\u201F": { "text": "{\\quotedblbase}" }, "\u2023": { "text": ">" }, "\u2024": { "text": "." }, "\u2025": { "text": "..", "alt": ["unicode-math"] }, "\u2027": { "text": "-" }, "\u202F": { "text": "\\," }, "\u2039": { "text": "{\\guilsinglleft}" }, "\u203A": { "text": "{\\guilsinglright}" }, "\u203E": { "text": "-" }, "\u2044": { "text": "{\\textfractionsolidus}", "alt": ["unicode-math"] }, "\u2048": { "text": "?!" }, "\u2049": { "text": "!?" }, "\u204A": { "text": "7" }, "\u2060": { "text": "{\\nolinebreak}" }, "\u2100": { "text": "a/c" }, "\u2101": { "text": "a/s" }, "\u2103": { "text": "{\\textcelsius}" }, "\u2105": { "text": "c/o" }, "\u2106": { "text": "c/u" }, "\u2109": { "text": "F" }, "\u2116": { "text": "{\\textnumero}" }, "\u2117": { "text": "{\\textcircledP}" }, "\u2120": { "text": "{\\textservicemark}" }, "\u2121": { "text": "TEL" }, "\u2127": { "text": "{\\textmho}", "alt": ["unicode-math"] }, "\u2129": { "text": "{\\textriota}", "alt": ["unicode-math"] }, "\u212E": { "text": "{\\textestimated}" }, "\u2160": { "text": "I" }, "\u2161": { "text": "II" }, "\u2162": { "text": "III" }, "\u2163": { "text": "IV" }, "\u2164": { "text": "V" }, "\u2165": { "text": "VI" }, "\u2166": { "text": "VII" }, "\u2167": { "text": "VIII" }, "\u2168": { "text": "IX" }, "\u2169": { "text": "X" }, "\u216A": { "text": "XI" }, "\u216B": { "text": "XII" }, "\u216C": { "text": "L" }, "\u216D": { "text": "C" }, "\u216E": { "text": "D" }, "\u216F": { "text": "M" }, "\u2170": { "text": "i" }, "\u2171": { "text": "ii" }, "\u2172": { "text": "iii" }, "\u2173": { "text": "iv" }, "\u2174": { "text": "v" }, "\u2175": { "text": "vi" }, "\u2176": { "text": "vii" }, "\u2177": { "text": "viii" }, "\u2178": { "text": "ix" }, "\u2179": { "text": "x" }, "\u217A": { "text": "xi" }, "\u217B": { "text": "xii" }, "\u217C": { "text": "l" }, "\u217D": { "text": "c" }, "\u217E": { "text": "d" }, "\u217F": { "text": "m" }, "\u2215": { "text": "/", "alt": ["unicode-math"] }, "\u221A": { "text": "{\\textsurd}", "alt": ["unicode-math"] }, "\u2422": { "text": "{\\textblank}", "alt": ["unicode-math"] }, "\u2460": { "text": "\\ding{172}" }, "\u2461": { "text": "\\ding{173}" }, "\u2462": { "text": "\\ding{174}" }, "\u2463": { "text": "\\ding{175}" }, "\u2464": { "text": "\\ding{176}" }, "\u2465": { "text": "\\ding{177}" }, "\u2466": { "text": "\\ding{178}" }, "\u2467": { "text": "\\ding{179}" }, "\u2468": { "text": "\\ding{180}" }, "\u2469": { "text": "\\ding{181}" }, "\u246A": { "text": "(11)" }, "\u246B": { "text": "(12)" }, "\u246C": { "text": "(13)" }, "\u246D": { "text": "(14)" }, "\u246E": { "text": "(15)" }, "\u246F": { "text": "(16)" }, "\u2470": { "text": "(17)" }, "\u2471": { "text": "(18)" }, "\u2472": { "text": "(19)" }, "\u2473": { "text": "(20)" }, "\u2474": { "text": "(1)" }, "\u2475": { "text": "(2)" }, "\u2476": { "text": "(3)" }, "\u2477": { "text": "(4)" }, "\u2478": { "text": "(5)" }, "\u2479": { "text": "(6)" }, "\u247A": { "text": "(7)" }, "\u247B": { "text": "(8)" }, "\u247C": { "text": "(9)" }, "\u247D": { "text": "(10)" }, "\u247E": { "text": "(11)" }, "\u247F": { "text": "(12)" }, "\u2480": { "text": "(13)" }, "\u2481": { "text": "(14)" }, "\u2482": { "text": "(15)" }, "\u2483": { "text": "(16)" }, "\u2484": { "text": "(17)" }, "\u2485": { "text": "(18)" }, "\u2486": { "text": "(19)" }, "\u2487": { "text": "(20)" }, "\u2488": { "text": "1." }, "\u2489": { "text": "2." }, "\u248A": { "text": "3." }, "\u248B": { "text": "4." }, "\u248C": { "text": "5." }, "\u248D": { "text": "6." }, "\u248E": { "text": "7." }, "\u248F": { "text": "8." }, "\u2490": { "text": "9." }, "\u2491": { "text": "10." }, "\u2492": { "text": "11." }, "\u2493": { "text": "12." }, "\u2494": { "text": "13." }, "\u2495": { "text": "14." }, "\u2496": { "text": "15." }, "\u2497": { "text": "16." }, "\u2498": { "text": "17." }, "\u2499": { "text": "18." }, "\u249A": { "text": "19." }, "\u249B": { "text": "20." }, "\u249C": { "text": "(a)" }, "\u249D": { "text": "(b)" }, "\u249E": { "text": "(c)" }, "\u249F": { "text": "(d)" }, "\u24A0": { "text": "(e)" }, "\u24A1": { "text": "(f)" }, "\u24A2": { "text": "(g)" }, "\u24A3": { "text": "(h)" }, "\u24A4": { "text": "(i)" }, "\u24A5": { "text": "(j)" }, "\u24A6": { "text": "(k)" }, "\u24A7": { "text": "(l)" }, "\u24A8": { "text": "(m)" }, "\u24A9": { "text": "(n)" }, "\u24AA": { "text": "(o)" }, "\u24AB": { "text": "(p)" }, "\u24AC": { "text": "(q)" }, "\u24AD": { "text": "(r)" }, "\u24AE": { "text": "(s)" }, "\u24AF": { "text": "(t)" }, "\u24B0": { "text": "(u)" }, "\u24B1": { "text": "(v)" }, "\u24B2": { "text": "(w)" }, "\u24B3": { "text": "(x)" }, "\u24B4": { "text": "(y)" }, "\u24B5": { "text": "(z)" }, "\u2500": { "text": "-", "alt": ["pmboxdraw"] }, "\u2504": { "text": "-" }, "\u2508": { "text": "-" }, "\u254C": { "text": "-" }, "\u2572": { "text": "\\" }, "\u2573": { "text": "X" }, "\u257C": { "text": "-", "alt": ["pmboxdraw"] }, "\u257E": { "text": "-", "alt": ["pmboxdraw"] }, "\u25A0": { "text": "\\ding{110}", "alt": ["unicode-math"] }, "\u25B2": { "text": "\\ding{115}", "alt": ["unicode-math"] }, "\u25BC": { "text": "\\ding{116}", "alt": ["unicode-math"] }, "\u25D7": { "text": "\\ding{119}", "alt": ["unicode-math"] }, "\u25E6": { "text": "{\\textopenbullet}", "alt": ["unicode-math"] }, "\u2605": { "text": "\\ding{72}", "alt": ["unicode-math"] }, "\u2606": { "text": "\\ding{73}", "alt": ["unicode-math"] }, "\u260E": { "text": "\\ding{37}" }, "\u2613": { "text": "X" }, "\u261B": { "text": "\\ding{42}" }, "\u2640": { "text": "{\\venus}", "alt": ["unicode-math"] }, "\u2665": { "text": "\\ding{170}", "alt": ["unicode-math"] }, "\u2666": { "text": "\\ding{169}", "alt": ["unicode-math"] }, "\u266A": { "text": "{\\textmusicalnote}", "alt": ["unicode-math"] }, "\u2701": { "text": "\\ding{33}" }, "\u2702": { "text": "\\ding{34}" }, "\u2703": { "text": "\\ding{35}" }, "\u2704": { "text": "\\ding{36}" }, "\u2706": { "text": "\\ding{38}" }, "\u2707": { "text": "\\ding{39}" }, "\u2708": { "text": "\\ding{40}" }, "\u2709": { "text": "\\ding{41}" }, "\u270C": { "text": "\\ding{44}" }, "\u270D": { "text": "\\ding{45}" }, "\u270F": { "text": "\\ding{47}" }, "\u2710": { "text": "\\ding{48}" }, "\u2711": { "text": "\\ding{49}" }, "\u2712": { "text": "\\ding{50}" }, "\u2713": { "text": "\\ding{51}", "alt": ["unicode-math"] }, "\u2714": { "text": "\\ding{52}" }, "\u2715": { "text": "\\ding{53}" }, "\u2716": { "text": "\\ding{54}" }, "\u2718": { "text": "\\ding{56}" }, "\u2719": { "text": "\\ding{57}" }, "\u271A": { "text": "\\ding{58}" }, "\u271B": { "text": "\\ding{59}" }, "\u271C": { "text": "\\ding{60}" }, "\u271D": { "text": "\\ding{61}" }, "\u271E": { "text": "\\ding{62}" }, "\u271F": { "text": "\\ding{63}" }, "\u2720": { "text": "\\ding{64}", "alt": ["unicode-math"] }, "\u2721": { "text": "\\ding{65}" }, "\u2722": { "text": "\\ding{66}" }, "\u2723": { "text": "\\ding{67}" }, "\u2724": { "text": "\\ding{68}" }, "\u2725": { "text": "\\ding{69}" }, "\u2726": { "text": "\\ding{70}" }, "\u2727": { "text": "\\ding{71}" }, "\u2729": { "text": "\\ding{73}" }, "\u272A": { "text": "\\ding{74}", "alt": ["unicode-math"] }, "\u272B": { "text": "\\ding{75}" }, "\u272C": { "text": "\\ding{76}" }, "\u272D": { "text": "\\ding{77}" }, "\u272E": { "text": "\\ding{78}" }, "\u272F": { "text": "\\ding{79}" }, "\u2730": { "text": "\\ding{80}" }, "\u2731": { "text": "\\ding{81}" }, "\u2732": { "text": "\\ding{82}" }, "\u2733": { "text": "\\ding{83}" }, "\u2734": { "text": "\\ding{84}" }, "\u2735": { "text": "\\ding{85}" }, "\u2736": { "text": "\\ding{86}", "alt": ["unicode-math"] }, "\u2737": { "text": "\\ding{87}" }, "\u2738": { "text": "\\ding{88}" }, "\u2739": { "text": "\\ding{89}" }, "\u273A": { "text": "\\ding{90}" }, "\u273B": { "text": "\\ding{91}" }, "\u273C": { "text": "\\ding{92}" }, "\u273D": { "text": "\\ding{93}", "alt": ["unicode-math"] }, "\u273E": { "text": "\\ding{94}" }, "\u273F": { "text": "\\ding{95}" }, "\u2740": { "text": "\\ding{96}" }, "\u2741": { "text": "\\ding{97}" }, "\u2742": { "text": "\\ding{98}" }, "\u2743": { "text": "\\ding{99}" }, "\u2744": { "text": "\\ding{100}" }, "\u2745": { "text": "\\ding{101}" }, "\u2746": { "text": "\\ding{102}" }, "\u2747": { "text": "\\ding{103}" }, "\u2748": { "text": "\\ding{104}" }, "\u2749": { "text": "\\ding{105}" }, "\u274A": { "text": "\\ding{106}" }, "\u274B": { "text": "\\ding{107}" }, "\u274D": { "text": "\\ding{109}" }, "\u274F": { "text": "\\ding{111}" }, "\u2750": { "text": "\\ding{112}" }, "\u2751": { "text": "\\ding{113}" }, "\u2752": { "text": "\\ding{114}" }, "\u2756": { "text": "\\ding{118}" }, "\u2758": { "text": "\\ding{120}" }, "\u2759": { "text": "\\ding{121}" }, "\u275A": { "text": "\\ding{122}" }, "\u275B": { "text": "\\ding{123}" }, "\u275C": { "text": "\\ding{124}" }, "\u275D": { "text": "\\ding{125}" }, "\u275E": { "text": "\\ding{126}" }, "\u2761": { "text": "\\ding{161}" }, "\u2762": { "text": "\\ding{162}" }, "\u2763": { "text": "\\ding{163}" }, "\u2764": { "text": "\\ding{164}" }, "\u2765": { "text": "\\ding{165}" }, "\u2766": { "text": "\\ding{166}" }, "\u2767": { "text": "\\ding{167}" }, "\u2776": { "text": "\\ding{182}" }, "\u2777": { "text": "\\ding{183}" }, "\u2778": { "text": "\\ding{184}" }, "\u2779": { "text": "\\ding{185}" }, "\u277A": { "text": "\\ding{186}" }, "\u277B": { "text": "\\ding{187}" }, "\u277C": { "text": "\\ding{188}" }, "\u277D": { "text": "\\ding{189}" }, "\u277E": { "text": "\\ding{190}" }, "\u277F": { "text": "\\ding{191}" }, "\u2780": { "text": "\\ding{192}" }, "\u2781": { "text": "\\ding{193}" }, "\u2782": { "text": "\\ding{194}" }, "\u2783": { "text": "\\ding{195}" }, "\u2784": { "text": "\\ding{196}" }, "\u2785": { "text": "\\ding{197}" }, "\u2786": { "text": "\\ding{198}" }, "\u2787": { "text": "\\ding{199}" }, "\u2788": { "text": "\\ding{200}" }, "\u2789": { "text": "\\ding{201}" }, "\u278A": { "text": "\\ding{202}" }, "\u278B": { "text": "\\ding{203}" }, "\u278C": { "text": "\\ding{204}" }, "\u278D": { "text": "\\ding{205}" }, "\u278E": { "text": "\\ding{206}" }, "\u278F": { "text": "\\ding{207}" }, "\u2790": { "text": "\\ding{208}" }, "\u2791": { "text": "\\ding{209}" }, "\u2792": { "text": "\\ding{210}" }, "\u2793": { "text": "\\ding{211}" }, "\u2794": { "text": "\\ding{212}" }, "\u2798": { "text": "\\ding{216}" }, "\u2799": { "text": "\\ding{217}" }, "\u279A": { "text": "\\ding{218}" }, "\u279B": { "text": "\\ding{219}", "alt": ["unicode-math"] }, "\u279C": { "text": "\\ding{220}" }, "\u279D": { "text": "\\ding{221}" }, "\u279E": { "text": "\\ding{222}" }, "\u279F": { "text": "\\ding{223}" }, "\u27A0": { "text": "\\ding{224}" }, "\u27A1": { "text": "\\ding{225}" }, "\u27A3": { "text": "\\ding{227}" }, "\u27A4": { "text": "\\ding{228}" }, "\u27A5": { "text": "\\ding{229}" }, "\u27A6": { "text": "\\ding{230}" }, "\u27A7": { "text": "\\ding{231}" }, "\u27A8": { "text": "\\ding{232}" }, "\u27A9": { "text": "\\ding{233}" }, "\u27AA": { "text": "\\ding{234}" }, "\u27AB": { "text": "\\ding{235}" }, "\u27AC": { "text": "\\ding{236}" }, "\u27AD": { "text": "\\ding{237}" }, "\u27AE": { "text": "\\ding{238}" }, "\u27AF": { "text": "\\ding{239}" }, "\u27B1": { "text": "\\ding{241}" }, "\u27B2": { "text": "\\ding{242}" }, "\u27B3": { "text": "\\ding{243}" }, "\u27B4": { "text": "\\ding{244}" }, "\u27B5": { "text": "\\ding{245}" }, "\u27B6": { "text": "\\ding{246}" }, "\u27B7": { "text": "\\ding{247}" }, "\u27B8": { "text": "\\ding{248}" }, "\u27B9": { "text": "\\ding{249}" }, "\u27BA": { "text": "\\ding{250}" }, "\u27BB": { "text": "\\ding{251}" }, "\u27BC": { "text": "\\ding{252}" }, "\u27BD": { "text": "\\ding{253}" }, "\u27BE": { "text": "\\ding{254}" }, "\uFB00": { "text": "ff" }, "\uFB01": { "text": "fi" }, "\uFB02": { "text": "fl" }, "\uFB03": { "text": "ffi" }, "\uFB04": { "text": "ffl" }, "\uFB05": { "text": "st" }, "\uFB06": { "text": "st" }, "\uFFFD": { "text": "{\\dbend}" }, "\u2052": { "text": "{\\textdiscount}" }, "\u203D": { "text": "{\\textinterrobang}" }, "\u203B": { "text": "{\\textreferencemark}" }, "\u0166": { "text": "{\\textTstroke}" }, "\u0167": { "text": "{\\texttstroke}" }, "\u02CB": { "text": "{\\textasciigrave}" }, "\u0391": { "math": "A", "alt": ["unicode-math"] }, "\u0392": { "math": "B", "alt": ["unicode-math"] }, "\u0395": { "math": "E", "alt": ["unicode-math"] }, "\u0396": { "math": "Z", "alt": ["unicode-math"] }, "\u0397": { "math": "H", "alt": ["unicode-math"] }, "\u0399": { "math": "I", "alt": ["unicode-math"] }, "\u039A": { "math": "K", "alt": ["unicode-math"] }, "\u039C": { "math": "M", "alt": ["unicode-math"] }, "\u039D": { "math": "N", "alt": ["unicode-math"] }, "\u039F": { "math": "O", "alt": ["unicode-math"] }, "\u03A1": { "math": "P", "alt": ["unicode-math"] }, "\u03A4": { "math": "T", "alt": ["unicode-math"] }, "\u03A7": { "math": "X", "alt": ["unicode-math"] }, "\u03BF": { "math": "o", "alt": ["unicode-math"] }, "\u210A": { "math": "g", "alt": ["mathrsfs"] }, "\u2110": { "math": "I", "alt": ["mathrsfs"] }, "\u2112": { "math": "L", "alt": ["mathrsfs", "unicode-math"] }, "\u211B": { "math": "R", "alt": ["mathrsfs", "unicode-math"] }, "\u212C": { "math": "B", "alt": ["mathrsfs"] }, "\u212F": { "math": "e", "alt": ["mathrsfs"] }, "\u2130": { "math": "E", "alt": ["mathrsfs"] }, "\u2131": { "math": "F", "alt": ["mathrsfs"] }, "\u2133": { "math": "M", "alt": ["mathrsfs"] }, "\u2134": { "math": "o", "alt": ["mathrsfs"] }, "\u{1D49C}": { "math": "A", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D49E}": { "math": "C", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D49F}": { "math": "D", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4A2}": { "math": "G", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4A5}": { "math": "J", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4A6}": { "math": "K", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4A9}": { "math": "N", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4AA}": { "math": "O", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4AB}": { "math": "P", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4AC}": { "math": "Q", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4AE}": { "math": "S", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4AF}": { "math": "T", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B0}": { "math": "U", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B1}": { "math": "V", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B2}": { "math": "W", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B3}": { "math": "X", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B4}": { "math": "Y", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B5}": { "math": "Z", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B6}": { "math": "a", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B7}": { "math": "b", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B8}": { "math": "c", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4B9}": { "math": "d", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4BB}": { "math": "f", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4BD}": { "math": "h", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4BE}": { "math": "i", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4BF}": { "math": "j", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C0}": { "math": "k", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C1}": { "math": "l", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C2}": { "math": "m", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C3}": { "math": "n", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C5}": { "math": "p", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C6}": { "math": "q", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C7}": { "math": "r", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C8}": { "math": "s", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4C9}": { "math": "t", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4CA}": { "math": "u", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4CB}": { "math": "v", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4CC}": { "math": "w", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4CD}": { "math": "x", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4CE}": { "math": "y", "alt": ["mathrsfs", "unicode-math"] }, "\u{1D4CF}": { "math": "z", "alt": ["mathrsfs", "unicode-math"] }, "\u24B6": { "text": "(A)" }, "\u24B7": { "text": "(B)" }, "\u24B8": { "text": "(C)" }, "\u24B9": { "text": "(D)" }, "\u24BA": { "text": "(E)" }, "\u24BB": { "text": "(F)" }, "\u24BC": { "text": "(G)" }, "\u24BD": { "text": "(H)" }, "\u24BE": { "text": "(I)" }, "\u24BF": { "text": "(J)" }, "\u24C0": { "text": "(K)" }, "\u24C1": { "text": "(L)" }, "\u24C2": { "text": "(M)" }, "\u24C3": { "text": "(N)" }, "\u24C4": { "text": "(O)" }, "\u24C5": { "text": "(P)" }, "\u24C6": { "text": "(Q)" }, "\u24C7": { "text": "(R)" }, "\u24C9": { "text": "(T)" }, "\u24CA": { "text": "(U)" }, "\u24CB": { "text": "(V)" }, "\u24CC": { "text": "(W)" }, "\u24CD": { "text": "(X)" }, "\u24CE": { "text": "(Y)" }, "\u24CF": { "text": "(Z)" }, "\u24D0": { "text": "(a)" }, "\u24D1": { "text": "(b)" }, "\u24D2": { "text": "(c)" }, "\u24D3": { "text": "(d)" }, "\u24D4": { "text": "(e)" }, "\u24D5": { "text": "(f)" }, "\u24D6": { "text": "(g)" }, "\u24D7": { "text": "(h)" }, "\u24D8": { "text": "(i)" }, "\u24D9": { "text": "(j)" }, "\u24DA": { "text": "(k)" }, "\u24DB": { "text": "(l)" }, "\u24DC": { "text": "(m)" }, "\u24DD": { "text": "(n)" }, "\u24DE": { "text": "(o)" }, "\u24DF": { "text": "(p)" }, "\u24E0": { "text": "(q)" }, "\u24E1": { "text": "(r)" }, "\u24E2": { "text": "(s)" }, "\u24E3": { "text": "(t)" }, "\u24E4": { "text": "(u)" }, "\u24E5": { "text": "(v)" }, "\u24E6": { "text": "(w)" }, "\u24E7": { "text": "(x)" }, "\u24E8": { "text": "(y)" }, "\u24E9": { "text": "(z)" }, "\u24EA": { "text": "(0)" }, "\u2501": { "text": "=", "alt": ["pmboxdraw"] }, "\u2502": { "text": "|", "alt": ["pmboxdraw"] }, "\u2503": { "text": "|", "alt": ["pmboxdraw"] }, "\u2505": { "text": "=" }, "\u2507": { "text": "|" }, "\u2509": { "text": "=" }, "\u250A": { "text": "|" }, "\u250B": { "text": "|" }, "\u254D": { "text": "=" }, "\u254E": { "text": "|" }, "\u254F": { "text": "|" }, "\u2550": { "text": "=", "alt": ["pmboxdraw"] }, "\u2551": { "text": "|", "alt": ["pmboxdraw"] }, "\u257D": { "text": "|", "alt": ["pmboxdraw"] }, "\u257F": { "text": "|", "alt": ["pmboxdraw"] } }, "package": { "wasysym": { "\u2653": { "text": "{\\pisces}", "math": "\\pisces" }, "\u263D": { "text": "{\\rightmoon}" }, "\u263E": { "text": "{\\leftmoon}" } }, "unicode-math": { "\u20AC": { "math": "\\euro" }, "\u0300": { "math": "\\grave" }, "\u0301": { "math": "\\acute" }, "\u0303": { "math": "\\tilde" }, "\u0306": { "math": "\\breve" }, "\u0307": { "math": "\\dot" }, "\u0308": { "math": "\\ddot" }, "\u0309": { "math": "\\ovhook" }, "\u030C": { "math": "\\check" }, "\u0310": { "math": "\\candra" }, "\u0312": { "math": "\\oturnedcomma" }, "\u0315": { "math": "\\ocommatopright" }, "\u031A": { "math": "\\droang" }, "\u034D": { "math": "\\underleftrightarrow" }, "\u0391": { "math": "\\mupAlpha" }, "\u0392": { "math": "\\mupBeta" }, "\u0393": { "math": "\\mupGamma" }, "\u0394": { "math": "\\mupDelta" }, "\u0395": { "math": "\\mupEpsilon" }, "\u0396": { "math": "\\mupZeta" }, "\u0397": { "math": "\\mupEta" }, "\u0398": { "math": "\\mupTheta" }, "\u0399": { "math": "\\mupIota" }, "\u039A": { "math": "\\mupKappa" }, "\u039B": { "math": "\\mupLambda" }, "\u039C": { "math": "\\mupMu" }, "\u039D": { "math": "\\mupNu" }, "\u039F": { "math": "\\mupOmicron" }, "\u03A1": { "math": "\\mupRho" }, "\u03A4": { "math": "\\mupTau" }, "\u03A7": { "math": "\\mupChi" }, "\u03BF": { "math": "\\mupomicron" }, "\u03D0": { "math": "\\varbeta" }, "\u03F0": { "math": "\\varkappa" }, "\u03F6": { "math": "\\upbackepsilon" }, "\u{1D400}": { "math": "\\mbfA" }, "\u{1D401}": { "math": "\\mbfB" }, "\u{1D402}": { "math": "\\mbfC" }, "\u{1D403}": { "math": "\\mbfD" }, "\u{1D404}": { "math": "\\mbfE" }, "\u{1D405}": { "math": "\\mbfF" }, "\u{1D406}": { "math": "\\mbfG" }, "\u{1D407}": { "math": "\\mbfH" }, "\u{1D408}": { "math": "\\mbfI" }, "\u{1D409}": { "math": "\\mbfJ" }, "\u{1D40A}": { "math": "\\mbfK" }, "\u{1D40B}": { "math": "\\mbfL" }, "\u{1D40C}": { "math": "\\mbfM" }, "\u{1D40D}": { "math": "\\mbfN" }, "\u{1D40E}": { "math": "\\mbfO" }, "\u{1D40F}": { "math": "\\mbfP" }, "\u{1D410}": { "math": "\\mbfQ" }, "\u{1D411}": { "math": "\\mbfR" }, "\u{1D412}": { "math": "\\mbfS" }, "\u{1D413}": { "math": "\\mbfT" }, "\u{1D414}": { "math": "\\mbfU" }, "\u{1D415}": { "math": "\\mbfV" }, "\u{1D416}": { "math": "\\mbfW" }, "\u{1D417}": { "math": "\\mbfX" }, "\u{1D418}": { "math": "\\mbfY" }, "\u{1D419}": { "math": "\\mbfZ" }, "\u{1D41A}": { "math": "\\mbfa" }, "\u{1D41B}": { "math": "\\mbfb" }, "\u{1D41C}": { "math": "\\mbfc" }, "\u{1D41D}": { "math": "\\mbfd" }, "\u{1D41E}": { "math": "\\mbfe" }, "\u{1D41F}": { "math": "\\mbff" }, "\u{1D420}": { "math": "\\mbfg" }, "\u{1D421}": { "math": "\\mbfh" }, "\u{1D422}": { "math": "\\mbfi" }, "\u{1D423}": { "math": "\\mbfj" }, "\u{1D424}": { "math": "\\mbfk" }, "\u{1D425}": { "math": "\\mbfl" }, "\u{1D426}": { "math": "\\mbfm" }, "\u{1D427}": { "math": "\\mbfn" }, "\u{1D428}": { "math": "\\mbfo" }, "\u{1D429}": { "math": "\\mbfp" }, "\u{1D42A}": { "math": "\\mbfq" }, "\u{1D42B}": { "math": "\\mbfr" }, "\u{1D42C}": { "math": "\\mbfs" }, "\u{1D42D}": { "math": "\\mbft" }, "\u{1D42E}": { "math": "\\mbfu" }, "\u{1D42F}": { "math": "\\mbfv" }, "\u{1D430}": { "math": "\\mbfw" }, "\u{1D431}": { "math": "\\mbfx" }, "\u{1D432}": { "math": "\\mbfy" }, "\u{1D433}": { "math": "\\mbfz" }, "\u{1D434}": { "math": "\\mitA" }, "\u{1D435}": { "math": "\\mitB" }, "\u{1D436}": { "math": "\\mitC" }, "\u{1D437}": { "math": "\\mitD" }, "\u{1D438}": { "math": "\\mitE" }, "\u{1D439}": { "math": "\\mitF" }, "\u{1D43A}": { "math": "\\mitG" }, "\u{1D43B}": { "math": "\\mitH" }, "\u{1D43C}": { "math": "\\mitI" }, "\u{1D43D}": { "math": "\\mitJ" }, "\u{1D43E}": { "math": "\\mitK" }, "\u{1D43F}": { "math": "\\mitL" }, "\u{1D440}": { "math": "\\mitM" }, "\u{1D441}": { "math": "\\mitN" }, "\u{1D442}": { "math": "\\mitO" }, "\u{1D443}": { "math": "\\mitP" }, "\u{1D444}": { "math": "\\mitQ" }, "\u{1D445}": { "math": "\\mitR" }, "\u{1D446}": { "math": "\\mitS" }, "\u{1D447}": { "math": "\\mitT" }, "\u{1D448}": { "math": "\\mitU" }, "\u{1D449}": { "math": "\\mitV" }, "\u{1D44A}": { "math": "\\mitW" }, "\u{1D44B}": { "math": "\\mitX" }, "\u{1D44C}": { "math": "\\mitY" }, "\u{1D44D}": { "math": "\\mitZ" }, "\u{1D44E}": { "math": "\\mita" }, "\u{1D44F}": { "math": "\\mitb" }, "\u{1D450}": { "math": "\\mitc" }, "\u{1D451}": { "math": "\\mitd" }, "\u{1D452}": { "math": "\\mite" }, "\u{1D453}": { "math": "\\mitf" }, "\u{1D454}": { "math": "\\mitg" }, "\u{1D456}": { "math": "\\miti" }, "\u{1D457}": { "math": "\\mitj" }, "\u{1D458}": { "math": "\\mitk" }, "\u{1D459}": { "math": "\\mitl" }, "\u{1D45A}": { "math": "\\mitm" }, "\u{1D45B}": { "math": "\\mitn" }, "\u{1D45C}": { "math": "\\mito" }, "\u{1D45D}": { "math": "\\mitp" }, "\u{1D45E}": { "math": "\\mitq" }, "\u{1D45F}": { "math": "\\mitr" }, "\u{1D460}": { "math": "\\mits" }, "\u{1D461}": { "math": "\\mitt" }, "\u{1D462}": { "math": "\\mitu" }, "\u{1D463}": { "math": "\\mitv" }, "\u{1D464}": { "math": "\\mitw" }, "\u{1D465}": { "math": "\\mitx" }, "\u{1D466}": { "math": "\\mity" }, "\u{1D467}": { "math": "\\mitz" }, "\u{1D468}": { "math": "\\mbfitA" }, "\u{1D469}": { "math": "\\mbfitB" }, "\u{1D46A}": { "math": "\\mbfitC" }, "\u{1D46B}": { "math": "\\mbfitD" }, "\u{1D46C}": { "math": "\\mbfitE" }, "\u{1D46D}": { "math": "\\mbfitF" }, "\u{1D46E}": { "math": "\\mbfitG" }, "\u{1D46F}": { "math": "\\mbfitH" }, "\u{1D470}": { "math": "\\mbfitI" }, "\u{1D471}": { "math": "\\mbfitJ" }, "\u{1D472}": { "math": "\\mbfitK" }, "\u{1D473}": { "math": "\\mbfitL" }, "\u{1D474}": { "math": "\\mbfitM" }, "\u{1D475}": { "math": "\\mbfitN" }, "\u{1D476}": { "math": "\\mbfitO" }, "\u{1D477}": { "math": "\\mbfitP" }, "\u{1D478}": { "math": "\\mbfitQ" }, "\u{1D479}": { "math": "\\mbfitR" }, "\u{1D47A}": { "math": "\\mbfitS" }, "\u{1D47B}": { "math": "\\mbfitT" }, "\u{1D47C}": { "math": "\\mbfitU" }, "\u{1D47D}": { "math": "\\mbfitV" }, "\u{1D47E}": { "math": "\\mbfitW" }, "\u{1D47F}": { "math": "\\mbfitX" }, "\u{1D480}": { "math": "\\mbfitY" }, "\u{1D481}": { "math": "\\mbfitZ" }, "\u{1D482}": { "math": "\\mbfita" }, "\u{1D483}": { "math": "\\mbfitb" }, "\u{1D484}": { "math": "\\mbfitc" }, "\u{1D485}": { "math": "\\mbfitd" }, "\u{1D486}": { "math": "\\mbfite" }, "\u{1D487}": { "math": "\\mbfitf" }, "\u{1D488}": { "math": "\\mbfitg" }, "\u{1D489}": { "math": "\\mbfith" }, "\u{1D48A}": { "math": "\\mbfiti" }, "\u{1D48B}": { "math": "\\mbfitj" }, "\u{1D48C}": { "math": "\\mbfitk" }, "\u{1D48D}": { "math": "\\mbfitl" }, "\u{1D48E}": { "math": "\\mbfitm" }, "\u{1D48F}": { "math": "\\mbfitn" }, "\u{1D490}": { "math": "\\mbfito" }, "\u{1D491}": { "math": "\\mbfitp" }, "\u{1D492}": { "math": "\\mbfitq" }, "\u{1D493}": { "math": "\\mbfitr" }, "\u{1D494}": { "math": "\\mbfits" }, "\u{1D495}": { "math": "\\mbfitt" }, "\u{1D496}": { "math": "\\mbfitu" }, "\u{1D497}": { "math": "\\mbfitv" }, "\u{1D498}": { "math": "\\mbfitw" }, "\u{1D499}": { "math": "\\mbfitx" }, "\u{1D49A}": { "math": "\\mbfity" }, "\u{1D49B}": { "math": "\\mbfitz" }, "\u{1D49C}": { "math": "\\mscrA" }, "\u{1D49E}": { "math": "\\mscrC" }, "\u{1D49F}": { "math": "\\mscrD" }, "\u{1D4A2}": { "math": "\\mscrG" }, "\u{1D4A5}": { "math": "\\mscrJ" }, "\u{1D4A6}": { "math": "\\mscrK" }, "\u{1D4A9}": { "math": "\\mscrN" }, "\u{1D4AA}": { "math": "\\mscrO" }, "\u{1D4AB}": { "math": "\\mscrP" }, "\u{1D4AC}": { "math": "\\mscrQ" }, "\u{1D4AE}": { "math": "\\mscrS" }, "\u{1D4AF}": { "math": "\\mscrT" }, "\u{1D4B0}": { "math": "\\mscrU" }, "\u{1D4B1}": { "math": "\\mscrV" }, "\u{1D4B2}": { "math": "\\mscrW" }, "\u{1D4B3}": { "math": "\\mscrX" }, "\u{1D4B4}": { "math": "\\mscrY" }, "\u{1D4B5}": { "math": "\\mscrZ" }, "\u{1D4B6}": { "math": "\\mscra" }, "\u{1D4B7}": { "math": "\\mscrb" }, "\u{1D4B8}": { "math": "\\mscrc" }, "\u{1D4B9}": { "math": "\\mscrd" }, "\u{1D4BB}": { "math": "\\mscrf" }, "\u{1D4BD}": { "math": "\\mscrh" }, "\u{1D4BE}": { "math": "\\mscri" }, "\u{1D4BF}": { "math": "\\mscrj" }, "\u{1D4C0}": { "math": "\\mscrk" }, "\u{1D4C1}": { "math": "\\mscrl" }, "\u{1D4C2}": { "math": "\\mscrm" }, "\u{1D4C3}": { "math": "\\mscrn" }, "\u{1D4C5}": { "math": "\\mscrp" }, "\u{1D4C6}": { "math": "\\mscrq" }, "\u{1D4C7}": { "math": "\\mscrr" }, "\u{1D4C8}": { "math": "\\mscrs" }, "\u{1D4C9}": { "math": "\\mscrt" }, "\u{1D4CA}": { "math": "\\mscru" }, "\u{1D4CB}": { "math": "\\mscrv" }, "\u{1D4CC}": { "math": "\\mscrw" }, "\u{1D4CD}": { "math": "\\mscrx" }, "\u{1D4CE}": { "math": "\\mscry" }, "\u{1D4CF}": { "math": "\\mscrz" }, "\u{1D4D0}": { "math": "\\mbfscrA" }, "\u{1D4D1}": { "math": "\\mbfscrB" }, "\u{1D4D2}": { "math": "\\mbfscrC" }, "\u{1D4D3}": { "math": "\\mbfscrD" }, "\u{1D4D4}": { "math": "\\mbfscrE" }, "\u{1D4D5}": { "math": "\\mbfscrF" }, "\u{1D4D6}": { "math": "\\mbfscrG" }, "\u{1D4D7}": { "math": "\\mbfscrH" }, "\u{1D4D8}": { "math": "\\mbfscrI" }, "\u{1D4D9}": { "math": "\\mbfscrJ" }, "\u{1D4DA}": { "math": "\\mbfscrK" }, "\u{1D4DB}": { "math": "\\mbfscrL" }, "\u{1D4DC}": { "math": "\\mbfscrM" }, "\u{1D4DD}": { "math": "\\mbfscrN" }, "\u{1D4DE}": { "math": "\\mbfscrO" }, "\u{1D4DF}": { "math": "\\mbfscrP" }, "\u{1D4E0}": { "math": "\\mbfscrQ" }, "\u{1D4E1}": { "math": "\\mbfscrR" }, "\u{1D4E2}": { "math": "\\mbfscrS" }, "\u{1D4E3}": { "math": "\\mbfscrT" }, "\u{1D4E4}": { "math": "\\mbfscrU" }, "\u{1D4E5}": { "math": "\\mbfscrV" }, "\u{1D4E6}": { "math": "\\mbfscrW" }, "\u{1D4E7}": { "math": "\\mbfscrX" }, "\u{1D4E8}": { "math": "\\mbfscrY" }, "\u{1D4E9}": { "math": "\\mbfscrZ" }, "\u{1D4EA}": { "math": "\\mbfscra" }, "\u{1D4EB}": { "math": "\\mbfscrb" }, "\u{1D4EC}": { "math": "\\mbfscrc" }, "\u{1D4ED}": { "math": "\\mbfscrd" }, "\u{1D4EE}": { "math": "\\mbfscre" }, "\u{1D4EF}": { "math": "\\mbfscrf" }, "\u{1D4F0}": { "math": "\\mbfscrg" }, "\u{1D4F1}": { "math": "\\mbfscrh" }, "\u{1D4F2}": { "math": "\\mbfscri" }, "\u{1D4F3}": { "math": "\\mbfscrj" }, "\u{1D4F4}": { "math": "\\mbfscrk" }, "\u{1D4F5}": { "math": "\\mbfscrl" }, "\u{1D4F6}": { "math": "\\mbfscrm" }, "\u{1D4F7}": { "math": "\\mbfscrn" }, "\u{1D4F8}": { "math": "\\mbfscro" }, "\u{1D4F9}": { "math": "\\mbfscrp" }, "\u{1D4FA}": { "math": "\\mbfscrq" }, "\u{1D4FB}": { "math": "\\mbfscrr" }, "\u{1D4FC}": { "math": "\\mbfscrs" }, "\u{1D4FD}": { "math": "\\mbfscrt" }, "\u{1D4FE}": { "math": "\\mbfscru" }, "\u{1D4FF}": { "math": "\\mbfscrv" }, "\u{1D500}": { "math": "\\mbfscrw" }, "\u{1D501}": { "math": "\\mbfscrx" }, "\u{1D502}": { "math": "\\mbfscry" }, "\u{1D503}": { "math": "\\mbfscrz" }, "\u{1D504}": { "math": "\\mfrakA" }, "\u{1D505}": { "math": "\\mfrakB" }, "\u{1D507}": { "math": "\\mfrakD" }, "\u{1D508}": { "math": "\\mfrakE" }, "\u{1D509}": { "math": "\\mfrakF" }, "\u{1D50A}": { "math": "\\mfrakG" }, "\u{1D50D}": { "math": "\\mfrakJ" }, "\u{1D50E}": { "math": "\\mfrakK" }, "\u{1D50F}": { "math": "\\mfrakL" }, "\u{1D510}": { "math": "\\mfrakM" }, "\u{1D511}": { "math": "\\mfrakN" }, "\u{1D512}": { "math": "\\mfrakO" }, "\u{1D513}": { "math": "\\mfrakP" }, "\u{1D514}": { "math": "\\mfrakQ" }, "\u{1D516}": { "math": "\\mfrakS" }, "\u{1D517}": { "math": "\\mfrakT" }, "\u{1D518}": { "math": "\\mfrakU" }, "\u{1D519}": { "math": "\\mfrakV" }, "\u{1D51A}": { "math": "\\mfrakW" }, "\u{1D51B}": { "math": "\\mfrakX" }, "\u{1D51C}": { "math": "\\mfrakY" }, "\u{1D51E}": { "math": "\\mfraka" }, "\u{1D51F}": { "math": "\\mfrakb" }, "\u{1D520}": { "math": "\\mfrakc" }, "\u{1D521}": { "math": "\\mfrakd" }, "\u{1D522}": { "math": "\\mfrake" }, "\u{1D523}": { "math": "\\mfrakf" }, "\u{1D524}": { "math": "\\mfrakg" }, "\u{1D525}": { "math": "\\mfrakh" }, "\u{1D526}": { "math": "\\mfraki" }, "\u{1D527}": { "math": "\\mfrakj" }, "\u{1D528}": { "math": "\\mfrakk" }, "\u{1D529}": { "math": "\\mfrakl" }, "\u{1D52A}": { "math": "\\mfrakm" }, "\u{1D52B}": { "math": "\\mfrakn" }, "\u{1D52C}": { "math": "\\mfrako" }, "\u{1D52D}": { "math": "\\mfrakp" }, "\u{1D52E}": { "math": "\\mfrakq" }, "\u{1D52F}": { "math": "\\mfrakr" }, "\u{1D530}": { "math": "\\mfraks" }, "\u{1D531}": { "math": "\\mfrakt" }, "\u{1D532}": { "math": "\\mfraku" }, "\u{1D533}": { "math": "\\mfrakv" }, "\u{1D534}": { "math": "\\mfrakw" }, "\u{1D535}": { "math": "\\mfrakx" }, "\u{1D536}": { "math": "\\mfraky" }, "\u{1D537}": { "math": "\\mfrakz" }, "\u{1D538}": { "math": "\\BbbA" }, "\u{1D539}": { "math": "\\BbbB" }, "\u{1D53B}": { "math": "\\BbbD" }, "\u{1D53C}": { "math": "\\BbbE" }, "\u{1D53D}": { "math": "\\BbbF" }, "\u{1D53E}": { "math": "\\BbbG" }, "\u{1D540}": { "math": "\\BbbI" }, "\u{1D541}": { "math": "\\BbbJ" }, "\u{1D542}": { "math": "\\BbbK" }, "\u{1D543}": { "math": "\\BbbL" }, "\u{1D544}": { "math": "\\BbbM" }, "\u{1D546}": { "math": "\\BbbO" }, "\u{1D54A}": { "math": "\\BbbS" }, "\u{1D54B}": { "math": "\\BbbT" }, "\u{1D54C}": { "math": "\\BbbU" }, "\u{1D54D}": { "math": "\\BbbV" }, "\u{1D54E}": { "math": "\\BbbW" }, "\u{1D54F}": { "math": "\\BbbX" }, "\u{1D550}": { "math": "\\BbbY" }, "\u{1D552}": { "math": "\\Bbba" }, "\u{1D553}": { "math": "\\Bbbb" }, "\u{1D554}": { "math": "\\Bbbc" }, "\u{1D555}": { "math": "\\Bbbd" }, "\u{1D556}": { "math": "\\Bbbe" }, "\u{1D557}": { "math": "\\Bbbf" }, "\u{1D558}": { "math": "\\Bbbg" }, "\u{1D559}": { "math": "\\Bbbh" }, "\u{1D55A}": { "math": "\\Bbbi" }, "\u{1D55B}": { "math": "\\Bbbj" }, "\u{1D55C}": { "math": "\\Bbbk" }, "\u{1D55D}": { "math": "\\Bbbl" }, "\u{1D55E}": { "math": "\\Bbbm" }, "\u{1D55F}": { "math": "\\Bbbn" }, "\u{1D560}": { "math": "\\Bbbo" }, "\u{1D561}": { "math": "\\Bbbp" }, "\u{1D562}": { "math": "\\Bbbq" }, "\u{1D563}": { "math": "\\Bbbr" }, "\u{1D564}": { "math": "\\Bbbs" }, "\u{1D565}": { "math": "\\Bbbt" }, "\u{1D566}": { "math": "\\Bbbu" }, "\u{1D567}": { "math": "\\Bbbv" }, "\u{1D568}": { "math": "\\Bbbw" }, "\u{1D569}": { "math": "\\Bbbx" }, "\u{1D56A}": { "math": "\\Bbby" }, "\u{1D56B}": { "math": "\\Bbbz" }, "\u{1D56C}": { "math": "\\mbffrakA" }, "\u{1D56D}": { "math": "\\mbffrakB" }, "\u{1D56E}": { "math": "\\mbffrakC" }, "\u{1D56F}": { "math": "\\mbffrakD" }, "\u{1D570}": { "math": "\\mbffrakE" }, "\u{1D571}": { "math": "\\mbffrakF" }, "\u{1D572}": { "math": "\\mbffrakG" }, "\u{1D573}": { "math": "\\mbffrakH" }, "\u{1D574}": { "math": "\\mbffrakI" }, "\u{1D575}": { "math": "\\mbffrakJ" }, "\u{1D576}": { "math": "\\mbffrakK" }, "\u{1D577}": { "math": "\\mbffrakL" }, "\u{1D578}": { "math": "\\mbffrakM" }, "\u{1D579}": { "math": "\\mbffrakN" }, "\u{1D57A}": { "math": "\\mbffrakO" }, "\u{1D57B}": { "math": "\\mbffrakP" }, "\u{1D57C}": { "math": "\\mbffrakQ" }, "\u{1D57D}": { "math": "\\mbffrakR" }, "\u{1D57E}": { "math": "\\mbffrakS" }, "\u{1D57F}": { "math": "\\mbffrakT" }, "\u{1D580}": { "math": "\\mbffrakU" }, "\u{1D581}": { "math": "\\mbffrakV" }, "\u{1D582}": { "math": "\\mbffrakW" }, "\u{1D583}": { "math": "\\mbffrakX" }, "\u{1D584}": { "math": "\\mbffrakY" }, "\u{1D585}": { "math": "\\mbffrakZ" }, "\u{1D586}": { "math": "\\mbffraka" }, "\u{1D587}": { "math": "\\mbffrakb" }, "\u{1D588}": { "math": "\\mbffrakc" }, "\u{1D589}": { "math": "\\mbffrakd" }, "\u{1D58A}": { "math": "\\mbffrake" }, "\u{1D58B}": { "math": "\\mbffrakf" }, "\u{1D58C}": { "math": "\\mbffrakg" }, "\u{1D58D}": { "math": "\\mbffrakh" }, "\u{1D58E}": { "math": "\\mbffraki" }, "\u{1D58F}": { "math": "\\mbffrakj" }, "\u{1D590}": { "math": "\\mbffrakk" }, "\u{1D591}": { "math": "\\mbffrakl" }, "\u{1D592}": { "math": "\\mbffrakm" }, "\u{1D593}": { "math": "\\mbffrakn" }, "\u{1D594}": { "math": "\\mbffrako" }, "\u{1D595}": { "math": "\\mbffrakp" }, "\u{1D596}": { "math": "\\mbffrakq" }, "\u{1D597}": { "math": "\\mbffrakr" }, "\u{1D598}": { "math": "\\mbffraks" }, "\u{1D599}": { "math": "\\mbffrakt" }, "\u{1D59A}": { "math": "\\mbffraku" }, "\u{1D59B}": { "math": "\\mbffrakv" }, "\u{1D59C}": { "math": "\\mbffrakw" }, "\u{1D59D}": { "math": "\\mbffrakx" }, "\u{1D59E}": { "math": "\\mbffraky" }, "\u{1D59F}": { "math": "\\mbffrakz" }, "\u{1D5A0}": { "math": "\\msansA" }, "\u{1D5A1}": { "math": "\\msansB" }, "\u{1D5A2}": { "math": "\\msansC" }, "\u{1D5A3}": { "math": "\\msansD" }, "\u{1D5A4}": { "math": "\\msansE" }, "\u{1D5A5}": { "math": "\\msansF" }, "\u{1D5A6}": { "math": "\\msansG" }, "\u{1D5A7}": { "math": "\\msansH" }, "\u{1D5A8}": { "math": "\\msansI" }, "\u{1D5A9}": { "math": "\\msansJ" }, "\u{1D5AA}": { "math": "\\msansK" }, "\u{1D5AB}": { "math": "\\msansL" }, "\u{1D5AC}": { "math": "\\msansM" }, "\u{1D5AD}": { "math": "\\msansN" }, "\u{1D5AE}": { "math": "\\msansO" }, "\u{1D5AF}": { "math": "\\msansP" }, "\u{1D5B0}": { "math": "\\msansQ" }, "\u{1D5B1}": { "math": "\\msansR" }, "\u{1D5B2}": { "math": "\\msansS" }, "\u{1D5B3}": { "math": "\\msansT" }, "\u{1D5B4}": { "math": "\\msansU" }, "\u{1D5B5}": { "math": "\\msansV" }, "\u{1D5B6}": { "math": "\\msansW" }, "\u{1D5B7}": { "math": "\\msansX" }, "\u{1D5B8}": { "math": "\\msansY" }, "\u{1D5B9}": { "math": "\\msansZ" }, "\u{1D5BA}": { "math": "\\msansa" }, "\u{1D5BB}": { "math": "\\msansb" }, "\u{1D5BC}": { "math": "\\msansc" }, "\u{1D5BD}": { "math": "\\msansd" }, "\u{1D5BE}": { "math": "\\msanse" }, "\u{1D5BF}": { "math": "\\msansf" }, "\u{1D5C0}": { "math": "\\msansg" }, "\u{1D5C1}": { "math": "\\msansh" }, "\u{1D5C2}": { "math": "\\msansi" }, "\u{1D5C3}": { "math": "\\msansj" }, "\u{1D5C4}": { "math": "\\msansk" }, "\u{1D5C5}": { "math": "\\msansl" }, "\u{1D5C6}": { "math": "\\msansm" }, "\u{1D5C7}": { "math": "\\msansn" }, "\u{1D5C8}": { "math": "\\msanso" }, "\u{1D5C9}": { "math": "\\msansp" }, "\u{1D5CA}": { "math": "\\msansq" }, "\u{1D5CB}": { "math": "\\msansr" }, "\u{1D5CC}": { "math": "\\msanss" }, "\u{1D5CD}": { "math": "\\msanst" }, "\u{1D5CE}": { "math": "\\msansu" }, "\u{1D5CF}": { "math": "\\msansv" }, "\u{1D5D0}": { "math": "\\msansw" }, "\u{1D5D1}": { "math": "\\msansx" }, "\u{1D5D2}": { "math": "\\msansy" }, "\u{1D5D3}": { "math": "\\msansz" }, "\u{1D5D4}": { "math": "\\mbfsansA" }, "\u{1D5D5}": { "math": "\\mbfsansB" }, "\u{1D5D6}": { "math": "\\mbfsansC" }, "\u{1D5D7}": { "math": "\\mbfsansD" }, "\u{1D5D8}": { "math": "\\mbfsansE" }, "\u{1D5D9}": { "math": "\\mbfsansF" }, "\u{1D5DA}": { "math": "\\mbfsansG" }, "\u{1D5DB}": { "math": "\\mbfsansH" }, "\u{1D5DC}": { "math": "\\mbfsansI" }, "\u{1D5DD}": { "math": "\\mbfsansJ" }, "\u{1D5DE}": { "math": "\\mbfsansK" }, "\u{1D5DF}": { "math": "\\mbfsansL" }, "\u{1D5E0}": { "math": "\\mbfsansM" }, "\u{1D5E1}": { "math": "\\mbfsansN" }, "\u{1D5E2}": { "math": "\\mbfsansO" }, "\u{1D5E3}": { "math": "\\mbfsansP" }, "\u{1D5E4}": { "math": "\\mbfsansQ" }, "\u{1D5E5}": { "math": "\\mbfsansR" }, "\u{1D5E6}": { "math": "\\mbfsansS" }, "\u{1D5E7}": { "math": "\\mbfsansT" }, "\u{1D5E8}": { "math": "\\mbfsansU" }, "\u{1D5E9}": { "math": "\\mbfsansV" }, "\u{1D5EA}": { "math": "\\mbfsansW" }, "\u{1D5EB}": { "math": "\\mbfsansX" }, "\u{1D5EC}": { "math": "\\mbfsansY" }, "\u{1D5ED}": { "math": "\\mbfsansZ" }, "\u{1D5EE}": { "math": "\\mbfsansa" }, "\u{1D5EF}": { "math": "\\mbfsansb" }, "\u{1D5F0}": { "math": "\\mbfsansc" }, "\u{1D5F1}": { "math": "\\mbfsansd" }, "\u{1D5F2}": { "math": "\\mbfsanse" }, "\u{1D5F3}": { "math": "\\mbfsansf" }, "\u{1D5F4}": { "math": "\\mbfsansg" }, "\u{1D5F5}": { "math": "\\mbfsansh" }, "\u{1D5F6}": { "math": "\\mbfsansi" }, "\u{1D5F7}": { "math": "\\mbfsansj" }, "\u{1D5F8}": { "math": "\\mbfsansk" }, "\u{1D5F9}": { "math": "\\mbfsansl" }, "\u{1D5FA}": { "math": "\\mbfsansm" }, "\u{1D5FB}": { "math": "\\mbfsansn" }, "\u{1D5FC}": { "math": "\\mbfsanso" }, "\u{1D5FD}": { "math": "\\mbfsansp" }, "\u{1D5FE}": { "math": "\\mbfsansq" }, "\u{1D5FF}": { "math": "\\mbfsansr" }, "\u{1D600}": { "math": "\\mbfsanss" }, "\u{1D601}": { "math": "\\mbfsanst" }, "\u{1D602}": { "math": "\\mbfsansu" }, "\u{1D603}": { "math": "\\mbfsansv" }, "\u{1D604}": { "math": "\\mbfsansw" }, "\u{1D605}": { "math": "\\mbfsansx" }, "\u{1D606}": { "math": "\\mbfsansy" }, "\u{1D607}": { "math": "\\mbfsansz" }, "\u{1D608}": { "math": "\\mitsansA" }, "\u{1D609}": { "math": "\\mitsansB" }, "\u{1D60A}": { "math": "\\mitsansC" }, "\u{1D60B}": { "math": "\\mitsansD" }, "\u{1D60C}": { "math": "\\mitsansE" }, "\u{1D60D}": { "math": "\\mitsansF" }, "\u{1D60E}": { "math": "\\mitsansG" }, "\u{1D60F}": { "math": "\\mitsansH" }, "\u{1D610}": { "math": "\\mitsansI" }, "\u{1D611}": { "math": "\\mitsansJ" }, "\u{1D612}": { "math": "\\mitsansK" }, "\u{1D613}": { "math": "\\mitsansL" }, "\u{1D614}": { "math": "\\mitsansM" }, "\u{1D615}": { "math": "\\mitsansN" }, "\u{1D616}": { "math": "\\mitsansO" }, "\u{1D617}": { "math": "\\mitsansP" }, "\u{1D618}": { "math": "\\mitsansQ" }, "\u{1D619}": { "math": "\\mitsansR" }, "\u{1D61A}": { "math": "\\mitsansS" }, "\u{1D61B}": { "math": "\\mitsansT" }, "\u{1D61C}": { "math": "\\mitsansU" }, "\u{1D61D}": { "math": "\\mitsansV" }, "\u{1D61E}": { "math": "\\mitsansW" }, "\u{1D61F}": { "math": "\\mitsansX" }, "\u{1D620}": { "math": "\\mitsansY" }, "\u{1D621}": { "math": "\\mitsansZ" }, "\u{1D622}": { "math": "\\mitsansa" }, "\u{1D623}": { "math": "\\mitsansb" }, "\u{1D624}": { "math": "\\mitsansc" }, "\u{1D625}": { "math": "\\mitsansd" }, "\u{1D626}": { "math": "\\mitsanse" }, "\u{1D627}": { "math": "\\mitsansf" }, "\u{1D628}": { "math": "\\mitsansg" }, "\u{1D629}": { "math": "\\mitsansh" }, "\u{1D62A}": { "math": "\\mitsansi" }, "\u{1D62B}": { "math": "\\mitsansj" }, "\u{1D62C}": { "math": "\\mitsansk" }, "\u{1D62D}": { "math": "\\mitsansl" }, "\u{1D62E}": { "math": "\\mitsansm" }, "\u{1D62F}": { "math": "\\mitsansn" }, "\u{1D630}": { "math": "\\mitsanso" }, "\u{1D631}": { "math": "\\mitsansp" }, "\u{1D632}": { "math": "\\mitsansq" }, "\u{1D633}": { "math": "\\mitsansr" }, "\u{1D634}": { "math": "\\mitsanss" }, "\u{1D635}": { "math": "\\mitsanst" }, "\u{1D636}": { "math": "\\mitsansu" }, "\u{1D637}": { "math": "\\mitsansv" }, "\u{1D638}": { "math": "\\mitsansw" }, "\u{1D639}": { "math": "\\mitsansx" }, "\u{1D63A}": { "math": "\\mitsansy" }, "\u{1D63B}": { "math": "\\mitsansz" }, "\u{1D63C}": { "math": "\\mbfitsansA" }, "\u{1D63D}": { "math": "\\mbfitsansB" }, "\u{1D63E}": { "math": "\\mbfitsansC" }, "\u{1D63F}": { "math": "\\mbfitsansD" }, "\u{1D640}": { "math": "\\mbfitsansE" }, "\u{1D641}": { "math": "\\mbfitsansF" }, "\u{1D642}": { "math": "\\mbfitsansG" }, "\u{1D643}": { "math": "\\mbfitsansH" }, "\u{1D644}": { "math": "\\mbfitsansI" }, "\u{1D645}": { "math": "\\mbfitsansJ" }, "\u{1D646}": { "math": "\\mbfitsansK" }, "\u{1D647}": { "math": "\\mbfitsansL" }, "\u{1D648}": { "math": "\\mbfitsansM" }, "\u{1D649}": { "math": "\\mbfitsansN" }, "\u{1D64A}": { "math": "\\mbfitsansO" }, "\u{1D64B}": { "math": "\\mbfitsansP" }, "\u{1D64C}": { "math": "\\mbfitsansQ" }, "\u{1D64D}": { "math": "\\mbfitsansR" }, "\u{1D64E}": { "math": "\\mbfitsansS" }, "\u{1D64F}": { "math": "\\mbfitsansT" }, "\u{1D650}": { "math": "\\mbfitsansU" }, "\u{1D651}": { "math": "\\mbfitsansV" }, "\u{1D652}": { "math": "\\mbfitsansW" }, "\u{1D653}": { "math": "\\mbfitsansX" }, "\u{1D654}": { "math": "\\mbfitsansY" }, "\u{1D655}": { "math": "\\mbfitsansZ" }, "\u{1D656}": { "math": "\\mbfitsansa" }, "\u{1D657}": { "math": "\\mbfitsansb" }, "\u{1D658}": { "math": "\\mbfitsansc" }, "\u{1D659}": { "math": "\\mbfitsansd" }, "\u{1D65A}": { "math": "\\mbfitsanse" }, "\u{1D65B}": { "math": "\\mbfitsansf" }, "\u{1D65C}": { "math": "\\mbfitsansg" }, "\u{1D65D}": { "math": "\\mbfitsansh" }, "\u{1D65E}": { "math": "\\mbfitsansi" }, "\u{1D65F}": { "math": "\\mbfitsansj" }, "\u{1D660}": { "math": "\\mbfitsansk" }, "\u{1D661}": { "math": "\\mbfitsansl" }, "\u{1D662}": { "math": "\\mbfitsansm" }, "\u{1D663}": { "math": "\\mbfitsansn" }, "\u{1D664}": { "math": "\\mbfitsanso" }, "\u{1D665}": { "math": "\\mbfitsansp" }, "\u{1D666}": { "math": "\\mbfitsansq" }, "\u{1D667}": { "math": "\\mbfitsansr" }, "\u{1D668}": { "math": "\\mbfitsanss" }, "\u{1D669}": { "math": "\\mbfitsanst" }, "\u{1D66A}": { "math": "\\mbfitsansu" }, "\u{1D66B}": { "math": "\\mbfitsansv" }, "\u{1D66C}": { "math": "\\mbfitsansw" }, "\u{1D66D}": { "math": "\\mbfitsansx" }, "\u{1D66E}": { "math": "\\mbfitsansy" }, "\u{1D66F}": { "math": "\\mbfitsansz" }, "\u{1D670}": { "math": "\\mttA" }, "\u{1D671}": { "math": "\\mttB" }, "\u{1D672}": { "math": "\\mttC" }, "\u{1D673}": { "math": "\\mttD" }, "\u{1D674}": { "math": "\\mttE" }, "\u{1D675}": { "math": "\\mttF" }, "\u{1D676}": { "math": "\\mttG" }, "\u{1D677}": { "math": "\\mttH" }, "\u{1D678}": { "math": "\\mttI" }, "\u{1D679}": { "math": "\\mttJ" }, "\u{1D67A}": { "math": "\\mttK" }, "\u{1D67B}": { "math": "\\mttL" }, "\u{1D67C}": { "math": "\\mttM" }, "\u{1D67D}": { "math": "\\mttN" }, "\u{1D67E}": { "math": "\\mttO" }, "\u{1D67F}": { "math": "\\mttP" }, "\u{1D680}": { "math": "\\mttQ" }, "\u{1D681}": { "math": "\\mttR" }, "\u{1D682}": { "math": "\\mttS" }, "\u{1D683}": { "math": "\\mttT" }, "\u{1D684}": { "math": "\\mttU" }, "\u{1D685}": { "math": "\\mttV" }, "\u{1D686}": { "math": "\\mttW" }, "\u{1D687}": { "math": "\\mttX" }, "\u{1D688}": { "math": "\\mttY" }, "\u{1D689}": { "math": "\\mttZ" }, "\u{1D68A}": { "math": "\\mtta" }, "\u{1D68B}": { "math": "\\mttb" }, "\u{1D68C}": { "math": "\\mttc" }, "\u{1D68D}": { "math": "\\mttd" }, "\u{1D68E}": { "math": "\\mtte" }, "\u{1D68F}": { "math": "\\mttf" }, "\u{1D690}": { "math": "\\mttg" }, "\u{1D691}": { "math": "\\mtth" }, "\u{1D692}": { "math": "\\mtti" }, "\u{1D693}": { "math": "\\mttj" }, "\u{1D694}": { "math": "\\mttk" }, "\u{1D695}": { "math": "\\mttl" }, "\u{1D696}": { "math": "\\mttm" }, "\u{1D697}": { "math": "\\mttn" }, "\u{1D698}": { "math": "\\mtto" }, "\u{1D699}": { "math": "\\mttp" }, "\u{1D69A}": { "math": "\\mttq" }, "\u{1D69B}": { "math": "\\mttr" }, "\u{1D69C}": { "math": "\\mtts" }, "\u{1D69D}": { "math": "\\mttt" }, "\u{1D69E}": { "math": "\\mttu" }, "\u{1D69F}": { "math": "\\mttv" }, "\u{1D6A0}": { "math": "\\mttw" }, "\u{1D6A1}": { "math": "\\mttx" }, "\u{1D6A2}": { "math": "\\mtty" }, "\u{1D6A3}": { "math": "\\mttz" }, "\u{1D6A4}": { "math": "\\imath" }, "\u{1D6A5}": { "math": "\\jmath" }, "\u{1D6A8}": { "math": "\\mbfAlpha" }, "\u{1D6A9}": { "math": "\\mbfBeta" }, "\u{1D6AA}": { "math": "\\mbfGamma" }, "\u{1D6AB}": { "math": "\\mbfDelta" }, "\u{1D6AC}": { "math": "\\mbfEpsilon" }, "\u{1D6AD}": { "math": "\\mbfZeta" }, "\u{1D6AE}": { "math": "\\mbfEta" }, "\u{1D6AF}": { "math": "\\mbfTheta" }, "\u{1D6B0}": { "math": "\\mbfIota" }, "\u{1D6B1}": { "math": "\\mbfKappa" }, "\u{1D6B2}": { "math": "\\mbfLambda" }, "\u{1D6B3}": { "math": "\\mbfMu" }, "\u{1D6B4}": { "math": "\\mbfNu" }, "\u{1D6B5}": { "math": "\\mbfXi" }, "\u{1D6B6}": { "math": "\\mbfOmicron" }, "\u{1D6B7}": { "math": "\\mbfPi" }, "\u{1D6B8}": { "math": "\\mbfRho" }, "\u{1D6B9}": { "math": "\\mbfvarTheta" }, "\u{1D6BA}": { "math": "\\mbfSigma" }, "\u{1D6BB}": { "math": "\\mbfTau" }, "\u{1D6BC}": { "math": "\\mbfUpsilon" }, "\u{1D6BD}": { "math": "\\mbfPhi" }, "\u{1D6BE}": { "math": "\\mbfChi" }, "\u{1D6BF}": { "math": "\\mbfPsi" }, "\u{1D6C0}": { "math": "\\mbfOmega" }, "\u{1D6C1}": { "math": "\\mbfnabla" }, "\u{1D6C2}": { "math": "\\mbfalpha" }, "\u{1D6C3}": { "math": "\\mbfbeta" }, "\u{1D6C4}": { "math": "\\mbfgamma" }, "\u{1D6C5}": { "math": "\\mbfdelta" }, "\u{1D6C6}": { "math": "\\mbfvarepsilon" }, "\u{1D6C7}": { "math": "\\mbfzeta" }, "\u{1D6C8}": { "math": "\\mbfeta" }, "\u{1D6C9}": { "math": "\\mbftheta" }, "\u{1D6CA}": { "math": "\\mbfiota" }, "\u{1D6CB}": { "math": "\\mbfkappa" }, "\u{1D6CC}": { "math": "\\mbflambda" }, "\u{1D6CD}": { "math": "\\mbfmu" }, "\u{1D6CE}": { "math": "\\mbfnu" }, "\u{1D6CF}": { "math": "\\mbfxi" }, "\u{1D6D0}": { "math": "\\mbfomicron" }, "\u{1D6D1}": { "math": "\\mbfpi" }, "\u{1D6D2}": { "math": "\\mbfrho" }, "\u{1D6D3}": { "math": "\\mbfvarsigma" }, "\u{1D6D4}": { "math": "\\mbfsigma" }, "\u{1D6D5}": { "math": "\\mbftau" }, "\u{1D6D6}": { "math": "\\mbfupsilon" }, "\u{1D6D7}": { "math": "\\mbfvarphi" }, "\u{1D6D8}": { "math": "\\mbfchi" }, "\u{1D6D9}": { "math": "\\mbfpsi" }, "\u{1D6DA}": { "math": "\\mbfomega" }, "\u{1D6DB}": { "math": "\\mbfpartial" }, "\u{1D6DC}": { "math": "\\mbfepsilon" }, "\u{1D6DD}": { "math": "\\mbfvartheta" }, "\u{1D6DE}": { "math": "\\mbfvarkappa" }, "\u{1D6DF}": { "math": "\\mbfphi" }, "\u{1D6E0}": { "math": "\\mbfvarrho" }, "\u{1D6E1}": { "math": "\\mbfvarpi" }, "\u{1D6E2}": { "math": "\\mitAlpha" }, "\u{1D6E3}": { "math": "\\mitBeta" }, "\u{1D6E4}": { "math": "\\mitGamma" }, "\u{1D6E5}": { "math": "\\mitDelta" }, "\u{1D6E6}": { "math": "\\mitEpsilon" }, "\u{1D6E7}": { "math": "\\mitZeta" }, "\u{1D6E8}": { "math": "\\mitEta" }, "\u{1D6E9}": { "math": "\\mitTheta" }, "\u{1D6EA}": { "math": "\\mitIota" }, "\u{1D6EB}": { "math": "\\mitKappa" }, "\u{1D6EC}": { "math": "\\mitLambda" }, "\u{1D6ED}": { "math": "\\mitMu" }, "\u{1D6EE}": { "math": "\\mitNu" }, "\u{1D6EF}": { "math": "\\mitXi" }, "\u{1D6F0}": { "math": "\\mitOmicron" }, "\u{1D6F1}": { "math": "\\mitPi" }, "\u{1D6F2}": { "math": "\\mitRho" }, "\u{1D6F3}": { "math": "\\mitvarTheta" }, "\u{1D6F4}": { "math": "\\mitSigma" }, "\u{1D6F5}": { "math": "\\mitTau" }, "\u{1D6F6}": { "math": "\\mitUpsilon" }, "\u{1D6F7}": { "math": "\\mitPhi" }, "\u{1D6F8}": { "math": "\\mitChi" }, "\u{1D6F9}": { "math": "\\mitPsi" }, "\u{1D6FA}": { "math": "\\mitOmega" }, "\u{1D6FB}": { "math": "\\mitnabla" }, "\u{1D6FC}": { "math": "\\mitalpha" }, "\u{1D6FD}": { "math": "\\mitbeta" }, "\u{1D6FE}": { "math": "\\mitgamma" }, "\u{1D6FF}": { "math": "\\mitdelta" }, "\u{1D700}": { "math": "\\mitvarepsilon" }, "\u{1D701}": { "math": "\\mitzeta" }, "\u{1D702}": { "math": "\\miteta" }, "\u{1D703}": { "math": "\\mittheta" }, "\u{1D704}": { "math": "\\mitiota" }, "\u{1D705}": { "math": "\\mitkappa" }, "\u{1D706}": { "math": "\\mitlambda" }, "\u{1D707}": { "math": "\\mitmu" }, "\u{1D708}": { "math": "\\mitnu" }, "\u{1D709}": { "math": "\\mitxi" }, "\u{1D70A}": { "math": "\\mitomicron" }, "\u{1D70B}": { "math": "\\mitpi" }, "\u{1D70C}": { "math": "\\mitrho" }, "\u{1D70D}": { "math": "\\mitvarsigma" }, "\u{1D70E}": { "math": "\\mitsigma" }, "\u{1D70F}": { "math": "\\mittau" }, "\u{1D710}": { "math": "\\mitupsilon" }, "\u{1D711}": { "math": "\\mitvarphi" }, "\u{1D712}": { "math": "\\mitchi" }, "\u{1D713}": { "math": "\\mitpsi" }, "\u{1D714}": { "math": "\\mitomega" }, "\u{1D715}": { "math": "\\mitpartial" }, "\u{1D716}": { "math": "\\mitepsilon" }, "\u{1D717}": { "math": "\\mitvartheta" }, "\u{1D718}": { "math": "\\mitvarkappa" }, "\u{1D719}": { "math": "\\mitphi" }, "\u{1D71A}": { "math": "\\mitvarrho" }, "\u{1D71B}": { "math": "\\mitvarpi" }, "\u{1D71C}": { "math": "\\mbfitAlpha" }, "\u{1D71D}": { "math": "\\mbfitBeta" }, "\u{1D71E}": { "math": "\\mbfitGamma" }, "\u{1D71F}": { "math": "\\mbfitDelta" }, "\u{1D720}": { "math": "\\mbfitEpsilon" }, "\u{1D721}": { "math": "\\mbfitZeta" }, "\u{1D722}": { "math": "\\mbfitEta" }, "\u{1D723}": { "math": "\\mbfitTheta" }, "\u{1D724}": { "math": "\\mbfitIota" }, "\u{1D725}": { "math": "\\mbfitKappa" }, "\u{1D726}": { "math": "\\mbfitLambda" }, "\u{1D727}": { "math": "\\mbfitMu" }, "\u{1D728}": { "math": "\\mbfitNu" }, "\u{1D729}": { "math": "\\mbfitXi" }, "\u{1D72A}": { "math": "\\mbfitOmicron" }, "\u{1D72B}": { "math": "\\mbfitPi" }, "\u{1D72C}": { "math": "\\mbfitRho" }, "\u{1D72D}": { "math": "\\mbfitvarTheta" }, "\u{1D72E}": { "math": "\\mbfitSigma" }, "\u{1D72F}": { "math": "\\mbfitTau" }, "\u{1D730}": { "math": "\\mbfitUpsilon" }, "\u{1D731}": { "math": "\\mbfitPhi" }, "\u{1D732}": { "math": "\\mbfitChi" }, "\u{1D733}": { "math": "\\mbfitPsi" }, "\u{1D734}": { "math": "\\mbfitOmega" }, "\u{1D735}": { "math": "\\mbfitnabla" }, "\u{1D736}": { "math": "\\mbfitalpha" }, "\u{1D737}": { "math": "\\mbfitbeta" }, "\u{1D738}": { "math": "\\mbfitgamma" }, "\u{1D739}": { "math": "\\mbfitdelta" }, "\u{1D73A}": { "math": "\\mbfitvarepsilon" }, "\u{1D73B}": { "math": "\\mbfitzeta" }, "\u{1D73C}": { "math": "\\mbfiteta" }, "\u{1D73D}": { "math": "\\mbfittheta" }, "\u{1D73E}": { "math": "\\mbfitiota" }, "\u{1D73F}": { "math": "\\mbfitkappa" }, "\u{1D740}": { "math": "\\mbfitlambda" }, "\u{1D741}": { "math": "\\mbfitmu" }, "\u{1D742}": { "math": "\\mbfitnu" }, "\u{1D743}": { "math": "\\mbfitxi" }, "\u{1D744}": { "math": "\\mbfitomicron" }, "\u{1D745}": { "math": "\\mbfitpi" }, "\u{1D746}": { "math": "\\mbfitrho" }, "\u{1D747}": { "math": "\\mbfitvarsigma" }, "\u{1D748}": { "math": "\\mbfitsigma" }, "\u{1D749}": { "math": "\\mbfittau" }, "\u{1D74A}": { "math": "\\mbfitupsilon" }, "\u{1D74B}": { "math": "\\mbfitvarphi" }, "\u{1D74C}": { "math": "\\mbfitchi" }, "\u{1D74D}": { "math": "\\mbfitpsi" }, "\u{1D74E}": { "math": "\\mbfitomega" }, "\u{1D74F}": { "math": "\\mbfitpartial" }, "\u{1D750}": { "math": "\\mbfitepsilon" }, "\u{1D751}": { "math": "\\mbfitvartheta" }, "\u{1D752}": { "math": "\\mbfitvarkappa" }, "\u{1D753}": { "math": "\\mbfitphi" }, "\u{1D754}": { "math": "\\mbfitvarrho" }, "\u{1D755}": { "math": "\\mbfitvarpi" }, "\u{1D756}": { "math": "\\mbfsansAlpha" }, "\u{1D757}": { "math": "\\mbfsansBeta" }, "\u{1D758}": { "math": "\\mbfsansGamma" }, "\u{1D759}": { "math": "\\mbfsansDelta" }, "\u{1D75A}": { "math": "\\mbfsansEpsilon" }, "\u{1D75B}": { "math": "\\mbfsansZeta" }, "\u{1D75C}": { "math": "\\mbfsansEta" }, "\u{1D75D}": { "math": "\\mbfsansTheta" }, "\u{1D75E}": { "math": "\\mbfsansIota" }, "\u{1D75F}": { "math": "\\mbfsansKappa" }, "\u{1D760}": { "math": "\\mbfsansLambda" }, "\u{1D761}": { "math": "\\mbfsansMu" }, "\u{1D762}": { "math": "\\mbfsansNu" }, "\u{1D763}": { "math": "\\mbfsansXi" }, "\u{1D764}": { "math": "\\mbfsansOmicron" }, "\u{1D765}": { "math": "\\mbfsansPi" }, "\u{1D766}": { "math": "\\mbfsansRho" }, "\u{1D767}": { "math": "\\mbfsansvarTheta" }, "\u{1D768}": { "math": "\\mbfsansSigma" }, "\u{1D769}": { "math": "\\mbfsansTau" }, "\u{1D76A}": { "math": "\\mbfsansUpsilon" }, "\u{1D76B}": { "math": "\\mbfsansPhi" }, "\u{1D76C}": { "math": "\\mbfsansChi" }, "\u{1D76D}": { "math": "\\mbfsansPsi" }, "\u{1D76E}": { "math": "\\mbfsansOmega" }, "\u{1D76F}": { "math": "\\mbfsansnabla" }, "\u{1D770}": { "math": "\\mbfsansalpha" }, "\u{1D771}": { "math": "\\mbfsansbeta" }, "\u{1D772}": { "math": "\\mbfsansgamma" }, "\u{1D773}": { "math": "\\mbfsansdelta" }, "\u{1D774}": { "math": "\\mbfsansvarepsilon" }, "\u{1D775}": { "math": "\\mbfsanszeta" }, "\u{1D776}": { "math": "\\mbfsanseta" }, "\u{1D777}": { "math": "\\mbfsanstheta" }, "\u{1D778}": { "math": "\\mbfsansiota" }, "\u{1D779}": { "math": "\\mbfsanskappa" }, "\u{1D77A}": { "math": "\\mbfsanslambda" }, "\u{1D77B}": { "math": "\\mbfsansmu" }, "\u{1D77C}": { "math": "\\mbfsansnu" }, "\u{1D77D}": { "math": "\\mbfsansxi" }, "\u{1D77E}": { "math": "\\mbfsansomicron" }, "\u{1D77F}": { "math": "\\mbfsanspi" }, "\u{1D780}": { "math": "\\mbfsansrho" }, "\u{1D781}": { "math": "\\mbfsansvarsigma" }, "\u{1D782}": { "math": "\\mbfsanssigma" }, "\u{1D783}": { "math": "\\mbfsanstau" }, "\u{1D784}": { "math": "\\mbfsansupsilon" }, "\u{1D785}": { "math": "\\mbfsansvarphi" }, "\u{1D786}": { "math": "\\mbfsanschi" }, "\u{1D787}": { "math": "\\mbfsanspsi" }, "\u{1D788}": { "math": "\\mbfsansomega" }, "\u{1D789}": { "math": "\\mbfsanspartial" }, "\u{1D78A}": { "math": "\\mbfsansepsilon" }, "\u{1D78B}": { "math": "\\mbfsansvartheta" }, "\u{1D78C}": { "math": "\\mbfsansvarkappa" }, "\u{1D78D}": { "math": "\\mbfsansphi" }, "\u{1D78E}": { "math": "\\mbfsansvarrho" }, "\u{1D78F}": { "math": "\\mbfsansvarpi" }, "\u{1D790}": { "math": "\\mbfitsansAlpha" }, "\u{1D791}": { "math": "\\mbfitsansBeta" }, "\u{1D792}": { "math": "\\mbfitsansGamma" }, "\u{1D793}": { "math": "\\mbfitsansDelta" }, "\u{1D794}": { "math": "\\mbfitsansEpsilon" }, "\u{1D795}": { "math": "\\mbfitsansZeta" }, "\u{1D796}": { "math": "\\mbfitsansEta" }, "\u{1D797}": { "math": "\\mbfitsansTheta" }, "\u{1D798}": { "math": "\\mbfitsansIota" }, "\u{1D799}": { "math": "\\mbfitsansKappa" }, "\u{1D79A}": { "math": "\\mbfitsansLambda" }, "\u{1D79B}": { "math": "\\mbfitsansMu" }, "\u{1D79C}": { "math": "\\mbfitsansNu" }, "\u{1D79D}": { "math": "\\mbfitsansXi" }, "\u{1D79E}": { "math": "\\mbfitsansOmicron" }, "\u{1D79F}": { "math": "\\mbfitsansPi" }, "\u{1D7A0}": { "math": "\\mbfitsansRho" }, "\u{1D7A1}": { "math": "\\mbfitsansvarTheta" }, "\u{1D7A2}": { "math": "\\mbfitsansSigma" }, "\u{1D7A3}": { "math": "\\mbfitsansTau" }, "\u{1D7A4}": { "math": "\\mbfitsansUpsilon" }, "\u{1D7A5}": { "math": "\\mbfitsansPhi" }, "\u{1D7A6}": { "math": "\\mbfitsansChi" }, "\u{1D7A7}": { "math": "\\mbfitsansPsi" }, "\u{1D7A8}": { "math": "\\mbfitsansOmega" }, "\u{1D7A9}": { "math": "\\mbfitsansnabla" }, "\u{1D7AA}": { "math": "\\mbfitsansalpha" }, "\u{1D7AB}": { "math": "\\mbfitsansbeta" }, "\u{1D7AC}": { "math": "\\mbfitsansgamma" }, "\u{1D7AD}": { "math": "\\mbfitsansdelta" }, "\u{1D7AE}": { "math": "\\mbfitsansvarepsilon" }, "\u{1D7AF}": { "math": "\\mbfitsanszeta" }, "\u{1D7B0}": { "math": "\\mbfitsanseta" }, "\u{1D7B1}": { "math": "\\mbfitsanstheta" }, "\u{1D7B2}": { "math": "\\mbfitsansiota" }, "\u{1D7B3}": { "math": "\\mbfitsanskappa" }, "\u{1D7B4}": { "math": "\\mbfitsanslambda" }, "\u{1D7B5}": { "math": "\\mbfitsansmu" }, "\u{1D7B6}": { "math": "\\mbfitsansnu" }, "\u{1D7B7}": { "math": "\\mbfitsansxi" }, "\u{1D7B8}": { "math": "\\mbfitsansomicron" }, "\u{1D7B9}": { "math": "\\mbfitsanspi" }, "\u{1D7BA}": { "math": "\\mbfitsansrho" }, "\u{1D7BB}": { "math": "\\mbfitsansvarsigma" }, "\u{1D7BC}": { "math": "\\mbfitsanssigma" }, "\u{1D7BD}": { "math": "\\mbfitsanstau" }, "\u{1D7BE}": { "math": "\\mbfitsansupsilon" }, "\u{1D7BF}": { "math": "\\mbfitsansvarphi" }, "\u{1D7C0}": { "math": "\\mbfitsanschi" }, "\u{1D7C1}": { "math": "\\mbfitsanspsi" }, "\u{1D7C2}": { "math": "\\mbfitsansomega" }, "\u{1D7C3}": { "math": "\\mbfitsanspartial" }, "\u{1D7C4}": { "math": "\\mbfitsansepsilon" }, "\u{1D7C5}": { "math": "\\mbfitsansvartheta" }, "\u{1D7C6}": { "math": "\\mbfitsansvarkappa" }, "\u{1D7C7}": { "math": "\\mbfitsansphi" }, "\u{1D7C8}": { "math": "\\mbfitsansvarrho" }, "\u{1D7C9}": { "math": "\\mbfitsansvarpi" }, "\u{1D7CA}": { "math": "\\mbfDigamma" }, "\u{1D7CB}": { "math": "\\mbfdigamma" }, "\u{1D7CE}": { "math": "\\mbfzero" }, "\u{1D7CF}": { "math": "\\mbfone" }, "\u{1D7D0}": { "math": "\\mbftwo" }, "\u{1D7D1}": { "math": "\\mbfthree" }, "\u{1D7D2}": { "math": "\\mbffour" }, "\u{1D7D3}": { "math": "\\mbffive" }, "\u{1D7D4}": { "math": "\\mbfsix" }, "\u{1D7D5}": { "math": "\\mbfseven" }, "\u{1D7D6}": { "math": "\\mbfeight" }, "\u{1D7D7}": { "math": "\\mbfnine" }, "\u{1D7D8}": { "math": "\\Bbbzero" }, "\u{1D7D9}": { "math": "\\Bbbone" }, "\u{1D7DA}": { "math": "\\Bbbtwo" }, "\u{1D7DB}": { "math": "\\Bbbthree" }, "\u{1D7DC}": { "math": "\\Bbbfour" }, "\u{1D7DD}": { "math": "\\Bbbfive" }, "\u{1D7DE}": { "math": "\\Bbbsix" }, "\u{1D7DF}": { "math": "\\Bbbseven" }, "\u{1D7E0}": { "math": "\\Bbbeight" }, "\u{1D7E1}": { "math": "\\Bbbnine" }, "\u{1D7E2}": { "math": "\\msanszero" }, "\u{1D7E3}": { "math": "\\msansone" }, "\u{1D7E4}": { "math": "\\msanstwo" }, "\u{1D7E5}": { "math": "\\msansthree" }, "\u{1D7E6}": { "math": "\\msansfour" }, "\u{1D7E7}": { "math": "\\msansfive" }, "\u{1D7E8}": { "math": "\\msanssix" }, "\u{1D7E9}": { "math": "\\msansseven" }, "\u{1D7EA}": { "math": "\\msanseight" }, "\u{1D7EB}": { "math": "\\msansnine" }, "\u{1D7EC}": { "math": "\\mbfsanszero" }, "\u{1D7ED}": { "math": "\\mbfsansone" }, "\u{1D7EE}": { "math": "\\mbfsanstwo" }, "\u{1D7EF}": { "math": "\\mbfsansthree" }, "\u{1D7F0}": { "math": "\\mbfsansfour" }, "\u{1D7F1}": { "math": "\\mbfsansfive" }, "\u{1D7F2}": { "math": "\\mbfsanssix" }, "\u{1D7F3}": { "math": "\\mbfsansseven" }, "\u{1D7F4}": { "math": "\\mbfsanseight" }, "\u{1D7F5}": { "math": "\\mbfsansnine" }, "\u{1D7F6}": { "math": "\\mttzero" }, "\u{1D7F7}": { "math": "\\mttone" }, "\u{1D7F8}": { "math": "\\mtttwo" }, "\u{1D7F9}": { "math": "\\mttthree" }, "\u{1D7FA}": { "math": "\\mttfour" }, "\u{1D7FB}": { "math": "\\mttfive" }, "\u{1D7FC}": { "math": "\\mttsix" }, "\u{1D7FD}": { "math": "\\mttseven" }, "\u{1D7FE}": { "math": "\\mtteight" }, "\u{1D7FF}": { "math": "\\mttnine" }, "u\u031B\u03030": { "math": "\\arabicmaj" }, "u\u031B\u03031": { "math": "\\arabichad" }, "\u2010": { "math": "\\mathhyphen" }, "\u2015": { "math": "\\horizbar" }, "\u2017": { "math": "\\twolowline" }, "\u2025": { "math": "\\enleadertwodots" }, "\u2033": { "math": "\\dprime" }, "\u2034": { "math": "\\trprime" }, "\u2035": { "math": "\\backprime" }, "\u2036": { "math": "\\backdprime" }, "\u2037": { "math": "\\backtrprime" }, "\u2038": { "math": "\\caretinsert" }, "\u203C": { "math": "\\Exclam" }, "\u2040": { "math": "\\tieconcat" }, "\u2043": { "math": "\\hyphenbullet" }, "\u2044": { "math": "\\fracslash" }, "\u2047": { "math": "\\Question" }, "\u2050": { "math": "\\closure" }, "\u2057": { "math": "\\qprime" }, "\u20D2": { "math": "\\vertoverlay" }, "\u20D7": { "math": "\\vec" }, "\u20DB": { "math": "\\dddot" }, "\u20DC": { "math": "\\ddddot" }, "\u20DD": { "math": "\\enclosecircle" }, "\u20DE": { "math": "\\enclosesquare" }, "\u20DF": { "math": "\\enclosediamond" }, "\u20E1": { "math": "\\overleftrightarrow" }, "\u20E4": { "math": "\\enclosetriangle" }, "\u20E7": { "math": "\\annuity" }, "\u20E8": { "math": "\\threeunderdot" }, "\u20E9": { "math": "\\widebridgeabove" }, "\u20EC": { "math": "\\underrightharpoondown" }, "\u20ED": { "math": "\\underleftharpoondown" }, "\u20EE": { "math": "\\underleftarrow" }, "\u20EF": { "math": "\\underrightarrow" }, "\u20F0": { "math": "\\asteraccent" }, "\u210E": { "math": "\\Planckconst" }, "\u210F": { "math": "\\hslash" }, "\u2112": { "math": "\\mscrL" }, "\u211B": { "math": "\\mscrR" }, "\u2127": { "math": "\\mho" }, "\u2129": { "math": "\\turnediota" }, "\u2132": { "math": "\\Finv" }, "\u2136": { "math": "\\beth" }, "\u2137": { "math": "\\gimel" }, "\u2138": { "math": "\\daleth" }, "\u2141": { "math": "\\Game" }, "\u2142": { "math": "\\sansLturned" }, "\u2143": { "math": "\\sansLmirrored" }, "\u2144": { "math": "\\Yup" }, "\u2145": { "math": "\\CapitalDifferentialD" }, "\u214A": { "math": "\\PropertyLine" }, "\u2190\u0338": { "math": "\\nleftarrow" }, "\u2192\u0338": { "math": "\\nrightarrow" }, "\u219E": { "math": "\\twoheadleftarrow" }, "\u219F": { "math": "\\twoheaduparrow" }, "\u21A0": { "math": "\\twoheadrightarrow" }, "\u21A1": { "math": "\\twoheaddownarrow" }, "\u21A2": { "math": "\\leftarrowtail" }, "\u21A3": { "math": "\\rightarrowtail" }, "\u21A4": { "math": "\\mapsfrom" }, "\u21A5": { "math": "\\mapsup" }, "\u21A7": { "math": "\\mapsdown" }, "\u21A8": { "math": "\\updownarrowbar" }, "\u21AB": { "math": "\\looparrowleft" }, "\u21AC": { "math": "\\looparrowright" }, "\u21AD": { "math": "\\leftrightsquigarrow" }, "\u2194\u0338": { "math": "\\nleftrightarrow" }, "\u21B0": { "math": "\\Lsh" }, "\u21B1": { "math": "\\Rsh" }, "\u21B3": { "text": "\\reflectbox{\\carriagereturn}", "math": "\\Rdsh" }, "\u21B4": { "math": "\\linefeed" }, "\u21B5": { "math": "\\carriagereturn" }, "\u21B6": { "math": "\\curvearrowleft" }, "\u21B7": { "math": "\\curvearrowright" }, "\u21B8": { "math": "\\barovernorthwestarrow" }, "\u21B9": { "math": "\\barleftarrowrightarrowbar" }, "\u21BA": { "math": "\\circlearrowleft" }, "\u21BE": { "math": "\\upharpoonright" }, "\u21BF": { "math": "\\upharpoonleft" }, "\u21C1": { "math": "\\rightharpoondown" }, "\u21C2": { "math": "\\downharpoonright" }, "\u21C3": { "math": "\\downharpoonleft" }, "\u21C4": { "math": "\\rightleftarrows" }, "\u21C6": { "math": "\\leftrightarrows" }, "\u21C7": { "math": "\\leftleftarrows" }, "\u21C8": { "math": "\\upuparrows" }, "\u21C9": { "math": "\\rightrightarrows" }, "\u21CA": { "math": "\\downdownarrows" }, "\u21CB": { "math": "\\leftrightharpoons" }, "\u21D0\u0338": { "math": "\\nLeftarrow" }, "\u21D4\u0338": { "math": "\\nLeftrightarrow" }, "\u21D2\u0338": { "math": "\\nRightarrow" }, "\u21D6": { "math": "\\Nwarrow" }, "\u21D7": { "math": "\\Nearrow" }, "\u21D8": { "math": "\\Searrow" }, "\u21D9": { "math": "\\Swarrow" }, "\u21DA": { "math": "\\Lleftarrow" }, "\u21DB": { "math": "\\Rrightarrow" }, "\u21DC": { "math": "\\leftsquigarrow" }, "\u21DD": { "math": "\\rightsquigarrow" }, "\u21DE": { "math": "\\nHuparrow" }, "\u21DF": { "math": "\\nHdownarrow" }, "\u21E1": { "math": "\\updasharrow" }, "\u21E3": { "math": "\\downdasharrow" }, "\u21E6": { "math": "\\leftwhitearrow" }, "\u21E7": { "math": "\\upwhitearrow" }, "\u21E8": { "math": "\\rightwhitearrow" }, "\u21E9": { "math": "\\downwhitearrow" }, "\u21EA": { "math": "\\whitearrowupfrombar" }, "\u21F4": { "math": "\\circleonrightarrow" }, "\u21F6": { "math": "\\rightthreearrows" }, "\u21F7": { "math": "\\nvleftarrow" }, "\u21F9": { "math": "\\nvleftrightarrow" }, "\u21FA": { "math": "\\nVleftarrow" }, "\u21FC": { "math": "\\nVleftrightarrow" }, "\u21FD": { "math": "\\leftarrowtriangle" }, "\u21FE": { "math": "\\rightarrowtriangle" }, "\u21FF": { "math": "\\leftrightarrowtriangle" }, "\u2201": { "math": "\\complement" }, "\u2203\u0338": { "math": "\\nexists" }, "\u2205": { "math": "\\varnothing" }, "\u2206": { "math": "\\increment" }, "\u2207": { "math": "\\nabla" }, "\u220A": { "math": "\\smallin" }, "\u220D": { "math": "\\smallni" }, "\u220E": { "math": "\\QED" }, "\u2214": { "math": "\\dotplus" }, "\u2215": { "math": "\\divslash" }, "\u221A": { "math": "\\sqrt" }, "\u221F": { "math": "\\rightangle" }, "\u2221": { "math": "\\measuredangle" }, "\u2222": { "math": "\\sphericalangle" }, "\u2223\u0338": { "math": "\\nmid" }, "\u2225\u0338": { "math": "\\nparallel" }, "\u2232": { "math": "\\lcirclerightint" }, "\u2234": { "math": "\\therefore" }, "\u2235": { "math": "\\because" }, "\u2237": { "math": "\\Colon" }, "\u2239": { "math": "\\eqcolon" }, "\u223D": { "math": "\\backsim" }, "\u224A": { "math": "\\approxeq" }, "\u224E": { "math": "\\Bumpeq" }, "\u224F": { "math": "\\bumpeq" }, "\u2252": { "math": "\\fallingdotseq" }, "\u2253": { "math": "\\risingdotseq" }, "\u2254": { "math": "\\coloneq" }, "\u2256": { "math": "\\eqcirc" }, "\u2257": { "math": "\\circeq" }, "\u2258": { "math": "\\arceq" }, "\u225A": { "math": "\\veeeq" }, "\u225C": { "math": "\\triangleq" }, "\u225D": { "math": "\\eqdef" }, "\u225E": { "math": "\\measeq" }, "\u225F": { "math": "\\questeq" }, "\u2263": { "math": "\\Equiv" }, "\u2268": { "math": "\\lneqq" }, "\u2269": { "math": "\\gneqq" }, "\u226C": { "math": "\\between" }, "\u224D\u0338": { "math": "\\nasymp" }, "\u2272\u0338": { "math": "\\nlesssim" }, "\u2273\u0338": { "math": "\\ngtrsim" }, "\u2276": { "math": "\\lessgtr" }, "\u2277": { "math": "\\gtrless" }, "\u227C": { "math": "\\preccurlyeq" }, "\u227D": { "math": "\\succcurlyeq" }, "\u228A": { "math": "\\subsetneq" }, "\u228B": { "math": "\\supsetneq" }, "\u228C": { "math": "\\cupleftarrow" }, "\u228D": { "math": "\\cupdot" }, "\u228F": { "math": "\\sqsubset" }, "\u2290": { "math": "\\sqsupset" }, "\u229A": { "math": "\\circledcirc" }, "\u229B": { "math": "\\circledast" }, "\u229C": { "math": "\\circledequal" }, "\u229D": { "math": "\\circleddash" }, "\u229E": { "math": "\\boxplus" }, "\u229F": { "math": "\\boxminus" }, "\u22A0": { "math": "\\boxtimes" }, "\u22A1": { "math": "\\boxdot" }, "\u22A6": { "math": "\\assert" }, "\u22A9": { "math": "\\Vdash" }, "\u22AA": { "math": "\\Vvdash" }, "\u22AB": { "math": "\\VDash" }, "\u22A2\u0338": { "math": "\\nvdash" }, "\u22A8\u0338": { "math": "\\nvDash" }, "\u22A9\u0338": { "math": "\\nVdash" }, "\u22AB\u0338": { "math": "\\nVDash" }, "\u22B0": { "math": "\\prurel" }, "\u22B1": { "math": "\\scurel" }, "\u22B2": { "math": "\\vartriangleleft" }, "\u22B3": { "math": "\\vartriangleright" }, "\u22B4": { "math": "\\trianglelefteq" }, "\u22B5": { "math": "\\trianglerighteq" }, "\u22B8": { "math": "\\multimap" }, "\u22BA": { "math": "\\intercal" }, "\u22BB": { "math": "\\veebar" }, "\u22BC": { "math": "\\barwedge" }, "\u22BD": { "math": "\\barvee" }, "\u22BF": { "math": "\\varlrtriangle" }, "\u22C7": { "math": "\\divideontimes" }, "\u22C9": { "math": "\\ltimes" }, "\u22CA": { "math": "\\rtimes" }, "\u22CB": { "math": "\\leftthreetimes" }, "\u22CC": { "math": "\\rightthreetimes" }, "\u22CD": { "math": "\\backsimeq" }, "\u22CE": { "math": "\\curlyvee" }, "\u22CF": { "math": "\\curlywedge" }, "\u22D0": { "math": "\\Subset" }, "\u22D1": { "math": "\\Supset" }, "\u22D2": { "math": "\\Cap" }, "\u22D3": { "math": "\\Cup" }, "\u22D4": { "math": "\\pitchfork" }, "\u22D5": { "math": "\\hash" }, "\u22D6": { "math": "\\lessdot" }, "\u22D7": { "math": "\\gtrdot" }, "\u22DA": { "math": "\\lesseqgtr" }, "\u22DB": { "math": "\\gtreqless" }, "\u22DC": { "math": "\\eqless" }, "\u22DD": { "math": "\\eqgtr" }, "\u22DE": { "math": "\\curlyeqprec" }, "\u22DF": { "math": "\\curlyeqsucc" }, "\u227C\u0338": { "math": "\\npreceq" }, "\u227D\u0338": { "math": "\\nsucceq" }, "\u22E4": { "math": "\\sqsubsetneq" }, "\u22E5": { "math": "\\sqsupsetneq" }, "\u22E6": { "math": "\\lnsim" }, "\u22E7": { "math": "\\gnsim" }, "\u22E8": { "math": "\\precedesnotsimilar" }, "\u22E9": { "math": "\\succnsim" }, "\u22B4\u0338": { "math": "\\ntrianglelefteq" }, "\u22B5\u0338": { "math": "\\ntrianglerighteq" }, "\u22F2": { "math": "\\disin" }, "\u22F3": { "math": "\\varisins" }, "\u22F4": { "math": "\\isins" }, "\u22F5": { "math": "\\isindot" }, "\u22F7": { "math": "\\isinobar" }, "\u22F8": { "math": "\\isinvb" }, "\u22F9": { "math": "\\isinE" }, "\u22FA": { "math": "\\nisd" }, "\u22FB": { "math": "\\varnis" }, "\u22FC": { "math": "\\nis" }, "\u22FD": { "math": "\\varniobar" }, "\u22FE": { "math": "\\niobar" }, "\u22FF": { "math": "\\bagmember" }, "\u2300": { "math": "\\diameter" }, "\u2302": { "math": "\\house" }, "\u2305": { "text": "{\\barwedge}", "math": "\\varbarwedge" }, "\u2310": { "math": "\\invneg" }, "\u2312": { "math": "\\profline" }, "\u2313": { "math": "\\profsurf" }, "\u2317": { "math": "\\viewdata" }, "\u2319": { "math": "\\turnednot" }, "\u231C": { "math": "\\ulcorner" }, "\u231D": { "math": "\\urcorner" }, "\u231E": { "math": "\\llcorner" }, "\u231F": { "math": "\\lrcorner" }, "\u2320": { "math": "\\inttop" }, "\u2321": { "math": "\\intbottom" }, "\u232C": { "math": "\\varhexagonlrbonds" }, "\u2332": { "math": "\\conictaper" }, "\u2336": { "math": "\\topbot" }, "\u233D": { "math": "\\obar" }, "\u2353": { "math": "\\APLboxupcaret" }, "\u2370": { "math": "\\APLboxquestion" }, "\u237C": { "math": "\\rangledownzigzagarrow" }, "\u2394": { "math": "\\hexagon" }, "\u239B": { "math": "\\lparenuend" }, "\u239C": { "math": "\\lparenextender" }, "\u239D": { "math": "\\lparenlend" }, "\u239E": { "math": "\\rparenuend" }, "\u239F": { "math": "\\rparenextender" }, "\u23A0": { "math": "\\rparenlend" }, "\u23A1": { "math": "\\lbrackuend" }, "\u23A2": { "math": "\\lbrackextender" }, "\u23A3": { "math": "\\lbracklend" }, "\u23A4": { "math": "\\rbrackuend" }, "\u23A5": { "math": "\\rbrackextender" }, "\u23A6": { "math": "\\rbracklend" }, "\u23A7": { "math": "\\lbraceuend" }, "\u23A8": { "math": "\\lbracemid" }, "\u23A9": { "math": "\\lbracelend" }, "\u23AA": { "math": "\\vbraceextender" }, "\u23AB": { "math": "\\rbraceuend" }, "\u23AC": { "math": "\\rbracemid" }, "\u23AD": { "math": "\\rbracelend" }, "\u23AE": { "math": "\\intextender" }, "\u23AF": { "math": "\\harrowextender" }, "\u23B2": { "math": "\\sumtop" }, "\u23B3": { "math": "\\sumbottom" }, "\u23B4": { "math": "\\overbracket" }, "\u23B5": { "math": "\\underbracket" }, "\u23B6": { "math": "\\bbrktbrk" }, "\u23B7": { "math": "\\sqrtbottom" }, "\u23B8": { "math": "\\lvboxline" }, "\u23B9": { "math": "\\rvboxline" }, "\u23CE": { "math": "\\varcarriagereturn" }, "\u23DC": { "math": "\\overparen" }, "\u23DD": { "math": "\\underparen" }, "\u23DE": { "math": "\\overbrace" }, "\u23DF": { "math": "\\underbrace" }, "\u23E0": { "math": "\\obrbrak" }, "\u23E1": { "math": "\\ubrbrak" }, "\u23E2": { "math": "\\trapezium" }, "\u23E3": { "math": "\\benzenr" }, "\u23E4": { "math": "\\strns" }, "\u23E5": { "math": "\\fltns" }, "\u23E6": { "math": "\\accurrent" }, "\u23E7": { "math": "\\elinters" }, "\u2422": { "math": "\\blanksymbol" }, "\u2423": { "math": "\\mathvisiblespace" }, "\u2506": { "math": "\\bdtriplevdash" }, "\u2580": { "math": "\\blockuphalf" }, "\u2584": { "math": "\\blocklowhalf" }, "\u2588": { "math": "\\blockfull" }, "\u258C": { "math": "\\blocklefthalf" }, "\u2590": { "math": "\\blockrighthalf" }, "\u2591": { "math": "\\blockqtrshaded" }, "\u2592": { "math": "\\blockhalfshaded" }, "\u2593": { "math": "\\blockthreeqtrshaded" }, "\u25A0": { "math": "\\mdlgblksquare" }, "\u25A2": { "math": "\\squoval" }, "\u25A3": { "math": "\\blackinwhitesquare" }, "\u25A4": { "math": "\\squarehfill" }, "\u25A5": { "math": "\\squarevfill" }, "\u25A6": { "math": "\\squarehvfill" }, "\u25A7": { "math": "\\squarenwsefill" }, "\u25A8": { "math": "\\squareneswfill" }, "\u25A9": { "math": "\\squarecrossfill" }, "\u25AA": { "math": "\\smblksquare" }, "\u25AB": { "math": "\\smwhtsquare" }, "\u25AC": { "math": "\\hrectangleblack" }, "\u25AD": { "math": "\\hrectangle" }, "\u25AE": { "math": "\\vrectangleblack" }, "\u25AF": { "math": "\\vrectangle" }, "\u25B0": { "math": "\\parallelogramblack" }, "\u25B1": { "math": "\\parallelogram" }, "\u25B2": { "math": "\\bigblacktriangleup" }, "\u25B3": { "math": "\\bigtriangleup" }, "\u25B4": { "math": "\\blacktriangle" }, "\u25B5": { "math": "\\vartriangle" }, "\u25B8": { "math": "\\smallblacktriangleright" }, "\u25B9": { "math": "\\smalltriangleright" }, "\u25BA": { "math": "\\blackpointerright" }, "\u25BB": { "math": "\\whitepointerright" }, "\u25BC": { "math": "\\bigblacktriangledown" }, "\u25BE": { "math": "\\blacktriangledown" }, "\u25BF": { "math": "\\triangledown" }, "\u25C2": { "math": "\\smallblacktriangleleft" }, "\u25C3": { "math": "\\smalltriangleleft" }, "\u25C4": { "math": "\\blackpointerleft" }, "\u25C5": { "math": "\\whitepointerleft" }, "\u25C8": { "math": "\\blackinwhitediamond" }, "\u25C9": { "math": "\\fisheye" }, "\u25CA": { "math": "\\lozenge" }, "\u25CC": { "math": "\\dottedcircle" }, "\u25CD": { "math": "\\circlevertfill" }, "\u25CE": { "math": "\\bullseye" }, "\u25D0": { "math": "\\circlelefthalfblack" }, "\u25D1": { "math": "\\circlerighthalfblack" }, "\u25D2": { "math": "\\circlebottomhalfblack" }, "\u25D3": { "math": "\\circletophalfblack" }, "\u25D4": { "math": "\\circleurquadblack" }, "\u25D5": { "math": "\\blackcircleulquadwhite" }, "\u25D6": { "math": "\\blacklefthalfcircle" }, "\u25D7": { "math": "\\blackrighthalfcircle" }, "\u25D8": { "math": "\\inversebullet" }, "\u25D9": { "math": "\\inversewhitecircle" }, "\u25DA": { "math": "\\invwhiteupperhalfcircle" }, "\u25DB": { "math": "\\invwhitelowerhalfcircle" }, "\u25DC": { "math": "\\ularc" }, "\u25DD": { "math": "\\urarc" }, "\u25DE": { "math": "\\lrarc" }, "\u25DF": { "math": "\\llarc" }, "\u25E0": { "math": "\\topsemicircle" }, "\u25E1": { "math": "\\botsemicircle" }, "\u25E2": { "math": "\\lrblacktriangle" }, "\u25E3": { "math": "\\llblacktriangle" }, "\u25E4": { "math": "\\ulblacktriangle" }, "\u25E5": { "math": "\\urblacktriangle" }, "\u25E6": { "math": "\\smwhtcircle" }, "\u25E7": { "math": "\\squareleftblack" }, "\u25E8": { "math": "\\squarerightblack" }, "\u25E9": { "math": "\\squareulblack" }, "\u25EA": { "math": "\\squarelrblack" }, "\u25EB": { "math": "\\boxbar" }, "\u25EC": { "math": "\\trianglecdot" }, "\u25ED": { "math": "\\triangleleftblack" }, "\u25EE": { "math": "\\trianglerightblack" }, "\u25F0": { "math": "\\squareulquad" }, "\u25F1": { "math": "\\squarellquad" }, "\u25F2": { "math": "\\squarelrquad" }, "\u25F3": { "math": "\\squareurquad" }, "\u25F4": { "math": "\\circleulquad" }, "\u25F5": { "math": "\\circlellquad" }, "\u25F6": { "math": "\\circlelrquad" }, "\u25F7": { "math": "\\circleurquad" }, "\u25F8": { "math": "\\ultriangle" }, "\u25F9": { "math": "\\urtriangle" }, "\u25FA": { "math": "\\lltriangle" }, "\u25FB": { "math": "\\mdwhtsquare" }, "\u25FC": { "math": "\\mdblksquare" }, "\u25FD": { "math": "\\mdsmwhtsquare" }, "\u25FE": { "math": "\\mdsmblksquare" }, "\u25FF": { "math": "\\lrtriangle" }, "\u2605": { "math": "\\bigstar" }, "\u2606": { "math": "\\bigwhitestar" }, "\u2621": { "math": "\\danger" }, "\u263B": { "math": "\\blacksmiley" }, "\u263C": { "math": "\\sun" }, "\u263D": { "math": "\\rightmoon" }, "\u263E": { "math": "\\leftmoon" }, "\u2640": { "math": "\\female" }, "\u2642": { "math": "\\male" }, "\u2664": { "math": "\\varspadesuit" }, "\u2665": { "math": "\\varheartsuit" }, "\u2666": { "math": "\\vardiamondsuit" }, "\u2667": { "math": "\\varclubsuit" }, "\u2669": { "math": "\\quarternote" }, "\u266A": { "math": "\\eighthnote" }, "\u266B": { "math": "\\twonotes" }, "\u266C": { "math": "\\sixteenthnote" }, "\u267E": { "math": "\\acidfree" }, "\u2680": { "math": "\\dicei" }, "\u2681": { "math": "\\diceii" }, "\u2682": { "math": "\\diceiii" }, "\u2683": { "math": "\\diceiv" }, "\u2684": { "math": "\\dicev" }, "\u2685": { "math": "\\dicevi" }, "\u2686": { "math": "\\circledrightdot" }, "\u2687": { "math": "\\circledtwodots" }, "\u2688": { "math": "\\blackcircledrightdot" }, "\u2689": { "math": "\\blackcircledtwodots" }, "\u26A5": { "math": "\\Hermaphrodite" }, "\u26AC": { "math": "\\mdsmwhtcircle" }, "\u26B2": { "math": "\\neuter" }, "\u2713": { "math": "\\checkmark" }, "\u2720": { "math": "\\maltese" }, "\u272A": { "math": "\\circledstar" }, "\u2736": { "math": "\\varstar" }, "\u273D": { "math": "\\dingasterisk" }, "\u2772": { "math": "\\lbrbrak" }, "\u2773": { "math": "\\rbrbrak" }, "\u279B": { "math": "\\draftingarrow" }, "\u27C0": { "math": "\\threedangle" }, "\u27C1": { "math": "\\whiteinwhitetriangle" }, "\u27C3": { "math": "\\subsetcirc" }, "\u27C4": { "math": "\\supsetcirc" }, "\u27C7": { "math": "\\veedot" }, "\u27C8": { "math": "\\bsolhsub" }, "\u27C9": { "math": "\\suphsol" }, "\u27CB": { "math": "\\diagup" }, "\u27CC": { "math": "\\longdivision" }, "\u27CD": { "math": "\\diagdown" }, "\u27D1": { "math": "\\wedgedot" }, "\u27D2": { "math": "\\upin" }, "\u27D3": { "math": "\\pullback" }, "\u27D4": { "math": "\\pushout" }, "\u27D5": { "math": "\\leftouterjoin" }, "\u27D6": { "math": "\\rightouterjoin" }, "\u27D7": { "math": "\\fullouterjoin" }, "\u27D8": { "math": "\\bigbot" }, "\u27D9": { "math": "\\bigtop" }, "\u27DA": { "math": "\\DashVDash" }, "\u27DB": { "math": "\\dashVdash" }, "\u27DC": { "math": "\\multimapinv" }, "\u27DD": { "math": "\\vlongdash" }, "\u27DE": { "math": "\\longdashv" }, "\u27DF": { "math": "\\cirbot" }, "\u27E0": { "math": "\\lozengeminus" }, "\u27E1": { "math": "\\concavediamond" }, "\u27E2": { "math": "\\concavediamondtickleft" }, "\u27E3": { "math": "\\concavediamondtickright" }, "\u27E4": { "math": "\\whitesquaretickleft" }, "\u27E5": { "math": "\\whitesquaretickright" }, "\u27EB": { "math": "\\rang" }, "\u27EC": { "math": "\\Lbrbrak" }, "\u27ED": { "math": "\\Rbrbrak" }, "\u27F0": { "math": "\\UUparrow" }, "\u27F1": { "math": "\\DDownarrow" }, "\u27F2": { "math": "\\acwgapcirclearrow" }, "\u27F3": { "math": "\\cwgapcirclearrow" }, "\u27F4": { "math": "\\rightarrowonoplus" }, "\u27FB": { "math": "\\longmapsfrom" }, "\u27FD": { "math": "\\Longmapsfrom" }, "\u27FE": { "math": "\\Longmapsto" }, "\u27FF": { "math": "\\longrightsquigarrow" }, "\u2901": { "math": "\\nVtwoheadrightarrow" }, "\u2902": { "math": "\\nvLeftarrow" }, "\u2903": { "math": "\\nvRightarrow" }, "\u2904": { "math": "\\nvLeftrightarrow" }, "\u2905": { "math": "\\twoheadmapsto" }, "\u2906": { "math": "\\Mapsfrom" }, "\u2907": { "math": "\\Mapsto" }, "\u2908": { "math": "\\downarrowbarred" }, "\u2909": { "math": "\\uparrowbarred" }, "\u290A": { "math": "\\Uuparrow" }, "\u290B": { "math": "\\Ddownarrow" }, "\u290C": { "math": "\\leftbkarrow" }, "\u290D": { "math": "\\rightbkarrow" }, "\u290E": { "math": "\\leftdbkarrow" }, "\u290F": { "math": "\\dbkarrow" }, "\u2910": { "math": "\\drbkarrow" }, "\u2911": { "math": "\\rightdotarrow" }, "\u2917": { "math": "\\nvtwoheadrightarrowtail" }, "\u2918": { "math": "\\nVtwoheadrightarrowtail" }, "\u2919": { "math": "\\lefttail" }, "\u291A": { "math": "\\righttail" }, "\u291B": { "math": "\\leftdbltail" }, "\u291C": { "math": "\\rightdbltail" }, "\u291D": { "math": "\\diamondleftarrow" }, "\u291E": { "math": "\\rightarrowdiamond" }, "\u291F": { "math": "\\diamondleftarrowbar" }, "\u2920": { "math": "\\barrightarrowdiamond" }, "\u2921": { "math": "\\nwsearrow" }, "\u2922": { "math": "\\neswarrow" }, "\u2923": { "math": "\\hknwarrow" }, "\u2924": { "math": "\\hknearrow" }, "\u2925": { "math": "\\hksearrow" }, "\u2926": { "math": "\\hkswarrow" }, "\u2927": { "math": "\\tona" }, "\u2928": { "math": "\\toea" }, "\u2929": { "math": "\\tosa" }, "\u292A": { "math": "\\towa" }, "\u292B": { "math": "\\rdiagovfdiag" }, "\u292C": { "math": "\\fdiagovrdiag" }, "\u292D": { "math": "\\seovnearrow" }, "\u292E": { "math": "\\neovsearrow" }, "\u292F": { "math": "\\fdiagovnearrow" }, "\u2930": { "math": "\\rdiagovsearrow" }, "\u2931": { "math": "\\neovnwarrow" }, "\u2932": { "math": "\\nwovnearrow" }, "\u2933": { "math": "\\rightcurvedarrow" }, "\u2934": { "math": "\\uprightcurvearrow" }, "\u2935": { "math": "\\downrightcurvedarrow" }, "\u2936": { "math": "\\leftdowncurvedarrow" }, "\u2937": { "math": "\\rightdowncurvedarrow" }, "\u2938": { "math": "\\cwrightarcarrow" }, "\u2939": { "math": "\\acwleftarcarrow" }, "\u293A": { "math": "\\acwoverarcarrow" }, "\u293B": { "math": "\\acwunderarcarrow" }, "\u293C": { "math": "\\curvearrowrightminus" }, "\u293D": { "math": "\\curvearrowleftplus" }, "\u293E": { "math": "\\cwundercurvearrow" }, "\u293F": { "math": "\\ccwundercurvearrow" }, "\u2942": { "math": "\\rightarrowshortleftarrow" }, "\u2943": { "math": "\\leftarrowshortrightarrow" }, "\u2944": { "math": "\\shortrightarrowleftarrow" }, "\u2945": { "math": "\\rightarrowplus" }, "\u2946": { "math": "\\leftarrowplus" }, "\u2947": { "math": "\\rightarrowx" }, "\u2948": { "math": "\\leftrightarrowcircle" }, "\u2949": { "math": "\\twoheaduparrowcircle" }, "\u294C": { "math": "\\updownharpoonrightleft" }, "\u294D": { "math": "\\updownharpoonleftright" }, "\u294E": { "math": "\\leftrightharpoonupup" }, "\u2950": { "math": "\\DownLeftRightVector" }, "\u2966": { "math": "\\leftrightharpoonsup" }, "\u2967": { "math": "\\leftrightharpoonsdown" }, "\u2968": { "math": "\\rightleftharpoonsup" }, "\u2969": { "math": "\\rightleftharpoonsdown" }, "\u2971": { "math": "\\equalrightarrow" }, "\u2972": { "math": "\\similarrightarrow" }, "\u2973": { "math": "\\leftarrowsimilar" }, "\u2974": { "math": "\\rightarrowsimilar" }, "\u2975": { "math": "\\rightarrowapprox" }, "\u2976": { "math": "\\ltlarr" }, "\u2977": { "math": "\\leftarrowless" }, "\u2978": { "math": "\\gtrarr" }, "\u2979": { "math": "\\subrarr" }, "\u297A": { "math": "\\leftarrowsubset" }, "\u297B": { "math": "\\suplarr" }, "\u297C": { "math": "\\leftfishtail" }, "\u297D": { "math": "\\rightfishtail" }, "\u297E": { "math": "\\upfishtail" }, "\u297F": { "math": "\\downfishtail" }, "\u2980": { "math": "\\Vvert" }, "\u2981": { "math": "\\spot" }, "\u2982": { "math": "\\typecolon" }, "\u2983": { "math": "\\lBrace" }, "\u2984": { "math": "\\rBrace" }, "\u2985": { "math": "\\lParen" }, "\u2986": { "math": "\\Elroang" }, "\u2987": { "math": "\\limg" }, "\u298B": { "math": "\\lbrackubar" }, "\u298C": { "math": "\\rbrackubar" }, "\u298D": { "math": "\\lbrackultick" }, "\u298E": { "math": "\\rbracklrtick" }, "\u298F": { "math": "\\lbracklltick" }, "\u2990": { "math": "\\rbrackurtick" }, "\u2991": { "math": "\\langledot" }, "\u2992": { "math": "\\rangledot" }, "\u2993": { "math": "\\lparenless" }, "\u2994": { "math": "\\rparengtr" }, "\u2995": { "math": "\\Lparengtr" }, "\u2996": { "math": "\\Rparenless" }, "\u2997": { "math": "\\lblkbrbrak" }, "\u2998": { "math": "\\rblkbrbrak" }, "\u2999": { "math": "\\fourvdots" }, "\u299A": { "math": "\\vzigzag" }, "\u299B": { "math": "\\measuredangleleft" }, "\u299D": { "math": "\\rightanglemdot" }, "\u299E": { "math": "\\angles" }, "\u299F": { "math": "\\angdnr" }, "\u29A0": { "math": "\\gtlpar" }, "\u29A1": { "math": "\\sphericalangleup" }, "\u29A2": { "math": "\\turnangle" }, "\u29A3": { "math": "\\revangle" }, "\u29A4": { "math": "\\angleubar" }, "\u29A5": { "math": "\\revangleubar" }, "\u29A6": { "math": "\\wideangledown" }, "\u29A7": { "math": "\\wideangleup" }, "\u29A8": { "math": "\\measanglerutone" }, "\u29A9": { "math": "\\measanglelutonw" }, "\u29AA": { "math": "\\measanglerdtose" }, "\u29AB": { "math": "\\measangleldtosw" }, "\u29AC": { "math": "\\measangleurtone" }, "\u29AD": { "math": "\\measangleultonw" }, "\u29AE": { "math": "\\measangledrtose" }, "\u29AF": { "math": "\\measangledltosw" }, "\u29B0": { "math": "\\revemptyset" }, "\u29B1": { "math": "\\emptysetobar" }, "\u29B2": { "math": "\\emptysetocirc" }, "\u29B3": { "math": "\\emptysetoarr" }, "\u29B4": { "math": "\\emptysetoarrl" }, "\u29B5": { "math": "\\circlehbar" }, "\u29B6": { "math": "\\circledvert" }, "\u29B7": { "math": "\\circledparallel" }, "\u29B8": { "math": "\\circledbslash" }, "\u29B9": { "math": "\\operp" }, "\u29BA": { "math": "\\obot" }, "\u29BB": { "math": "\\olcross" }, "\u29BC": { "math": "\\odotslashdot" }, "\u29BD": { "math": "\\uparrowoncircle" }, "\u29BE": { "math": "\\circledwhitebullet" }, "\u29BF": { "math": "\\circledbullet" }, "\u29C0": { "math": "\\circledless" }, "\u29C1": { "math": "\\circledgtr" }, "\u29C2": { "math": "\\cirscir" }, "\u29C3": { "math": "\\cirE" }, "\u29C5": { "math": "\\boxbslash" }, "\u29C6": { "math": "\\boxast" }, "\u29C7": { "math": "\\boxcircle" }, "\u29C8": { "math": "\\boxbox" }, "\u29C9": { "math": "\\boxonbox" }, "\u29CA": { "math": "\\triangleodot" }, "\u29CB": { "math": "\\triangleubar" }, "\u29CC": { "math": "\\triangles" }, "\u29CD": { "math": "\\triangleserifs" }, "\u29CE": { "math": "\\rtriltri" }, "\u29D1": { "math": "\\lfbowtie" }, "\u29D2": { "math": "\\rfbowtie" }, "\u29D3": { "math": "\\fbowtie" }, "\u29D4": { "math": "\\lftimes" }, "\u29D5": { "math": "\\rftimes" }, "\u29D6": { "math": "\\hourglass" }, "\u29D7": { "math": "\\blackhourglass" }, "\u29D8": { "math": "\\lvzigzag" }, "\u29D9": { "math": "\\rvzigzag" }, "\u29DA": { "math": "\\Lvzigzag" }, "\u29DB": { "math": "\\Rvzigzag" }, "\u29DC": { "math": "\\iinfin" }, "\u29DD": { "math": "\\tieinfty" }, "\u29DE": { "math": "\\nvinfty" }, "\u29E0": { "math": "\\laplac" }, "\u29E1": { "math": "\\lrtriangleeq" }, "\u29E2": { "math": "\\shuffle" }, "\u29E3": { "math": "\\eparsl" }, "\u29E4": { "math": "\\smeparsl" }, "\u29E5": { "math": "\\eqvparsl" }, "\u29E6": { "math": "\\gleichstark" }, "\u29E7": { "math": "\\thermod" }, "\u29E8": { "math": "\\downtriangleleftblack" }, "\u29E9": { "math": "\\downtrianglerightblack" }, "\u29EA": { "math": "\\blackdiamonddownarrow" }, "\u29EB": { "math": "\\blacklozenge" }, "\u29EC": { "math": "\\circledownarrow" }, "\u29ED": { "math": "\\blackcircledownarrow" }, "\u29EE": { "math": "\\errbarsquare" }, "\u29EF": { "math": "\\errbarblacksquare" }, "\u29F0": { "math": "\\errbardiamond" }, "\u29F1": { "math": "\\errbarblackdiamond" }, "\u29F2": { "math": "\\errbarcircle" }, "\u29F3": { "math": "\\errbarblackcircle" }, "\u29F4": { "math": "\\RuleDelayed" }, "\u29F6": { "math": "\\dsol" }, "\u29F7": { "math": "\\rsolbar" }, "\u29F8": { "math": "\\xsol" }, "\u29FA": { "math": "\\doubleplus" }, "\u29FB": { "math": "\\tripleplus" }, "\u29FC": { "math": "\\lcurvyangle" }, "\u29FD": { "math": "\\rcurvyangle" }, "\u29FE": { "math": "\\tplus" }, "\u29FF": { "math": "\\tminus" }, "\u2A03": { "math": "\\bigcupdot" }, "\u2A04": { "math": "\\Elxuplus" }, "\u2A05": { "math": "\\bigsqcap" }, "\u2A07": { "math": "\\conjquant" }, "\u2A08": { "math": "\\disjquant" }, "\u2A0A": { "math": "\\modtwosum" }, "\u2A0B": { "math": "\\sumint" }, "\u2A0C": { "math": "\\iiiint" }, "\u2A0D": { "math": "\\intbar" }, "\u2A0E": { "math": "\\intBar" }, "\u2A10": { "math": "\\cirfnint" }, "\u2A11": { "math": "\\awint" }, "\u2A12": { "math": "\\rppolint" }, "\u2A13": { "math": "\\scpolint" }, "\u2A14": { "math": "\\npolint" }, "\u2A15": { "math": "\\pointint" }, "\u2A17": { "math": "\\intlarhk" }, "\u2A18": { "math": "\\intx" }, "\u2A19": { "math": "\\intcap" }, "\u2A1A": { "math": "\\intcup" }, "\u2A1B": { "math": "\\upint" }, "\u2A1C": { "math": "\\lowint" }, "\u2A1D": { "math": "\\Join" }, "\u2A1E": { "math": "\\bigtriangleleft" }, "\u2A1F": { "math": "\\zcmp" }, "\u2A20": { "math": "\\zpipe" }, "\u2A21": { "math": "\\zproject" }, "\u2A22": { "math": "\\ringplus" }, "\u2A23": { "math": "\\plushat" }, "\u2A24": { "math": "\\simplus" }, "\u2A25": { "math": "\\plusdot" }, "\u2A26": { "math": "\\plussim" }, "\u2A27": { "math": "\\plussubtwo" }, "\u2A28": { "math": "\\plustrif" }, "\u2A29": { "math": "\\commaminus" }, "\u2A2A": { "math": "\\minusdot" }, "\u2A2B": { "math": "\\minusfdots" }, "\u2A2C": { "math": "\\minusrdots" }, "\u2A2D": { "math": "\\opluslhrim" }, "\u2A2E": { "math": "\\oplusrhrim" }, "\u2A2F": { "math": "\\vectimes" }, "\u2A30": { "math": "\\dottimes" }, "\u2A31": { "math": "\\timesbar" }, "\u2A32": { "math": "\\btimes" }, "\u2A33": { "math": "\\smashtimes" }, "\u2A34": { "math": "\\otimeslhrim" }, "\u2A35": { "math": "\\otimesrhrim" }, "\u2A36": { "math": "\\otimeshat" }, "\u2A37": { "math": "\\Otimes" }, "\u2A38": { "math": "\\odiv" }, "\u2A39": { "math": "\\triangleplus" }, "\u2A3A": { "math": "\\triangleminus" }, "\u2A3B": { "math": "\\triangletimes" }, "\u2A3C": { "math": "\\intprod" }, "\u2A3D": { "math": "\\intprodr" }, "\u2A3E": { "math": "\\fcmp" }, "\u2A40": { "math": "\\capdot" }, "\u2A41": { "math": "\\uminus" }, "\u2A42": { "math": "\\barcup" }, "\u2A43": { "math": "\\barcap" }, "\u2A44": { "math": "\\capwedge" }, "\u2A45": { "math": "\\cupvee" }, "\u2A46": { "math": "\\cupovercap" }, "\u2A47": { "math": "\\capovercup" }, "\u2A48": { "math": "\\cupbarcap" }, "\u2A49": { "math": "\\capbarcup" }, "\u2A4A": { "math": "\\twocups" }, "\u2A4B": { "math": "\\twocaps" }, "\u2A4C": { "math": "\\closedvarcup" }, "\u2A4D": { "math": "\\closedvarcap" }, "\u2A4E": { "math": "\\Sqcap" }, "\u2A4F": { "math": "\\Sqcup" }, "\u2A50": { "math": "\\closedvarcupsmashprod" }, "\u2A51": { "math": "\\wedgeodot" }, "\u2A52": { "math": "\\veeodot" }, "\u2A53": { "math": "\\Wedge" }, "\u2A54": { "math": "\\Vee" }, "\u2A55": { "math": "\\wedgeonwedge" }, "\u2A57": { "math": "\\bigslopedvee" }, "\u2A58": { "math": "\\bigslopedwedge" }, "\u2A59": { "math": "\\veeonwedge" }, "\u2A5A": { "math": "\\wedgemidvert" }, "\u2A5B": { "math": "\\veemidvert" }, "\u2A5C": { "math": "\\midbarwedge" }, "\u2A5D": { "math": "\\midbarvee" }, "\u2A5F": { "math": "\\wedgebar" }, "\u2A60": { "math": "\\wedgedoublebar" }, "\u2A61": { "math": "\\varveebar" }, "\u2A62": { "math": "\\doublebarvee" }, "\u2A63": { "math": "\\veedoublebar" }, "\u2A64": { "math": "\\dsub" }, "\u2A65": { "math": "\\rsub" }, "\u2A66": { "math": "\\eqdot" }, "\u2A67": { "math": "\\dotequiv" }, "\u2A68": { "math": "\\equivVert" }, "\u2A69": { "math": "\\equivVvert" }, "\u2A6A": { "math": "\\dotsim" }, "\u2A6B": { "math": "\\simrdots" }, "\u2A6C": { "math": "\\simminussim" }, "\u2A6D": { "math": "\\congdot" }, "\u2A6F": { "math": "\\hatapprox" }, "\u2A70": { "math": "\\approxeqq" }, "\u2A71": { "math": "\\eqqplus" }, "\u2A72": { "math": "\\pluseqq" }, "\u2A73": { "math": "\\eqqsim" }, "\u2A74": { "math": "\\Coloneqq" }, "\u2A77": { "math": "\\ddotseq" }, "\u2A78": { "math": "\\equivDD" }, "\u2A79": { "math": "\\ltcir" }, "\u2A7A": { "math": "\\gtcir" }, "\u2A7B": { "math": "\\ltquest" }, "\u2A7C": { "math": "\\gtquest" }, "\u2A7D": { "math": "\\leqslant" }, "\u2A7E": { "math": "\\geqslant" }, "\u2A7F": { "math": "\\lesdot" }, "\u2A80": { "math": "\\gesdot" }, "\u2A81": { "math": "\\lesdoto" }, "\u2A82": { "math": "\\gesdoto" }, "\u2A83": { "math": "\\lesdotor" }, "\u2A84": { "math": "\\gesdotol" }, "\u2A85": { "math": "\\lessapprox" }, "\u2A86": { "math": "\\gtrapprox" }, "\u2A87": { "math": "\\lneq" }, "\u2A88": { "math": "\\gneq" }, "\u2A89": { "math": "\\lnapprox" }, "\u2A8A": { "math": "\\gnapprox" }, "\u2A8B": { "math": "\\lesseqqgtr" }, "\u2A8C": { "math": "\\gtreqqless" }, "\u2A8D": { "math": "\\lsime" }, "\u2A8E": { "math": "\\gsime" }, "\u2A8F": { "math": "\\lsimg" }, "\u2A90": { "math": "\\gsiml" }, "\u2A91": { "math": "\\lgE" }, "\u2A92": { "math": "\\glE" }, "\u2A93": { "math": "\\lesges" }, "\u2A94": { "math": "\\gesles" }, "\u2A95": { "math": "\\eqslantless" }, "\u2A96": { "math": "\\eqslantgtr" }, "\u2A97": { "math": "\\elsdot" }, "\u2A98": { "math": "\\egsdot" }, "\u2A99": { "math": "\\eqqless" }, "\u2A9A": { "math": "\\eqqgtr" }, "\u2A9B": { "math": "\\eqqslantless" }, "\u2A9C": { "math": "\\eqqslantgtr" }, "\u2A9D": { "math": "\\simless" }, "\u2A9E": { "math": "\\simgtr" }, "\u2A9F": { "math": "\\simlE" }, "\u2AA0": { "math": "\\simgE" }, "\u2AA3": { "math": "\\partialmeetcontraction" }, "\u2AA4": { "math": "\\glj" }, "\u2AA5": { "math": "\\gla" }, "\u2AA8": { "math": "\\lescc" }, "\u2AA9": { "math": "\\gescc" }, "\u2AAA": { "math": "\\smt" }, "\u2AAB": { "math": "\\lat" }, "\u2AAC": { "math": "\\smte" }, "\u2AAD": { "math": "\\late" }, "\u2AAE": { "math": "\\bumpeqq" }, "\u2AB1": { "math": "\\precneq" }, "\u2AB2": { "math": "\\succneq" }, "\u2AB3": { "math": "\\preceqq" }, "\u2AB4": { "math": "\\succeqq" }, "\u2AB5": { "math": "\\precneqq" }, "\u2AB6": { "math": "\\succneqq" }, "\u2AB7": { "math": "\\precapprox" }, "\u2AB8": { "math": "\\succapprox" }, "\u2AB9": { "math": "\\precnapprox" }, "\u2ABA": { "math": "\\succnapprox" }, "\u2ABD": { "math": "\\subsetdot" }, "\u2ABE": { "math": "\\supsetdot" }, "\u2ABF": { "math": "\\subsetplus" }, "\u2AC0": { "math": "\\supsetplus" }, "\u2AC1": { "math": "\\submult" }, "\u2AC2": { "math": "\\supmult" }, "\u2AC3": { "math": "\\subedot" }, "\u2AC4": { "math": "\\supedot" }, "\u2AC5": { "math": "\\subseteqq" }, "\u2AC6": { "math": "\\supseteqq" }, "\u2AC7": { "math": "\\subsim" }, "\u2AC8": { "math": "\\supsim" }, "\u2AC9": { "math": "\\subsetapprox" }, "\u2ACA": { "math": "\\supsetapprox" }, "\u2ACB": { "math": "\\subsetneqq" }, "\u2ACC": { "math": "\\supsetneqq" }, "\u2ACD": { "math": "\\lsqhook" }, "\u2ACE": { "math": "\\rsqhook" }, "\u2ACF": { "math": "\\csub" }, "\u2AD0": { "math": "\\csup" }, "\u2AD1": { "math": "\\csube" }, "\u2AD2": { "math": "\\csupe" }, "\u2AD3": { "math": "\\subsup" }, "\u2AD4": { "math": "\\supsub" }, "\u2AD5": { "math": "\\subsub" }, "\u2AD6": { "math": "\\supsup" }, "\u2AD7": { "math": "\\suphsub" }, "\u2AD8": { "math": "\\supdsub" }, "\u2AD9": { "math": "\\forkv" }, "\u2ADA": { "math": "\\topfork" }, "\u2ADB": { "math": "\\mlcp" }, "\u2ADD\u0338": { "math": "\\forks" }, "\u2ADD": { "math": "\\forksnot" }, "\u2ADE": { "math": "\\shortlefttack" }, "\u2ADF": { "math": "\\shortdowntack" }, "\u2AE0": { "math": "\\shortuptack" }, "\u2AE1": { "math": "\\perps" }, "\u2AE2": { "math": "\\vDdash" }, "\u2AE3": { "math": "\\dashV" }, "\u2AE4": { "math": "\\Dashv" }, "\u2AE5": { "math": "\\DashV" }, "\u2AE6": { "math": "\\varVdash" }, "\u2AE7": { "math": "\\Barv" }, "\u2AE8": { "math": "\\vBar" }, "\u2AE9": { "math": "\\vBarv" }, "\u2AEB": { "math": "\\Vbar" }, "\u2AEC": { "math": "\\Not" }, "\u2AED": { "math": "\\bNot" }, "\u2AEE": { "math": "\\revnmid" }, "\u2AEF": { "math": "\\cirmid" }, "\u2AF0": { "math": "\\midcir" }, "\u2AF1": { "math": "\\topcir" }, "\u2AF2": { "math": "\\nhpar" }, "\u2AF3": { "math": "\\parsim" }, "\u2AF4": { "math": "\\interleave" }, "\u2AF5": { "math": "\\nhVvert" }, "\u2AF6": { "math": "\\threedotcolon" }, "\u2AF7": { "math": "\\lllnest" }, "\u2AF8": { "math": "\\gggnest" }, "\u2AF9": { "math": "\\leqqslant" }, "\u2AFA": { "math": "\\geqqslant" }, "\u2AFB": { "math": "\\trslash" }, "\u2AFC": { "math": "\\biginterleave" }, "\u2AFE": { "math": "\\talloblong" }, "\u2AFF": { "math": "\\bigtalloblong" }, "\u2B12": { "math": "\\squaretopblack" }, "\u2B13": { "math": "\\squarebotblack" }, "\u2B14": { "math": "\\squareurblack" }, "\u2B15": { "math": "\\squarellblack" }, "\u2B16": { "math": "\\diamondleftblack" }, "\u2B17": { "math": "\\diamondrightblack" }, "\u2B18": { "math": "\\diamondtopblack" }, "\u2B19": { "math": "\\diamondbotblack" }, "\u2B1A": { "math": "\\dottedsquare" }, "\u2B1B": { "math": "\\lgblksquare" }, "\u2B1C": { "math": "\\lgwhtsquare" }, "\u2B1D": { "math": "\\vysmblksquare" }, "\u2B1E": { "math": "\\vysmwhtsquare" }, "\u2B1F": { "math": "\\pentagonblack" }, "\u2B20": { "math": "\\pentagon" }, "\u2B21": { "math": "\\varhexagon" }, "\u2B22": { "math": "\\varhexagonblack" }, "\u2B23": { "math": "\\hexagonblack" }, "\u2B24": { "math": "\\lgblkcircle" }, "\u2B25": { "math": "\\mdblkdiamond" }, "\u2B26": { "math": "\\mdwhtdiamond" }, "\u2B27": { "math": "\\mdblklozenge" }, "\u2B28": { "math": "\\mdwhtlozenge" }, "\u2B29": { "math": "\\smblkdiamond" }, "\u2B2A": { "math": "\\smblklozenge" }, "\u2B2B": { "math": "\\smwhtlozenge" }, "\u2B2C": { "math": "\\blkhorzoval" }, "\u2B2D": { "math": "\\whthorzoval" }, "\u2B2E": { "math": "\\blkvertoval" }, "\u2B2F": { "math": "\\whtvertoval" }, "\u2B30": { "math": "\\circleonleftarrow" }, "\u2B31": { "math": "\\leftthreearrows" }, "\u2B32": { "math": "\\leftarrowonoplus" }, "\u2B33": { "math": "\\longleftsquigarrow" }, "\u2B34": { "math": "\\nvtwoheadleftarrow" }, "\u2B35": { "math": "\\nVtwoheadleftarrow" }, "\u2B36": { "math": "\\twoheadmapsfrom" }, "\u2B37": { "math": "\\twoheadleftdbkarrow" }, "\u2B38": { "math": "\\leftdotarrow" }, "\u2B39": { "math": "\\nvleftarrowtail" }, "\u2B3A": { "math": "\\nVleftarrowtail" }, "\u2B3B": { "math": "\\twoheadleftarrowtail" }, "\u2B3C": { "math": "\\nvtwoheadleftarrowtail" }, "\u2B3D": { "math": "\\nVtwoheadleftarrowtail" }, "\u2B3E": { "math": "\\leftarrowx" }, "\u2B3F": { "math": "\\leftcurvedarrow" }, "\u2B40": { "math": "\\equalleftarrow" }, "\u2B41": { "math": "\\bsimilarleftarrow" }, "\u2B42": { "math": "\\leftarrowbackapprox" }, "\u2B43": { "math": "\\rightarrowgtr" }, "\u2B44": { "math": "\\rightarrowsupset" }, "\u2B45": { "math": "\\LLeftarrow" }, "\u2B46": { "math": "\\RRightarrow" }, "\u2B47": { "math": "\\bsimilarrightarrow" }, "\u2B48": { "math": "\\rightarrowbackapprox" }, "\u2B49": { "math": "\\similarleftarrow" }, "\u2B4A": { "math": "\\leftarrowapprox" }, "\u2B4B": { "math": "\\leftarrowbsimilar" }, "\u2B4C": { "math": "\\rightarrowbsimilar" }, "\u2B50": { "math": "\\medwhitestar" }, "\u2B51": { "math": "\\medblackstar" }, "\u2B52": { "math": "\\smwhitestar" }, "\u2B53": { "math": "\\rightpentagonblack" }, "\u2B54": { "math": "\\rightpentagon" }, "\u3012": { "math": "\\postalmark" }, "\u3030": { "math": "\\hzigzag" } }, "amssymb": { "\xF0": { "math": "\\eth" }, "\u2A7D": { "math": "\\leqslant" }, "\u2A7D\u0338": { "math": "\\nleqslant" }, "\u2A7E": { "math": "\\geqslant" }, "\u2A7E\u0338": { "math": "\\ngeqslant" } }, "arevmath": { "\xF0": { "math": "\\eth" } }, "MinionPro": { "\u03D0": { "math": "\\varbeta" }, "\u03F0": { "math": "\\varkappa" } }, "mathrsfs": { "\u210A": { "math": "\\mathscr{g}" }, "\u210B": { "math": "\\mathscr{H}" }, "\u2110": { "math": "\\mathscr{I}" }, "\u2112": { "math": "\\mathscr{L}" }, "\u211B": { "math": "\\mathscr{R}" }, "\u212C": { "math": "\\mathscr{B}" }, "\u212F": { "math": "\\mathscr{e}" }, "\u2130": { "math": "\\mathscr{E}" }, "\u2131": { "math": "\\mathscr{F}" }, "\u2133": { "math": "\\mathscr{M}" }, "\u2134": { "math": "\\mathscr{o}" }, "\u{1D49C}": { "math": "\\mathscr{A}" }, "\u{1D49E}": { "math": "\\mathscr{C}" }, "\u{1D49F}": { "math": "\\mathscr{D}" }, "\u{1D4A2}": { "math": "\\mathscr{G}" }, "\u{1D4A5}": { "math": "\\mathscr{J}" }, "\u{1D4A6}": { "math": "\\mathscr{K}" }, "\u{1D4A9}": { "math": "\\mathscr{N}" }, "\u{1D4AA}": { "math": "\\mathscr{O}" }, "\u{1D4AB}": { "math": "\\mathscr{P}" }, "\u{1D4AC}": { "math": "\\mathscr{Q}" }, "\u{1D4AE}": { "math": "\\mathscr{S}" }, "\u{1D4AF}": { "math": "\\mathscr{T}" }, "\u{1D4B0}": { "math": "\\mathscr{U}" }, "\u{1D4B1}": { "math": "\\mathscr{V}" }, "\u{1D4B2}": { "math": "\\mathscr{W}" }, "\u{1D4B3}": { "math": "\\mathscr{X}" }, "\u{1D4B4}": { "math": "\\mathscr{Y}" }, "\u{1D4B5}": { "math": "\\mathscr{Z}" }, "\u{1D4B6}": { "math": "\\mathscr{a}" }, "\u{1D4B7}": { "math": "\\mathscr{b}" }, "\u{1D4B8}": { "math": "\\mathscr{c}" }, "\u{1D4B9}": { "math": "\\mathscr{d}" }, "\u{1D4BB}": { "math": "\\mathscr{f}" }, "\u{1D4BD}": { "math": "\\mathscr{h}" }, "\u{1D4BE}": { "math": "\\mathscr{i}" }, "\u{1D4BF}": { "math": "\\mathscr{j}" }, "\u{1D4C0}": { "math": "\\mathscr{k}" }, "\u{1D4C1}": { "math": "\\mathscr{l}" }, "\u{1D4C2}": { "math": "\\mathscr{m}" }, "\u{1D4C3}": { "math": "\\mathscr{n}" }, "\u{1D4C5}": { "math": "\\mathscr{p}" }, "\u{1D4C6}": { "math": "\\mathscr{q}" }, "\u{1D4C7}": { "math": "\\mathscr{r}" }, "\u{1D4C8}": { "math": "\\mathscr{s}" }, "\u{1D4C9}": { "math": "\\mathscr{t}" }, "\u{1D4CA}": { "math": "\\mathscr{u}" }, "\u{1D4CB}": { "math": "\\mathscr{v}" }, "\u{1D4CC}": { "math": "\\mathscr{w}" }, "\u{1D4CD}": { "math": "\\mathscr{x}" }, "\u{1D4CE}": { "math": "\\mathscr{y}" }, "\u{1D4CF}": { "math": "\\mathscr{z}" } }, "MnSymbol": { "\u2232": { "math": "\\lcirclerightint" }, "\u2233": { "math": "\\rcirclerightint" } }, "mathabx": { "\u2238": { "math": "\\dotdiv" } }, "xecjk": { "\u2242": { "math": "\\texteqsim" }, "\u05D0": { "text": "{\\hebalef}" }, "\u05E2": { "text": "{\\hebayin}" }, "\u05D1": { "text": "{\\hebbet}" }, "\u05D3": { "text": "{\\hebdalet}" }, "\u05DA": { "text": "{\\hebfinalkaf}" }, "\u05DD": { "text": "{\\hebfinalmem}" }, "\u05DF": { "text": "{\\hebfinalnun}" }, "\u05E3": { "text": "{\\hebfinalpe}" }, "\u05E5": { "text": "{\\hebfinaltsadi}" }, "\u05D2": { "text": "{\\hebgimel}" }, "\u05D4": { "text": "{\\hebhe}" }, "\u05D7": { "text": "{\\hebhet}" }, "\u05DB": { "text": "{\\hebkaf}" }, "\u05DC": { "text": "{\\heblamed}" }, "\u05DE": { "text": "{\\hebmem}" }, "\u05E0": { "text": "{\\hebnun}" }, "\u05E4": { "text": "{\\hebpe}" }, "\u05E7": { "text": "{\\hebqof}" }, "\u05E8": { "text": "{\\hebresh}" }, "\u05E1": { "text": "{\\hebsamekh}" }, "\u05E9": { "text": "{\\hebshin}" }, "\u05EA": { "text": "{\\hebtav}" }, "\u05D8": { "text": "{\\hebtet}" }, "\u05E6": { "text": "{\\hebtsadi}" }, "\u05D5": { "text": "{\\hebvav}" }, "\u05D9": { "text": "{\\hebyod}" }, "\u05D6": { "text": "{\\hebzayin}" }, "\u0138": { "text": "{\\textkra}" } }, "textcomp": { "\xA2": { "text": "{\\textcent}" }, "\xA4": { "text": "{\\textcurrency}" }, "\xA5": { "text": "{\\textyen}" }, "\u0E3F": { "text": "{\\textbaht}" }, "\u20A1": { "text": "{\\textcolonmonetary}" }, "\u20A4": { "text": "{\\textlira}" }, "\u20A6": { "text": "{\\textnaira}" }, "\u20A7": { "text": "{\\textpeseta}" }, "\u20A9": { "text": "{\\textwon}" }, "\u20AB": { "text": "{\\textdong}" }, "\u20B1": { "text": "{\\textpeso}" }, "\xA6": { "text": "{\\textbrokenbar}" }, "\xA9": { "text": "{\\textcopyright}" }, "\xAA": { "text": "{\\textordfeminine}" }, "\xB0": { "text": "{\\textdegree}" }, "\xB6": { "text": "{\\textparagraph}" }, "\xBA": { "text": "{\\textordmasculine}" }, "\xF0": { "text": "{\\textdh}" }, "\u02D9": { "text": "{\\textperiodcentered}" }, "\u2022": { "text": "{\\textbullet}" }, "\u2030": { "text": "{\\textperthousand}" }, "\u2031": { "text": "{\\textpertenthousand}" }, "\u211E": { "text": "{\\textrecipe}" }, "\u2122": { "text": "{\\texttrademark}" }, "\u2191": { "text": "{\\textuparrow}" }, "\u2192": { "text": "{\\textrightarrow}" } }, "inputenx": { "\u0126": { "text": "{\\textmalteseH}" }, "\u0278": { "text": "{\\textphi}" }, "\u2248": { "text": "{\\textapproxequal}" } }, "tipa": { "\u0127": { "text": "{\\textcrh}" }, "\u0195": { "text": "{\\texthvlig}" }, "\u019E": { "text": "\\textipa{\\textnrleg}" }, "\u0250": { "text": "\\textipa{\\textturna}" }, "\u0252": { "text": "textipa{\\textopeno}" }, "\u0254": { "text": "\\textipa{O}" }, "\u0256": { "text": "{\\textrtaild}" }, "\u0259": { "text": "{\\textschwa}" }, "\u0263": { "text": "\\textipa{G}" }, "\u0264": { "text": "{\\textrevscripta}" }, "\u0278": { "text": "{\\textphi}" }, "\u029E": { "text": "{\\textturnk}" }, "\u02E5": { "text": "\\tone{55}" }, "\u02E6": { "text": "\\tone{44}" }, "\u02E7": { "text": "\\tone{33}" }, "\u02E8": { "text": "\\tone{22}" }, "\u02E9": { "text": "\\tone{11}" }, "\u0300\u0304": { "text": "{\\textgravemacron}" }, "\u0300\u0307": { "text": "{\\textgravedot}" }, "\u0301\u0304": { "text": "{\\textacutemacron}" }, "\u0301\u030C": { "text": "{\\textacutewedge}" }, "\u0302\u0307": { "text": "{\\textcircumdot}" }, "\u0303\u0307": { "text": "{\\texttildedot}" }, "\u0304\u0300": { "text": "{\\textgravemacron}" }, "\u0306\u0304": { "text": "{\\textbrevemacron}" }, "\u0307\u0301": { "text": "{\\textdotacute}" }, "\u0307\u0306": { "text": "{\\textdotbreve}" }, "\u030A\u0304": { "text": "{\\textringmacron}" }, "\u030D": { "text": "{\\textvbaraccent}" }, "\u030E": { "text": "{\\textdoublevbaraccent}" }, "\u0310": { "text": "{\\textdotbreve}" }, "\u0318": { "text": "{\\textadvancing}" }, "\u0319": { "text": "{\\textretracting}" }, "\u031A": { "text": "{\\textcorner}" }, "\u031C": { "text": "{\\textsublhalfring}" }, "\u031D": { "text": "{\\textraising}" }, "\u031E": { "text": "{\\textlowering}" }, "\u031F": { "text": "{\\textsubplus}" }, "\u0324": { "text": "{\\textsubumlaut}" }, "\u0325": { "text": "{\\textsubring}" }, "\u0329": { "text": "{\\textsyllabic}" }, "\u032A": { "text": "{\\textsubbridge}" }, "\u032C": { "text": "{\\textsubwedge}" }, "\u032F": { "text": "{\\textsubarch}" }, "\u0330": { "text": "{\\textsubtilde}" }, "\u0331": { "text": "{\\textsubbar}" }, "\u0334": { "text": "{\\textsuperimposetilde}" }, "\u0339": { "text": "{\\textsubrhalfring}" }, "\u033A": { "text": "{\\textinvsubbridge}" }, "\u033B": { "text": "{\\textsubsquare}" }, "\u033C": { "text": "{\\textseagull}" }, "\u033D": { "text": "{\\textovercross}" }, "\u2094": { "text": "\\textsubscript{\\textschwa}" } }, "ipa": { "\u026F": { "text": "{\\textturnm}" } }, "mathscinet": { "\u02BF": { "text": "{\\lasp}" } }, "textalpha": { "\u03B1": { "text": "{\\textalpha}" } }, "graphics": { "\u21B3": { "text": "\\reflectbox{\\carriagereturn}" } }, "pmboxdraw": { "\u2500": { "text": "{\\textSFx}" }, "\u2501": { "text": "\\pmboxdrawuni{2501}" }, "\u2502": { "text": "{\\textSFxi}" }, "\u2503": { "text": "\\pmboxdrawuni{2503}" }, "\u250C": { "text": "{\\textSFi}" }, "\u250D": { "text": "\\pmboxdrawuni{250D}" }, "\u250E": { "text": "\\pmboxdrawuni{250E}" }, "\u250F": { "text": "\\pmboxdrawuni{250F}" }, "\u2510": { "text": "{\\textSFiii}" }, "\u2511": { "text": "\\pmboxdrawuni{2511}" }, "\u2512": { "text": "\\pmboxdrawuni{2512}" }, "\u2513": { "text": "\\pmboxdrawuni{2513}" }, "\u2514": { "text": "{\\textSFii}" }, "\u2515": { "text": "\\pmboxdrawuni{2515}" }, "\u2516": { "text": "\\pmboxdrawuni{2516}" }, "\u2517": { "text": "\\pmboxdrawuni{2517}" }, "\u2518": { "text": "{\\textSFiv}" }, "\u2519": { "text": "\\pmboxdrawuni{2519}" }, "\u251A": { "text": "\\pmboxdrawuni{251A}" }, "\u251B": { "text": "\\pmboxdrawuni{251B}" }, "\u251C": { "text": "{\\textSFviii}" }, "\u251D": { "text": "\\pmboxdrawuni{251D}" }, "\u251E": { "text": "\\pmboxdrawuni{251E}" }, "\u251F": { "text": "\\pmboxdrawuni{251F}" }, "\u2520": { "text": "\\pmboxdrawuni{2520}" }, "\u2521": { "text": "\\pmboxdrawuni{2521}" }, "\u2522": { "text": "\\pmboxdrawuni{2522}" }, "\u2523": { "text": "\\pmboxdrawuni{2523}" }, "\u2524": { "text": "{\\textSFix}" }, "\u2525": { "text": "\\pmboxdrawuni{2525}" }, "\u2526": { "text": "\\pmboxdrawuni{2526}" }, "\u2527": { "text": "\\pmboxdrawuni{2527}" }, "\u2528": { "text": "\\pmboxdrawuni{2528}" }, "\u2529": { "text": "\\pmboxdrawuni{2529}" }, "\u252A": { "text": "\\pmboxdrawuni{252A}" }, "\u252B": { "text": "\\pmboxdrawuni{252B}" }, "\u252C": { "text": "{\\textSFvi}" }, "\u252D": { "text": "\\pmboxdrawuni{252D}" }, "\u252E": { "text": "\\pmboxdrawuni{252E}" }, "\u252F": { "text": "\\pmboxdrawuni{252F}" }, "\u2530": { "text": "\\pmboxdrawuni{2530}" }, "\u2531": { "text": "\\pmboxdrawuni{2531}" }, "\u2532": { "text": "\\pmboxdrawuni{2532}" }, "\u2533": { "text": "\\pmboxdrawuni{2533}" }, "\u2534": { "text": "{\\textSFvii}" }, "\u2535": { "text": "\\pmboxdrawuni{2535}" }, "\u2536": { "text": "\\pmboxdrawuni{2536}" }, "\u2537": { "text": "\\pmboxdrawuni{2537}" }, "\u2538": { "text": "\\pmboxdrawuni{2538}" }, "\u2539": { "text": "\\pmboxdrawuni{2539}" }, "\u253A": { "text": "\\pmboxdrawuni{253A}" }, "\u253B": { "text": "\\pmboxdrawuni{253B}" }, "\u253C": { "text": "{\\textSFv}" }, "\u253D": { "text": "\\pmboxdrawuni{253D}" }, "\u253E": { "text": "\\pmboxdrawuni{253E}" }, "\u253F": { "text": "\\pmboxdrawuni{253F}" }, "\u2540": { "text": "\\pmboxdrawuni{2540}" }, "\u2541": { "text": "\\pmboxdrawuni{2541}" }, "\u2542": { "text": "\\pmboxdrawuni{2542}" }, "\u2543": { "text": "\\pmboxdrawuni{2543}" }, "\u2544": { "text": "\\pmboxdrawuni{2544}" }, "\u2545": { "text": "\\pmboxdrawuni{2545}" }, "\u2546": { "text": "\\pmboxdrawuni{2546}" }, "\u2547": { "text": "\\pmboxdrawuni{2547}" }, "\u2548": { "text": "\\pmboxdrawuni{2548}" }, "\u2549": { "text": "\\pmboxdrawuni{2549}" }, "\u254A": { "text": "\\pmboxdrawuni{254A}" }, "\u254B": { "text": "\\pmboxdrawuni{254B}" }, "\u2550": { "text": "{\\textSFxliii}" }, "\u2551": { "text": "{\\textSFxxiv}" }, "\u2552": { "text": "{\\textSFli}" }, "\u2553": { "text": "{\\textSFlii}" }, "\u2554": { "text": "{\\textSFxxxix}" }, "\u2555": { "text": "{\\textSFxxii}" }, "\u2556": { "text": "{\\textSFxxi}" }, "\u2557": { "text": "{\\textSFxxv}" }, "\u2558": { "text": "{\\textSFl}" }, "\u2559": { "text": "{\\textSFxlix}" }, "\u255A": { "text": "{\\textSFxxxviii}" }, "\u255B": { "text": "{\\textSFxxviii}" }, "\u255C": { "text": "{\\textSFxxvii}" }, "\u255D": { "text": "{\\textSFxxvi}" }, "\u255E": { "text": "{\\textSFxxxvi}" }, "\u255F": { "text": "{\\textSFxxxvii}" }, "\u2560": { "text": "{\\textSFxlii}" }, "\u2561": { "text": "{\\textSFxix}" }, "\u2562": { "text": "{\\textSFxx}" }, "\u2563": { "text": "{\\textSFxxiii}" }, "\u2564": { "text": "{\\textSFxlvii}" }, "\u2565": { "text": "{\\textSFxlviii}" }, "\u2566": { "text": "{\\textSFxli}" }, "\u2567": { "text": "{\\textSFxlv}" }, "\u2568": { "text": "{\\textSFxlvi}" }, "\u2569": { "text": "{\\textSFxl}" }, "\u256A": { "text": "{\\textSFliv}" }, "\u256B": { "text": "{\\textSFliii}" }, "\u256C": { "text": "{\\textSFxliv}" }, "\u2574": { "text": "\\pmboxdrawuni{2574}" }, "\u2575": { "text": "\\pmboxdrawuni{2575}" }, "\u2576": { "text": "\\pmboxdrawuni{2576}" }, "\u2577": { "text": "\\pmboxdrawuni{2577}" }, "\u2578": { "text": "\\pmboxdrawuni{2578}" }, "\u2579": { "text": "\\pmboxdrawuni{2579}" }, "\u257A": { "text": "\\pmboxdrawuni{257A}" }, "\u257B": { "text": "\\pmboxdrawuni{257B}" }, "\u257C": { "text": "\\pmboxdrawuni{257C}" }, "\u257D": { "text": "\\pmboxdrawuni{257D}" }, "\u257E": { "text": "\\pmboxdrawuni{257E}" }, "\u257F": { "text": "\\pmboxdrawuni{257F}" }, "\u2580": { "text": "{\\textupblock}" }, "\u2581": { "text": "\\pmboxdrawuni{2581}" }, "\u2582": { "text": "\\pmboxdrawuni{2582}" }, "\u2583": { "text": "\\pmboxdrawuni{2583}" }, "\u2584": { "text": "{\\textdnblock}" }, "\u2585": { "text": "\\pmboxdrawuni{2585}" }, "\u2586": { "text": "\\pmboxdrawuni{2586}" }, "\u2587": { "text": "\\pmboxdrawuni{2587}" }, "\u2588": { "text": "{\\textblock}" }, "\u2589": { "text": "\\pmboxdrawuni{2589}" }, "\u258A": { "text": "\\pmboxdrawuni{258A}" }, "\u258B": { "text": "\\pmboxdrawuni{258B}" }, "\u258C": { "text": "{\\textlfblock}" }, "\u258D": { "text": "\\pmboxdrawuni{258D}" }, "\u258E": { "text": "\\pmboxdrawuni{258E}" }, "\u258F": { "text": "\\pmboxdrawuni{258F}" }, "\u2590": { "text": "{\\textrtblock}" }, "\u2591": { "text": "{\\textltshade}" }, "\u2592": { "text": "{\\textshade}" }, "\u2593": { "text": "{\\textdkshade}" }, "\u2594": { "text": "\\pmboxdrawuni{2594}" }, "\u2595": { "text": "\\pmboxdrawuni{2595}" }, "\u2596": { "text": "\\pmboxdrawuni{2596}" }, "\u2597": { "text": "\\pmboxdrawuni{2597}" }, "\u2598": { "text": "\\pmboxdrawuni{2598}" }, "\u2599": { "text": "\\pmboxdrawuni{2599}" }, "\u259A": { "text": "\\pmboxdrawuni{259A}" }, "\u259B": { "text": "\\pmboxdrawuni{259B}" }, "\u259C": { "text": "\\pmboxdrawuni{259C}" }, "\u259D": { "text": "\\pmboxdrawuni{259D}" }, "\u259E": { "text": "\\pmboxdrawuni{259E}" }, "\u259F": { "text": "\\pmboxdrawuni{259F}" } } } };
    }
  });

  // node_modules/unicode2latex/tables/minimal.json
  var require_minimal = __commonJS({
    "node_modules/unicode2latex/tables/minimal.json"(exports, module) {
      module.exports = { "base": { "#": { "text": "\\#", "math": "\\#" }, "$": { "text": "\\$", "math": "\\$" }, "%": { "text": "\\%", "math": "\\%" }, "&": { "text": "\\&", "math": "\\&" }, "_": { "text": "\\_", "math": "\\_" }, "\xA0": { "text": "~", "math": "~" }, "\u205F": { "text": "\\:", "math": "\\:" }, "<": { "math": "<" }, ">": { "math": ">" }, "\\": { "text": "\\textbackslash", "math": "\\backslash", "macrospacer": true }, "\u2003": { "math": "\\quad" }, "\u200A": { "math": "\\mkern1mu" }, "^": { "text": "\\textasciicircum", "macrospacer": true }, "{": { "text": "\\{" }, "}": { "text": "\\}" }, "~": { "text": "\\textasciitilde", "macrospacer": true }, "\u2002": { "text": "\\enspace", "macrospacer": true }, "\u2004": { "text": "\\;" }, "\u2005": { "text": "\\>" }, "\u2006": { "text": "\\hspace{0.166em}" }, "\u2007": { "text": "\\hphantom{0}" }, "\u2008": { "text": "\\hphantom{,}" }, "\u2009": { "text": "\\," }, "\u200B": { "text": "\\hspace{0pt}" }, "\u202F": { "text": "\\," } }, "package": {} };
    }
  });

  // node_modules/unicode2latex/tables/latex2unicode.json
  var require_latex2unicode = __commonJS({
    "node_modules/unicode2latex/tables/latex2unicode.json"(exports, module) {
      module.exports = { "''": { "text": "\u201D", "math": "''" }, "--": { "text": "\u2013", "math": "--" }, "---": { "text": "\u2014", "math": "---" }, "<": { "text": "\xA1", "math": "<" }, "<<": { "text": "\xAB", "math": "<<" }, "<\\kern-0.58em(": "\u2993", ">": { "text": "\xBF", "math": ">" }, ">>": { "text": "\xBB", "math": ">>" }, "\\": "\\", '\\"': "\u0308", '\\"{\\i}': "i\u0308", "\\#": "#", "\\$": "$", "\\%": "%", "\\&": "&", "\\'": "\u0301", "\\'\\i": "i\u0301", "\\,": "\u2009", "\\-": "\xAD", "\\.": "\u0307", "\\/": "", "\\:": "\u205F", "\\;": "\u2004", "\\=": "\u0304", "\\>": "\u2005", "\\@": "", "\\AA": "A\u030A", "\\AC": "\u223F", "\\AE": "\xC6", "\\APLboxquestion": "\u2370", "\\APLboxupcaret": "\u2353", "\\APLcomment": "\u235D", "\\APLdownarrowbox": "\u2357", "\\APLinput": "\u235E", "\\APLinv": "\u2339", "\\APLleftarrowbox": "\u2347", "\\APLlog": "\u235F", "\\APLnotbackslash": "\u2340", "\\APLnotslash": "\u233F", "\\APLrightarrowbox": "\u2348", "\\APLuparrowbox": "\u2350", "\\Angle": "\u299C", "\\Angstroem": "A\u030A", "\\Angstrom": "A\u030A", "\\Barv": "\u2AE7", "\\BbbA": "\u{1D538}", "\\BbbB": "\u{1D539}", "\\BbbC": "\u2102", "\\BbbD": "\u{1D53B}", "\\BbbE": "\u{1D53C}", "\\BbbF": "\u{1D53D}", "\\BbbG": "\u{1D53E}", "\\BbbGamma": "\u213E", "\\BbbH": "\u210D", "\\BbbI": "\u{1D540}", "\\BbbJ": "\u{1D541}", "\\BbbK": "\u{1D542}", "\\BbbL": "\u{1D543}", "\\BbbM": "\u{1D544}", "\\BbbN": "\u2115", "\\BbbO": "\u{1D546}", "\\BbbP": "\u2119", "\\BbbPi": "\u213F", "\\BbbQ": "\u211A", "\\BbbR": "\u211D", "\\BbbS": "\u{1D54A}", "\\BbbT": "\u{1D54B}", "\\BbbU": "\u{1D54C}", "\\BbbV": "\u{1D54D}", "\\BbbW": "\u{1D54E}", "\\BbbX": "\u{1D54F}", "\\BbbY": "\u{1D550}", "\\BbbZ": "\u2124", "\\Bbba": "\u{1D552}", "\\Bbbb": "\u{1D553}", "\\Bbbc": "\u{1D554}", "\\Bbbd": "\u{1D555}", "\\Bbbe": "\u{1D556}", "\\Bbbeight": "\u{1D7E0}", "\\Bbbf": "\u{1D557}", "\\Bbbfive": "\u{1D7DD}", "\\Bbbfour": "\u{1D7DC}", "\\Bbbg": "\u{1D558}", "\\Bbbgamma": "\u213D", "\\Bbbh": "\u{1D559}", "\\Bbbi": "\u{1D55A}", "\\Bbbj": "\u{1D55B}", "\\Bbbk": "\u{1D55C}", "\\Bbbl": "\u{1D55D}", "\\Bbbm": "\u{1D55E}", "\\Bbbn": "\u{1D55F}", "\\Bbbnine": "\u{1D7E1}", "\\Bbbo": "\u{1D560}", "\\Bbbone": "\u{1D7D9}", "\\Bbbp": "\u{1D561}", "\\Bbbpi": "\u213C", "\\Bbbq": "\u{1D562}", "\\Bbbr": "\u{1D563}", "\\Bbbs": "\u{1D564}", "\\Bbbseven": "\u{1D7DF}", "\\Bbbsix": "\u{1D7DE}", "\\Bbbsum": "\u2140", "\\Bbbt": "\u{1D565}", "\\Bbbthree": "\u{1D7DB}", "\\Bbbtwo": "\u{1D7DA}", "\\Bbbu": "\u{1D566}", "\\Bbbv": "\u{1D567}", "\\Bbbw": "\u{1D568}", "\\Bbbx": "\u{1D569}", "\\Bbby": "\u{1D56A}", "\\Bbbz": "\u{1D56B}", "\\Bbbzero": "\u{1D7D8}", "\\Box": "\u25A1", "\\Bumpeq": "\u224E", "\\CIRCLE": "\u25CF", "\\Cap": "\u22D2", "\\CapitalDifferentialD": "\u2145", "\\CheckedBox": "\u2611", "\\Colon": "\u2237", "\\Coloneq": "\u2A74", "\\Coloneqq": "\u2A74", "\\ComplexI": "\u2148", "\\ComplexJ": "\u2149", "\\Cup": "\u22D3", "\\DDownarrow": "\u27F1", "\\DH": "\xD0", "\\DJ": "\u0110", "\\DashV": "\u2AE5", "\\DashVDash": "\u27DA", "\\Dashv": "\u2AE4", "\\Ddownarrow": "\u290B", "\\Delta": "\u0394", "\\Diamond": "\u25C7", "\\Diamondblack": "\u25C6", "\\Diamonddot": "\u27D0", "\\DifferentialD": "\u2146", "\\Digamma": "\u03DC", "\\Doteq": "\u2251", "\\DownArrowBar": "\u2913", "\\DownArrowUpArrow": "\u21F5", "\\DownLeftRightVector": "\u2950", "\\DownLeftTeeVector": "\u295E", "\\DownLeftVectorBar": "\u2956", "\\DownRightTeeVector": "\u295F", "\\DownRightVectorBar": "\u2957", "\\Downarrow": "\u21D3", "\\ElOr": "\u2A56", "\\Elolarr": "\u2940", "\\Elorarr": "\u2941", "\\Elroang": "\u2986", "\\Elxsqcup": "\u2A06", "\\Elxuplus": "\u2A04", "\\Equal": "\u2A75", "\\Equiv": "\u2263", "\\Euler": "\u2107", "\\Eulerconst": "\u2107", "\\Exclam": "\u203C", "\\ExponetialE": "\u2147", "\\Finv": "\u2132", "\\Game": "\u2141", "\\Gamma": "\u0393", "\\Gt": "\u2AA2", "\\H": "\u030B", "\\Hermaphrodite": "\u26A5", "\\H{}": "\u02DD", "\\IJ": "\u0132", "\\Im": "\u2111", "\\Join": "\u2A1D", "\\Koppa": "\u03DE", "\\L": "\u0141", "\\LEFTCIRCLE": "\u25D6", "\\LHD": "\u25C0", "\\LLeftarrow": "\u2B45", "\\LVec": "\u20D6", "\\Lambda": "\u039B", "\\Lbag": "\u27C5", "\\Lbrbrak": "\u27EC", "\\Ldsh": "\u21B2", "\\LeftArrowBar": "\u21E4", "\\LeftDownTeeVector": "\u2961", "\\LeftDownVectorBar": "\u2959", "\\LeftRightVector": "\u294E", "\\LeftTeeVector": "\u295A", "\\LeftTriangleBar": "\u29CF", "\\LeftUpDownVector": "\u2951", "\\LeftUpTeeVector": "\u2960", "\\LeftUpVectorBar": "\u2958", "\\LeftVectorBar": "\u2952", "\\Leftarrow": "\u21D0", "\\Leftrightarrow": "\u21D4", "\\Lleftarrow": "\u21DA", "\\Longleftarrow": "\u27F8", "\\Longleftrightarrow": "\u27FA", "\\Longmapsfrom": "\u27FD", "\\Longmapsto": "\u27FE", "\\Longrightarrow": "\u27F9", "\\Lparengtr": "\u2995", "\\Lsh": "\u21B0", "\\Lt": "\u2AA1", "\\Lvzigzag": "\u29DA", "\\MapsDown": "\u21A7", "\\MapsUp": "\u21A5", "\\Mapsfrom": "\u2906", "\\Mapsto": "\u2907", "\\NG": "\u014A", "\\Nearrow": "\u21D7", "\\NestedGreaterGreater": "\u2AA2", "\\NestedLessLess": "\u2AA1", "\\Not": "\u2AEC", "\\NotEqualTilde": "\u2242\u0338", "\\NotGreaterGreater": "\u226B\u0338", "\\NotHumpDownHump": "\u224E\u0338", "\\NotHumpEqual": "\u224F\u0338", "\\NotLeftTriangleBar": "\u29CF\u0338", "\\NotLessLess": "\u226A\u0338", "\\NotNestedGreaterGreater": "\u2AA2\u0338", "\\NotNestedLessLess": "\u2AA1\u0338", "\\NotPrecedesTilde": "\u227E\u0338", "\\NotRightTriangleBar": "\u29D0\u0338", "\\NotSquareSubset": "\u228F\u0338", "\\NotSquareSuperset": "\u2290\u0338", "\\NotSucceedsTilde": "\u227F\u0338", "\\Nwarrow": "\u21D6", "\\O": "\xD8", "\\OE": "\u0152", "\\Omega": "\u03A9", "\\Otimes": "\u2A37", "\\P": "\xB6", "\\Phi": "\u03A6", "\\Pi": "\u03A0", "\\Pisymbol{ppi020}{105}": "\u2A9E", "\\Pisymbol{ppi020}{117}": "\u2A9D", "\\Pisymbol{ppi022}{87}": "\u03D0", "\\Planckconst": "\u210E", "\\Prec": "\u2ABB", "\\PropertyLine": "\u214A", "\\Psi": "\u03A8", "\\QED": "\u220E", "\\Qoppa": "\u03D8", "\\Question": "\u2047", "\\RHD": "\u25B6", "\\RIGHTCIRCLE": "\u25D7", "\\RRightarrow": "\u2B46", "\\Rbag": "\u27C6", "\\Rbrbrak": "\u27ED", "\\Rdsh": "\u21B3", "\\Re": "\u211C", "\\ReverseUpEquilibrium": "\u296F", "\\RightArrowBar": "\u21E5", "\\RightDownTeeVector": "\u295D", "\\RightDownVectorBar": "\u2955", "\\RightTeeVector": "\u295B", "\\RightTriangleBar": "\u29D0", "\\RightUpDownVector": "\u294F", "\\RightUpTeeVector": "\u295C", "\\RightUpVectorBar": "\u2954", "\\RightVectorBar": "\u2953", "\\Rightarrow": "\u21D2", "\\RoundImplies": "\u2970", "\\Rparenless": "\u2996", "\\Rrightarrow": "\u21DB", "\\Rsh": "\u21B1", "\\RuleDelayed": "\u29F4", "\\Rvzigzag": "\u29DB", "\\S": "\xA7", "\\Same": "\u2A76", "\\Sampi": "\u03E0", "\\Searrow": "\u21D8", "\\Sigma": "\u03A3", "\\Sqcap": "\u2A4E", "\\Sqcup": "\u2A4F", "\\Square": "\u2610", "\\Stigma": "\u03DA", "\\Subset": "\u22D0", "\\Succ": "\u2ABC", "\\Sun": "\u2609", "\\Supset": "\u22D1", "\\Swarrow": "\u21D9", "\\TH": "\xDE", "\\Theta": "\u0398", "\\Top": "\u2AEA", "\\UUparrow": "\u27F0", "\\UpArrowBar": "\u2912", "\\UpEquilibrium": "\u296E", "\\Uparrow": "\u21D1", "\\Updownarrow": "\u21D5", "\\Upsilon": "\u03A5", "\\Uuparrow": "\u290A", "\\VDash": "\u22AB", "\\Vbar": "\u2AEB", "\\Vdash": "\u22A9", "\\Vee": "\u2A54", "\\Vert": "\u2016", "\\Vvdash": "\u22AA", "\\Vvert": "\u2980", "\\Wedge": "\u2A53", "\\XBox": "\u2612", "\\Xi": "\u039E", "\\Yup": "\u2144", "\\\\backslash": "\u0871", "\\^": "\u0302", "\\^\\j": "j\u0302", "\\^{\\i}": "i\u0302", "\\_": "_", "\\`": "\u0300", "\\`\\i": "i\u0300", "\\aa": "a\u030A", "\\accurrent": "\u23E6", "\\acidfree": "\u267E", "\\acute": "\u0301", "\\acute{\\alpha}": "\u03B1\u0301", "\\acute{\\ddot{\\iota}}": "\u03B9\u0308\u0301", "\\acute{\\ddot{\\upsilon}}": "\u03C5\u0308\u0301", "\\acute{\\epsilon}": "\u03B5\u0301", "\\acute{\\eta}": "\u03B7\u0301", "\\acute{\\iota}": "\u03B9\u0301", "\\acute{\\omega}": "\u03C9\u0301", "\\acute{\\upsilon}": "\u03C5\u0301", "\\acwcirclearrow": "\u2940", "\\acwgapcirclearrow": "\u27F2", "\\acwleftarcarrow": "\u2939", "\\acwopencirclearrow": "\u21BA", "\\acwoverarcarrow": "\u293A", "\\acwunderarcarrow": "\u293B", "\\adots": "\u22F0", "\\ae": "\xE6", "\\aleph": "\u2135", "\\allequal": "\u224C", "\\alpha": "\u03B1", "\\amalg": "\u2A3F", "\\anchor": "\u2693", "\\angdnr": "\u299F", "\\angle": "\u2220", "\\angles": "\u299E", "\\angleubar": "\u29A4", "\\annuity": "\u20E7", "\\approx": "\u2248", "\\approxeq": "\u224A", "\\approxeqq": "\u2A70", "\\approxident": "\u224B", "\\approxnotequal": "\u2246", "\\aquarius": "\u2652", "\\arabichad": "u\u031B\u03031", "\\arabicmaj": "u\u031B\u03030", "\\arceq": "\u2258", "\\aries": "\u2648", "\\arrowbullet": "\u27A2", "\\arrowwaveleft": "\u219C", "\\arrowwaveright": "\u219D", "\\assert": "\u22A6", "\\ast": "\u2217", "\\asteq": "\u2A6E", "\\asteraccent": "\u20F0", "\\astrosun": "\u2609", "\\asymp": "\u224D", "\\awint": "\u2A11", "\\bNot": "\u2AED", "\\backcong": "\u224C", "\\backdprime": "\u2036", "\\backepsilon": "\u03F6", "\\backprime": "\u2035", "\\backsim": "\u223D", "\\backsimeq": "\u22CD", "\\backslash": "\\", "\\backtrprime": "\u2037", "\\bagmember": "\u22FF", "\\ballotx": "\u2717", "\\bar": "\u0305", "\\barV": "\u2AEA", "\\barcap": "\u2A43", "\\barcup": "\u2A42", "\\bardownharpoonleft": "\u2961", "\\bardownharpoonright": "\u295D", "\\barin": "\u22F6", "\\barleftarrow": "\u21E4", "\\barleftarrowrightarrowbar": "\u21B9", "\\barleftharpoon": "\u296B", "\\barleftharpoondown": "\u2956", "\\barleftharpoonup": "\u2952", "\\barovernorthwestarrow": "\u21B8", "\\barrightarrowdiamond": "\u2920", "\\barrightharpoon": "\u296D", "\\barrightharpoondown": "\u295F", "\\barrightharpoonup": "\u295B", "\\baruparrow": "\u2912", "\\barupharpoonleft": "\u2958", "\\barupharpoonright": "\u2954", "\\barvee": "\u22BD", "\\barwedge": { "text": "\u2305", "math": "\u22BC" }, "\\bbrktbrk": "\u23B6", "\\bdtriplevdash": "\u2506", "\\because": "\u2235", "\\benzenr": "\u23E3", "\\beta": "\u03B2", "\\beth": "\u2136", "\\between": "\u226C", "\\bigblacktriangledown": "\u25BC", "\\bigblacktriangleup": "\u25B2", "\\bigbot": "\u27D8", "\\bigcap": "\u22C2", "\\bigcirc": "\u25EF", "\\bigcup": "\u22C3", "\\bigcupdot": "\u2A03", "\\biginterleave": "\u2AFC", "\\bigodot": "\u2A00", "\\bigoplus": "\u2A01", "\\bigotimes": "\u2A02", "\\bigslopedvee": "\u2A57", "\\bigslopedwedge": "\u2A58", "\\bigsqcap": "\u2A05", "\\bigsqcup": "\u2A06", "\\bigstar": "\u2605", "\\bigtalloblong": "\u2AFF", "\\bigtimes": "\u2A09", "\\bigtop": "\u27D9", "\\bigtriangledown": "\u25BD", "\\bigtriangleleft": "\u2A1E", "\\bigtriangleup": "\u25B3", "\\biguplus": "\u2A04", "\\bigvee": "\u22C1", "\\bigwedge": "\u22C0", "\\bigwhitestar": "\u2606", "\\bij": "\u2916", "\\biohazard": "\u2623", "\\blackcircledownarrow": "\u29ED", "\\blackcircledrightdot": "\u2688", "\\blackcircledtwodots": "\u2689", "\\blackcircleulquadwhite": "\u25D5", "\\blackdiamonddownarrow": "\u29EA", "\\blackhourglass": "\u29D7", "\\blackinwhitediamond": "\u25C8", "\\blackinwhitesquare": "\u25A3", "\\blacklefthalfcircle": "\u25D6", "\\blacklozenge": "\u29EB", "\\blackpointerleft": "\u25C4", "\\blackpointerright": "\u25BA", "\\blackrighthalfcircle": "\u25D7", "\\blacksmiley": "\u263B", "\\blacksquare": "\u2B1B", "\\blacktriangle": "\u25B4", "\\blacktriangledown": "\u25BE", "\\blacktriangleleft": "\u25C0", "\\blacktriangleright": "\u25B6", "\\blanksymbol": "\u2422", "\\blkhorzoval": "\u2B2C", "\\blkvertoval": "\u2B2E", "\\blockfull": "\u2588", "\\blockhalfshaded": "\u2592", "\\blocklefthalf": "\u258C", "\\blocklowhalf": "\u2584", "\\blockqtrshaded": "\u2591", "\\blockrighthalf": "\u2590", "\\blockthreeqtrshaded": "\u2593", "\\blockuphalf": "\u2580", "\\bot": "\u22A5", "\\botsemicircle": "\u25E1", "\\bowtie": "\u22C8", "\\boxast": "\u29C6", "\\boxbar": "\u25EB", "\\boxbox": "\u29C8", "\\boxbslash": "\u29C5", "\\boxcircle": "\u29C7", "\\boxdiag": "\u29C4", "\\boxdot": "\u22A1", "\\boxminus": "\u229F", "\\boxonbox": "\u29C9", "\\boxplus": "\u229E", "\\boxslash": "\u29C4", "\\boxtimes": "\u22A0", "\\breve": "\u0306", "\\bsimilarleftarrow": "\u2B41", "\\bsimilarrightarrow": "\u2B47", "\\bsolhsub": "\u27C8", "\\btimes": "\u2A32", "\\bud": "\u042A", "\\bullet": "\u2219", "\\bullseye": "\u25CE", "\\bumpeq": "\u224F", "\\bumpeqq": "\u2AAE", "\\c": "\u0327", "\\cancer": "\u264B", "\\candra": "\u0310", "\\cap": "\u2229", "\\capbarcup": "\u2A49", "\\capdot": "\u2A40", "\\capovercup": "\u2A47", "\\capricornus": "\u2651", "\\capwedge": "\u2A44", "\\caretinsert": "\u2038", "\\carriagereturn": "\u21B5", "\\ccwundercurvearrow": "\u293F", "\\cdot": "\u22C5", "\\cdotp": "\xB7", "\\cdots": "\u22EF", "\\cdprime": "\u042A", "\\check": "\u030C", "\\checkmark": "\u2713", "\\chi": "\u03C7", "\\cirE": "\u29C3", "\\cirbot": "\u27DF", "\\circ": "\u2218", "\\circeq": "\u2257", "\\circlearrowleft": "\u21BA", "\\circlearrowright": "\u21BB", "\\circlebottomhalfblack": "\u25D2", "\\circledS": "\u24C8", "\\circledast": "\u229B", "\\circledbslash": "\u29B8", "\\circledbullet": "\u29BF", "\\circledcirc": "\u229A", "\\circleddash": "\u229D", "\\circledequal": "\u229C", "\\circledgtr": "\u29C1", "\\circledless": "\u29C0", "\\circledownarrow": "\u29EC", "\\circledparallel": "\u29B7", "\\circledrightdot": "\u2686", "\\circledstar": "\u272A", "\\circledtwodots": "\u2687", "\\circledvert": "\u29B6", "\\circledwhitebullet": "\u29BE", "\\circlehbar": "\u29B5", "\\circlelefthalfblack": "\u25D0", "\\circlellquad": "\u25F5", "\\circlelrquad": "\u25F6", "\\circleonleftarrow": "\u2B30", "\\circleonrightarrow": "\u21F4", "\\circlerighthalfblack": "\u25D1", "\\circletophalfblack": "\u25D3", "\\circleulquad": "\u25F4", "\\circleurquad": "\u25F7", "\\circleurquadblack": "\u25D4", "\\circlevertfill": "\u25CD", "\\cirfnint": "\u2A10", "\\cirmid": "\u2AEF", "\\cirscir": "\u29C2", "\\clockoint": "\u2A0F", "\\closedvarcap": "\u2A4D", "\\closedvarcup": "\u2A4C", "\\closedvarcupsmashprod": "\u2A50", "\\closure": "\u2050", "\\clubsuit": "\u2663", "\\clwintegral": "\u2231", "\\coloneq": "\u2254", "\\commaminus": "\u2A29", "\\complement": "\u2201", "\\concavediamond": "\u27E1", "\\concavediamondtickleft": "\u27E2", "\\concavediamondtickright": "\u27E3", "\\cong": "\u2245", "\\congdot": "\u2A6D", "\\conictaper": "\u2332", "\\conjquant": "\u2A07", "\\coprod": "\u2210", "\\copyright": "\xA9", "\\cprime": "\u042C", "\\csub": "\u2ACF", "\\csube": "\u2AD1", "\\csup": "\u2AD0", "\\csupe": "\u2AD2", "\\cuberoot": "\u221B", "\\cup": "\u222A", "\\cupbarcap": "\u2A48", "\\cupdot": "\u228D", "\\cupleftarrow": "\u228C", "\\cupovercap": "\u2A46", "\\cupvee": "\u2A45", "\\curlyeqprec": "\u22DE", "\\curlyeqsucc": "\u22DF", "\\curlyvee": "\u22CE", "\\curlywedge": "\u22CF", "\\curvearrowleft": "\u21B6", "\\curvearrowleftplus": "\u293D", "\\curvearrowright": "\u21B7", "\\curvearrowrightminus": "\u293C", "\\cwcirclearrow": "\u2941", "\\cwgapcirclearrow": "\u27F3", "\\cwopencirclearrow": "\u21BB", "\\cwrightarcarrow": "\u2938", "\\cwundercurvearrow": "\u293E", "\\cyrchar\\CYRA": "\u0410", "\\cyrchar\\CYRABHCH": "\u04BC", "\\cyrchar\\CYRABHCHDSC": "\u04BE", "\\cyrchar\\CYRABHDZE": "\u04E0", "\\cyrchar\\CYRABHHA": "\u04A8", "\\cyrchar\\CYRAE": "\u04D4", "\\cyrchar\\CYRB": "\u0411", "\\cyrchar\\CYRBYUS": "\u046A", "\\cyrchar\\CYRC": "\u0426", "\\cyrchar\\CYRCH": "\u0427", "\\cyrchar\\CYRCHLDSC": "\u04CB", "\\cyrchar\\CYRCHRDSC": "\u04B6", "\\cyrchar\\CYRCHVCRS": "\u04B8", "\\cyrchar\\CYRD": "\u0414", "\\cyrchar\\CYRDJE": "\u0402", "\\cyrchar\\CYRDZE": "\u0405", "\\cyrchar\\CYRDZHE": "\u040F", "\\cyrchar\\CYRE": "\u0415", "\\cyrchar\\CYREREV": "\u042D", "\\cyrchar\\CYRERY": "\u042B", "\\cyrchar\\CYRF": "\u0424", "\\cyrchar\\CYRFITA": "\u0472", "\\cyrchar\\CYRG": "\u0413", "\\cyrchar\\CYRGHCRS": "\u0492", "\\cyrchar\\CYRGHK": "\u0494", "\\cyrchar\\CYRGUP": "\u0490", "\\cyrchar\\CYRH": "\u0425", "\\cyrchar\\CYRHDSC": "\u04B2", "\\cyrchar\\CYRHRDSN": "\u042A", "\\cyrchar\\CYRI": "\u0418", "\\cyrchar\\CYRIE": "\u0404", "\\cyrchar\\CYRII": "\u0406", "\\cyrchar\\CYRIOTBYUS": "\u046C", "\\cyrchar\\CYRIOTE": "\u0464", "\\cyrchar\\CYRIOTLYUS": "\u0468", "\\cyrchar\\CYRISHRT": "\u0418\u0306", "\\cyrchar\\CYRIZH": "\u0474", "\\cyrchar\\CYRJE": "\u0408", "\\cyrchar\\CYRK": "\u041A", "\\cyrchar\\CYRKBEAK": "\u04A0", "\\cyrchar\\CYRKDSC": "\u049A", "\\cyrchar\\CYRKHCRS": "\u049E", "\\cyrchar\\CYRKHK": "\u04C3", "\\cyrchar\\CYRKOPPA": "\u0480", "\\cyrchar\\CYRKSI": "\u046E", "\\cyrchar\\CYRKVCRS": "\u049C", "\\cyrchar\\CYRL": "\u041B", "\\cyrchar\\CYRLDSC": "\u04C5", "\\cyrchar\\CYRLJE": "\u0409", "\\cyrchar\\CYRLYUS": "\u0466", "\\cyrchar\\CYRM": "\u041C", "\\cyrchar\\CYRMDSC": "\u04CD", "\\cyrchar\\CYRN": "\u041D", "\\cyrchar\\CYRNDSC": "\u04A2", "\\cyrchar\\CYRNG": "\u04A4", "\\cyrchar\\CYRNHK": "\u04C7", "\\cyrchar\\CYRNJE": "\u040A", "\\cyrchar\\CYRO": "\u041E", "\\cyrchar\\CYROMEGA": "\u0460", "\\cyrchar\\CYROMEGARND": "\u047A", "\\cyrchar\\CYROMEGATITLO": "\u047C", "\\cyrchar\\CYROT": "\u047E", "\\cyrchar\\CYROTLD": "\u04E8", "\\cyrchar\\CYRP": "\u041F", "\\cyrchar\\CYRPHK": "\u04A6", "\\cyrchar\\CYRPSI": "\u0470", "\\cyrchar\\CYRR": "\u0420", "\\cyrchar\\CYRRTICK": "\u048E", "\\cyrchar\\CYRS": "\u0421", "\\cyrchar\\CYRSCHWA": "\u04D8", "\\cyrchar\\CYRSDSC": "\u04AA", "\\cyrchar\\CYRSEMISFTSN": "\u048C", "\\cyrchar\\CYRSFTSN": "\u042C", "\\cyrchar\\CYRSH": "\u0428", "\\cyrchar\\CYRSHCH": "\u0429", "\\cyrchar\\CYRSHHA": "\u04BA", "\\cyrchar\\CYRT": "\u0422", "\\cyrchar\\CYRTDSC": "\u04AC", "\\cyrchar\\CYRTETSE": "\u04B4", "\\cyrchar\\CYRTSHE": "\u040B", "\\cyrchar\\CYRU": "\u0423", "\\cyrchar\\CYRUK": "\u0478", "\\cyrchar\\CYRUSHRT": "\u0423\u0306", "\\cyrchar\\CYRV": "\u0412", "\\cyrchar\\CYRY": "\u04AE", "\\cyrchar\\CYRYA": "\u042F", "\\cyrchar\\CYRYAT": "\u0462", "\\cyrchar\\CYRYHCRS": "\u04B0", "\\cyrchar\\CYRYI": "\u0406\u0308", "\\cyrchar\\CYRYO": "\u0415\u0308", "\\cyrchar\\CYRYU": "\u042E", "\\cyrchar\\CYRZ": "\u0417", "\\cyrchar\\CYRZDSC": "\u0498", "\\cyrchar\\CYRZH": "\u0416", "\\cyrchar\\CYRZHDSC": "\u0496", "\\cyrchar\\CYRpalochka": "\u04C0", "\\cyrchar\\cyra": "\u0430", "\\cyrchar\\cyrabhch": "\u04BD", "\\cyrchar\\cyrabhchdsc": "\u04BF", "\\cyrchar\\cyrabhdze": "\u04E1", "\\cyrchar\\cyrabhha": "\u04A9", "\\cyrchar\\cyrae": "\u04D5", "\\cyrchar\\cyrb": "\u0431", "\\cyrchar\\cyrbyus": "\u046B", "\\cyrchar\\cyrc": "\u0446", "\\cyrchar\\cyrch": "\u0447", "\\cyrchar\\cyrchldsc": "\u04CC", "\\cyrchar\\cyrchrdsc": "\u04B7", "\\cyrchar\\cyrchvcrs": "\u04B9", "\\cyrchar\\cyrd": "\u0434", "\\cyrchar\\cyrdje": "\u0452", "\\cyrchar\\cyrdze": "\u0455", "\\cyrchar\\cyrdzhe": "\u045F", "\\cyrchar\\cyre": "\u0435", "\\cyrchar\\cyrerev": "\u044D", "\\cyrchar\\cyrery": "\u044B", "\\cyrchar\\cyrf": "\u0444", "\\cyrchar\\cyrfita": "\u0473", "\\cyrchar\\cyrg": "\u0433", "\\cyrchar\\cyrghcrs": "\u0493", "\\cyrchar\\cyrghk": "\u0495", "\\cyrchar\\cyrgup": "\u0491", "\\cyrchar\\cyrh": "\u0445", "\\cyrchar\\cyrhdsc": "\u04B3", "\\cyrchar\\cyrhrdsn": "\u044A", "\\cyrchar\\cyrhundredthousands": "\u0488", "\\cyrchar\\cyri": "\u0438", "\\cyrchar\\cyrie": "\u0454", "\\cyrchar\\cyrii": "\u0456", "\\cyrchar\\cyriotbyus": "\u046D", "\\cyrchar\\cyriote": "\u0465", "\\cyrchar\\cyriotlyus": "\u0469", "\\cyrchar\\cyrishrt": "\u0438\u0306", "\\cyrchar\\cyrizh": "\u0475", "\\cyrchar\\cyrje": "\u0458", "\\cyrchar\\cyrk": "\u043A", "\\cyrchar\\cyrkbeak": "\u04A1", "\\cyrchar\\cyrkdsc": "\u049B", "\\cyrchar\\cyrkhcrs": "\u049F", "\\cyrchar\\cyrkhk": "\u04C4", "\\cyrchar\\cyrkoppa": "\u0481", "\\cyrchar\\cyrksi": "\u046F", "\\cyrchar\\cyrkvcrs": "\u049D", "\\cyrchar\\cyrl": "\u043B", "\\cyrchar\\cyrldsc": "\u04C6", "\\cyrchar\\cyrlje": "\u0459", "\\cyrchar\\cyrlyus": "\u0467", "\\cyrchar\\cyrm": "\u043C", "\\cyrchar\\cyrmdsc": "\u04CE", "\\cyrchar\\cyrmillions": "\u0489", "\\cyrchar\\cyrn": "\u043D", "\\cyrchar\\cyrndsc": "\u04A3", "\\cyrchar\\cyrng": "\u04A5", "\\cyrchar\\cyrnhk": "\u04C8", "\\cyrchar\\cyrnje": "\u045A", "\\cyrchar\\cyro": "\u043E", "\\cyrchar\\cyromega": "\u0461", "\\cyrchar\\cyromegarnd": "\u047B", "\\cyrchar\\cyromegatitlo": "\u047D", "\\cyrchar\\cyrot": "\u047F", "\\cyrchar\\cyrotld": "\u04E9", "\\cyrchar\\cyrp": "\u043F", "\\cyrchar\\cyrphk": "\u04A7", "\\cyrchar\\cyrpsi": "\u0471", "\\cyrchar\\cyrr": "\u0440", "\\cyrchar\\cyrrtick": "\u048F", "\\cyrchar\\cyrs": "\u0441", "\\cyrchar\\cyrschwa": "\u04D9", "\\cyrchar\\cyrsdsc": "\u04AB", "\\cyrchar\\cyrsemisftsn": "\u048D", "\\cyrchar\\cyrsftsn": "\u044C", "\\cyrchar\\cyrsh": "\u0448", "\\cyrchar\\cyrshch": "\u0449", "\\cyrchar\\cyrshha": "\u04BB", "\\cyrchar\\cyrt": "\u0442", "\\cyrchar\\cyrtdsc": "\u04AD", "\\cyrchar\\cyrtetse": "\u04B5", "\\cyrchar\\cyrthousands": "\u0482", "\\cyrchar\\cyrtshe": "\u045B", "\\cyrchar\\cyru": "\u0443", "\\cyrchar\\cyruk": "\u0479", "\\cyrchar\\cyrushrt": "\u0443\u0306", "\\cyrchar\\cyrv": "\u0432", "\\cyrchar\\cyry": "\u04AF", "\\cyrchar\\cyrya": "\u044F", "\\cyrchar\\cyryat": "\u0463", "\\cyrchar\\cyryhcrs": "\u04B1", "\\cyrchar\\cyryi": "\u0456\u0308", "\\cyrchar\\cyryo": "\u0435\u0308", "\\cyrchar\\cyryu": "\u044E", "\\cyrchar\\cyrz": "\u0437", "\\cyrchar\\cyrzdsc": "\u0499", "\\cyrchar\\cyrzh": "\u0436", "\\cyrchar\\cyrzhdsc": "\u0497", "\\cyrchar{\\'\\CYRG}": "\u0413\u0301", "\\cyrchar{\\'\\CYRK}": "\u041A\u0301", "\\cyrchar{\\'\\cyrg}": "\u0433\u0301", "\\cyrchar{\\'\\cyrk}": "\u043A\u0301", "\\c{\\u{E}}": "E\u0327\u0306", "\\c{\\u{e}}": "e\u0327\u0306", "\\d": "\u0323", "\\dag": "\u2020", "\\dagger": "\u2020", "\\daleth": "\u2138", "\\danger": "\u2621", "\\dashV": "\u2AE3", "\\dashVdash": "\u27DB", "\\dashcolon": "\u2239", "\\dashleftarrow": "\u21E0", "\\dashleftharpoondown": "\u296B", "\\dashrightarrow": "\u21E2", "\\dashrightharpoondown": "\u296D", "\\dashv": "\u22A3", "\\dbend": "\uFFFD", "\\dbkarrow": "\u290F", "\\dblarrowupdown": "\u21C5", "\\ddag": "\u2021", "\\ddagger": "\u2021", "\\ddddot": "\u20DC", "\\dddot": "\u20DB", "\\ddot": "\u0308", "\\ddots": "\u22F1", "\\ddotseq": "\u2A77", "\\ddot{\\iota}": "\u03B9\u0308", "\\ddot{\\upsilon}": "\u03C5\u0308", "\\delta": "\u03B4", "\\dh": "\xF0", "\\diagdown": "\u27CD", "\\diagup": "\u27CB", "\\diameter": "\u2300", "\\diamond": "\u2662", "\\diamondbotblack": "\u2B19", "\\diamondcdot": "\u27D0", "\\diamondleftarrow": "\u291D", "\\diamondleftarrowbar": "\u291F", "\\diamondleftblack": "\u2B16", "\\diamondrightblack": "\u2B17", "\\diamondsuit": "\u2662", "\\diamondtopblack": "\u2B18", "\\dicei": "\u2680", "\\diceii": "\u2681", "\\diceiii": "\u2682", "\\diceiv": "\u2683", "\\dicev": "\u2684", "\\dicevi": "\u2685", "\\digamma": "\u03DD", "\\dingasterisk": "\u273D", "\\ding{100}": "\u2744", "\\ding{101}": "\u2745", "\\ding{102}": "\u2746", "\\ding{103}": "\u2747", "\\ding{104}": "\u2748", "\\ding{105}": "\u2749", "\\ding{106}": "\u274A", "\\ding{107}": "\u274B", "\\ding{108}": "\u25CF", "\\ding{109}": "\u274D", "\\ding{110}": "\u25A0", "\\ding{111}": "\u274F", "\\ding{112}": "\u2750", "\\ding{113}": "\u2751", "\\ding{114}": "\u2752", "\\ding{115}": "\u25B2", "\\ding{116}": "\u25BC", "\\ding{117}": "\u25C6", "\\ding{118}": "\u2756", "\\ding{119}": "\u25D7", "\\ding{120}": "\u2758", "\\ding{121}": "\u2759", "\\ding{122}": "\u275A", "\\ding{123}": "\u275B", "\\ding{124}": "\u275C", "\\ding{125}": "\u275D", "\\ding{126}": "\u275E", "\\ding{161}": "\u2761", "\\ding{162}": "\u2762", "\\ding{163}": "\u2763", "\\ding{164}": "\u2764", "\\ding{165}": "\u2765", "\\ding{166}": "\u2766", "\\ding{167}": "\u2767", "\\ding{168}": "\u2663", "\\ding{169}": "\u2666", "\\ding{170}": "\u2665", "\\ding{171}": "\u2660", "\\ding{172}": "\u2460", "\\ding{173}": "\u2461", "\\ding{174}": "\u2462", "\\ding{175}": "\u2463", "\\ding{176}": "\u2464", "\\ding{177}": "\u2465", "\\ding{178}": "\u2466", "\\ding{179}": "\u2467", "\\ding{180}": "\u2468", "\\ding{181}": "\u2469", "\\ding{182}": "\u2776", "\\ding{183}": "\u2777", "\\ding{184}": "\u2778", "\\ding{185}": "\u2779", "\\ding{186}": "\u277A", "\\ding{187}": "\u277B", "\\ding{188}": "\u277C", "\\ding{189}": "\u277D", "\\ding{190}": "\u277E", "\\ding{191}": "\u277F", "\\ding{192}": "\u2780", "\\ding{193}": "\u2781", "\\ding{194}": "\u2782", "\\ding{195}": "\u2783", "\\ding{196}": "\u2784", "\\ding{197}": "\u2785", "\\ding{198}": "\u2786", "\\ding{199}": "\u2787", "\\ding{200}": "\u2788", "\\ding{201}": "\u2789", "\\ding{202}": "\u278A", "\\ding{203}": "\u278B", "\\ding{204}": "\u278C", "\\ding{205}": "\u278D", "\\ding{206}": "\u278E", "\\ding{207}": "\u278F", "\\ding{208}": "\u2790", "\\ding{209}": "\u2791", "\\ding{210}": "\u2792", "\\ding{211}": "\u2793", "\\ding{212}": "\u2794", "\\ding{216}": "\u2798", "\\ding{217}": "\u2799", "\\ding{218}": "\u279A", "\\ding{219}": "\u279B", "\\ding{220}": "\u279C", "\\ding{221}": "\u279D", "\\ding{222}": "\u279E", "\\ding{223}": "\u279F", "\\ding{224}": "\u27A0", "\\ding{225}": "\u27A1", "\\ding{226}": "\u27A2", "\\ding{227}": "\u27A3", "\\ding{228}": "\u27A4", "\\ding{229}": "\u27A5", "\\ding{230}": "\u27A6", "\\ding{231}": "\u27A7", "\\ding{232}": "\u27A8", "\\ding{233}": "\u27A9", "\\ding{234}": "\u27AA", "\\ding{235}": "\u27AB", "\\ding{236}": "\u27AC", "\\ding{237}": "\u27AD", "\\ding{238}": "\u27AE", "\\ding{239}": "\u27AF", "\\ding{241}": "\u27B1", "\\ding{242}": "\u27B2", "\\ding{243}": "\u27B3", "\\ding{244}": "\u27B4", "\\ding{245}": "\u27B5", "\\ding{246}": "\u27B6", "\\ding{247}": "\u27B7", "\\ding{248}": "\u27B8", "\\ding{249}": "\u27B9", "\\ding{250}": "\u27BA", "\\ding{251}": "\u27BB", "\\ding{252}": "\u27BC", "\\ding{253}": "\u27BD", "\\ding{254}": "\u27BE", "\\ding{33}": "\u2701", "\\ding{34}": "\u2702", "\\ding{35}": "\u2703", "\\ding{36}": "\u2704", "\\ding{37}": "\u260E", "\\ding{38}": "\u2706", "\\ding{39}": "\u2707", "\\ding{40}": "\u2708", "\\ding{41}": "\u2709", "\\ding{42}": "\u261B", "\\ding{43}": "\u261E", "\\ding{44}": "\u270C", "\\ding{45}": "\u270D", "\\ding{46}": "\u270E", "\\ding{47}": "\u270F", "\\ding{48}": "\u2710", "\\ding{49}": "\u2711", "\\ding{50}": "\u2712", "\\ding{51}": "\u2713", "\\ding{52}": "\u2714", "\\ding{53}": "\u2715", "\\ding{54}": "\u2716", "\\ding{55}": "\u2717", "\\ding{56}": "\u2718", "\\ding{57}": "\u2719", "\\ding{58}": "\u271A", "\\ding{59}": "\u271B", "\\ding{60}": "\u271C", "\\ding{61}": "\u271D", "\\ding{62}": "\u271E", "\\ding{63}": "\u271F", "\\ding{64}": "\u2720", "\\ding{65}": "\u2721", "\\ding{66}": "\u2722", "\\ding{67}": "\u2723", "\\ding{68}": "\u2724", "\\ding{69}": "\u2725", "\\ding{70}": "\u2726", "\\ding{71}": "\u2727", "\\ding{72}": "\u2605", "\\ding{73}": "\u2606", "\\ding{74}": "\u272A", "\\ding{75}": "\u272B", "\\ding{76}": "\u272C", "\\ding{77}": "\u272D", "\\ding{78}": "\u272E", "\\ding{79}": "\u272F", "\\ding{80}": "\u2730", "\\ding{81}": "\u2731", "\\ding{82}": "\u2732", "\\ding{83}": "\u2733", "\\ding{84}": "\u2734", "\\ding{85}": "\u2735", "\\ding{86}": "\u2736", "\\ding{87}": "\u2737", "\\ding{88}": "\u2738", "\\ding{89}": "\u2739", "\\ding{90}": "\u273A", "\\ding{91}": "\u273B", "\\ding{92}": "\u273C", "\\ding{93}": "\u273D", "\\ding{94}": "\u273E", "\\ding{95}": "\u273F", "\\ding{96}": "\u2740", "\\ding{97}": "\u2741", "\\ding{98}": "\u2742", "\\ding{99}": "\u2743", "\\disin": "\u22F2", "\\disjquant": "\u2A08", "\\div": "\xF7", "\\divideontimes": "\u22C7", "\\divslash": "\u2215", "\\dj": "\u0111", "\\dlsh": "\u21B2", "\\dot": "\u0307", "\\dotdiv": "\u2238", "\\doteq": "\u2250", "\\doteqdot": "\u2251", "\\dotequiv": "\u2A67", "\\dotminus": "\u2238", "\\dotplus": "\u2214", "\\dots": "\u2026", "\\dotsim": "\u2A6A", "\\dotsminusdots": "\u223A", "\\dottedcircle": "\u25CC", "\\dottedsquare": "\u2B1A", "\\dottimes": "\u2A30", "\\doublebarvee": "\u2A62", "\\doublebarwedge": "\u2A5E", "\\doubleplus": "\u29FA", "\\downarrow": "\u2193", "\\downarrowbar": "\u2913", "\\downarrowbarred": "\u2908", "\\downdasharrow": "\u21E3", "\\downdownarrows": "\u21CA", "\\downdownharpoons": "\u2965", "\\downfishtail": "\u297F", "\\downharpoonleft": "\u21C3", "\\downharpoonleftbar": "\u2959", "\\downharpoonright": "\u21C2", "\\downharpoonrightbar": "\u2955", "\\downharpoonsleftright": "\u2965", "\\downrightcurvedarrow": "\u2935", "\\downslopeellipsis": "\u22F1", "\\downtriangleleftblack": "\u29E8", "\\downtrianglerightblack": "\u29E9", "\\downuparrows": "\u21F5", "\\downupharpoonsleftright": "\u296F", "\\downwhitearrow": "\u21E9", "\\downzigzagarrow": "\u21AF", "\\dprime": "\u2033", "\\draftingarrow": "\u279B", "\\drbkarrow": "\u2910", "\\droang": "\u031A", "\\dsol": "\u29F6", "\\dsub": "\u2A64", "\\dualmap": "\u29DF", "\\earth": "\u2641", "\\egsdot": "\u2A98", "\\eighthnote": "\u266A", "\\elinters": "\u23E7", "\\ell": "\u2113", "\\elsdot": "\u2A97", "\\emptysetoarr": "\u29B3", "\\emptysetoarrl": "\u29B4", "\\emptysetobar": "\u29B1", "\\emptysetocirc": "\u29B2", "\\enclosecircle": "\u20DD", "\\enclosediamond": "\u20DF", "\\enclosesquare": "\u20DE", "\\enclosetriangle": "\u20E4", "\\enleadertwodots": "\u2025", "\\enspace": "\u2002", "\\eparsl": "\u29E3", "\\epsilon": "\u03F5", "\\eqcirc": "\u2256", "\\eqcolon": "\u2255", "\\eqdef": "\u225D", "\\eqdot": "\u2A66", "\\eqeq": "\u2A75", "\\eqeqeq": "\u2A76", "\\eqgtr": "\u22DD", "\\eqless": "\u22DC", "\\eqqgtr": "\u2A9A", "\\eqqless": "\u2A99", "\\eqqplus": "\u2A71", "\\eqqsim": "\u2A73", "\\eqqslantgtr": "\u2A9C", "\\eqqslantless": "\u2A9B", "\\eqsim": "\u2242", "\\eqslantgtr": "\u2A96", "\\eqslantless": "\u2A95", "\\equal": "=", "\\equalleftarrow": "\u2B40", "\\equalparallel": "\u22D5", "\\equalrightarrow": "\u2971", "\\equiv": "\u2261", "\\equivDD": "\u2A78", "\\equivVert": "\u2A68", "\\equivVvert": "\u2A69", "\\eqvparsl": "\u29E5", "\\errbarblackcircle": "\u29F3", "\\errbarblackdiamond": "\u29F1", "\\errbarblacksquare": "\u29EF", "\\errbarcircle": "\u29F2", "\\errbardiamond": "\u29F0", "\\errbarsquare": "\u29EE", "\\estimates": "\u2259", "\\eta": "\u03B7", "\\eth": "\xF0", "\\euro": "\u20AC", "\\exists": "\u2203", "\\fallingdotseq": "\u2252", "\\fbowtie": "\u29D3", "\\fbox{~~}": "\u25AD", "\\fcmp": "\u2A3E", "\\fdiagovnearrow": "\u292F", "\\fdiagovrdiag": "\u292C", "\\female": "\u2640", "\\ffun": "\u21FB", "\\finj": "\u2915", "\\fint": "\u2A0F", "\\fisheye": "\u25C9", "\\flat": "\u266D", "\\fltns": "\u23E5", "\\forall": "\u2200", "\\forcesextra": "\u22A8", "\\forks": "\u2ADD\u0338", "\\forksnot": "\u2ADD", "\\forkv": "\u2AD9", "\\fourthroot": "\u221C", "\\fourvdots": "\u2999", "\\fracslash": "\u2044", "\\frac{0}{3}": "\u2189", "\\frac{1}": "\u215F", "\\frac{1}{10}": "\u2152", "\\frac{1}{2}": "\xBD", "\\frac{1}{3}": "\u2153", "\\frac{1}{4}": "\xBC", "\\frac{1}{5}": "\u2155", "\\frac{1}{6}": "\u2159", "\\frac{1}{7}": "\u2150", "\\frac{1}{8}": "\u215B", "\\frac{1}{9}": "\u2151", "\\frac{2}{3}": "\u2154", "\\frac{2}{5}": "\u2156", "\\frac{3}{4}": "\xBE", "\\frac{3}{5}": "\u2157", "\\frac{3}{8}": "\u215C", "\\frac{4}{5}": "\u2158", "\\frac{5}{6}": "\u215A", "\\frac{5}{8}": "\u215D", "\\frac{7}{8}": "\u215E", "\\frown": "\u2322", "\\frownie": "\u2639", "\\fullouterjoin": "\u27D7", "\\gamma": "\u03B3", "\\ge": "\u2265", "\\gemini": "\u264A", "\\geq": "\u2265", "\\geqq": "\u2267", "\\geqqslant": "\u2AFA", "\\geqslant": "\u2A7E", "\\gescc": "\u2AA9", "\\gesdot": "\u2A80", "\\gesdoto": "\u2A82", "\\gesdotol": "\u2A84", "\\gesles": "\u2A94", "\\gg": "\u226B", "\\ggcurly": "\u2ABC", "\\ggg": "\u22D9", "\\gggnest": "\u2AF8", "\\gimel": "\u2137", "\\glE": "\u2A92", "\\gla": "\u2AA5", "\\gleichstark": "\u29E6", "\\glj": "\u2AA4", "\\gnapprox": "\u2A8A", "\\gneq": "\u2A88", "\\gneqq": "\u2269", "\\gnsim": "\u22E7", "\\grave": "\u0300", "\\greater": ">", "\\greaterequivlnt": "\u2273", "\\gsime": "\u2A8E", "\\gsiml": "\u2A90", "\\gtcc": "\u2AA7", "\\gtcir": "\u2A7A", "\\gtlpar": "\u29A0", "\\gtquest": "\u2A7C", "\\gtrapprox": "\u2A86", "\\gtrarr": "\u2978", "\\gtrdot": "\u22D7", "\\gtreqless": "\u22DB", "\\gtreqqless": "\u2A8C", "\\gtrless": "\u2277", "\\gtrsim": "\u2273", "\\guillemotleft": "\xAB", "\\guillemotright": "\xBB", "\\guilsinglleft": "\u2039", "\\guilsinglright": "\u203A", "\\gvertneqq": "\u2269\uFE00", "\\harrowextender": "\u23AF", "\\hash": "\u22D5", "\\hat": "\u2227", "\\hatapprox": "\u2A6F", "\\hbar": "\u0127", "\\heartsuit": "\u2661", "\\hebalef": "\u05D0", "\\hebayin": "\u05E2", "\\hebbet": "\u05D1", "\\hebdalet": "\u05D3", "\\hebfinalkaf": "\u05DA", "\\hebfinalmem": "\u05DD", "\\hebfinalnun": "\u05DF", "\\hebfinalpe": "\u05E3", "\\hebfinaltsadi": "\u05E5", "\\hebgimel": "\u05D2", "\\hebhe": "\u05D4", "\\hebhet": "\u05D7", "\\hebkaf": "\u05DB", "\\heblamed": "\u05DC", "\\hebmem": "\u05DE", "\\hebnun": "\u05E0", "\\hebpe": "\u05E4", "\\hebqof": "\u05E7", "\\hebresh": "\u05E8", "\\hebsamekh": "\u05E1", "\\hebshin": "\u05E9", "\\hebtav": "\u05EA", "\\hebtet": "\u05D8", "\\hebtsadi": "\u05E6", "\\hebvav": "\u05D5", "\\hebyod": "\u05D9", "\\hebzayin": "\u05D6", "\\hermitconjmatrix": "\u22B9", "\\hermitmatrix": "\u22B9", "\\hexagon": "\u2394", "\\hexagonblack": "\u2B23", "\\hknearrow": "\u2924", "\\hknwarrow": "\u2923", "\\hksearrow": "\u2925", "\\hkswarrow": "\u2926", "\\homothetic": "\u223B", "\\hookleftarrow": "\u21A9", "\\hookrightarrow": "\u21AA", "\\horizbar": "\u2015", "\\hourglass": "\u29D6", "\\house": "\u2302", "\\hphantom{,}": "\u2008", "\\hphantom{0}": "\u2007", "\\hrectangle": "\u25AD", "\\hrectangleblack": "\u25AC", "\\hslash": "\u210F", "\\hspace{0.166em}": "\u2006", "\\hspace{0.25em}": "\u2005", "\\hspace{0.6em}": "\u2002", "\\hspace{0pt}": "\u200B", "\\hyphenbullet": "\u2043", "\\hzigzag": "\u3030", "\\i": "\u0131", "\\iiiint": "\u2A0C", "\\iiint": "\u222D", "\\iinfin": "\u29DC", "\\iint": "\u222C", "\\ij": "\u0133", "\\image": "\u22B7", "\\imageof": "\u22B7", "\\imath": "\u{1D6A4}", "\\in": "\u2208", "\\increment": "\u2206", "\\infty": "\u221E", "\\int": "\u222B", "\\intBar": "\u2A0E", "\\intbar": "\u2A0D", "\\intbottom": "\u2321", "\\intcap": "\u2A19", "\\intclockwise": "\u2231", "\\intcup": "\u2A1A", "\\intercal": "\u22BA", "\\interleave": "\u2AF4", "\\intextender": "\u23AE", "\\intlarhk": "\u2A17", "\\intprod": "\u2A3C", "\\intprodr": "\u2A3D", "\\inttop": "\u2320", "\\intx": "\u2A18", "\\invamp": "\u214B", "\\invdiameter": "\u2349", "\\inversebullet": "\u25D8", "\\inversewhitecircle": "\u25D9", "\\invlazys": "\u223E", "\\invneg": "\u2310", "\\invnot": "\u2310", "\\invwhitelowerhalfcircle": "\u25DB", "\\invwhiteupperhalfcircle": "\u25DA", "\\iota": "\u03B9", "\\isinE": "\u22F9", "\\isindot": "\u22F5", "\\isinobar": "\u22F7", "\\isins": "\u22F4", "\\isinvb": "\u22F8", "\\j": "\u0237", "\\jmath": "\u{1D6A5}", "\\jupiter": "\u2643", "\\k": "\u0328", "\\kappa": "\u03BA", "\\kernelcontraction": "\u223B", "\\koppa": "\u03DF", "\\k{}": "\u02DB", "\\l": "\u0142", "\\lAngle": "\u27EA", "\\lBrace": "\u2983", "\\lBrack": "\u27E6", "\\lParen": "\u2985", "\\lambda": "\u03BB", "\\lang": "\u27EA", "\\langle": "\u27E8", "\\langledot": "\u2991", "\\laplac": "\u29E0", "\\lasp": "\u02BF", "\\lat": "\u2AAB", "\\late": "\u2AAD", "\\lazysinv": "\u223E", "\\lbag": "\u27C5", "\\lblkbrbrak": "\u2997", "\\lblot": "\u2989", "\\lbrace": "{", "\\lbracelend": "\u23A9", "\\lbracemid": "\u23A8", "\\lbraceuend": "\u23A7", "\\lbrack": "[", "\\lbrackextender": "\u23A2", "\\lbracklend": "\u23A3", "\\lbracklltick": "\u298F", "\\lbrackubar": "\u298B", "\\lbrackuend": "\u23A1", "\\lbrackultick": "\u298D", "\\lbrbrak": "\u3014", "\\lceil": "\u2308", "\\lcirclerightint": "\u2232", "\\lcurvyangle": "\u29FC", "\\ldots": "\u2026", "\\le": "\u2264", "\\left": "", "\\leftarrow": "\u2190", "\\leftarrowapprox": "\u2B4A", "\\leftarrowbackapprox": "\u2B42", "\\leftarrowbsimilar": "\u2B4B", "\\leftarrowless": "\u2977", "\\leftarrowonoplus": "\u2B32", "\\leftarrowplus": "\u2946", "\\leftarrowshortrightarrow": "\u2943", "\\leftarrowsimilar": "\u2973", "\\leftarrowsubset": "\u297A", "\\leftarrowtail": "\u21A2", "\\leftarrowtriangle": "\u21FD", "\\leftarrowx": "\u2B3E", "\\leftbarharpoon": "\u296A", "\\leftbkarrow": "\u290C", "\\leftcurvedarrow": "\u2B3F", "\\leftdasharrow": "\u21E0", "\\leftdbkarrow": "\u290E", "\\leftdbltail": "\u291B", "\\leftdotarrow": "\u2B38", "\\leftdowncurvedarrow": "\u2936", "\\leftfishtail": "\u297C", "\\leftharpoonaccent": "\u20D0", "\\leftharpoondown": "\u21BD", "\\leftharpoondownbar": "\u295E", "\\leftharpoonsupdown": "\u2962", "\\leftharpoonup": "\u21BC", "\\leftharpoonupbar": "\u295A", "\\leftharpoonupdash": "\u296A", "\\leftleftarrows": "\u21C7", "\\leftleftharpoons": "\u2962", "\\leftmoon": "\u263E", "\\leftouterjoin": "\u27D5", "\\leftrightarrow": "\u2194", "\\leftrightarrowcircle": "\u2948", "\\leftrightarrows": "\u21C6", "\\leftrightarrowtriangle": "\u21FF", "\\leftrightharpoon": "\u294A", "\\leftrightharpoondowndown": "\u2950", "\\leftrightharpoondownup": "\u294B", "\\leftrightharpoons": "\u21CB", "\\leftrightharpoonsdown": "\u2967", "\\leftrightharpoonsup": "\u2966", "\\leftrightharpoonupdown": "\u294A", "\\leftrightharpoonupup": "\u294E", "\\leftrightsquigarrow": "\u21AD", "\\leftslice": "\u2AA6", "\\leftsquigarrow": "\u21DC", "\\lefttail": "\u2919", "\\leftthreearrows": "\u2B31", "\\leftthreetimes": "\u22CB", "\\leftwavearrow": "\u219C", "\\leftwhitearrow": "\u21E6", "\\leo": "\u264C", "\\leq": "\u2264", "\\leqq": "\u2266", "\\leqqslant": "\u2AF9", "\\leqslant": "\u2A7D", "\\lescc": "\u2AA8", "\\lesdot": "\u2A7F", "\\lesdoto": "\u2A81", "\\lesdotor": "\u2A83", "\\lesges": "\u2A93", "\\less": "<", "\\lessapprox": "\u2A85", "\\lessdot": "\u22D6", "\\lesseqgtr": "\u22DA", "\\lesseqqgtr": "\u2A8B", "\\lessequivlnt": "\u2272", "\\lessgtr": "\u2276", "\\lesssim": "\u2272", "\\lfbowtie": "\u29D1", "\\lfloor": "\u230A", "\\lftimes": "\u29D4", "\\lgE": "\u2A91", "\\lgblkcircle": "\u2B24", "\\lgblksquare": "\u2B1B", "\\lgroup": "\u27EE", "\\lgwhtcircle": "\u25EF", "\\lgwhtsquare": "\u2B1C", "\\lhd": "\u25C1", "\\libra": "\u264E", "\\lightning": "\u21AF", "\\limg": "\u2987", "\\linefeed": "\u21B4", "\\ll": "\u226A", "\\llangle": "\u2989", "\\llarc": "\u25DF", "\\llblacktriangle": "\u25E3", "\\llbracket": "\u27E6", "\\llcorner": "\u231E", "\\llcurly": "\u2ABB", "\\lll": "\u22D8", "\\lllnest": "\u2AF7", "\\llparenthesis": "\u2987", "\\lltriangle": "\u25FA", "\\lmoustache": "\u23B0", "\\lnapprox": "\u2A89", "\\lneq": "\u2A87", "\\lneqq": "\u2268", "\\lnot": "\xAC", "\\lnsim": "\u22E6", "\\longdashv": "\u27DE", "\\longdivision": "\u27CC", "\\longleftarrow": "\u27F5", "\\longleftrightarrow": "\u27F7", "\\longleftsquigarrow": "\u2B33", "\\longmapsfrom": "\u27FB", "\\longmapsto": "\u27FC", "\\longrightarrow": "\u27F6", "\\longrightsquigarrow": "\u27FF", "\\looparrowleft": "\u21AB", "\\looparrowright": "\u21AC", "\\lowint": "\u2A1C", "\\lozenge": "\u25CA", "\\lozengeminus": "\u27E0", "\\lparen": "(", "\\lparenextender": "\u239C", "\\lparenlend": "\u239D", "\\lparenless": "\u2993", "\\lparenuend": "\u239B", "\\lrarc": "\u25DE", "\\lrblacktriangle": "\u25E2", "\\lrcorner": "\u231F", "\\lrtriangle": "\u25FF", "\\lrtriangleeq": "\u29E1", "\\lsime": "\u2A8D", "\\lsimg": "\u2A8F", "\\lsqhook": "\u2ACD", "\\ltcc": "\u2AA6", "\\ltcir": "\u2A79", "\\ltimes": "\u22C9", "\\ltlarr": "\u2976", "\\ltquest": "\u2A7B", "\\ltrivb": "\u29CF", "\\lvboxline": "\u23B8", "\\lvec": "\u20D0", "\\lvertneqq": "\u2268\uFE00", "\\lvzigzag": "\u29D8", "\\male": "\u2642", "\\maltese": "\u2720", "\\mapsdown": "\u21A7", "\\mapsfrom": "\u21A4", "\\mapsto": "\u21A6", "\\mapsup": "\u21A5", "\\mathampersand": "&", "\\mathatsign": "@", "\\mathbb{0}": "\u{1D7D8}", "\\mathbb{1}": "\u{1D7D9}", "\\mathbb{2}": "\u{1D7DA}", "\\mathbb{3}": "\u{1D7DB}", "\\mathbb{4}": "\u{1D7DC}", "\\mathbb{5}": "\u{1D7DD}", "\\mathbb{6}": "\u{1D7DE}", "\\mathbb{7}": "\u{1D7DF}", "\\mathbb{8}": "\u{1D7E0}", "\\mathbb{9}": "\u{1D7E1}", "\\mathbb{A}": "\u{1D538}", "\\mathbb{B}": "\u{1D539}", "\\mathbb{C}": "\u2102", "\\mathbb{D}": "\u{1D53B}", "\\mathbb{E}": "\u{1D53C}", "\\mathbb{F}": "\u{1D53D}", "\\mathbb{G}": "\u{1D53E}", "\\mathbb{H}": "\u210D", "\\mathbb{I}": "\u{1D540}", "\\mathbb{J}": "\u{1D541}", "\\mathbb{K}": "\u{1D542}", "\\mathbb{L}": "\u{1D543}", "\\mathbb{M}": "\u{1D544}", "\\mathbb{N}": "\u2115", "\\mathbb{O}": "\u{1D546}", "\\mathbb{P}": "\u2119", "\\mathbb{Q}": "\u211A", "\\mathbb{R}": "\u211D", "\\mathbb{S}": "\u{1D54A}", "\\mathbb{T}": "\u{1D54B}", "\\mathbb{U}": "\u{1D54C}", "\\mathbb{V}": "\u{1D54D}", "\\mathbb{W}": "\u{1D54E}", "\\mathbb{X}": "\u{1D54F}", "\\mathbb{Y}": "\u{1D550}", "\\mathbb{Z}": "\u2124", "\\mathbb{\\Gamma}": "\u213E", "\\mathbb{\\Pi}": "\u213F", "\\mathbb{\\Sigma}": "\u2140", "\\mathbb{\\gamma}": "\u213D", "\\mathbb{\\pi}": "\u213C", "\\mathbb{a}": "\u{1D552}", "\\mathbb{b}": "\u{1D553}", "\\mathbb{c}": "\u{1D554}", "\\mathbb{d}": "\u{1D555}", "\\mathbb{e}": "\u{1D556}", "\\mathbb{f}": "\u{1D557}", "\\mathbb{g}": "\u{1D558}", "\\mathbb{h}": "\u{1D559}", "\\mathbb{i}": "\u{1D55A}", "\\mathbb{j}": "\u{1D55B}", "\\mathbb{k}": "\u{1D55C}", "\\mathbb{l}": "\u{1D55D}", "\\mathbb{m}": "\u{1D55E}", "\\mathbb{n}": "\u{1D55F}", "\\mathbb{o}": "\u{1D560}", "\\mathbb{p}": "\u{1D561}", "\\mathbb{q}": "\u{1D562}", "\\mathbb{r}": "\u{1D563}", "\\mathbb{s}": "\u{1D564}", "\\mathbb{t}": "\u{1D565}", "\\mathbb{u}": "\u{1D566}", "\\mathbb{v}": "\u{1D567}", "\\mathbb{w}": "\u{1D568}", "\\mathbb{x}": "\u{1D569}", "\\mathbb{y}": "\u{1D56A}", "\\mathbb{z}": "\u{1D56B}", "\\mathbf{0}": "\u{1D7CE}", "\\mathbf{1}": "\u{1D7CF}", "\\mathbf{2}": "\u{1D7D0}", "\\mathbf{3}": "\u{1D7D1}", "\\mathbf{4}": "\u{1D7D2}", "\\mathbf{5}": "\u{1D7D3}", "\\mathbf{6}": "\u{1D7D4}", "\\mathbf{7}": "\u{1D7D5}", "\\mathbf{8}": "\u{1D7D6}", "\\mathbf{9}": "\u{1D7D7}", "\\mathbf{A}": "\u{1D400}", "\\mathbf{B}": "\u{1D401}", "\\mathbf{C}": "\u{1D402}", "\\mathbf{D}": "\u{1D403}", "\\mathbf{E}": "\u{1D404}", "\\mathbf{F}": "\u{1D405}", "\\mathbf{G}": "\u{1D406}", "\\mathbf{H}": "\u{1D407}", "\\mathbf{I}": "\u{1D408}", "\\mathbf{J}": "\u{1D409}", "\\mathbf{K}": "\u{1D40A}", "\\mathbf{L}": "\u{1D40B}", "\\mathbf{M}": "\u{1D40C}", "\\mathbf{N}": "\u{1D40D}", "\\mathbf{O}": "\u{1D40E}", "\\mathbf{P}": "\u{1D40F}", "\\mathbf{Q}": "\u{1D410}", "\\mathbf{R}": "\u{1D411}", "\\mathbf{S}": "\u{1D412}", "\\mathbf{T}": "\u{1D413}", "\\mathbf{U}": "\u{1D414}", "\\mathbf{V}": "\u{1D415}", "\\mathbf{W}": "\u{1D416}", "\\mathbf{X}": "\u{1D417}", "\\mathbf{Y}": "\u{1D418}", "\\mathbf{Z}": "\u{1D419}", "\\mathbf{\\Delta}": "\u{1D6AB}", "\\mathbf{\\Gamma}": "\u{1D6AA}", "\\mathbf{\\Lambda}": "\u{1D6B2}", "\\mathbf{\\Omega}": "\u{1D6C0}", "\\mathbf{\\Phi}": "\u{1D6BD}", "\\mathbf{\\Pi}": "\u{1D6B7}", "\\mathbf{\\Psi}": "\u{1D6BF}", "\\mathbf{\\Sigma}": "\u{1D6BA}", "\\mathbf{\\Theta}": "\u{1D6AF}", "\\mathbf{\\Upsilon}": "\u{1D6BC}", "\\mathbf{\\Xi}": "\u{1D6B5}", "\\mathbf{\\alpha}": "\u{1D6C2}", "\\mathbf{\\beta}": "\u{1D6C3}", "\\mathbf{\\delta}": "\u{1D6C5}", "\\mathbf{\\epsilon}": "\u{1D6C6}", "\\mathbf{\\eta}": "\u{1D6C8}", "\\mathbf{\\gamma}": "\u{1D6C4}", "\\mathbf{\\lambda}": "\u{1D6CC}", "\\mathbf{\\nabla}": "\u{1D6C1}", "\\mathbf{\\omega}": "\u{1D6DA}", "\\mathbf{\\phi}": "\u{1D6D7}", "\\mathbf{\\pi}": "\u{1D6D1}", "\\mathbf{\\psi}": "\u{1D6D9}", "\\mathbf{\\sigma}": "\u{1D6D4}", "\\mathbf{\\theta}": "\u{1D6C9}", "\\mathbf{\\upsilon}": "\u{1D6D6}", "\\mathbf{\\varkappa}": "\u{1D6DE}", "\\mathbf{\\varpi}": "\u{1D6E1}", "\\mathbf{\\varrho}": "\u{1D6E0}", "\\mathbf{\\varsigma}": "\u{1D6D3}", "\\mathbf{\\vartheta}": "\u{1D6B9}", "\\mathbf{\\xi}": "\u{1D6CF}", "\\mathbf{\\zeta}": "\u{1D6C7}", "\\mathbf{a}": "\u{1D41A}", "\\mathbf{b}": "\u{1D41B}", "\\mathbf{c}": "\u{1D41C}", "\\mathbf{d}": "\u{1D41D}", "\\mathbf{e}": "\u{1D41E}", "\\mathbf{f}": "\u{1D41F}", "\\mathbf{g}": "\u{1D420}", "\\mathbf{h}": "\u{1D421}", "\\mathbf{i}": "\u{1D422}", "\\mathbf{j}": "\u{1D423}", "\\mathbf{k}": "\u{1D424}", "\\mathbf{l}": "\u{1D425}", "\\mathbf{m}": "\u{1D426}", "\\mathbf{n}": "\u{1D427}", "\\mathbf{o}": "\u{1D428}", "\\mathbf{p}": "\u{1D429}", "\\mathbf{q}": "\u{1D42A}", "\\mathbf{r}": "\u{1D42B}", "\\mathbf{s}": "\u{1D42C}", "\\mathbf{t}": "\u{1D42D}", "\\mathbf{u}": "\u{1D42E}", "\\mathbf{v}": "\u{1D42F}", "\\mathbf{w}": "\u{1D430}", "\\mathbf{x}": "\u{1D431}", "\\mathbf{y}": "\u{1D432}", "\\mathbf{z}": "\u{1D433}", "\\mathbin{{:}\\!\\!{-}\\!\\!{:}}": "\u223A", "\\mathbit{A}": "\u{1D468}", "\\mathbit{B}": "\u{1D469}", "\\mathbit{C}": "\u{1D46A}", "\\mathbit{D}": "\u{1D46B}", "\\mathbit{E}": "\u{1D46C}", "\\mathbit{F}": "\u{1D46D}", "\\mathbit{G}": "\u{1D46E}", "\\mathbit{H}": "\u{1D46F}", "\\mathbit{I}": "\u{1D470}", "\\mathbit{J}": "\u{1D471}", "\\mathbit{K}": "\u{1D472}", "\\mathbit{L}": "\u{1D473}", "\\mathbit{M}": "\u{1D474}", "\\mathbit{N}": "\u{1D475}", "\\mathbit{O}": "\u{1D476}", "\\mathbit{P}": "\u{1D477}", "\\mathbit{Q}": "\u{1D478}", "\\mathbit{R}": "\u{1D479}", "\\mathbit{S}": "\u{1D47A}", "\\mathbit{T}": "\u{1D47B}", "\\mathbit{U}": "\u{1D47C}", "\\mathbit{V}": "\u{1D47D}", "\\mathbit{W}": "\u{1D47E}", "\\mathbit{X}": "\u{1D47F}", "\\mathbit{Y}": "\u{1D480}", "\\mathbit{Z}": "\u{1D481}", "\\mathbit{\\Delta}": "\u{1D71F}", "\\mathbit{\\Gamma}": "\u{1D71E}", "\\mathbit{\\Lambda}": "\u{1D726}", "\\mathbit{\\Omega}": "\u{1D734}", "\\mathbit{\\Phi}": "\u{1D731}", "\\mathbit{\\Pi}": "\u{1D72B}", "\\mathbit{\\Psi}": "\u{1D733}", "\\mathbit{\\Sigma}": "\u{1D72E}", "\\mathbit{\\Theta}": "\u{1D723}", "\\mathbit{\\Upsilon}": "\u{1D730}", "\\mathbit{\\Xi}": "\u{1D729}", "\\mathbit{\\alpha}": "\u{1D736}", "\\mathbit{\\beta}": "\u{1D737}", "\\mathbit{\\chi}": "\u{1D74C}", "\\mathbit{\\delta}": "\u{1D739}", "\\mathbit{\\epsilon}": "\u{1D73A}", "\\mathbit{\\eta}": "\u{1D73C}", "\\mathbit{\\gamma}": "\u{1D738}", "\\mathbit{\\imath}": "\u{1D73E}", "\\mathbit{\\kappa}": "\u{1D73F}", "\\mathbit{\\lambda}": "\u{1D740}", "\\mathbit{\\nabla}": "\u{1D735}", "\\mathbit{\\omega}": "\u{1D74E}", "\\mathbit{\\phi}": "\u{1D753}", "\\mathbit{\\pi}": "\u{1D745}", "\\mathbit{\\psi}": "\u{1D74D}", "\\mathbit{\\rho}": "\u{1D746}", "\\mathbit{\\sigma}": "\u{1D748}", "\\mathbit{\\tau}": "\u{1D749}", "\\mathbit{\\theta}": "\u{1D73D}", "\\mathbit{\\upsilon}": "\u{1D74A}", "\\mathbit{\\varkappa}": "\u{1D752}", "\\mathbit{\\varphi}": "\u{1D74B}", "\\mathbit{\\varpi}": "\u{1D755}", "\\mathbit{\\varrho}": "\u{1D754}", "\\mathbit{\\varsigma}": "\u{1D747}", "\\mathbit{\\vartheta}": "\u{1D751}", "\\mathbit{\\xi}": "\u{1D743}", "\\mathbit{\\zeta}": "\u{1D73B}", "\\mathbit{a}": "\u{1D482}", "\\mathbit{b}": "\u{1D483}", "\\mathbit{c}": "\u{1D484}", "\\mathbit{d}": "\u{1D485}", "\\mathbit{e}": "\u{1D486}", "\\mathbit{f}": "\u{1D487}", "\\mathbit{g}": "\u{1D488}", "\\mathbit{h}": "\u{1D489}", "\\mathbit{i}": "\u{1D48A}", "\\mathbit{j}": "\u{1D48B}", "\\mathbit{k}": "\u{1D48C}", "\\mathbit{l}": "\u{1D48D}", "\\mathbit{m}": "\u{1D48E}", "\\mathbit{n}": "\u{1D48F}", "\\mathbit{o}": "\u{1D490}", "\\mathbit{p}": "\u{1D491}", "\\mathbit{q}": "\u{1D492}", "\\mathbit{r}": "\u{1D493}", "\\mathbit{s}": "\u{1D494}", "\\mathbit{t}": "\u{1D495}", "\\mathbit{u}": "\u{1D496}", "\\mathbit{v}": "\u{1D497}", "\\mathbit{w}": "\u{1D498}", "\\mathbit{x}": "\u{1D499}", "\\mathbit{y}": "\u{1D49A}", "\\mathbit{z}": "\u{1D49B}", "\\mathcolon": ":", "\\mathcomma": ",", "\\mathdollar": "$", "\\mathexclam": "!", "\\mathfrak{A}": "\u{1D504}", "\\mathfrak{B}": "\u{1D505}", "\\mathfrak{C}": "\u212D", "\\mathfrak{D}": "\u{1D507}", "\\mathfrak{E}": "\u{1D508}", "\\mathfrak{F}": "\u{1D509}", "\\mathfrak{G}": "\u{1D50A}", "\\mathfrak{H}": "\u210C", "\\mathfrak{I}": "\u2111", "\\mathfrak{J}": "\u{1D50D}", "\\mathfrak{K}": "\u{1D50E}", "\\mathfrak{L}": "\u{1D50F}", "\\mathfrak{M}": "\u{1D510}", "\\mathfrak{N}": "\u{1D511}", "\\mathfrak{O}": "\u{1D512}", "\\mathfrak{P}": "\u{1D513}", "\\mathfrak{Q}": "\u{1D514}", "\\mathfrak{R}": "\u211C", "\\mathfrak{S}": "\u{1D516}", "\\mathfrak{T}": "\u{1D517}", "\\mathfrak{U}": "\u{1D518}", "\\mathfrak{V}": "\u{1D519}", "\\mathfrak{W}": "\u{1D51A}", "\\mathfrak{X}": "\u{1D51B}", "\\mathfrak{Y}": "\u{1D51C}", "\\mathfrak{Z}": "\u2128", "\\mathfrak{a}": "\u{1D51E}", "\\mathfrak{b}": "\u{1D51F}", "\\mathfrak{c}": "\u{1D520}", "\\mathfrak{d}": "\u{1D521}", "\\mathfrak{e}": "\u{1D522}", "\\mathfrak{f}": "\u{1D523}", "\\mathfrak{g}": "\u{1D524}", "\\mathfrak{h}": "\u{1D525}", "\\mathfrak{i}": "\u{1D526}", "\\mathfrak{j}": "\u{1D527}", "\\mathfrak{k}": "\u{1D528}", "\\mathfrak{l}": "\u{1D529}", "\\mathfrak{m}": "\u{1D52A}", "\\mathfrak{n}": "\u{1D52B}", "\\mathfrak{o}": "\u{1D52C}", "\\mathfrak{p}": "\u{1D52D}", "\\mathfrak{q}": "\u{1D52E}", "\\mathfrak{r}": "\u{1D52F}", "\\mathfrak{s}": "\u{1D530}", "\\mathfrak{t}": "\u{1D531}", "\\mathfrak{u}": "\u{1D532}", "\\mathfrak{v}": "\u{1D533}", "\\mathfrak{w}": "\u{1D534}", "\\mathfrak{x}": "\u{1D535}", "\\mathfrak{y}": "\u{1D536}", "\\mathfrak{z}": "\u{1D537}", "\\mathhyphen": "\u2010", "\\mathmit{A}": "\u{1D4D0}", "\\mathmit{B}": "\u{1D4D1}", "\\mathmit{C}": "\u{1D4D2}", "\\mathmit{D}": "\u{1D4D3}", "\\mathmit{E}": "\u{1D4D4}", "\\mathmit{F}": "\u{1D4D5}", "\\mathmit{G}": "\u{1D4D6}", "\\mathmit{H}": "\u{1D4D7}", "\\mathmit{I}": "\u{1D4D8}", "\\mathmit{J}": "\u{1D4D9}", "\\mathmit{K}": "\u{1D4DA}", "\\mathmit{L}": "\u{1D4DB}", "\\mathmit{M}": "\u{1D4DC}", "\\mathmit{N}": "\u{1D4DD}", "\\mathmit{O}": "\u{1D4DE}", "\\mathmit{P}": "\u{1D4DF}", "\\mathmit{Q}": "\u{1D4E0}", "\\mathmit{R}": "\u{1D4E1}", "\\mathmit{S}": "\u{1D4E2}", "\\mathmit{T}": "\u{1D4E3}", "\\mathmit{U}": "\u{1D4E4}", "\\mathmit{V}": "\u{1D4E5}", "\\mathmit{W}": "\u{1D4E6}", "\\mathmit{X}": "\u{1D4E7}", "\\mathmit{Y}": "\u{1D4E8}", "\\mathmit{Z}": "\u{1D4E9}", "\\mathmit{a}": "\u{1D4EA}", "\\mathmit{b}": "\u{1D4EB}", "\\mathmit{c}": "\u{1D4EC}", "\\mathmit{d}": "\u{1D4ED}", "\\mathmit{e}": "\u{1D4EE}", "\\mathmit{f}": "\u{1D4EF}", "\\mathmit{g}": "\u{1D4F0}", "\\mathmit{h}": "\u{1D4F1}", "\\mathmit{i}": "\u{1D4F2}", "\\mathmit{j}": "\u{1D4F3}", "\\mathmit{k}": "\u{1D4F4}", "\\mathmit{l}": "\u{1D4F5}", "\\mathmit{m}": "\u{1D4F6}", "\\mathmit{n}": "\u{1D4F7}", "\\mathmit{o}": "\u{1D4F8}", "\\mathmit{p}": "\u{1D4F9}", "\\mathmit{q}": "\u{1D4FA}", "\\mathmit{r}": "\u{1D4FB}", "\\mathmit{s}": "\u{1D4FC}", "\\mathmit{t}": "\u{1D4FD}", "\\mathmit{u}": "\u{1D4FE}", "\\mathmit{v}": "\u{1D4FF}", "\\mathmit{w}": "\u{1D500}", "\\mathmit{x}": "\u{1D501}", "\\mathmit{y}": "\u{1D502}", "\\mathmit{z}": "\u{1D503}", "\\mathoctothorpe": "#", "\\mathparagraph": "\xB6", "\\mathpercent": "%", "\\mathperiod": ".", "\\mathplus": "+", "\\mathquestion": "?", "\\mathratio": "\u2236", "\\mathring": "\u030A", "\\mathrm{'Y}": "\u03A5\u0301", "\\mathrm{'\\Omega}": "\u03A9\u0301", "\\mathrm{\\ddot{I}}": "\u0399\u0308", "\\mathrm{\\ddot{Y}}": "\u03A5\u0308", "\\mathscr{A}": "\u{1D49C}", "\\mathscr{B}": "\u212C", "\\mathscr{C}": "\u{1D49E}", "\\mathscr{D}": "\u{1D49F}", "\\mathscr{E}": "\u2130", "\\mathscr{F}": "\u2131", "\\mathscr{G}": "\u{1D4A2}", "\\mathscr{H}": "\u210B", "\\mathscr{I}": "\u2110", "\\mathscr{J}": "\u{1D4A5}", "\\mathscr{K}": "\u{1D4A6}", "\\mathscr{L}": "\u2112", "\\mathscr{M}": "\u2133", "\\mathscr{N}": "\u{1D4A9}", "\\mathscr{O}": "\u{1D4AA}", "\\mathscr{P}": "\u{1D4AB}", "\\mathscr{Q}": "\u{1D4AC}", "\\mathscr{R}": "\u211B", "\\mathscr{S}": "\u{1D4AE}", "\\mathscr{T}": "\u{1D4AF}", "\\mathscr{U}": "\u{1D4B0}", "\\mathscr{V}": "\u{1D4B1}", "\\mathscr{W}": "\u{1D4B2}", "\\mathscr{X}": "\u{1D4B3}", "\\mathscr{Y}": "\u{1D4B4}", "\\mathscr{Z}": "\u{1D4B5}", "\\mathscr{a}": "\u{1D4B6}", "\\mathscr{b}": "\u{1D4B7}", "\\mathscr{c}": "\u{1D4B8}", "\\mathscr{d}": "\u{1D4B9}", "\\mathscr{e}": "\u212F", "\\mathscr{f}": "\u{1D4BB}", "\\mathscr{g}": "\u210A", "\\mathscr{h}": "\u{1D4BD}", "\\mathscr{i}": "\u{1D4BE}", "\\mathscr{j}": "\u{1D4BF}", "\\mathscr{k}": "\u{1D4C0}", "\\mathscr{l}": "\u{1D4C1}", "\\mathscr{m}": "\u{1D4C2}", "\\mathscr{n}": "\u{1D4C3}", "\\mathscr{o}": "\u2134", "\\mathscr{p}": "\u{1D4C5}", "\\mathscr{q}": "\u{1D4C6}", "\\mathscr{r}": "\u{1D4C7}", "\\mathscr{s}": "\u{1D4C8}", "\\mathscr{t}": "\u{1D4C9}", "\\mathscr{u}": "\u{1D4CA}", "\\mathscr{v}": "\u{1D4CB}", "\\mathscr{w}": "\u{1D4CC}", "\\mathscr{x}": "\u{1D4CD}", "\\mathscr{y}": "\u{1D4CE}", "\\mathscr{z}": "\u{1D4CF}", "\\mathsection": "\xA7", "\\mathsemicolon": ";", "\\mathsfbfsl{A}": "\u{1D63C}", "\\mathsfbfsl{B}": "\u{1D63D}", "\\mathsfbfsl{C}": "\u{1D63E}", "\\mathsfbfsl{D}": "\u{1D63F}", "\\mathsfbfsl{E}": "\u{1D640}", "\\mathsfbfsl{F}": "\u{1D641}", "\\mathsfbfsl{G}": "\u{1D642}", "\\mathsfbfsl{H}": "\u{1D643}", "\\mathsfbfsl{I}": "\u{1D644}", "\\mathsfbfsl{J}": "\u{1D645}", "\\mathsfbfsl{K}": "\u{1D646}", "\\mathsfbfsl{L}": "\u{1D647}", "\\mathsfbfsl{M}": "\u{1D648}", "\\mathsfbfsl{N}": "\u{1D649}", "\\mathsfbfsl{O}": "\u{1D64A}", "\\mathsfbfsl{P}": "\u{1D64B}", "\\mathsfbfsl{Q}": "\u{1D64C}", "\\mathsfbfsl{R}": "\u{1D64D}", "\\mathsfbfsl{S}": "\u{1D64E}", "\\mathsfbfsl{T}": "\u{1D64F}", "\\mathsfbfsl{U}": "\u{1D650}", "\\mathsfbfsl{V}": "\u{1D651}", "\\mathsfbfsl{W}": "\u{1D652}", "\\mathsfbfsl{X}": "\u{1D653}", "\\mathsfbfsl{Y}": "\u{1D654}", "\\mathsfbfsl{Z}": "\u{1D655}", "\\mathsfbfsl{\\Delta}": "\u{1D793}", "\\mathsfbfsl{\\Gamma}": "\u{1D792}", "\\mathsfbfsl{\\Lambda}": "\u{1D79A}", "\\mathsfbfsl{\\Omega}": "\u{1D7A8}", "\\mathsfbfsl{\\Phi}": "\u{1D7A5}", "\\mathsfbfsl{\\Pi}": "\u{1D79F}", "\\mathsfbfsl{\\Psi}": "\u{1D7A7}", "\\mathsfbfsl{\\Sigma}": "\u{1D7A2}", "\\mathsfbfsl{\\Theta}": "\u{1D797}", "\\mathsfbfsl{\\Upsilon}": "\u{1D7A4}", "\\mathsfbfsl{\\Xi}": "\u{1D79D}", "\\mathsfbfsl{\\alpha}": "\u{1D7AA}", "\\mathsfbfsl{\\beta}": "\u{1D7AB}", "\\mathsfbfsl{\\chi}": "\u{1D7C0}", "\\mathsfbfsl{\\delta}": "\u{1D7AD}", "\\mathsfbfsl{\\eta}": "\u{1D7B0}", "\\mathsfbfsl{\\gamma}": "\u{1D7AC}", "\\mathsfbfsl{\\imath}": "\u{1D7B2}", "\\mathsfbfsl{\\kappa}": "\u{1D7B3}", "\\mathsfbfsl{\\lambda}": "\u{1D7B4}", "\\mathsfbfsl{\\nabla}": "\u{1D7A9}", "\\mathsfbfsl{\\omega}": "\u{1D7C2}", "\\mathsfbfsl{\\phi}": "\u{1D7C7}", "\\mathsfbfsl{\\pi}": "\u{1D7B9}", "\\mathsfbfsl{\\psi}": "\u{1D7C1}", "\\mathsfbfsl{\\rho}": "\u{1D7BA}", "\\mathsfbfsl{\\sigma}": "\u{1D7BC}", "\\mathsfbfsl{\\tau}": "\u{1D7BD}", "\\mathsfbfsl{\\theta}": "\u{1D7B1}", "\\mathsfbfsl{\\upsilon}": "\u{1D7BE}", "\\mathsfbfsl{\\varepsilon}": "\u{1D7AE}", "\\mathsfbfsl{\\varkappa}": "\u{1D7C6}", "\\mathsfbfsl{\\varphi}": "\u{1D7BF}", "\\mathsfbfsl{\\varpi}": "\u{1D7C9}", "\\mathsfbfsl{\\varrho}": "\u{1D7C8}", "\\mathsfbfsl{\\varsigma}": "\u{1D7BB}", "\\mathsfbfsl{\\vartheta}": "\u{1D7C5}", "\\mathsfbfsl{\\xi}": "\u{1D7B7}", "\\mathsfbfsl{\\zeta}": "\u{1D7AF}", "\\mathsfbfsl{a}": "\u{1D656}", "\\mathsfbfsl{b}": "\u{1D657}", "\\mathsfbfsl{c}": "\u{1D658}", "\\mathsfbfsl{d}": "\u{1D659}", "\\mathsfbfsl{e}": "\u{1D65A}", "\\mathsfbfsl{f}": "\u{1D65B}", "\\mathsfbfsl{g}": "\u{1D65C}", "\\mathsfbfsl{h}": "\u{1D65D}", "\\mathsfbfsl{i}": "\u{1D65E}", "\\mathsfbfsl{j}": "\u{1D65F}", "\\mathsfbfsl{k}": "\u{1D660}", "\\mathsfbfsl{l}": "\u{1D661}", "\\mathsfbfsl{m}": "\u{1D662}", "\\mathsfbfsl{n}": "\u{1D663}", "\\mathsfbfsl{o}": "\u{1D664}", "\\mathsfbfsl{p}": "\u{1D665}", "\\mathsfbfsl{q}": "\u{1D666}", "\\mathsfbfsl{r}": "\u{1D667}", "\\mathsfbfsl{s}": "\u{1D668}", "\\mathsfbfsl{t}": "\u{1D669}", "\\mathsfbfsl{u}": "\u{1D66A}", "\\mathsfbfsl{v}": "\u{1D66B}", "\\mathsfbfsl{w}": "\u{1D66C}", "\\mathsfbfsl{x}": "\u{1D66D}", "\\mathsfbfsl{y}": "\u{1D66E}", "\\mathsfbfsl{z}": "\u{1D66F}", "\\mathsfbf{0}": "\u{1D7EC}", "\\mathsfbf{1}": "\u{1D7ED}", "\\mathsfbf{2}": "\u{1D7EE}", "\\mathsfbf{3}": "\u{1D7EF}", "\\mathsfbf{4}": "\u{1D7F0}", "\\mathsfbf{5}": "\u{1D7F1}", "\\mathsfbf{6}": "\u{1D7F2}", "\\mathsfbf{7}": "\u{1D7F3}", "\\mathsfbf{8}": "\u{1D7F4}", "\\mathsfbf{9}": "\u{1D7F5}", "\\mathsfbf{A}": "\u{1D5D4}", "\\mathsfbf{B}": "\u{1D5D5}", "\\mathsfbf{C}": "\u{1D5D6}", "\\mathsfbf{D}": "\u{1D5D7}", "\\mathsfbf{E}": "\u{1D5D8}", "\\mathsfbf{F}": "\u{1D5D9}", "\\mathsfbf{G}": "\u{1D5DA}", "\\mathsfbf{H}": "\u{1D5DB}", "\\mathsfbf{I}": "\u{1D5DC}", "\\mathsfbf{J}": "\u{1D5DD}", "\\mathsfbf{K}": "\u{1D5DE}", "\\mathsfbf{L}": "\u{1D5DF}", "\\mathsfbf{M}": "\u{1D5E0}", "\\mathsfbf{N}": "\u{1D5E1}", "\\mathsfbf{O}": "\u{1D5E2}", "\\mathsfbf{P}": "\u{1D5E3}", "\\mathsfbf{Q}": "\u{1D5E4}", "\\mathsfbf{R}": "\u{1D5E5}", "\\mathsfbf{S}": "\u{1D5E6}", "\\mathsfbf{T}": "\u{1D5E7}", "\\mathsfbf{U}": "\u{1D5E8}", "\\mathsfbf{V}": "\u{1D5E9}", "\\mathsfbf{W}": "\u{1D5EA}", "\\mathsfbf{X}": "\u{1D5EB}", "\\mathsfbf{Y}": "\u{1D5EC}", "\\mathsfbf{Z}": "\u{1D5ED}", "\\mathsfbf{\\Delta}": "\u{1D759}", "\\mathsfbf{\\Gamma}": "\u{1D758}", "\\mathsfbf{\\Lambda}": "\u{1D760}", "\\mathsfbf{\\Omega}": "\u{1D76E}", "\\mathsfbf{\\Phi}": "\u{1D76B}", "\\mathsfbf{\\Pi}": "\u{1D765}", "\\mathsfbf{\\Psi}": "\u{1D76D}", "\\mathsfbf{\\Sigma}": "\u{1D768}", "\\mathsfbf{\\Theta}": "\u{1D75D}", "\\mathsfbf{\\Upsilon}": "\u{1D76A}", "\\mathsfbf{\\Xi}": "\u{1D763}", "\\mathsfbf{\\alpha}": "\u{1D770}", "\\mathsfbf{\\beta}": "\u{1D771}", "\\mathsfbf{\\chi}": "\u{1D786}", "\\mathsfbf{\\delta}": "\u{1D773}", "\\mathsfbf{\\eta}": "\u{1D776}", "\\mathsfbf{\\gamma}": "\u{1D772}", "\\mathsfbf{\\imath}": "\u{1D778}", "\\mathsfbf{\\kappa}": "\u{1D779}", "\\mathsfbf{\\lambda}": "\u{1D77A}", "\\mathsfbf{\\nabla}": "\u{1D76F}", "\\mathsfbf{\\omega}": "\u{1D788}", "\\mathsfbf{\\phi}": "\u{1D78D}", "\\mathsfbf{\\pi}": "\u{1D77F}", "\\mathsfbf{\\psi}": "\u{1D787}", "\\mathsfbf{\\rho}": "\u{1D780}", "\\mathsfbf{\\sigma}": "\u{1D782}", "\\mathsfbf{\\tau}": "\u{1D783}", "\\mathsfbf{\\theta}": "\u{1D777}", "\\mathsfbf{\\upsilon}": "\u{1D784}", "\\mathsfbf{\\varepsilon}": "\u{1D774}", "\\mathsfbf{\\varkappa}": "\u{1D78C}", "\\mathsfbf{\\varphi}": "\u{1D785}", "\\mathsfbf{\\varpi}": "\u{1D78F}", "\\mathsfbf{\\varrho}": "\u{1D78E}", "\\mathsfbf{\\varsigma}": "\u{1D781}", "\\mathsfbf{\\vartheta}": "\u{1D78B}", "\\mathsfbf{\\xi}": "\u{1D77D}", "\\mathsfbf{\\zeta}": "\u{1D775}", "\\mathsfbf{a}": "\u{1D5EE}", "\\mathsfbf{b}": "\u{1D5EF}", "\\mathsfbf{c}": "\u{1D5F0}", "\\mathsfbf{d}": "\u{1D5F1}", "\\mathsfbf{e}": "\u{1D5F2}", "\\mathsfbf{f}": "\u{1D5F3}", "\\mathsfbf{g}": "\u{1D5F4}", "\\mathsfbf{h}": "\u{1D5F5}", "\\mathsfbf{i}": "\u{1D5F6}", "\\mathsfbf{j}": "\u{1D5F7}", "\\mathsfbf{k}": "\u{1D5F8}", "\\mathsfbf{l}": "\u{1D5F9}", "\\mathsfbf{m}": "\u{1D5FA}", "\\mathsfbf{n}": "\u{1D5FB}", "\\mathsfbf{o}": "\u{1D5FC}", "\\mathsfbf{p}": "\u{1D5FD}", "\\mathsfbf{q}": "\u{1D5FE}", "\\mathsfbf{r}": "\u{1D5FF}", "\\mathsfbf{s}": "\u{1D600}", "\\mathsfbf{t}": "\u{1D601}", "\\mathsfbf{u}": "\u{1D602}", "\\mathsfbf{v}": "\u{1D603}", "\\mathsfbf{w}": "\u{1D604}", "\\mathsfbf{x}": "\u{1D605}", "\\mathsfbf{y}": "\u{1D606}", "\\mathsfbf{z}": "\u{1D607}", "\\mathsfsl{A}": "\u{1D608}", "\\mathsfsl{B}": "\u{1D609}", "\\mathsfsl{C}": "\u{1D60A}", "\\mathsfsl{D}": "\u{1D60B}", "\\mathsfsl{E}": "\u{1D60C}", "\\mathsfsl{F}": "\u{1D60D}", "\\mathsfsl{G}": "\u{1D60E}", "\\mathsfsl{H}": "\u{1D60F}", "\\mathsfsl{I}": "\u{1D610}", "\\mathsfsl{J}": "\u{1D611}", "\\mathsfsl{K}": "\u{1D612}", "\\mathsfsl{L}": "\u{1D613}", "\\mathsfsl{M}": "\u{1D614}", "\\mathsfsl{N}": "\u{1D615}", "\\mathsfsl{O}": "\u{1D616}", "\\mathsfsl{P}": "\u{1D617}", "\\mathsfsl{Q}": "\u{1D618}", "\\mathsfsl{R}": "\u{1D619}", "\\mathsfsl{S}": "\u{1D61A}", "\\mathsfsl{T}": "\u{1D61B}", "\\mathsfsl{U}": "\u{1D61C}", "\\mathsfsl{V}": "\u{1D61D}", "\\mathsfsl{W}": "\u{1D61E}", "\\mathsfsl{X}": "\u{1D61F}", "\\mathsfsl{Y}": "\u{1D620}", "\\mathsfsl{Z}": "\u{1D621}", "\\mathsfsl{a}": "\u{1D622}", "\\mathsfsl{b}": "\u{1D623}", "\\mathsfsl{c}": "\u{1D624}", "\\mathsfsl{d}": "\u{1D625}", "\\mathsfsl{e}": "\u{1D626}", "\\mathsfsl{f}": "\u{1D627}", "\\mathsfsl{g}": "\u{1D628}", "\\mathsfsl{h}": "\u{1D629}", "\\mathsfsl{i}": "\u{1D62A}", "\\mathsfsl{j}": "\u{1D62B}", "\\mathsfsl{k}": "\u{1D62C}", "\\mathsfsl{l}": "\u{1D62D}", "\\mathsfsl{m}": "\u{1D62E}", "\\mathsfsl{n}": "\u{1D62F}", "\\mathsfsl{o}": "\u{1D630}", "\\mathsfsl{p}": "\u{1D631}", "\\mathsfsl{q}": "\u{1D632}", "\\mathsfsl{r}": "\u{1D633}", "\\mathsfsl{s}": "\u{1D634}", "\\mathsfsl{t}": "\u{1D635}", "\\mathsfsl{u}": "\u{1D636}", "\\mathsfsl{v}": "\u{1D637}", "\\mathsfsl{w}": "\u{1D638}", "\\mathsfsl{x}": "\u{1D639}", "\\mathsfsl{y}": "\u{1D63A}", "\\mathsfsl{z}": "\u{1D63B}", "\\mathsf{0}": "\u{1D7E2}", "\\mathsf{1}": "\u{1D7E3}", "\\mathsf{2}": "\u{1D7E4}", "\\mathsf{3}": "\u{1D7E5}", "\\mathsf{4}": "\u{1D7E6}", "\\mathsf{5}": "\u{1D7E7}", "\\mathsf{6}": "\u{1D7E8}", "\\mathsf{7}": "\u{1D7E9}", "\\mathsf{8}": "\u{1D7EA}", "\\mathsf{9}": "\u{1D7EB}", "\\mathsf{A}": "\u{1D5A0}", "\\mathsf{B}": "\u{1D5A1}", "\\mathsf{C}": "\u{1D5A2}", "\\mathsf{D}": "\u{1D5A3}", "\\mathsf{E}": "\u{1D5A4}", "\\mathsf{F}": "\u{1D5A5}", "\\mathsf{G}": "\u{1D5A6}", "\\mathsf{H}": "\u{1D5A7}", "\\mathsf{I}": "\u{1D5A8}", "\\mathsf{J}": "\u{1D5A9}", "\\mathsf{K}": "\u{1D5AA}", "\\mathsf{L}": "\u{1D5AB}", "\\mathsf{M}": "\u{1D5AC}", "\\mathsf{N}": "\u{1D5AD}", "\\mathsf{O}": "\u{1D5AE}", "\\mathsf{P}": "\u{1D5AF}", "\\mathsf{Q}": "\u{1D5B0}", "\\mathsf{R}": "\u{1D5B1}", "\\mathsf{S}": "\u{1D5B2}", "\\mathsf{T}": "\u{1D5B3}", "\\mathsf{U}": "\u{1D5B4}", "\\mathsf{V}": "\u{1D5B5}", "\\mathsf{W}": "\u{1D5B6}", "\\mathsf{X}": "\u{1D5B7}", "\\mathsf{Y}": "\u{1D5B8}", "\\mathsf{Z}": "\u{1D5B9}", "\\mathsf{a}": "\u{1D5BA}", "\\mathsf{b}": "\u{1D5BB}", "\\mathsf{c}": "\u{1D5BC}", "\\mathsf{d}": "\u{1D5BD}", "\\mathsf{e}": "\u{1D5BE}", "\\mathsf{f}": "\u{1D5BF}", "\\mathsf{g}": "\u{1D5C0}", "\\mathsf{h}": "\u{1D5C1}", "\\mathsf{i}": "\u{1D5C2}", "\\mathsf{j}": "\u{1D5C3}", "\\mathsf{k}": "\u{1D5C4}", "\\mathsf{l}": "\u{1D5C5}", "\\mathsf{m}": "\u{1D5C6}", "\\mathsf{n}": "\u{1D5C7}", "\\mathsf{o}": "\u{1D5C8}", "\\mathsf{p}": "\u{1D5C9}", "\\mathsf{q}": "\u{1D5CA}", "\\mathsf{r}": "\u{1D5CB}", "\\mathsf{s}": "\u{1D5CC}", "\\mathsf{t}": "\u{1D5CD}", "\\mathsf{u}": "\u{1D5CE}", "\\mathsf{v}": "\u{1D5CF}", "\\mathsf{w}": "\u{1D5D0}", "\\mathsf{x}": "\u{1D5D1}", "\\mathsf{y}": "\u{1D5D2}", "\\mathsf{z}": "\u{1D5D3}", "\\mathslash": "/", "\\mathsterling": "\xA3", "\\mathtt{0}": "\u{1D7F6}", "\\mathtt{1}": "\u{1D7F7}", "\\mathtt{2}": "\u{1D7F8}", "\\mathtt{3}": "\u{1D7F9}", "\\mathtt{4}": "\u{1D7FA}", "\\mathtt{5}": "\u{1D7FB}", "\\mathtt{6}": "\u{1D7FC}", "\\mathtt{7}": "\u{1D7FD}", "\\mathtt{8}": "\u{1D7FE}", "\\mathtt{9}": "\u{1D7FF}", "\\mathtt{A}": "\u{1D670}", "\\mathtt{B}": "\u{1D671}", "\\mathtt{C}": "\u{1D672}", "\\mathtt{D}": "\u{1D673}", "\\mathtt{E}": "\u{1D674}", "\\mathtt{F}": "\u{1D675}", "\\mathtt{G}": "\u{1D676}", "\\mathtt{H}": "\u{1D677}", "\\mathtt{I}": "\u{1D678}", "\\mathtt{J}": "\u{1D679}", "\\mathtt{K}": "\u{1D67A}", "\\mathtt{L}": "\u{1D67B}", "\\mathtt{M}": "\u{1D67C}", "\\mathtt{N}": "\u{1D67D}", "\\mathtt{O}": "\u{1D67E}", "\\mathtt{P}": "\u{1D67F}", "\\mathtt{Q}": "\u{1D680}", "\\mathtt{R}": "\u{1D681}", "\\mathtt{S}": "\u{1D682}", "\\mathtt{T}": "\u{1D683}", "\\mathtt{U}": "\u{1D684}", "\\mathtt{V}": "\u{1D685}", "\\mathtt{W}": "\u{1D686}", "\\mathtt{X}": "\u{1D687}", "\\mathtt{Y}": "\u{1D688}", "\\mathtt{Z}": "\u{1D689}", "\\mathtt{a}": "\u{1D68A}", "\\mathtt{b}": "\u{1D68B}", "\\mathtt{c}": "\u{1D68C}", "\\mathtt{d}": "\u{1D68D}", "\\mathtt{e}": "\u{1D68E}", "\\mathtt{f}": "\u{1D68F}", "\\mathtt{g}": "\u{1D690}", "\\mathtt{h}": "\u{1D691}", "\\mathtt{i}": "\u{1D692}", "\\mathtt{j}": "\u{1D693}", "\\mathtt{k}": "\u{1D694}", "\\mathtt{l}": "\u{1D695}", "\\mathtt{m}": "\u{1D696}", "\\mathtt{n}": "\u{1D697}", "\\mathtt{o}": "\u{1D698}", "\\mathtt{p}": "\u{1D699}", "\\mathtt{q}": "\u{1D69A}", "\\mathtt{r}": "\u{1D69B}", "\\mathtt{s}": "\u{1D69C}", "\\mathtt{t}": "\u{1D69D}", "\\mathtt{u}": "\u{1D69E}", "\\mathtt{v}": "\u{1D69F}", "\\mathtt{w}": "\u{1D6A0}", "\\mathtt{x}": "\u{1D6A1}", "\\mathtt{y}": "\u{1D6A2}", "\\mathtt{z}": "\u{1D6A3}", "\\mathunderbar": "\u0332", "\\mathvisiblespace": "\u2423", "\\mbfA": "\u{1D400}", "\\mbfAlpha": "\u{1D6A8}", "\\mbfB": "\u{1D401}", "\\mbfBeta": "\u{1D6A9}", "\\mbfC": "\u{1D402}", "\\mbfChi": "\u{1D6BE}", "\\mbfD": "\u{1D403}", "\\mbfDelta": "\u{1D6AB}", "\\mbfDigamma": "\u{1D7CA}", "\\mbfE": "\u{1D404}", "\\mbfEpsilon": "\u{1D6AC}", "\\mbfEta": "\u{1D6AE}", "\\mbfF": "\u{1D405}", "\\mbfG": "\u{1D406}", "\\mbfGamma": "\u{1D6AA}", "\\mbfH": "\u{1D407}", "\\mbfI": "\u{1D408}", "\\mbfIota": "\u{1D6B0}", "\\mbfJ": "\u{1D409}", "\\mbfK": "\u{1D40A}", "\\mbfKappa": "\u{1D6B1}", "\\mbfL": "\u{1D40B}", "\\mbfLambda": "\u{1D6B2}", "\\mbfM": "\u{1D40C}", "\\mbfMu": "\u{1D6B3}", "\\mbfN": "\u{1D40D}", "\\mbfNu": "\u{1D6B4}", "\\mbfO": "\u{1D40E}", "\\mbfOmega": "\u{1D6C0}", "\\mbfOmicron": "\u{1D6B6}", "\\mbfP": "\u{1D40F}", "\\mbfPhi": "\u{1D6BD}", "\\mbfPi": "\u{1D6B7}", "\\mbfPsi": "\u{1D6BF}", "\\mbfQ": "\u{1D410}", "\\mbfR": "\u{1D411}", "\\mbfRho": "\u{1D6B8}", "\\mbfS": "\u{1D412}", "\\mbfSigma": "\u{1D6BA}", "\\mbfT": "\u{1D413}", "\\mbfTau": "\u{1D6BB}", "\\mbfTheta": "\u{1D6AF}", "\\mbfU": "\u{1D414}", "\\mbfUpsilon": "\u{1D6BC}", "\\mbfV": "\u{1D415}", "\\mbfW": "\u{1D416}", "\\mbfX": "\u{1D417}", "\\mbfXi": "\u{1D6B5}", "\\mbfY": "\u{1D418}", "\\mbfZ": "\u{1D419}", "\\mbfZeta": "\u{1D6AD}", "\\mbfa": "\u{1D41A}", "\\mbfalpha": "\u{1D6C2}", "\\mbfb": "\u{1D41B}", "\\mbfbeta": "\u{1D6C3}", "\\mbfc": "\u{1D41C}", "\\mbfchi": "\u{1D6D8}", "\\mbfd": "\u{1D41D}", "\\mbfdelta": "\u{1D6C5}", "\\mbfdigamma": "\u{1D7CB}", "\\mbfe": "\u{1D41E}", "\\mbfeight": "\u{1D7D6}", "\\mbfepsilon": "\u{1D6DC}", "\\mbfeta": "\u{1D6C8}", "\\mbff": "\u{1D41F}", "\\mbffive": "\u{1D7D3}", "\\mbffour": "\u{1D7D2}", "\\mbffrakA": "\u{1D56C}", "\\mbffrakB": "\u{1D56D}", "\\mbffrakC": "\u{1D56E}", "\\mbffrakD": "\u{1D56F}", "\\mbffrakE": "\u{1D570}", "\\mbffrakF": "\u{1D571}", "\\mbffrakG": "\u{1D572}", "\\mbffrakH": "\u{1D573}", "\\mbffrakI": "\u{1D574}", "\\mbffrakJ": "\u{1D575}", "\\mbffrakK": "\u{1D576}", "\\mbffrakL": "\u{1D577}", "\\mbffrakM": "\u{1D578}", "\\mbffrakN": "\u{1D579}", "\\mbffrakO": "\u{1D57A}", "\\mbffrakP": "\u{1D57B}", "\\mbffrakQ": "\u{1D57C}", "\\mbffrakR": "\u{1D57D}", "\\mbffrakS": "\u{1D57E}", "\\mbffrakT": "\u{1D57F}", "\\mbffrakU": "\u{1D580}", "\\mbffrakV": "\u{1D581}", "\\mbffrakW": "\u{1D582}", "\\mbffrakX": "\u{1D583}", "\\mbffrakY": "\u{1D584}", "\\mbffrakZ": "\u{1D585}", "\\mbffraka": "\u{1D586}", "\\mbffrakb": "\u{1D587}", "\\mbffrakc": "\u{1D588}", "\\mbffrakd": "\u{1D589}", "\\mbffrake": "\u{1D58A}", "\\mbffrakf": "\u{1D58B}", "\\mbffrakg": "\u{1D58C}", "\\mbffrakh": "\u{1D58D}", "\\mbffraki": "\u{1D58E}", "\\mbffrakj": "\u{1D58F}", "\\mbffrakk": "\u{1D590}", "\\mbffrakl": "\u{1D591}", "\\mbffrakm": "\u{1D592}", "\\mbffrakn": "\u{1D593}", "\\mbffrako": "\u{1D594}", "\\mbffrakp": "\u{1D595}", "\\mbffrakq": "\u{1D596}", "\\mbffrakr": "\u{1D597}", "\\mbffraks": "\u{1D598}", "\\mbffrakt": "\u{1D599}", "\\mbffraku": "\u{1D59A}", "\\mbffrakv": "\u{1D59B}", "\\mbffrakw": "\u{1D59C}", "\\mbffrakx": "\u{1D59D}", "\\mbffraky": "\u{1D59E}", "\\mbffrakz": "\u{1D59F}", "\\mbfg": "\u{1D420}", "\\mbfgamma": "\u{1D6C4}", "\\mbfh": "\u{1D421}", "\\mbfi": "\u{1D422}", "\\mbfiota": "\u{1D6CA}", "\\mbfitA": "\u{1D468}", "\\mbfitAlpha": "\u{1D71C}", "\\mbfitB": "\u{1D469}", "\\mbfitBeta": "\u{1D71D}", "\\mbfitC": "\u{1D46A}", "\\mbfitChi": "\u{1D732}", "\\mbfitD": "\u{1D46B}", "\\mbfitDelta": "\u{1D71F}", "\\mbfitE": "\u{1D46C}", "\\mbfitEpsilon": "\u{1D720}", "\\mbfitEta": "\u{1D722}", "\\mbfitF": "\u{1D46D}", "\\mbfitG": "\u{1D46E}", "\\mbfitGamma": "\u{1D71E}", "\\mbfitH": "\u{1D46F}", "\\mbfitI": "\u{1D470}", "\\mbfitIota": "\u{1D724}", "\\mbfitJ": "\u{1D471}", "\\mbfitK": "\u{1D472}", "\\mbfitKappa": "\u{1D725}", "\\mbfitL": "\u{1D473}", "\\mbfitLambda": "\u{1D726}", "\\mbfitM": "\u{1D474}", "\\mbfitMu": "\u{1D727}", "\\mbfitN": "\u{1D475}", "\\mbfitNu": "\u{1D728}", "\\mbfitO": "\u{1D476}", "\\mbfitOmega": "\u{1D734}", "\\mbfitOmicron": "\u{1D72A}", "\\mbfitP": "\u{1D477}", "\\mbfitPhi": "\u{1D731}", "\\mbfitPi": "\u{1D72B}", "\\mbfitPsi": "\u{1D733}", "\\mbfitQ": "\u{1D478}", "\\mbfitR": "\u{1D479}", "\\mbfitRho": "\u{1D72C}", "\\mbfitS": "\u{1D47A}", "\\mbfitSigma": "\u{1D72E}", "\\mbfitT": "\u{1D47B}", "\\mbfitTau": "\u{1D72F}", "\\mbfitTheta": "\u{1D723}", "\\mbfitU": "\u{1D47C}", "\\mbfitUpsilon": "\u{1D730}", "\\mbfitV": "\u{1D47D}", "\\mbfitW": "\u{1D47E}", "\\mbfitX": "\u{1D47F}", "\\mbfitXi": "\u{1D729}", "\\mbfitY": "\u{1D480}", "\\mbfitZ": "\u{1D481}", "\\mbfitZeta": "\u{1D721}", "\\mbfita": "\u{1D482}", "\\mbfitalpha": "\u{1D736}", "\\mbfitb": "\u{1D483}", "\\mbfitbeta": "\u{1D737}", "\\mbfitc": "\u{1D484}", "\\mbfitchi": "\u{1D74C}", "\\mbfitd": "\u{1D485}", "\\mbfitdelta": "\u{1D739}", "\\mbfite": "\u{1D486}", "\\mbfitepsilon": "\u{1D750}", "\\mbfiteta": "\u{1D73C}", "\\mbfitf": "\u{1D487}", "\\mbfitg": "\u{1D488}", "\\mbfitgamma": "\u{1D738}", "\\mbfith": "\u{1D489}", "\\mbfiti": "\u{1D48A}", "\\mbfitiota": "\u{1D73E}", "\\mbfitj": "\u{1D48B}", "\\mbfitk": "\u{1D48C}", "\\mbfitkappa": "\u{1D73F}", "\\mbfitl": "\u{1D48D}", "\\mbfitlambda": "\u{1D740}", "\\mbfitm": "\u{1D48E}", "\\mbfitmu": "\u{1D741}", "\\mbfitn": "\u{1D48F}", "\\mbfitnabla": "\u{1D735}", "\\mbfitnu": "\u{1D742}", "\\mbfito": "\u{1D490}", "\\mbfitomega": "\u{1D74E}", "\\mbfitomicron": "\u{1D744}", "\\mbfitp": "\u{1D491}", "\\mbfitpartial": "\u{1D74F}", "\\mbfitphi": "\u{1D753}", "\\mbfitpi": "\u{1D745}", "\\mbfitpsi": "\u{1D74D}", "\\mbfitq": "\u{1D492}", "\\mbfitr": "\u{1D493}", "\\mbfitrho": "\u{1D746}", "\\mbfits": "\u{1D494}", "\\mbfitsansA": "\u{1D63C}", "\\mbfitsansAlpha": "\u{1D790}", "\\mbfitsansB": "\u{1D63D}", "\\mbfitsansBeta": "\u{1D791}", "\\mbfitsansC": "\u{1D63E}", "\\mbfitsansChi": "\u{1D7A6}", "\\mbfitsansD": "\u{1D63F}", "\\mbfitsansDelta": "\u{1D793}", "\\mbfitsansE": "\u{1D640}", "\\mbfitsansEpsilon": "\u{1D794}", "\\mbfitsansEta": "\u{1D796}", "\\mbfitsansF": "\u{1D641}", "\\mbfitsansG": "\u{1D642}", "\\mbfitsansGamma": "\u{1D792}", "\\mbfitsansH": "\u{1D643}", "\\mbfitsansI": "\u{1D644}", "\\mbfitsansIota": "\u{1D798}", "\\mbfitsansJ": "\u{1D645}", "\\mbfitsansK": "\u{1D646}", "\\mbfitsansKappa": "\u{1D799}", "\\mbfitsansL": "\u{1D647}", "\\mbfitsansLambda": "\u{1D79A}", "\\mbfitsansM": "\u{1D648}", "\\mbfitsansMu": "\u{1D79B}", "\\mbfitsansN": "\u{1D649}", "\\mbfitsansNu": "\u{1D79C}", "\\mbfitsansO": "\u{1D64A}", "\\mbfitsansOmega": "\u{1D7A8}", "\\mbfitsansOmicron": "\u{1D79E}", "\\mbfitsansP": "\u{1D64B}", "\\mbfitsansPhi": "\u{1D7A5}", "\\mbfitsansPi": "\u{1D79F}", "\\mbfitsansPsi": "\u{1D7A7}", "\\mbfitsansQ": "\u{1D64C}", "\\mbfitsansR": "\u{1D64D}", "\\mbfitsansRho": "\u{1D7A0}", "\\mbfitsansS": "\u{1D64E}", "\\mbfitsansSigma": "\u{1D7A2}", "\\mbfitsansT": "\u{1D64F}", "\\mbfitsansTau": "\u{1D7A3}", "\\mbfitsansTheta": "\u{1D797}", "\\mbfitsansU": "\u{1D650}", "\\mbfitsansUpsilon": "\u{1D7A4}", "\\mbfitsansV": "\u{1D651}", "\\mbfitsansW": "\u{1D652}", "\\mbfitsansX": "\u{1D653}", "\\mbfitsansXi": "\u{1D79D}", "\\mbfitsansY": "\u{1D654}", "\\mbfitsansZ": "\u{1D655}", "\\mbfitsansZeta": "\u{1D795}", "\\mbfitsansa": "\u{1D656}", "\\mbfitsansalpha": "\u{1D7AA}", "\\mbfitsansb": "\u{1D657}", "\\mbfitsansbeta": "\u{1D7AB}", "\\mbfitsansc": "\u{1D658}", "\\mbfitsanschi": "\u{1D7C0}", "\\mbfitsansd": "\u{1D659}", "\\mbfitsansdelta": "\u{1D7AD}", "\\mbfitsanse": "\u{1D65A}", "\\mbfitsansepsilon": "\u{1D7C4}", "\\mbfitsanseta": "\u{1D7B0}", "\\mbfitsansf": "\u{1D65B}", "\\mbfitsansg": "\u{1D65C}", "\\mbfitsansgamma": "\u{1D7AC}", "\\mbfitsansh": "\u{1D65D}", "\\mbfitsansi": "\u{1D65E}", "\\mbfitsansiota": "\u{1D7B2}", "\\mbfitsansj": "\u{1D65F}", "\\mbfitsansk": "\u{1D660}", "\\mbfitsanskappa": "\u{1D7B3}", "\\mbfitsansl": "\u{1D661}", "\\mbfitsanslambda": "\u{1D7B4}", "\\mbfitsansm": "\u{1D662}", "\\mbfitsansmu": "\u{1D7B5}", "\\mbfitsansn": "\u{1D663}", "\\mbfitsansnabla": "\u{1D7A9}", "\\mbfitsansnu": "\u{1D7B6}", "\\mbfitsanso": "\u{1D664}", "\\mbfitsansomega": "\u{1D7C2}", "\\mbfitsansomicron": "\u{1D7B8}", "\\mbfitsansp": "\u{1D665}", "\\mbfitsanspartial": "\u{1D7C3}", "\\mbfitsansphi": "\u{1D7C7}", "\\mbfitsanspi": "\u{1D7B9}", "\\mbfitsanspsi": "\u{1D7C1}", "\\mbfitsansq": "\u{1D666}", "\\mbfitsansr": "\u{1D667}", "\\mbfitsansrho": "\u{1D7BA}", "\\mbfitsanss": "\u{1D668}", "\\mbfitsanssigma": "\u{1D7BC}", "\\mbfitsanst": "\u{1D669}", "\\mbfitsanstau": "\u{1D7BD}", "\\mbfitsanstheta": "\u{1D7B1}", "\\mbfitsansu": "\u{1D66A}", "\\mbfitsansupsilon": "\u{1D7BE}", "\\mbfitsansv": "\u{1D66B}", "\\mbfitsansvarTheta": "\u{1D7A1}", "\\mbfitsansvarepsilon": "\u{1D7AE}", "\\mbfitsansvarkappa": "\u{1D7C6}", "\\mbfitsansvarphi": "\u{1D7BF}", "\\mbfitsansvarpi": "\u{1D7C9}", "\\mbfitsansvarrho": "\u{1D7C8}", "\\mbfitsansvarsigma": "\u{1D7BB}", "\\mbfitsansvartheta": "\u{1D7C5}", "\\mbfitsansw": "\u{1D66C}", "\\mbfitsansx": "\u{1D66D}", "\\mbfitsansxi": "\u{1D7B7}", "\\mbfitsansy": "\u{1D66E}", "\\mbfitsansz": "\u{1D66F}", "\\mbfitsanszeta": "\u{1D7AF}", "\\mbfitsigma": "\u{1D748}", "\\mbfitt": "\u{1D495}", "\\mbfittau": "\u{1D749}", "\\mbfittheta": "\u{1D73D}", "\\mbfitu": "\u{1D496}", "\\mbfitupsilon": "\u{1D74A}", "\\mbfitv": "\u{1D497}", "\\mbfitvarTheta": "\u{1D72D}", "\\mbfitvarepsilon": "\u{1D73A}", "\\mbfitvarkappa": "\u{1D752}", "\\mbfitvarphi": "\u{1D74B}", "\\mbfitvarpi": "\u{1D755}", "\\mbfitvarrho": "\u{1D754}", "\\mbfitvarsigma": "\u{1D747}", "\\mbfitvartheta": "\u{1D751}", "\\mbfitw": "\u{1D498}", "\\mbfitx": "\u{1D499}", "\\mbfitxi": "\u{1D743}", "\\mbfity": "\u{1D49A}", "\\mbfitz": "\u{1D49B}", "\\mbfitzeta": "\u{1D73B}", "\\mbfj": "\u{1D423}", "\\mbfk": "\u{1D424}", "\\mbfkappa": "\u{1D6CB}", "\\mbfl": "\u{1D425}", "\\mbflambda": "\u{1D6CC}", "\\mbfm": "\u{1D426}", "\\mbfmu": "\u{1D6CD}", "\\mbfn": "\u{1D427}", "\\mbfnabla": "\u{1D6C1}", "\\mbfnine": "\u{1D7D7}", "\\mbfnu": "\u{1D6CE}", "\\mbfo": "\u{1D428}", "\\mbfomega": "\u{1D6DA}", "\\mbfomicron": "\u{1D6D0}", "\\mbfone": "\u{1D7CF}", "\\mbfp": "\u{1D429}", "\\mbfpartial": "\u{1D6DB}", "\\mbfphi": "\u{1D6DF}", "\\mbfpi": "\u{1D6D1}", "\\mbfpsi": "\u{1D6D9}", "\\mbfq": "\u{1D42A}", "\\mbfr": "\u{1D42B}", "\\mbfrho": "\u{1D6D2}", "\\mbfs": "\u{1D42C}", "\\mbfsansA": "\u{1D5D4}", "\\mbfsansAlpha": "\u{1D756}", "\\mbfsansB": "\u{1D5D5}", "\\mbfsansBeta": "\u{1D757}", "\\mbfsansC": "\u{1D5D6}", "\\mbfsansChi": "\u{1D76C}", "\\mbfsansD": "\u{1D5D7}", "\\mbfsansDelta": "\u{1D759}", "\\mbfsansE": "\u{1D5D8}", "\\mbfsansEpsilon": "\u{1D75A}", "\\mbfsansEta": "\u{1D75C}", "\\mbfsansF": "\u{1D5D9}", "\\mbfsansG": "\u{1D5DA}", "\\mbfsansGamma": "\u{1D758}", "\\mbfsansH": "\u{1D5DB}", "\\mbfsansI": "\u{1D5DC}", "\\mbfsansIota": "\u{1D75E}", "\\mbfsansJ": "\u{1D5DD}", "\\mbfsansK": "\u{1D5DE}", "\\mbfsansKappa": "\u{1D75F}", "\\mbfsansL": "\u{1D5DF}", "\\mbfsansLambda": "\u{1D760}", "\\mbfsansM": "\u{1D5E0}", "\\mbfsansMu": "\u{1D761}", "\\mbfsansN": "\u{1D5E1}", "\\mbfsansNu": "\u{1D762}", "\\mbfsansO": "\u{1D5E2}", "\\mbfsansOmega": "\u{1D76E}", "\\mbfsansOmicron": "\u{1D764}", "\\mbfsansP": "\u{1D5E3}", "\\mbfsansPhi": "\u{1D76B}", "\\mbfsansPi": "\u{1D765}", "\\mbfsansPsi": "\u{1D76D}", "\\mbfsansQ": "\u{1D5E4}", "\\mbfsansR": "\u{1D5E5}", "\\mbfsansRho": "\u{1D766}", "\\mbfsansS": "\u{1D5E6}", "\\mbfsansSigma": "\u{1D768}", "\\mbfsansT": "\u{1D5E7}", "\\mbfsansTau": "\u{1D769}", "\\mbfsansTheta": "\u{1D75D}", "\\mbfsansU": "\u{1D5E8}", "\\mbfsansUpsilon": "\u{1D76A}", "\\mbfsansV": "\u{1D5E9}", "\\mbfsansW": "\u{1D5EA}", "\\mbfsansX": "\u{1D5EB}", "\\mbfsansXi": "\u{1D763}", "\\mbfsansY": "\u{1D5EC}", "\\mbfsansZ": "\u{1D5ED}", "\\mbfsansZeta": "\u{1D75B}", "\\mbfsansa": "\u{1D5EE}", "\\mbfsansalpha": "\u{1D770}", "\\mbfsansb": "\u{1D5EF}", "\\mbfsansbeta": "\u{1D771}", "\\mbfsansc": "\u{1D5F0}", "\\mbfsanschi": "\u{1D786}", "\\mbfsansd": "\u{1D5F1}", "\\mbfsansdelta": "\u{1D773}", "\\mbfsanse": "\u{1D5F2}", "\\mbfsanseight": "\u{1D7F4}", "\\mbfsansepsilon": "\u{1D78A}", "\\mbfsanseta": "\u{1D776}", "\\mbfsansf": "\u{1D5F3}", "\\mbfsansfive": "\u{1D7F1}", "\\mbfsansfour": "\u{1D7F0}", "\\mbfsansg": "\u{1D5F4}", "\\mbfsansgamma": "\u{1D772}", "\\mbfsansh": "\u{1D5F5}", "\\mbfsansi": "\u{1D5F6}", "\\mbfsansiota": "\u{1D778}", "\\mbfsansj": "\u{1D5F7}", "\\mbfsansk": "\u{1D5F8}", "\\mbfsanskappa": "\u{1D779}", "\\mbfsansl": "\u{1D5F9}", "\\mbfsanslambda": "\u{1D77A}", "\\mbfsansm": "\u{1D5FA}", "\\mbfsansmu": "\u{1D77B}", "\\mbfsansn": "\u{1D5FB}", "\\mbfsansnabla": "\u{1D76F}", "\\mbfsansnine": "\u{1D7F5}", "\\mbfsansnu": "\u{1D77C}", "\\mbfsanso": "\u{1D5FC}", "\\mbfsansomega": "\u{1D788}", "\\mbfsansomicron": "\u{1D77E}", "\\mbfsansone": "\u{1D7ED}", "\\mbfsansp": "\u{1D5FD}", "\\mbfsanspartial": "\u{1D789}", "\\mbfsansphi": "\u{1D78D}", "\\mbfsanspi": "\u{1D77F}", "\\mbfsanspsi": "\u{1D787}", "\\mbfsansq": "\u{1D5FE}", "\\mbfsansr": "\u{1D5FF}", "\\mbfsansrho": "\u{1D780}", "\\mbfsanss": "\u{1D600}", "\\mbfsansseven": "\u{1D7F3}", "\\mbfsanssigma": "\u{1D782}", "\\mbfsanssix": "\u{1D7F2}", "\\mbfsanst": "\u{1D601}", "\\mbfsanstau": "\u{1D783}", "\\mbfsanstheta": "\u{1D777}", "\\mbfsansthree": "\u{1D7EF}", "\\mbfsanstwo": "\u{1D7EE}", "\\mbfsansu": "\u{1D602}", "\\mbfsansupsilon": "\u{1D784}", "\\mbfsansv": "\u{1D603}", "\\mbfsansvarTheta": "\u{1D767}", "\\mbfsansvarepsilon": "\u{1D774}", "\\mbfsansvarkappa": "\u{1D78C}", "\\mbfsansvarphi": "\u{1D785}", "\\mbfsansvarpi": "\u{1D78F}", "\\mbfsansvarrho": "\u{1D78E}", "\\mbfsansvarsigma": "\u{1D781}", "\\mbfsansvartheta": "\u{1D78B}", "\\mbfsansw": "\u{1D604}", "\\mbfsansx": "\u{1D605}", "\\mbfsansxi": "\u{1D77D}", "\\mbfsansy": "\u{1D606}", "\\mbfsansz": "\u{1D607}", "\\mbfsanszero": "\u{1D7EC}", "\\mbfsanszeta": "\u{1D775}", "\\mbfscrA": "\u{1D4D0}", "\\mbfscrB": "\u{1D4D1}", "\\mbfscrC": "\u{1D4D2}", "\\mbfscrD": "\u{1D4D3}", "\\mbfscrE": "\u{1D4D4}", "\\mbfscrF": "\u{1D4D5}", "\\mbfscrG": "\u{1D4D6}", "\\mbfscrH": "\u{1D4D7}", "\\mbfscrI": "\u{1D4D8}", "\\mbfscrJ": "\u{1D4D9}", "\\mbfscrK": "\u{1D4DA}", "\\mbfscrL": "\u{1D4DB}", "\\mbfscrM": "\u{1D4DC}", "\\mbfscrN": "\u{1D4DD}", "\\mbfscrO": "\u{1D4DE}", "\\mbfscrP": "\u{1D4DF}", "\\mbfscrQ": "\u{1D4E0}", "\\mbfscrR": "\u{1D4E1}", "\\mbfscrS": "\u{1D4E2}", "\\mbfscrT": "\u{1D4E3}", "\\mbfscrU": "\u{1D4E4}", "\\mbfscrV": "\u{1D4E5}", "\\mbfscrW": "\u{1D4E6}", "\\mbfscrX": "\u{1D4E7}", "\\mbfscrY": "\u{1D4E8}", "\\mbfscrZ": "\u{1D4E9}", "\\mbfscra": "\u{1D4EA}", "\\mbfscrb": "\u{1D4EB}", "\\mbfscrc": "\u{1D4EC}", "\\mbfscrd": "\u{1D4ED}", "\\mbfscre": "\u{1D4EE}", "\\mbfscrf": "\u{1D4EF}", "\\mbfscrg": "\u{1D4F0}", "\\mbfscrh": "\u{1D4F1}", "\\mbfscri": "\u{1D4F2}", "\\mbfscrj": "\u{1D4F3}", "\\mbfscrk": "\u{1D4F4}", "\\mbfscrl": "\u{1D4F5}", "\\mbfscrm": "\u{1D4F6}", "\\mbfscrn": "\u{1D4F7}", "\\mbfscro": "\u{1D4F8}", "\\mbfscrp": "\u{1D4F9}", "\\mbfscrq": "\u{1D4FA}", "\\mbfscrr": "\u{1D4FB}", "\\mbfscrs": "\u{1D4FC}", "\\mbfscrt": "\u{1D4FD}", "\\mbfscru": "\u{1D4FE}", "\\mbfscrv": "\u{1D4FF}", "\\mbfscrw": "\u{1D500}", "\\mbfscrx": "\u{1D501}", "\\mbfscry": "\u{1D502}", "\\mbfscrz": "\u{1D503}", "\\mbfseven": "\u{1D7D5}", "\\mbfsigma": "\u{1D6D4}", "\\mbfsix": "\u{1D7D4}", "\\mbft": "\u{1D42D}", "\\mbftau": "\u{1D6D5}", "\\mbftheta": "\u{1D6C9}", "\\mbfthree": "\u{1D7D1}", "\\mbftwo": "\u{1D7D0}", "\\mbfu": "\u{1D42E}", "\\mbfupsilon": "\u{1D6D6}", "\\mbfv": "\u{1D42F}", "\\mbfvarTheta": "\u{1D6B9}", "\\mbfvarepsilon": "\u{1D6C6}", "\\mbfvarkappa": "\u{1D6DE}", "\\mbfvarphi": "\u{1D6D7}", "\\mbfvarpi": "\u{1D6E1}", "\\mbfvarrho": "\u{1D6E0}", "\\mbfvarsigma": "\u{1D6D3}", "\\mbfvartheta": "\u{1D6DD}", "\\mbfw": "\u{1D430}", "\\mbfx": "\u{1D431}", "\\mbfxi": "\u{1D6CF}", "\\mbfy": "\u{1D432}", "\\mbfz": "\u{1D433}", "\\mbfzero": "\u{1D7CE}", "\\mbfzeta": "\u{1D6C7}", "\\mdblkcircle": "\u26AB", "\\mdblkdiamond": "\u2B25", "\\mdblklozenge": "\u2B27", "\\mdblksquare": "\u25FC", "\\mdlgblkcircle": "\u25CF", "\\mdlgblkdiamond": "\u25C6", "\\mdlgblklozenge": "\u29EB", "\\mdlgblksquare": "\u25A0", "\\mdlgwhtcircle": "\u25CB", "\\mdlgwhtdiamond": "\u25C7", "\\mdlgwhtlozenge": "\u25CA", "\\mdlgwhtsquare": "\u25A1", "\\mdsmblkcircle": "\u2981", "\\mdsmblksquare": "\u25FE", "\\mdsmwhtcircle": "\u26AC", "\\mdsmwhtsquare": "\u25FD", "\\mdwhtcircle": "\u26AA", "\\mdwhtdiamond": "\u2B26", "\\mdwhtlozenge": "\u2B28", "\\mdwhtsquare": "\u25FB", "\\measangledltosw": "\u29AF", "\\measangledrtose": "\u29AE", "\\measangleldtosw": "\u29AB", "\\measanglelutonw": "\u29A9", "\\measanglerdtose": "\u29AA", "\\measanglerutone": "\u29A8", "\\measangleultonw": "\u29AD", "\\measangleurtone": "\u29AC", "\\measeq": "\u225E", "\\measuredangle": "\u2221", "\\measuredangleleft": "\u299B", "\\measuredrightangle": "\u22BE", "\\medblackstar": "\u2B51", "\\medbullet": "\u26AB", "\\medcirc": "\u26AA", "\\medspace": "\u2005", "\\medwhitestar": "\u2B50", "\\mercury": "\u263F", "\\mfrakA": "\u{1D504}", "\\mfrakB": "\u{1D505}", "\\mfrakC": "\u212D", "\\mfrakD": "\u{1D507}", "\\mfrakE": "\u{1D508}", "\\mfrakF": "\u{1D509}", "\\mfrakG": "\u{1D50A}", "\\mfrakH": "\u210C", "\\mfrakJ": "\u{1D50D}", "\\mfrakK": "\u{1D50E}", "\\mfrakL": "\u{1D50F}", "\\mfrakM": "\u{1D510}", "\\mfrakN": "\u{1D511}", "\\mfrakO": "\u{1D512}", "\\mfrakP": "\u{1D513}", "\\mfrakQ": "\u{1D514}", "\\mfrakS": "\u{1D516}", "\\mfrakT": "\u{1D517}", "\\mfrakU": "\u{1D518}", "\\mfrakV": "\u{1D519}", "\\mfrakW": "\u{1D51A}", "\\mfrakX": "\u{1D51B}", "\\mfrakY": "\u{1D51C}", "\\mfrakZ": "\u2128", "\\mfraka": "\u{1D51E}", "\\mfrakb": "\u{1D51F}", "\\mfrakc": "\u{1D520}", "\\mfrakd": "\u{1D521}", "\\mfrake": "\u{1D522}", "\\mfrakf": "\u{1D523}", "\\mfrakg": "\u{1D524}", "\\mfrakh": "\u{1D525}", "\\mfraki": "\u{1D526}", "\\mfrakj": "\u{1D527}", "\\mfrakk": "\u{1D528}", "\\mfrakl": "\u{1D529}", "\\mfrakm": "\u{1D52A}", "\\mfrakn": "\u{1D52B}", "\\mfrako": "\u{1D52C}", "\\mfrakp": "\u{1D52D}", "\\mfrakq": "\u{1D52E}", "\\mfrakr": "\u{1D52F}", "\\mfraks": "\u{1D530}", "\\mfrakt": "\u{1D531}", "\\mfraku": "\u{1D532}", "\\mfrakv": "\u{1D533}", "\\mfrakw": "\u{1D534}", "\\mfrakx": "\u{1D535}", "\\mfraky": "\u{1D536}", "\\mfrakz": "\u{1D537}", "\\mho": "\u2127", "\\mid": "\u2223", "\\midbarvee": "\u2A5D", "\\midbarwedge": "\u2A5C", "\\midcir": "\u2AF0", "\\minus": "\u2212", "\\minusdot": "\u2A2A", "\\minusfdots": "\u2A2B", "\\minusrdots": "\u2A2C", "\\mitA": "\u{1D434}", "\\mitAlpha": "\u{1D6E2}", "\\mitB": "\u{1D435}", "\\mitBbbD": "\u2145", "\\mitBbbd": "\u2146", "\\mitBbbe": "\u2147", "\\mitBbbi": "\u2148", "\\mitBbbj": "\u2149", "\\mitBeta": "\u{1D6E3}", "\\mitC": "\u{1D436}", "\\mitChi": "\u{1D6F8}", "\\mitD": "\u{1D437}", "\\mitDelta": "\u{1D6E5}", "\\mitE": "\u{1D438}", "\\mitEpsilon": "\u{1D6E6}", "\\mitEta": "\u{1D6E8}", "\\mitF": "\u{1D439}", "\\mitG": "\u{1D43A}", "\\mitGamma": "\u{1D6E4}", "\\mitH": "\u{1D43B}", "\\mitI": "\u{1D43C}", "\\mitIota": "\u{1D6EA}", "\\mitJ": "\u{1D43D}", "\\mitK": "\u{1D43E}", "\\mitKappa": "\u{1D6EB}", "\\mitL": "\u{1D43F}", "\\mitLambda": "\u{1D6EC}", "\\mitM": "\u{1D440}", "\\mitMu": "\u{1D6ED}", "\\mitN": "\u{1D441}", "\\mitNu": "\u{1D6EE}", "\\mitO": "\u{1D442}", "\\mitOmega": "\u{1D6FA}", "\\mitOmicron": "\u{1D6F0}", "\\mitP": "\u{1D443}", "\\mitPhi": "\u{1D6F7}", "\\mitPi": "\u{1D6F1}", "\\mitPsi": "\u{1D6F9}", "\\mitQ": "\u{1D444}", "\\mitR": "\u{1D445}", "\\mitRho": "\u{1D6F2}", "\\mitS": "\u{1D446}", "\\mitSigma": "\u{1D6F4}", "\\mitT": "\u{1D447}", "\\mitTau": "\u{1D6F5}", "\\mitTheta": "\u{1D6E9}", "\\mitU": "\u{1D448}", "\\mitUpsilon": "\u{1D6F6}", "\\mitV": "\u{1D449}", "\\mitW": "\u{1D44A}", "\\mitX": "\u{1D44B}", "\\mitXi": "\u{1D6EF}", "\\mitY": "\u{1D44C}", "\\mitZ": "\u{1D44D}", "\\mitZeta": "\u{1D6E7}", "\\mita": "\u{1D44E}", "\\mitalpha": "\u{1D6FC}", "\\mitb": "\u{1D44F}", "\\mitbeta": "\u{1D6FD}", "\\mitc": "\u{1D450}", "\\mitchi": "\u{1D712}", "\\mitd": "\u{1D451}", "\\mitdelta": "\u{1D6FF}", "\\mite": "\u{1D452}", "\\mitepsilon": "\u{1D716}", "\\miteta": "\u{1D702}", "\\mitf": "\u{1D453}", "\\mitg": "\u{1D454}", "\\mitgamma": "\u{1D6FE}", "\\miti": "\u{1D456}", "\\mitiota": "\u{1D704}", "\\mitj": "\u{1D457}", "\\mitk": "\u{1D458}", "\\mitkappa": "\u{1D705}", "\\mitl": "\u{1D459}", "\\mitlambda": "\u{1D706}", "\\mitm": "\u{1D45A}", "\\mitmu": "\u{1D707}", "\\mitn": "\u{1D45B}", "\\mitnabla": "\u{1D6FB}", "\\mitnu": "\u{1D708}", "\\mito": "\u{1D45C}", "\\mitomega": "\u{1D714}", "\\mitomicron": "\u{1D70A}", "\\mitp": "\u{1D45D}", "\\mitpartial": "\u{1D715}", "\\mitphi": "\u{1D719}", "\\mitpi": "\u{1D70B}", "\\mitpsi": "\u{1D713}", "\\mitq": "\u{1D45E}", "\\mitr": "\u{1D45F}", "\\mitrho": "\u{1D70C}", "\\mits": "\u{1D460}", "\\mitsansA": "\u{1D608}", "\\mitsansB": "\u{1D609}", "\\mitsansC": "\u{1D60A}", "\\mitsansD": "\u{1D60B}", "\\mitsansE": "\u{1D60C}", "\\mitsansF": "\u{1D60D}", "\\mitsansG": "\u{1D60E}", "\\mitsansH": "\u{1D60F}", "\\mitsansI": "\u{1D610}", "\\mitsansJ": "\u{1D611}", "\\mitsansK": "\u{1D612}", "\\mitsansL": "\u{1D613}", "\\mitsansM": "\u{1D614}", "\\mitsansN": "\u{1D615}", "\\mitsansO": "\u{1D616}", "\\mitsansP": "\u{1D617}", "\\mitsansQ": "\u{1D618}", "\\mitsansR": "\u{1D619}", "\\mitsansS": "\u{1D61A}", "\\mitsansT": "\u{1D61B}", "\\mitsansU": "\u{1D61C}", "\\mitsansV": "\u{1D61D}", "\\mitsansW": "\u{1D61E}", "\\mitsansX": "\u{1D61F}", "\\mitsansY": "\u{1D620}", "\\mitsansZ": "\u{1D621}", "\\mitsansa": "\u{1D622}", "\\mitsansb": "\u{1D623}", "\\mitsansc": "\u{1D624}", "\\mitsansd": "\u{1D625}", "\\mitsanse": "\u{1D626}", "\\mitsansf": "\u{1D627}", "\\mitsansg": "\u{1D628}", "\\mitsansh": "\u{1D629}", "\\mitsansi": "\u{1D62A}", "\\mitsansj": "\u{1D62B}", "\\mitsansk": "\u{1D62C}", "\\mitsansl": "\u{1D62D}", "\\mitsansm": "\u{1D62E}", "\\mitsansn": "\u{1D62F}", "\\mitsanso": "\u{1D630}", "\\mitsansp": "\u{1D631}", "\\mitsansq": "\u{1D632}", "\\mitsansr": "\u{1D633}", "\\mitsanss": "\u{1D634}", "\\mitsanst": "\u{1D635}", "\\mitsansu": "\u{1D636}", "\\mitsansv": "\u{1D637}", "\\mitsansw": "\u{1D638}", "\\mitsansx": "\u{1D639}", "\\mitsansy": "\u{1D63A}", "\\mitsansz": "\u{1D63B}", "\\mitsigma": "\u{1D70E}", "\\mitt": "\u{1D461}", "\\mittau": "\u{1D70F}", "\\mittheta": "\u{1D703}", "\\mitu": "\u{1D462}", "\\mitupsilon": "\u{1D710}", "\\mitv": "\u{1D463}", "\\mitvarTheta": "\u{1D6F3}", "\\mitvarepsilon": "\u{1D700}", "\\mitvarkappa": "\u{1D718}", "\\mitvarphi": "\u{1D711}", "\\mitvarpi": "\u{1D71B}", "\\mitvarrho": "\u{1D71A}", "\\mitvarsigma": "\u{1D70D}", "\\mitvartheta": "\u{1D717}", "\\mitw": "\u{1D464}", "\\mitx": "\u{1D465}", "\\mitxi": "\u{1D709}", "\\mity": "\u{1D466}", "\\mitz": "\u{1D467}", "\\mitzeta": "\u{1D701}", "\\mkern1mu": "\u200A", "\\mlcp": "\u2ADB", "\\models": "\u22A7", "\\modtwosum": "\u2A0A", "\\mp": "\u2213", "\\msansA": "\u{1D5A0}", "\\msansB": "\u{1D5A1}", "\\msansC": "\u{1D5A2}", "\\msansD": "\u{1D5A3}", "\\msansE": "\u{1D5A4}", "\\msansF": "\u{1D5A5}", "\\msansG": "\u{1D5A6}", "\\msansH": "\u{1D5A7}", "\\msansI": "\u{1D5A8}", "\\msansJ": "\u{1D5A9}", "\\msansK": "\u{1D5AA}", "\\msansL": "\u{1D5AB}", "\\msansM": "\u{1D5AC}", "\\msansN": "\u{1D5AD}", "\\msansO": "\u{1D5AE}", "\\msansP": "\u{1D5AF}", "\\msansQ": "\u{1D5B0}", "\\msansR": "\u{1D5B1}", "\\msansS": "\u{1D5B2}", "\\msansT": "\u{1D5B3}", "\\msansU": "\u{1D5B4}", "\\msansV": "\u{1D5B5}", "\\msansW": "\u{1D5B6}", "\\msansX": "\u{1D5B7}", "\\msansY": "\u{1D5B8}", "\\msansZ": "\u{1D5B9}", "\\msansa": "\u{1D5BA}", "\\msansb": "\u{1D5BB}", "\\msansc": "\u{1D5BC}", "\\msansd": "\u{1D5BD}", "\\msanse": "\u{1D5BE}", "\\msanseight": "\u{1D7EA}", "\\msansf": "\u{1D5BF}", "\\msansfive": "\u{1D7E7}", "\\msansfour": "\u{1D7E6}", "\\msansg": "\u{1D5C0}", "\\msansh": "\u{1D5C1}", "\\msansi": "\u{1D5C2}", "\\msansj": "\u{1D5C3}", "\\msansk": "\u{1D5C4}", "\\msansl": "\u{1D5C5}", "\\msansm": "\u{1D5C6}", "\\msansn": "\u{1D5C7}", "\\msansnine": "\u{1D7EB}", "\\msanso": "\u{1D5C8}", "\\msansone": "\u{1D7E3}", "\\msansp": "\u{1D5C9}", "\\msansq": "\u{1D5CA}", "\\msansr": "\u{1D5CB}", "\\msanss": "\u{1D5CC}", "\\msansseven": "\u{1D7E9}", "\\msanssix": "\u{1D7E8}", "\\msanst": "\u{1D5CD}", "\\msansthree": "\u{1D7E5}", "\\msanstwo": "\u{1D7E4}", "\\msansu": "\u{1D5CE}", "\\msansv": "\u{1D5CF}", "\\msansw": "\u{1D5D0}", "\\msansx": "\u{1D5D1}", "\\msansy": "\u{1D5D2}", "\\msansz": "\u{1D5D3}", "\\msanszero": "\u{1D7E2}", "\\mscrA": "\u{1D49C}", "\\mscrB": "\u212C", "\\mscrC": "\u{1D49E}", "\\mscrD": "\u{1D49F}", "\\mscrE": "\u2130", "\\mscrF": "\u2131", "\\mscrG": "\u{1D4A2}", "\\mscrH": "\u210B", "\\mscrI": "\u2110", "\\mscrJ": "\u{1D4A5}", "\\mscrK": "\u{1D4A6}", "\\mscrL": "\u2112", "\\mscrM": "\u2133", "\\mscrN": "\u{1D4A9}", "\\mscrO": "\u{1D4AA}", "\\mscrP": "\u{1D4AB}", "\\mscrQ": "\u{1D4AC}", "\\mscrR": "\u211B", "\\mscrS": "\u{1D4AE}", "\\mscrT": "\u{1D4AF}", "\\mscrU": "\u{1D4B0}", "\\mscrV": "\u{1D4B1}", "\\mscrW": "\u{1D4B2}", "\\mscrX": "\u{1D4B3}", "\\mscrY": "\u{1D4B4}", "\\mscrZ": "\u{1D4B5}", "\\mscra": "\u{1D4B6}", "\\mscrb": "\u{1D4B7}", "\\mscrc": "\u{1D4B8}", "\\mscrd": "\u{1D4B9}", "\\mscre": "\u212F", "\\mscrf": "\u{1D4BB}", "\\mscrg": "\u210A", "\\mscrh": "\u{1D4BD}", "\\mscri": "\u{1D4BE}", "\\mscrj": "\u{1D4BF}", "\\mscrk": "\u{1D4C0}", "\\mscrl": "\u{1D4C1}", "\\mscrm": "\u{1D4C2}", "\\mscrn": "\u{1D4C3}", "\\mscro": "\u2134", "\\mscrp": "\u{1D4C5}", "\\mscrq": "\u{1D4C6}", "\\mscrr": "\u{1D4C7}", "\\mscrs": "\u{1D4C8}", "\\mscrt": "\u{1D4C9}", "\\mscru": "\u{1D4CA}", "\\mscrv": "\u{1D4CB}", "\\mscrw": "\u{1D4CC}", "\\mscrx": "\u{1D4CD}", "\\mscry": "\u{1D4CE}", "\\mscrz": "\u{1D4CF}", "\\mttA": "\u{1D670}", "\\mttB": "\u{1D671}", "\\mttC": "\u{1D672}", "\\mttD": "\u{1D673}", "\\mttE": "\u{1D674}", "\\mttF": "\u{1D675}", "\\mttG": "\u{1D676}", "\\mttH": "\u{1D677}", "\\mttI": "\u{1D678}", "\\mttJ": "\u{1D679}", "\\mttK": "\u{1D67A}", "\\mttL": "\u{1D67B}", "\\mttM": "\u{1D67C}", "\\mttN": "\u{1D67D}", "\\mttO": "\u{1D67E}", "\\mttP": "\u{1D67F}", "\\mttQ": "\u{1D680}", "\\mttR": "\u{1D681}", "\\mttS": "\u{1D682}", "\\mttT": "\u{1D683}", "\\mttU": "\u{1D684}", "\\mttV": "\u{1D685}", "\\mttW": "\u{1D686}", "\\mttX": "\u{1D687}", "\\mttY": "\u{1D688}", "\\mttZ": "\u{1D689}", "\\mtta": "\u{1D68A}", "\\mttb": "\u{1D68B}", "\\mttc": "\u{1D68C}", "\\mttd": "\u{1D68D}", "\\mtte": "\u{1D68E}", "\\mtteight": "\u{1D7FE}", "\\mttf": "\u{1D68F}", "\\mttfive": "\u{1D7FB}", "\\mttfour": "\u{1D7FA}", "\\mttg": "\u{1D690}", "\\mtth": "\u{1D691}", "\\mtti": "\u{1D692}", "\\mttj": "\u{1D693}", "\\mttk": "\u{1D694}", "\\mttl": "\u{1D695}", "\\mttm": "\u{1D696}", "\\mttn": "\u{1D697}", "\\mttnine": "\u{1D7FF}", "\\mtto": "\u{1D698}", "\\mttone": "\u{1D7F7}", "\\mttp": "\u{1D699}", "\\mttq": "\u{1D69A}", "\\mttr": "\u{1D69B}", "\\mtts": "\u{1D69C}", "\\mttseven": "\u{1D7FD}", "\\mttsix": "\u{1D7FC}", "\\mttt": "\u{1D69D}", "\\mttthree": "\u{1D7F9}", "\\mtttwo": "\u{1D7F8}", "\\mttu": "\u{1D69E}", "\\mttv": "\u{1D69F}", "\\mttw": "\u{1D6A0}", "\\mttx": "\u{1D6A1}", "\\mtty": "\u{1D6A2}", "\\mttz": "\u{1D6A3}", "\\mttzero": "\u{1D7F6}", "\\mu": "\u{1D707}", "\\multimap": "\u22B8", "\\multimapboth": "\u29DF", "\\multimapinv": "\u27DC", "\\mupAlpha": "\u0391", "\\mupBeta": "\u0392", "\\mupChi": "\u03A7", "\\mupDelta": "\u0394", "\\mupEpsilon": "\u0395", "\\mupEta": "\u0397", "\\mupGamma": "\u0393", "\\mupIota": "\u0399", "\\mupKappa": "\u039A", "\\mupLambda": "\u039B", "\\mupMu": "\u039C", "\\mupNu": "\u039D", "\\mupOmega": "\u03A9", "\\mupOmicron": "\u039F", "\\mupPhi": "\u03A6", "\\mupPi": "\u03A0", "\\mupPsi": "\u03A8", "\\mupRho": "\u03A1", "\\mupSigma": "\u03A3", "\\mupTau": "\u03A4", "\\mupTheta": "\u0398", "\\mupUpsilon": "\u03A5", "\\mupXi": "\u039E", "\\mupZeta": "\u0396", "\\mupalpha": "\u03B1", "\\mupbeta": "\u03B2", "\\mupchi": "\u03C7", "\\mupdelta": "\u03B4", "\\mupepsilon": "\u03F5", "\\mupeta": "\u03B7", "\\mupgamma": "\u03B3", "\\mupiota": "\u03B9", "\\mupkappa": "\u03BA", "\\muplambda": "\u03BB", "\\mupmu": "\u03BC", "\\mupnu": "\u03BD", "\\mupomega": "\u03C9", "\\mupomicron": "\u03BF", "\\mupphi": "\u03D5", "\\muppi": "\u03C0", "\\muppsi": "\u03C8", "\\muprho": "\u03C1", "\\mupsigma": "\u03C3", "\\muptau": "\u03C4", "\\muptheta": "\u03B8", "\\mupupsilon": "\u03C5", "\\mupvarTheta": "\u03F4", "\\mupvarepsilon": "\u03B5", "\\mupvarkappa": "\u03F0", "\\mupvarphi": "\u03C6", "\\mupvarpi": "\u03D6", "\\mupvarrho": "\u03F1", "\\mupvarsigma": "\u03C2", "\\mupvartheta": "\u03D1", "\\mupxi": "\u03BE", "\\mupzeta": "\u03B6", "\\m{e}": "\u03B5", "\\nHdownarrow": "\u21DF", "\\nHuparrow": "\u21DE", "\\nLeftarrow": "\u21D0\u0338", "\\nLeftrightarrow": "\u21D4\u0338", "\\nRightarrow": "\u21D2\u0338", "\\nVDash": "\u22AB\u0338", "\\nVdash": "\u22A9\u0338", "\\nVleftarrow": "\u21FA", "\\nVleftarrowtail": "\u2B3A", "\\nVleftrightarrow": "\u21FC", "\\nVrightarrow": "\u21FB", "\\nVrightarrowtail": "\u2915", "\\nVtwoheadleftarrow": "\u2B35", "\\nVtwoheadleftarrowtail": "\u2B3D", "\\nVtwoheadrightarrow": "\u2901", "\\nVtwoheadrightarrowtail": "\u2918", "\\nabla": "\u{1D6FB}", "\\napprox": "\u2248\u0338", "\\nasymp": "\u224D\u0338", "\\natural": "\u266E", "\\ncong": "\u2245\u0338", "\\ne": "=\u0338", "\\nearrow": "\u2197", "\\neg": "\xAC", "\\neovnwarrow": "\u2931", "\\neovsearrow": "\u292E", "\\neptune": "\u2646", "\\neq": "=\u0338", "\\nequiv": "\u2261\u0338", "\\neswarrow": "\u2922", "\\neuter": "\u26B2", "\\nexists": "\u2203\u0338", "\\ng": "\u014B", "\\ngeq": "\u2265\u0338", "\\ngeqslant": "\u2A7E\u0338", "\\ngtr": ">\u0338", "\\ngtrless": "\u2277\u0338", "\\ngtrsim": "\u2273\u0338", "\\nhVvert": "\u2AF5", "\\nhpar": "\u2AF2", "\\ni": "\u220B", "\\niobar": "\u22FE", "\\nis": "\u22FC", "\\nisd": "\u22FA", "\\nleftarrow": "\u2190\u0338", "\\nleftrightarrow": "\u2194\u0338", "\\nleq": "\u2264\u0338", "\\nleqslant": "\u2A7D\u0338", "\\nless": "<\u0338", "\\nlessgtr": "\u2276\u0338", "\\nlesssim": "\u2272\u0338", "\\nmid": "\u2223\u0338", "\\nni": "\u220B\u0338", "\\nobreakspace": "\xA0", "\\nolinebreak": "\u2060", "\\not": "\u0338", "\\not<": "<\u0338", "\\not>": ">\u0338", "\\not\\apid": "\u224B\u0338", "\\not\\approx": "\u2248\u0338", "\\not\\cong": "\u2245\u0338", "\\not\\doteq": "\u2250\u0338", "\\not\\equiv": "\u2261\u0338", "\\not\\geq": "\u2265\u0338", "\\not\\in": "\u2208\u0338", "\\not\\leq": "\u2264\u0338", "\\not\\ni": "\u220B\u0338", "\\not\\prec": "\u227A\u0338", "\\not\\preceq": "\u2AAF\u0338", "\\not\\sim": "\u223C\u0338", "\\not\\simeq": "\u2243\u0338", "\\not\\sqsubseteq": "\u2291\u0338", "\\not\\sqsupseteq": "\u2292\u0338", "\\not\\subset": "\u2282\u0338", "\\not\\subseteq": "\u2286\u0338", "\\not\\succ": "\u227B\u0338", "\\not\\succeq": "\u2AB0\u0338", "\\not\\supset": "\u2283\u0338", "\\not\\supseteq": "\u2287\u0338", "\\notaccent": "\u0338", "\\notbackslash": "\u2340", "\\notgreaterless": "\u2277\u0338", "\\notin": "\u2208\u0338", "\\notlessgreater": "\u2276\u0338", "\\notslash": "\u233F", "\\nparallel": "\u2225\u0338", "\\npolint": "\u2A14", "\\nprec": "\u227A\u0338", "\\npreccurlyeq": "\u227C\u0338", "\\npreceq": "\u227C\u0338", "\\nrightarrow": "\u2192\u0338", "\\nsim": "\u223C\u0338", "\\nsime": "\u2243\u0338", "\\nsimeq": "\u2243\u0338", "\\nsqsubseteq": "\u2291\u0338", "\\nsqsupseteq": "\u2292\u0338", "\\nsubset": "\u2282\u0338", "\\nsubseteq": "\u2286\u0338", "\\nsubseteqq": "\u2AC5\u0338", "\\nsucc": "\u227B\u0338", "\\nsucccurlyeq": "\u227D\u0338", "\\nsucceq": "\u227D\u0338", "\\nsupset": "\u2283\u0338", "\\nsupseteq": "\u2287\u0338", "\\nsupseteqq": "\u2AC6\u0338", "\\ntriangleleft": "\u22B2\u0338", "\\ntrianglelefteq": "\u22B4\u0338", "\\ntriangleright": "\u22B3\u0338", "\\ntrianglerighteq": "\u22B5\u0338", "\\nu": "\u03BD", "\\nvDash": "\u22A8\u0338", "\\nvLeftarrow": "\u2902", "\\nvLeftrightarrow": "\u2904", "\\nvRightarrow": "\u2903", "\\nvartriangleleft": "\u22B2\u0338", "\\nvartriangleright": "\u22B3\u0338", "\\nvdash": "\u22A2\u0338", "\\nvinfty": "\u29DE", "\\nvleftarrow": "\u21F7", "\\nvleftarrowtail": "\u2B39", "\\nvleftrightarrow": "\u21F9", "\\nvrightarrow": "\u21F8", "\\nvrightarrowtail": "\u2914", "\\nvtwoheadleftarrow": "\u2B34", "\\nvtwoheadleftarrowtail": "\u2B3C", "\\nvtwoheadrightarrow": "\u2900", "\\nvtwoheadrightarrowtail": "\u2917", "\\nwarrow": "\u2196", "\\nwovnearrow": "\u2932", "\\nwsearrow": "\u2921", "\\o": "\xF8", "\\obar": "\u233D", "\\obot": "\u29BA", "\\obrbrak": "\u23E0", "\\obslash": "\u29B8", "\\ocirc": "\u030A", "\\ocirc{u}": "u\u030A", "\\ocommatopright": "\u0315", "\\odiv": "\u2A38", "\\odot": "\u2299", "\\odotslashdot": "\u29BC", "\\oe": "\u0153", "\\ogreaterthan": "\u29C1", "\\oiiint": "\u2230", "\\oiint": "\u222F", "\\oint": "\u222E", "\\ointctrclockwise": "\u2233", "\\olcross": "\u29BB", "\\olessthan": "\u29C0", "\\omega": "\u03C9", "\\ominus": "\u2296", "\\openbracketleft": "\u301A", "\\openbracketright": "\u301B", "\\operp": "\u29B9", "\\oplus": "\u2295", "\\opluslhrim": "\u2A2D", "\\oplusrhrim": "\u2A2E", "\\original": "\u22B6", "\\origof": "\u22B6", "\\oslash": "\u2298", "\\otimes": "\u2297", "\\otimeshat": "\u2A36", "\\otimeslhrim": "\u2A34", "\\otimesrhrim": "\u2A35", "\\oturnedcomma": "\u0312", "\\overbar": "\u0305", "\\overbrace": "\u23DE", "\\overbracket": "\u23B4", "\\overleftarrow.unicode-math": "\u20D6", "\\overleftharpoon": "\u20D0", "\\overleftrightarrow": "\u20E1", "\\overline": "\u0305", "\\overparen": "\u23DC", "\\overrightarrow": "\u20D7", "\\overrightharpoon": "\u20D1", "\\ovhook": "\u0309", "\\parallel": "\u2225", "\\parallelogram": "\u25B1", "\\parallelogramblack": "\u25B0", "\\parsim": "\u2AF3", "\\partial": "\u2202", "\\partialmeetcontraction": "\u2AA3", "\\pencil": "\u270E", "\\pentagon": "\u2B20", "\\pentagonblack": "\u2B1F", "\\perp": "\u27C2", "\\perps": "\u2AE1", "\\perspcorrespond": "\u2A5E", "\\pfun": "\u21F8", "\\phi": "\u03D5", "\\pi": "\u03C0", "\\pinj": "\u2914", "\\pisces": "\u2653", "\\pitchfork": "\u22D4", "\\plusdot": "\u2A25", "\\pluseqq": "\u2A72", "\\plushat": "\u2A23", "\\plussim": "\u2A26", "\\plussubtwo": "\u2A27", "\\plustrif": "\u2A28", "\\pluto": "\u2647", "\\pm": "\xB1", "\\pmboxdrawuni{2501}": "\u2501", "\\pmboxdrawuni{2503}": "\u2503", "\\pmboxdrawuni{250D}": "\u250D", "\\pmboxdrawuni{250E}": "\u250E", "\\pmboxdrawuni{250F}": "\u250F", "\\pmboxdrawuni{2511}": "\u2511", "\\pmboxdrawuni{2512}": "\u2512", "\\pmboxdrawuni{2513}": "\u2513", "\\pmboxdrawuni{2515}": "\u2515", "\\pmboxdrawuni{2516}": "\u2516", "\\pmboxdrawuni{2517}": "\u2517", "\\pmboxdrawuni{2519}": "\u2519", "\\pmboxdrawuni{251A}": "\u251A", "\\pmboxdrawuni{251B}": "\u251B", "\\pmboxdrawuni{251D}": "\u251D", "\\pmboxdrawuni{251E}": "\u251E", "\\pmboxdrawuni{251F}": "\u251F", "\\pmboxdrawuni{2520}": "\u2520", "\\pmboxdrawuni{2521}": "\u2521", "\\pmboxdrawuni{2522}": "\u2522", "\\pmboxdrawuni{2523}": "\u2523", "\\pmboxdrawuni{2525}": "\u2525", "\\pmboxdrawuni{2526}": "\u2526", "\\pmboxdrawuni{2527}": "\u2527", "\\pmboxdrawuni{2528}": "\u2528", "\\pmboxdrawuni{2529}": "\u2529", "\\pmboxdrawuni{252A}": "\u252A", "\\pmboxdrawuni{252B}": "\u252B", "\\pmboxdrawuni{252D}": "\u252D", "\\pmboxdrawuni{252E}": "\u252E", "\\pmboxdrawuni{252F}": "\u252F", "\\pmboxdrawuni{2530}": "\u2530", "\\pmboxdrawuni{2531}": "\u2531", "\\pmboxdrawuni{2532}": "\u2532", "\\pmboxdrawuni{2533}": "\u2533", "\\pmboxdrawuni{2535}": "\u2535", "\\pmboxdrawuni{2536}": "\u2536", "\\pmboxdrawuni{2537}": "\u2537", "\\pmboxdrawuni{2538}": "\u2538", "\\pmboxdrawuni{2539}": "\u2539", "\\pmboxdrawuni{253A}": "\u253A", "\\pmboxdrawuni{253B}": "\u253B", "\\pmboxdrawuni{253D}": "\u253D", "\\pmboxdrawuni{253E}": "\u253E", "\\pmboxdrawuni{253F}": "\u253F", "\\pmboxdrawuni{2540}": "\u2540", "\\pmboxdrawuni{2541}": "\u2541", "\\pmboxdrawuni{2542}": "\u2542", "\\pmboxdrawuni{2543}": "\u2543", "\\pmboxdrawuni{2544}": "\u2544", "\\pmboxdrawuni{2545}": "\u2545", "\\pmboxdrawuni{2546}": "\u2546", "\\pmboxdrawuni{2547}": "\u2547", "\\pmboxdrawuni{2548}": "\u2548", "\\pmboxdrawuni{2549}": "\u2549", "\\pmboxdrawuni{254A}": "\u254A", "\\pmboxdrawuni{254B}": "\u254B", "\\pmboxdrawuni{2574}": "\u2574", "\\pmboxdrawuni{2575}": "\u2575", "\\pmboxdrawuni{2576}": "\u2576", "\\pmboxdrawuni{2577}": "\u2577", "\\pmboxdrawuni{2578}": "\u2578", "\\pmboxdrawuni{2579}": "\u2579", "\\pmboxdrawuni{257A}": "\u257A", "\\pmboxdrawuni{257B}": "\u257B", "\\pmboxdrawuni{257C}": "\u257C", "\\pmboxdrawuni{257D}": "\u257D", "\\pmboxdrawuni{257E}": "\u257E", "\\pmboxdrawuni{257F}": "\u257F", "\\pmboxdrawuni{2581}": "\u2581", "\\pmboxdrawuni{2582}": "\u2582", "\\pmboxdrawuni{2583}": "\u2583", "\\pmboxdrawuni{2585}": "\u2585", "\\pmboxdrawuni{2586}": "\u2586", "\\pmboxdrawuni{2587}": "\u2587", "\\pmboxdrawuni{2589}": "\u2589", "\\pmboxdrawuni{258A}": "\u258A", "\\pmboxdrawuni{258B}": "\u258B", "\\pmboxdrawuni{258D}": "\u258D", "\\pmboxdrawuni{258E}": "\u258E", "\\pmboxdrawuni{258F}": "\u258F", "\\pmboxdrawuni{2594}": "\u2594", "\\pmboxdrawuni{2595}": "\u2595", "\\pmboxdrawuni{2596}": "\u2596", "\\pmboxdrawuni{2597}": "\u2597", "\\pmboxdrawuni{2598}": "\u2598", "\\pmboxdrawuni{2599}": "\u2599", "\\pmboxdrawuni{259A}": "\u259A", "\\pmboxdrawuni{259B}": "\u259B", "\\pmboxdrawuni{259C}": "\u259C", "\\pmboxdrawuni{259D}": "\u259D", "\\pmboxdrawuni{259E}": "\u259E", "\\pmboxdrawuni{259F}": "\u259F", "\\pointint": "\u2A15", "\\pointright": "\u261E", "\\postalmark": "\u3012", "\\pounds": "\xA3", "\\prec": "\u227A", "\\precapprox": "\u2AB7", "\\preccurlyeq": "\u227C", "\\precedesnotsimilar": "\u22E8", "\\preceq": "\u2AAF", "\\preceqq": "\u2AB3", "\\precnapprox": "\u2AB9", "\\precneq": "\u2AB1", "\\precneqq": "\u2AB5", "\\precnsim": "\u22E8", "\\precsim": "\u227E", "\\prime": "\u2032", "\\prod": "\u220F", "\\profline": "\u2312", "\\profsurf": "\u2313", "\\propto": "\u221D", "\\prurel": "\u22B0", "\\psi": "\u03C8", "\\psur": "\u2900", "\\pullback": "\u27D3", "\\pushout": "\u27D4", "\\qoppa": "\u03D9", "\\qprime": "\u2057", "\\qquad": "\u2003\u2003", "\\quad": "\u2003", "\\quarternote": "\u2669", "\\questeq": "\u225F", "\\quotedblbase": "\u201F", "\\quotesinglbase": "\u201A", "\\r": "\u030A", "\\rAngle": "\u27EB", "\\rBrace": "\u2984", "\\rBrack": "\u27E7", "\\rParen": "\u2986", "\\radiation": "\u2622", "\\rang": "\u27EB", "\\rangle": "\u27E9", "\\rangledot": "\u2992", "\\rangledownzigzagarrow": "\u237C", "\\rbag": "\u27C6", "\\rblkbrbrak": "\u2998", "\\rblot": "\u298A", "\\rbrace": "}", "\\rbracelend": "\u23AD", "\\rbracemid": "\u23AC", "\\rbraceuend": "\u23AB", "\\rbrack": "]", "\\rbrackextender": "\u23A5", "\\rbracklend": "\u23A6", "\\rbracklrtick": "\u298E", "\\rbrackubar": "\u298C", "\\rbrackuend": "\u23A4", "\\rbrackurtick": "\u2990", "\\rbrbrak": "\u3015", "\\rceil": "\u2309", "\\rcirclerightint": "\u2233", "\\rcurvyangle": "\u29FD", "\\rdiagovfdiag": "\u292B", "\\rdiagovsearrow": "\u2930", "\\recorder": "\u2315", "\\recycle": "\u267B", "\\reflectbox{\\carriagereturn}": "\u21B3", "\\revangle": "\u29A3", "\\revangleubar": "\u29A5", "\\revemptyset": "\u29B0", "\\reversesolidus": "\u29F5", "\\revnmid": "\u2AEE", "\\rfbowtie": "\u29D2", "\\rfloor": "\u230B", "\\rftimes": "\u29D5", "\\rgroup": "\u27EF", "\\rhd": "\u25B7", "\\rho": "\u03C1", "\\right": "", "\\rightangle": "\u221F", "\\rightanglearc": "\u22BE", "\\rightanglemdot": "\u299D", "\\rightanglesqr": "\u299C", "\\rightarrow": "\u2192", "\\rightarrowapprox": "\u2975", "\\rightarrowbackapprox": "\u2B48", "\\rightarrowbar": "\u21E5", "\\rightarrowbsimilar": "\u2B4C", "\\rightarrowdiamond": "\u291E", "\\rightarrowgtr": "\u2B43", "\\rightarrowonoplus": "\u27F4", "\\rightarrowplus": "\u2945", "\\rightarrowshortleftarrow": "\u2942", "\\rightarrowsimilar": "\u2974", "\\rightarrowsupset": "\u2B44", "\\rightarrowtail": "\u21A3", "\\rightarrowtriangle": "\u21FE", "\\rightarrowx": "\u2947", "\\rightbarharpoon": "\u296C", "\\rightbkarrow": "\u290D", "\\rightcurvedarrow": "\u2933", "\\rightdasharrow": "\u21E2", "\\rightdbltail": "\u291C", "\\rightdotarrow": "\u2911", "\\rightdowncurvedarrow": "\u2937", "\\rightfishtail": "\u297D", "\\rightharpoonaccent": "\u20D1", "\\rightharpoondown": "\u21C1", "\\rightharpoondownbar": "\u2957", "\\rightharpoonsupdown": "\u2964", "\\rightharpoonup": "\u21C0", "\\rightharpoonupbar": "\u2953", "\\rightharpoonupdash": "\u296C", "\\rightimply": "\u2970", "\\rightleftarrows": "\u21C4", "\\rightleftharpoon": "\u294B", "\\rightleftharpoons": "\u21CC", "\\rightleftharpoonsdown": "\u2969", "\\rightleftharpoonsup": "\u2968", "\\rightmoon": "\u263D", "\\rightouterjoin": "\u27D6", "\\rightpentagon": "\u2B54", "\\rightpentagonblack": "\u2B53", "\\rightrightarrows": "\u21C9", "\\rightrightharpoons": "\u2964", "\\rightslice": "\u2AA7", "\\rightsquigarrow": "\u21DD", "\\righttail": "\u291A", "\\rightthreearrows": "\u21F6", "\\rightthreetimes": "\u22CC", "\\rightwavearrow": "\u219D", "\\rightwhitearrow": "\u21E8", "\\rimg": "\u2988", "\\ringplus": "\u2A22", "\\risingdotseq": "\u2253", "\\rmoustache": "\u23B1", "\\rparen": ")", "\\rparenextender": "\u239F", "\\rparengtr": "\u2994", "\\rparenlend": "\u23A0", "\\rparenuend": "\u239E", "\\rppolint": "\u2A12", "\\rrangle": "\u298A", "\\rrbracket": "\u27E7", "\\rrparenthesis": "\u2988", "\\rsolbar": "\u29F7", "\\rsqhook": "\u2ACE", "\\rsub": "\u2A65", "\\rtimes": "\u22CA", "\\rtriltri": "\u29CE", "\\ruledelayed": "\u29F4", "\\rule{1em}{1pt}": "\u2015", "\\rvboxline": "\u23B9", "\\rvzigzag": "\u29D9", "\\r{}": "\u02DA", "\\sagittarius": "\u2650", "\\sampi": "\u03E1", "\\sansLmirrored": "\u2143", "\\sansLturned": "\u2142", "\\saturn": "\u2644", "\\scorpio": "\u264F", "\\scpolint": "\u2A13", "\\scurel": "\u22B1", "\\searrow": "\u2198", "\\seovnearrow": "\u292D", "\\setminus": "\u29F5", "\\sharp": "\u266F", "\\shortdowntack": "\u2ADF", "\\shortlefttack": "\u2ADE", "\\shortrightarrowleftarrow": "\u2944", "\\shortuptack": "\u2AE0", "\\shuffle": "\u29E2", "\\sigma": "\u03C3", "\\sim": "\u223C", "\\sim\\joinrel\\leadsto": "\u27FF", "\\sime": "\u2243", "\\simeq": "\u2243", "\\simgE": "\u2AA0", "\\simgtr": "\u2A9E", "\\similarleftarrow": "\u2B49", "\\similarrightarrow": "\u2972", "\\simlE": "\u2A9F", "\\simless": "\u2A9D", "\\simminussim": "\u2A6C", "\\simneqq": "\u2246", "\\simplus": "\u2A24", "\\simrdots": "\u2A6B", "\\sinewave": "\u223F", "\\sixteenthnote": "\u266C", "\\skull": "\u2620", "\\slash": "/\u200B", "\\smallblacktriangleleft": "\u25C2", "\\smallblacktriangleright": "\u25B8", "\\smallin": "\u220A", "\\smallni": "\u220D", "\\smalltriangleleft": "\u25C3", "\\smalltriangleright": "\u25B9", "\\smashtimes": "\u2A33", "\\smblkcircle": "\u2022", "\\smblkdiamond": "\u2B29", "\\smblklozenge": "\u2B2A", "\\smblksquare": "\u25AA", "\\smeparsl": "\u29E4", "\\smile": "\u2323", "\\smiley": "\u263A", "\\smt": "\u2AAA", "\\smte": "\u2AAC", "\\smwhitestar": "\u2B52", "\\smwhtcircle": "\u25E6", "\\smwhtdiamond": "\u22C4", "\\smwhtlozenge": "\u2B2B", "\\smwhtsquare": "\u25AB", "\\spadesuit": "\u2660", "\\sphericalangle": "\u2222", "\\sphericalangleup": "\u29A1", "\\spot": "\u2981", "\\sqcap": "\u2293", "\\sqcup": "\u2294", "\\sqint": "\u2A16", "\\sqlozenge": "\u2311", "\\sqrint": "\u2A16", "\\sqrt": "\u221A", "\\sqrt[3]": "\u221B", "\\sqrt[4]": "\u221C", "\\sqrtbottom": "\u23B7", "\\sqsubset": "\u228F", "\\sqsubseteq": "\u2291", "\\sqsubsetneq": "\u22E4", "\\sqsupset": "\u2290", "\\sqsupseteq": "\u2292", "\\sqsupsetneq": "\u22E5", "\\square": "\u25FB", "\\squarebotblack": "\u2B13", "\\squarecrossfill": "\u25A9", "\\squarehfill": "\u25A4", "\\squarehvfill": "\u25A6", "\\squareleftblack": "\u25E7", "\\squarellblack": "\u2B15", "\\squarellquad": "\u25F1", "\\squarelrblack": "\u25EA", "\\squarelrquad": "\u25F2", "\\squareneswfill": "\u25A8", "\\squarenwsefill": "\u25A7", "\\squarerightblack": "\u25E8", "\\squaretopblack": "\u2B12", "\\squareulblack": "\u25E9", "\\squareulquad": "\u25F0", "\\squareurblack": "\u2B14", "\\squareurquad": "\u25F3", "\\squarevfill": "\u25A5", "\\squoval": "\u25A2", "\\ss": "\xDF", "\\sslash": "\u2AFD", "\\stackrel{*}{=}": "\u2A6E", "\\star": "\u22C6", "\\stareq": "\u225B", "\\starequal": "\u225B", "\\steaming": "\u2615", "\\stigma": "\u03DB", "\\strns": "\u23E4", "\\subedot": "\u2AC3", "\\submult": "\u2AC1", "\\subrarr": "\u2979", "\\subset": "\u2282", "\\subsetapprox": "\u2AC9", "\\subsetcirc": "\u27C3", "\\subsetdot": "\u2ABD", "\\subseteq": "\u2286", "\\subseteqq": "\u2AC5", "\\subsetneq": "\u228A", "\\subsetneqq": "\u2ACB", "\\subsetplus": "\u2ABF", "\\subsim": "\u2AC7", "\\subsub": "\u2AD5", "\\subsup": "\u2AD3", "\\succ": "\u227B", "\\succapprox": "\u2AB8", "\\succcurlyeq": "\u227D", "\\succeq": "\u2AB0", "\\succeqq": "\u2AB4", "\\succnapprox": "\u2ABA", "\\succneq": "\u2AB2", "\\succneqq": "\u2AB6", "\\succnsim": "\u22E9", "\\succsim": "\u227F", "\\sum": "\u2211", "\\sumbottom": "\u23B3", "\\sumint": "\u2A0B", "\\sumtop": "\u23B2", "\\sun": "\u263C", "\\supdsub": "\u2AD8", "\\supedot": "\u2AC4", "\\suphsol": "\u27C9", "\\suphsub": "\u2AD7", "\\suplarr": "\u297B", "\\supmult": "\u2AC2", "\\supset": "\u2283", "\\supsetapprox": "\u2ACA", "\\supsetcirc": "\u27C4", "\\supsetdot": "\u2ABE", "\\supseteq": "\u2287", "\\supseteqq": "\u2AC6", "\\supsetneq": "\u228B", "\\supsetneqq": "\u2ACC", "\\supsetplus": "\u2AC0", "\\supsim": "\u2AC8", "\\supsub": "\u2AD4", "\\supsup": "\u2AD6", "\\surd": "\u221A", "\\surfintegral": "\u222F", "\\swarrow": "\u2199", "\\swords": "\u2694", "\\talloblong": "\u2AFE", "\\tau": "\u03C4", "\\taurus": "\u2649", "\\textGamma": "\u0393", "\\textOmega": "\u03A9", "\\textPhi": "\u03A6", "\\textSFi": "\u250C", "\\textSFii": "\u2514", "\\textSFiii": "\u2510", "\\textSFiv": "\u2518", "\\textSFix": "\u2524", "\\textSFl": "\u2558", "\\textSFli": "\u2552", "\\textSFlii": "\u2553", "\\textSFliii": "\u256B", "\\textSFliv": "\u256A", "\\textSFv": "\u253C", "\\textSFvi": "\u252C", "\\textSFvii": "\u2534", "\\textSFviii": "\u251C", "\\textSFx": "\u2500", "\\textSFxi": "\u2502", "\\textSFxix": "\u2561", "\\textSFxl": "\u2569", "\\textSFxli": "\u2566", "\\textSFxlii": "\u2560", "\\textSFxliii": "\u2550", "\\textSFxliv": "\u256C", "\\textSFxlix": "\u2559", "\\textSFxlv": "\u2567", "\\textSFxlvi": "\u2568", "\\textSFxlvii": "\u2564", "\\textSFxlviii": "\u2565", "\\textSFxx": "\u2562", "\\textSFxxi": "\u2556", "\\textSFxxii": "\u2555", "\\textSFxxiii": "\u2563", "\\textSFxxiv": "\u2551", "\\textSFxxv": "\u2557", "\\textSFxxvi": "\u255D", "\\textSFxxvii": "\u255C", "\\textSFxxviii": "\u255B", "\\textSFxxxix": "\u2554", "\\textSFxxxvi": "\u255E", "\\textSFxxxvii": "\u255F", "\\textSFxxxviii": "\u255A", "\\textSigma": "\u03A3", "\\textTheta": "\u03F4", "\\textTstroke": "\u0166", "\\textacutedbl": "\u02DD", "\\textacutemacron": "\u0301\u0304", "\\textacutewedge": "\u0301\u030C", "\\textadvancing": "\u0318", "\\textalpha": "\u03B1", "\\textapproxequal": "\u2248", "\\textasciiacute": "\xB4", "\\textasciibreve": "\u02D8", "\\textasciicaron": "\u02C7", "\\textasciicircum": "^", "\\textasciidieresis": "\xA8", "\\textasciigrave": "\u02CB", "\\textasciimacron": "\xAF", "\\textasciitilde": "~", "\\textasteriskcentered": "*", "\\textbackslash": "\\", "\\textbaht": "\u0E3F", "\\textbar": "|", "\\textbardbl": "\u2016", "\\textbeta": "\u03B2", "\\textbigcircle": "\u25EF", "\\textblacksquare": "\u25A0", "\\textblank": "\u2422", "\\textblock": "\u2588", "\\textbraceleft": "{", "\\textbraceright": "}", "\\textbrevemacron": "\u0306\u0304", "\\textbrokenbar": "\xA6", "\\textbullet": "\u2022", "\\textcap": "\u2227", "\\textcelsius": "\u2103", "\\textcent": "\xA2", "\\textcircledP": "\u2117", "\\textcircled{R}": "\xAE", "\\textcircumdot": "\u0302\u0307", "\\textcolonmonetary": "\u20A1", "\\textcommabelow": "\u0326", "\\textcompwordmark": "\u200C", "\\textcontourintegral": "\u222E", "\\textcopyright": "\xA9", "\\textcorner": "\u031A", "\\textcrh": "\u0127", "\\textcurrency": "\xA4", "\\textdagger": "\u2020", "\\textdaggerdbl": "\u2021", "\\textdbllowline": "\u2017", "\\textdegree": "\xB0", "\\textdelta": "\u03B4", "\\textdh": "\xF0", "\\textdiscount": "\u2052", "\\textdiv": "\xF7", "\\textdkshade": "\u2593", "\\textdnblock": "\u2584", "\\textdollar": "$", "\\textdong": "\u20AB", "\\textdotacute": "\u0307\u0301", "\\textdotbreve": "\u0310", "\\textdoublegrave": "\u030F", "\\textdoublepipe": "\u01C2", "\\textdoublevbaraccent": "\u030E", "\\textdownarrow": "\u2193", "\\textelement": "\u2208", "\\textellipsis": "\u2026", "\\textemdash": "\u2014", "\\textendash": "\u2013", "\\texteopen": "\u03B5", "\\textepsilon": "\u03B5", "\\texteqsim": "\u2242", "\\textequivalence": "\u2261", "\\textesh": "\u01AA", "\\textestimated": "\u212E", "\\texteuro": "\u20AC", "\\textexclamdown": "\xA1", "\\textflorin": "\u0192", "\\textfractionsolidus": "\u2044", "\\textfrac{0}{3}": "\u2189", "\\textfrac{1}": "\u215F", "\\textfrac{1}{10}": "\u2152", "\\textfrac{1}{3}": "\u2153", "\\textfrac{1}{5}": "\u2155", "\\textfrac{1}{6}": "\u2159", "\\textfrac{1}{7}": "\u2150", "\\textfrac{1}{8}": "\u215B", "\\textfrac{1}{9}": "\u2151", "\\textfrac{2}{3}": "\u2154", "\\textfrac{2}{5}": "\u2156", "\\textfrac{3}{5}": "\u2157", "\\textfrac{3}{8}": "\u215C", "\\textfrac{4}{5}": "\u2158", "\\textfrac{5}{6}": "\u215A", "\\textfrac{5}{8}": "\u215D", "\\textfrac{7}{8}": "\u215E", "\\textgravedot": "\u0300\u0307", "\\textgravemacron": "\u0300\u0304", "\\textgreater": ">", "\\textgreaterequal": "\u2265", "\\texthorizontalbar": "\u2015", "\\texthvlig": "\u0195", "\\textincrement": "\u2206", "\\textinfinity": "\u221E", "\\textintegral": "\u222B", "\\textinterrobang": "\u203D", "\\textintersection": "\u2229", "\\textinvsubbridge": "\u033A", "\\textipa{O}": "\u0254", "\\textipa{\\textnrleg}": "\u019E", "\\textipa{\\textturna}": "\u0250", "\\textkra": "\u0138", "\\textlangle": "\u3008", "\\textleftarrow": "\u2190", "\\textless": "<", "\\textlessequal": "\u2264", "\\textlfblock": "\u258C", "\\textlira": "\u20A4", "\\textlnot": "\xAC", "\\textlowering": "\u031E", "\\textlozenge": "\u25CA", "\\textltshade": "\u2591", "\\textmalteseH": "\u0126", "\\textmalteseh": "\u0127", "\\textmho": "\u2127", "\\textmu": "\xB5", "\\textmusicalnote": "\u266A", "\\textnaira": "\u20A6", "\\textniepsilon": "\u03B5", "\\textnotequal": "=\u0338", "\\textnsuperior": "\u207F", "\\textnumero": "\u2116", "\\textohm": "\u03A9", "\\textonehalf": "\xBD", "\\textonequarter": "\xBC", "\\textonesuperior": "\xB9", "\\textopenbullet": "\u25E6", "\\textordfeminine": "\xAA", "\\textordmasculine": "\xBA", "\\textovercross": "\u033D", "\\textparagraph": "\xB6", "\\textpartial": "\u2202", "\\textperiodcentered": "\u02D9", "\\textpertenthousand": "\u2031", "\\textperthousand": "\u2030", "\\textpeseta": "\u20A7", "\\textpeso": "\u20B1", "\\textphi": "\u0278", "\\textpi": "\u03C0", "\\textpm": "\xB1", "\\textproduct": "\u220F", "\\textquestiondown": "\xBF", "\\textquotedbl": '"', "\\textquotedblleft": "\u201C", "\\textquotedblright": "\u201D", "\\textquoteleft": "\u2018", "\\textquoteright": "\u2019", "\\textraising": "\u031D", "\\textrangle": "\u3009", "\\textrecipe": "\u211E", "\\textreferencemark": "\u203B", "\\textregistered": "\xAE", "\\textretracting": "\u0319", "\\textrevlogicalnot": "\u2310", "\\textrevscripta": "\u0264", "\\textrightarrow": "\u2192", "\\textringmacron": "\u030A\u0304", "\\textriota": "\u2129", "\\textrtaild": "\u0256", "\\textrtblock": "\u2590", "\\textschwa": "\u0259", "\\textseagull": "\u033C", "\\textsection": "\xA7", "\\textservicemark": "\u2120", "\\textshade": "\u2592", "\\textsigma": "\u03C3", "\\textsterling": "\xA3", "\\textsubarch": "\u032F", "\\textsubbar": "\u0331", "\\textsubbridge": "\u032A", "\\textsubbridge{d}": "\u0256", "\\textsubgrave": "\u0316", "\\textsublhalfring": "\u031C", "\\textsubplus": "\u031F", "\\textsubrhalfring": "\u0339", "\\textsubring": "\u0325", "\\textsubscript{0}": "\u2080", "\\textsubscript{1}": "\u2081", "\\textsubscript{2}": "\u2082", "\\textsubscript{3}": "\u2083", "\\textsubscript{4}": "\u2084", "\\textsubscript{5}": "\u2085", "\\textsubscript{6}": "\u2086", "\\textsubscript{7}": "\u2087", "\\textsubscript{8}": "\u2088", "\\textsubscript{9}": "\u2089", "\\textsubscript{\\textschwa}": "\u2094", "\\textsubscript{a}": "\u2090", "\\textsubscript{e}": "\u2091", "\\textsubscript{h}": "\u2095", "\\textsubscript{k}": "\u2096", "\\textsubscript{l}": "\u2097", "\\textsubscript{m}": "\u2098", "\\textsubscript{n}": "\u2099", "\\textsubscript{o}": "\u2092", "\\textsubscript{p}": "\u209A", "\\textsubscript{s}": "\u209B", "\\textsubscript{t}": "\u209C", "\\textsubscript{x}": "\u2093", "\\textsubsquare": "\u033B", "\\textsubtilde": "\u0330", "\\textsubumlaut": "\u0324", "\\textsubwedge": "\u032C", "\\textsummation": "\u2211", "\\textsuperimposetilde": "\u0334", "\\textsuperscript{1}": "\xB9", "\\textsuperscript{2}": "\xB2", "\\textsuperscript{3}": "\xB3", "\\textsuperscript{4}": "\u2074", "\\textsuperscript{5}": "\u2075", "\\textsuperscript{6}": "\u2076", "\\textsuperscript{7}": "\u2077", "\\textsuperscript{8}": "\u2078", "\\textsuperscript{9}": "\u2079", "\\textsuperscript{A}": "\u1D2C", "\\textsuperscript{a}": "\u1D43", "\\textsuperscript{b}": "\u1D47", "\\textsuperscript{c}": "\u1D9C", "\\textsuperscript{d}": "\u1D48", "\\textsuperscript{e}": "\u1D49", "\\textsuperscript{f}": "\u1DA0", "\\textsuperscript{g}": "\u1D4D", "\\textsuperscript{h}": "\u02B0", "\\textsuperscript{i}": "\u2071", "\\textsuperscript{j}": "\u02B2", "\\textsuperscript{k}": "\u1D4F", "\\textsuperscript{l}": "\u02E1", "\\textsuperscript{m}": "\u1D50", "\\textsuperscript{n}": "\u207F", "\\textsuperscript{o}": "\u1D52", "\\textsuperscript{p}": "\u1D56", "\\textsuperscript{r}": "\u02B3", "\\textsuperscript{s}": "\u02E2", "\\textsuperscript{t}": "\u1D57", "\\textsuperscript{u}": "\u1D58", "\\textsuperscript{v}": "\u1D5B", "\\textsuperscript{w}": "\u02B7", "\\textsuperscript{x}": "\u02E3", "\\textsuperscript{y}": "\u02B8", "\\textsuperscript{z}": "\u1DBB", "\\textsurd": "\u221A", "\\textsyllabic": "\u0329", "\\texttau": "\u03C4", "\\texttheta": "\u03B8", "\\textthreequarters": "\xBE", "\\textthreesuperior": "\xB3", "\\texttildedot": "\u0303\u0307", "\\texttildelow": "\u02DC", "\\texttimes": "\xD7", "\\texttrademark": "\u2122", "\\texttstroke": "\u0167", "\\textturnk": "\u029E", "\\textturnm": "\u026F", "\\texttwosuperior": "\xB2", "\\textunderscore": "_", "\\textuparrow": "\u2191", "\\textupblock": "\u2580", "\\textvartheta": "\u03D1", "\\textvbaraccent": "\u030D", "\\textvisiblespace": "\u2294", "\\textwon": "\u20A9", "\\textyen": "\xA5", "\\th": "\xFE", "\\therefore": "\u2234", "\\thermod": "\u29E7", "\\theta": "\u03B8", "\\thickspace": "\u2005", "\\thinspace": "\u2009", "\\threedangle": "\u27C0", "\\threedotcolon": "\u2AF6", "\\threeunderdot": "\u20E8", "\\tieconcat": "\u2040", "\\tieinfty": "\u29DD", "\\tilde": "\u0303", "\\tildetrpl": "\u224B", "\\times": "\xD7", "\\timesbar": "\u2A31", "\\tminus": "\u29FF", "\\to": "\u2192", "\\toea": "\u2928", "\\tona": "\u2927", "\\tone{11}": "\u02E9", "\\tone{22}": "\u02E8", "\\tone{33}": "\u02E7", "\\tone{44}": "\u02E6", "\\tone{55}": "\u02E5", "\\top": "\u22A4", "\\topbot": "\u2336", "\\topcir": "\u2AF1", "\\topfork": "\u2ADA", "\\topsemicircle": "\u25E0", "\\tosa": "\u2929", "\\towa": "\u292A", "\\tplus": "\u29FE", "\\trapezium": "\u23E2", "\\trianglecdot": "\u25EC", "\\triangledown": "\u25BF", "\\triangleleft": "\u25C1", "\\triangleleftblack": "\u25ED", "\\trianglelefteq": "\u22B4", "\\triangleminus": "\u2A3A", "\\triangleodot": "\u29CA", "\\triangleplus": "\u2A39", "\\triangleq": "\u225C", "\\triangleright": "\u25B7", "\\trianglerightblack": "\u25EE", "\\trianglerighteq": "\u22B5", "\\triangles": "\u29CC", "\\triangleserifs": "\u29CD", "\\triangletimes": "\u2A3B", "\\triangleubar": "\u29CB", "\\tripleplus": "\u29FB", "\\trprime": "\u2034", "\\trslash": "\u2AFB", "\\truestate": "\u22A7", "\\turnangle": "\u29A2", "\\turnediota": "\u2129", "\\turnednot": "\u2319", "\\twocaps": "\u2A4B", "\\twocups": "\u2A4A", "\\twoheaddownarrow": "\u21A1", "\\twoheadleftarrow": "\u219E", "\\twoheadleftarrowtail": "\u2B3B", "\\twoheadleftdbkarrow": "\u2B37", "\\twoheadmapsfrom": "\u2B36", "\\twoheadmapsto": "\u2905", "\\twoheadrightarrow": "\u21A0", "\\twoheadrightarrowtail": "\u2916", "\\twoheaduparrow": "\u219F", "\\twoheaduparrowcircle": "\u2949", "\\twolowline": "\u2017", "\\twonotes": "\u266B", "\\typecolon": "\u2982", "\\t{ia}": "i\uFE20a\uFE21", "\\u": "\u0306", "\\ubrbrak": "\u23E1", "\\ularc": "\u25DC", "\\ulblacktriangle": "\u25E4", "\\ulcorner": "\u231C", "\\ultriangle": "\u25F8", "\\uminus": "\u2A41", "\\underbar": "\u0331", "\\underbrace": "\u23DF", "\\underbracket": "\u23B5", "\\underleftarrow": "\u20EE", "\\underleftharpoondown": "\u20ED", "\\underleftrightarrow": "\u034D", "\\underline": "\u0332", "\\underparen": "\u23DD", "\\underrightarrow": "\u20EF", "\\underrightharpoondown": "\u20EC", "\\unicodecdots": "\u22EF", "\\unicodeellipsis": "\u2026", "\\upDigamma": "\u03DC", "\\upand": "\u214B", "\\uparrow": "\u2191", "\\uparrowbarred": "\u2909", "\\uparrowoncircle": "\u29BD", "\\upbackepsilon": "\u03F6", "\\updasharrow": "\u21E1", "\\updigamma": "\u03DD", "\\updownarrow": "\u2195", "\\updownarrowbar": "\u21A8", "\\updownarrows": "\u21C5", "\\updownharpoonleftleft": "\u2951", "\\updownharpoonleftright": "\u294D", "\\updownharpoonrightleft": "\u294C", "\\updownharpoonrightright": "\u294F", "\\updownharpoonsleftright": "\u296E", "\\upfishtail": "\u297E", "\\upharpoonleft": "\u21BF", "\\upharpoonleftbar": "\u2960", "\\upharpoonright": "\u21BE", "\\upharpoonrightbar": "\u295C", "\\upharpoonsleftright": "\u2963", "\\upin": "\u27D2", "\\upint": "\u2A1B", "\\uplus": "\u228E", "\\uprightcurvearrow": "\u2934", "\\upsilon": "\u03C5", "\\upslopeellipsis": "\u22F0", "\\upuparrows": "\u21C8", "\\upupharpoons": "\u2963", "\\upvarTheta": "\u03F4", "\\upwhitearrow": "\u21E7", "\\uranus": "\u2645", "\\urarc": "\u25DD", "\\urblacktriangle": "\u25E5", "\\urcorner": "\u231D", "\\urtriangle": "\u25F9", "\\utilde": "\u0330", "\\v": "\u030C", "\\vBar": "\u2AE8", "\\vBarv": "\u2AE9", "\\vDash": "\u22A8", "\\vDdash": "\u2AE2", "\\varGamma": "\u0393", "\\varVdash": "\u2AE6", "\\varbarwedge": "\u2305", "\\varbeta": "\u03D0", "\\varcarriagereturn": "\u23CE", "\\varclubsuit": "\u2667", "\\vardiamondsuit": "\u2666", "\\vardoublebarwedge": "\u2306", "\\varepsilon": "\u03B5", "\\varheartsuit": "\u2665", "\\varhexagon": "\u2B21", "\\varhexagonblack": "\u2B22", "\\varhexagonlrbonds": "\u232C", "\\varisinobar": "\u22F6", "\\varisins": "\u22F3", "\\varkappa": "\u03F0", "\\varlrtriangle": "\u22BF", "\\varniobar": "\u22FD", "\\varnis": "\u22FB", "\\varnothing": "\u2205", "\\varointclockwise": "\u2232", "\\varphi": "\u03C6", "\\varpi": "\u03D6", "\\varprod": "\u2A09", "\\varrho": "\u03F1", "\\varsigma": "\u03C2", "\\varspadesuit": "\u2664", "\\varstar": "\u2736", "\\varsubsetneqq": "\u228A\uFE00", "\\varsupsetneq": "\u228B\uFE00", "\\vartheta": "\u03D1", "\\vartriangle": "\u25B5", "\\vartriangleleft": "\u22B2", "\\vartriangleright": "\u22B3", "\\varveebar": "\u2A61", "\\vbraceextender": "\u23AA", "\\vbrtri": "\u29D0", "\\vdash": "\u22A2", "\\vdots": "\u22EE", "\\vec": "\u20D7", "\\vectimes": "\u2A2F", "\\vee": "\u2228", "\\veebar": "\u22BB", "\\veedot": "\u27C7", "\\veedoublebar": "\u2A63", "\\veeeq": "\u225A", "\\veemidvert": "\u2A5B", "\\veeodot": "\u2A52", "\\veeonvee": "\u2A56", "\\veeonwedge": "\u2A59", "\\venus": "\u2640", "\\vert": "|", "\\vertoverlay": "\u20D2", "\\verymuchgreater": "\u22D9", "\\verymuchless": "\u22D8", "\\viewdata": "\u2317", "\\virgo": "\u264D", "\\vlongdash": "\u27DD", "\\volintegral": "\u2230", "\\vrectangle": "\u25AF", "\\vrectangleblack": "\u25AE", "\\vysmblkcircle": "\u2219", "\\vysmblksquare": "\u2B1D", "\\vysmwhtcircle": "\u2218", "\\vysmwhtsquare": "\u2B1E", "\\vzigzag": "\u299A", "\\v{\\i}": "i\u030C", "\\v{\\j}": "j\u030C", "\\warning": "\u26A0", "\\wasylozenge": "\u2311", "\\wedge": "\u2227", "\\wedgebar": "\u2A5F", "\\wedgedot": "\u27D1", "\\wedgedoublebar": "\u2A60", "\\wedgemidvert": "\u2A5A", "\\wedgeodot": "\u2A51", "\\wedgeonwedge": "\u2A55", "\\wedgeq": "\u2259", "\\whitearrowupfrombar": "\u21EA", "\\whiteinwhitetriangle": "\u27C1", "\\whitepointerleft": "\u25C5", "\\whitepointerright": "\u25BB", "\\whitesquaretickleft": "\u27E4", "\\whitesquaretickright": "\u27E5", "\\whthorzoval": "\u2B2D", "\\whtvertoval": "\u2B2F", "\\wideangledown": "\u29A6", "\\wideangleup": "\u29A7", "\\widebreve": "\u0306", "\\widebridgeabove": "\u20E9", "\\widecheck": "\u030C", "\\widehat": "\u2227", "\\wideoverbar": "\u0305", "\\widetilde": "\u0303", "\\wideutilde": "\u0330", "\\wp": "\u2118", "\\wr": "\u2240", "\\xbsol": "\u29F9", "\\xi": "\u03BE", "\\xsol": "\u29F8", "\\yinyang": "\u262F", "\\zcmp": "\u2A1F", "\\zeta": "\u03B6", "\\zhide": "\u29F9", "\\zpipe": "\u2A20", "\\zproject": "\u2A21", "\\{": "{", "\\}": "}", "\\~": "\u0303", "\\~{\\i}": "i\u0303", "\\\xB4": "\u0301", "^\\circ": "\xB0", "^{(}": "\u207D", "^{)}": "\u207E", "^{+}": "\u207A", "^{-}": "\u207B", "^{0}": "\u2070", "^{1}": "\xB9", "^{2}": "\xB2", "^{3}": "\xB3", "^{4}": "\u2074", "^{5}": "\u2075", "^{6}": "\u2076", "^{7}": "\u2077", "^{8}": "\u2078", "^{9}": "\u2079", "^{=}": "\u207C", "^{A}": "\u1D2C", "^{a}": "\u1D43", "^{b}": "\u1D47", "^{c}": "\u1D9C", "^{d}": "\u1D48", "^{e}": "\u1D49", "^{f}": "\u1DA0", "^{g}": "\u1D4D", "^{h}": "\u02B0", "^{i}": "\u2071", "^{j}": "\u02B2", "^{k}": "\u1D4F", "^{l}": "\u02E1", "^{m}": "\u1D50", "^{n}": "\u207F", "^{o}": "\u1D52", "^{p}": "\u1D56", "^{r}": "\u02B3", "^{s}": "\u02E2", "^{t}": "\u1D57", "^{u}": "\u1D58", "^{v}": "\u1D5B", "^{w}": "\u02B7", "^{x}": "\u02E3", "^{y}": "\u02B8", "^{z}": "\u1DBB", "_\\infty": " \u035A", "_{(}": "\u208D", "_{)}": "\u208E", "_{+}": "\u208A", "_{-}": "\u208B", "_{0}": "\u2080", "_{1}": "\u2081", "_{2}": "\u2082", "_{3}": "\u2083", "_{4}": "\u2084", "_{5}": "\u2085", "_{6}": "\u2086", "_{7}": "\u2087", "_{8}": "\u2088", "_{9}": "\u2089", "_{=}": "\u208C", "_{a}": "\u2090", "_{e}": "\u2091", "_{h}": "\u2095", "_{k}": "\u2096", "_{l}": "\u2097", "_{m}": "\u2098", "_{n}": "\u2099", "_{o}": "\u2092", "_{p}": "\u209A", "_{s}": "\u209B", "_{t}": "\u209C", "_{x}": "\u2093", "``": { "text": "\u201C", "math": "``" }, "textipa{\\textopeno}": "\u0252", "{'''}": { "text": "{'''}", "math": "\u2034" }, "{''}": { "text": "{''}", "math": "\u2033" }, "{\\'{}I}": "\u0399\u0301", "{\\'{}O}": "\u039F\u0301", "{\\aftergroup\\ignorespaces}": "\u200C", "{\\int\\!\\int\\!\\int}": "\u222D", "{\\int\\!\\int}": "\u222C", '{\\mathchar"2208}': "\u2316", "{\\not\\kern-0.3em\\times}": "\u224D\u0338", "{\\r A}": "A\u030A", "{\\r U}": "U\u030A", "{\\r a}": "a\u030A", "{\\r u}": "u\u030A", "{\\rlap{\\textbackslash}{{/}\\!\\!{/}}}": "\u2AFD\u20E5", "{\\u \\i}": "i\u0306", "{_\\ast}": "\u2217", "{{/}\\!\\!{/}}": "\u2AFD", "~": "\xA0" };
    }
  });

  // node_modules/unicode2latex/tables/combining.json
  var require_combining = __commonJS({
    "node_modules/unicode2latex/tables/combining.json"(exports, module) {
      module.exports = { "macros": ["acute", "bar", "breve", "c", "candra", "check", "d", "ddot", "dot", "droang", "grave", "hat", "k", "mathring", "ocirc", "overbar", "overline", "r", "textacutemacron", "textacutewedge", "textadvancing", "textbrevemacron", "textcircumdot", "textcommabelow", "textcorner", "textdotacute", "textdotbreve", "textdoublegrave", "textdoublevbaraccent", "textgravedot", "textgravemacron", "textinvsubbridge", "textlowering", "textovercross", "textraising", "textretracting", "textringmacron", "textseagull", "textsubarch", "textsubbar", "textsubbridge", "textsubgrave", "textsublhalfring", "textsubplus", "textsubrhalfring", "textsubring", "textsubsquare", "textsubtilde", "textsubumlaut", "textsubwedge", "textsuperimposetilde", "textsyllabic", "texttildedot", "textvbaraccent", "tilde", "u", "underbar", "utilde", "v", "widebreve", "widecheck", "widehat", "wideoverbar", "widetilde", "wideutilde"], "tolatex": { "\u0300": { "mode": "text", "macro": "`" }, "\u0301": { "mode": "text", "macro": "'" }, "\u0303": { "mode": "text", "macro": "~" }, "\u0305": { "mode": "math", "macro": "overline" }, "\u0306": { "mode": "text", "macro": "u" }, "\u0307": { "mode": "text", "macro": "." }, "\u0308": { "mode": "text", "macro": '"' }, "\u030A": { "mode": "text", "macro": "r" }, "\u030C": { "mode": "text", "macro": "v" }, "\u0310": { "mode": "text", "macro": "textdotbreve" }, "\u031A": { "mode": "text", "macro": "textcorner" }, "\u0331": { "mode": "text", "macro": "textsubbar" }, "\xB8": { "mode": "text", "macro": "c" }, "\u0300\u0304": { "mode": "text", "macro": "textgravemacron" }, "\u0300\u0307": { "mode": "text", "macro": "textgravedot" }, "\u0301\u0304": { "mode": "text", "macro": "textacutemacron" }, "\u0301\u030C": { "mode": "text", "macro": "textacutewedge" }, "\u0302\u0307": { "mode": "text", "macro": "textcircumdot" }, "\u0302": { "mode": "text", "macro": "^" }, "\u0303\u0307": { "mode": "text", "macro": "texttildedot" }, "\u0304": { "mode": "text", "macro": "=" }, "\u0304\u0300": { "mode": "text", "macro": "textgravemacron" }, "\u0306\u0304": { "mode": "text", "macro": "textbrevemacron" }, "\u0307\u0301": { "mode": "text", "macro": "textdotacute" }, "\u0307\u0306": { "mode": "text", "macro": "textdotbreve" }, "\u030A\u0304": { "mode": "text", "macro": "textringmacron" }, "\u030B": { "mode": "text", "macro": "H" }, "\u030D": { "mode": "text", "macro": "textvbaraccent" }, "\u030E": { "mode": "text", "macro": "textdoublevbaraccent" }, "\u030F": { "mode": "text", "macro": "textdoublegrave" }, "\u0316": { "mode": "text", "macro": "textsubgrave" }, "\u0318": { "mode": "text", "macro": "textadvancing" }, "\u0319": { "mode": "text", "macro": "textretracting" }, "\u031C": { "mode": "text", "macro": "textsublhalfring" }, "\u031D": { "mode": "text", "macro": "textraising" }, "\u031E": { "mode": "text", "macro": "textlowering" }, "\u031F": { "mode": "text", "macro": "textsubplus" }, "\u0323": { "mode": "text", "macro": "d" }, "\u0324": { "mode": "text", "macro": "textsubumlaut" }, "\u0325": { "mode": "text", "macro": "textsubring" }, "\u0326": { "mode": "text", "macro": "textcommabelow" }, "\u0327": { "mode": "text", "macro": "c" }, "\u0328": { "mode": "text", "macro": "k" }, "\u0329": { "mode": "text", "macro": "textsyllabic" }, "\u032A": { "mode": "text", "macro": "textsubbridge" }, "\u032C": { "mode": "text", "macro": "textsubwedge" }, "\u032F": { "mode": "text", "macro": "textsubarch" }, "\u0330": { "mode": "text", "macro": "textsubtilde" }, "\u0334": { "mode": "text", "macro": "textsuperimposetilde" }, "\u0339": { "mode": "text", "macro": "textsubrhalfring" }, "\u033A": { "mode": "text", "macro": "textinvsubbridge" }, "\u033B": { "mode": "text", "macro": "textsubsquare" }, "\u033C": { "mode": "text", "macro": "textseagull" }, "\u033D": { "mode": "text", "macro": "textovercross" } }, "tounicode": { "grave": "\u0300", "acute": "\u0301", "widetilde": "\u0303", "tilde": "\u0303", "overbar": "\u0305", "bar": "\u0305", "wideoverbar": "\u0305", "overline": "\u0305", "widebreve": "\u0306", "breve": "\u0306", "dot": "\u0307", "ddot": "\u0308", "ocirc": "\u030A", "mathring": "\u030A", "widecheck": "\u030C", "check": "\u030C", "candra": "\u0310", "droang": "\u031A", "utilde": "\u0330", "wideutilde": "\u0330", "underbar": "\u0331", "widehat": "\u2227", "hat": "\u2227", "`": "\u0300", "textgravemacron": "\u0300\u0304", "textgravedot": "\u0300\u0307", "'": "\u0301", "\xB4": "\u0301", "textacutemacron": "\u0301\u0304", "textacutewedge": "\u0301\u030C", "textcircumdot": "\u0302\u0307", "^": "\u0302", "~": "\u0303", "texttildedot": "\u0303\u0307", "=": "\u0304", "u": "\u0306", "textbrevemacron": "\u0306\u0304", ".": "\u0307", "textdotacute": "\u0307\u0301", '"': "\u0308", "r": "\u030A", "textringmacron": "\u030A\u0304", "H": "\u030B", "v": "\u030C", "textvbaraccent": "\u030D", "textdoublevbaraccent": "\u030E", "textdoublegrave": "\u030F", "textdotbreve": "\u0310", "textsubgrave": "\u0316", "textadvancing": "\u0318", "textretracting": "\u0319", "textcorner": "\u031A", "textsublhalfring": "\u031C", "textraising": "\u031D", "textlowering": "\u031E", "textsubplus": "\u031F", "d": "\u0323", "textsubumlaut": "\u0324", "textsubring": "\u0325", "textcommabelow": "\u0326", "c": "\u0327", "k": "\u0328", "textsyllabic": "\u0329", "textsubbridge": "\u032A", "textsubwedge": "\u032C", "textsubarch": "\u032F", "textsubtilde": "\u0330", "textsubbar": "\u0331", "textsuperimposetilde": "\u0334", "textsubrhalfring": "\u0339", "textinvsubbridge": "\u033A", "textsubsquare": "\u033B", "textseagull": "\u033C", "textovercross": "\u033D" }, "regex": "(\u0300\u0304|\u0304\u0300)|(\u0300\u0307|\u0307\u0300)|(\u0301\u0304|\u0304\u0301)|(\u0301\u030C|\u030C\u0301)|(\u0302\u0307|\u0307\u0302)|(\u0303\u0307|\u0307\u0303)|(\u0304\u0300|\u0300\u0304)|(\u0306\u0304|\u0304\u0306)|(\u0307\u0301|\u0301\u0307)|(\u0307\u0306|\u0306\u0307)|(\u030A\u0304|\u0304\u030A)|[\u0300\u0301\u0303\u0303\u0305\u0305\u0305\u0305\u0306\u0306\u0307\u0308\u030A\u030A\u030C\u030C\u0310\u031A\u0330\u0330\u0331\u2227\u2227\xB8\u0300\u0301\u0301\u0302\u0303\u0304\u0306\u0307\u0308\u030A\u030B\u030C\u030D\u030E\u030F\u0310\u0316\u0318\u0319\u031A\u031C\u031D\u031E\u031F\u0323\u0324\u0325\u0326\u0327\u0328\u0329\u032A\u032C\u032F\u0330\u0331\u0334\u0339\u033A\u033B\u033C\u033D]" };
    }
  });

  // node_modules/unicode2latex/index.js
  var require_unicode2latex = __commonJS({
    "node_modules/unicode2latex/index.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Transform = exports.replace_macro_spacers = exports.combining = exports.latex2unicode = exports.minimal = exports.bibtex = exports.biblatex = void 0;
      exports.biblatex = require_biblatex();
      exports.bibtex = require_bibtex();
      exports.minimal = require_minimal();
      var maps = { biblatex: exports.biblatex, bibtex: exports.bibtex, minimal: exports.minimal };
      exports.latex2unicode = require_latex2unicode();
      function permutations(str) {
        if (str.length === 0)
          return [];
        if (str.length === 1)
          return [str];
        const result = [];
        for (let i = 0; i < str.length; i++) {
          const firstChar = str[i];
          const remainingChars = str.slice(0, i) + str.slice(i + 1);
          const remainingPermutations = permutations(remainingChars);
          for (let j = 0; j < remainingPermutations.length; j++) {
            result.push(firstChar + remainingPermutations[j]);
          }
        }
        return result;
      }
      exports.combining = require_combining();
      var combining_re = new RegExp(exports.combining.regex);
      function replace_macro_spacers(latex) {
        return latex.replace(/\0(\s)/g, "{}$1").replace(/\0([^;.,!?${}_^\\/])/g, " $1").replace(/\0/g, "");
      }
      exports.replace_macro_spacers = replace_macro_spacers;
      var switchMode = {
        math: "text",
        text: "math"
      };
      var re3 = /(i\uFE20a\uFE21)|([^\u0300-\u036F][\u0300-\u036F]+)|([\uD800-\uDBFF][\uDC00-\uDFFF])|(.)/g;
      var Transform = class {
        constructor(mode, options2 = {}) {
          let map = Object.assign({}, maps[mode].base);
          const packages = maps[mode].package;
          for (const pkg of (options2.packages || []).map((p) => packages[p]).filter((p) => p)) {
            map = Object.assign(Object.assign({}, map), pkg);
          }
          for (const mode2 of ["text", "math"]) {
            if (!(mode2 in options2))
              continue;
            for (const c of options2[mode2]) {
              if (mode2 in map[c])
                map[c] = { [mode2]: map[c][mode2] };
            }
          }
          for (const c of options2.ascii || "") {
            if (exports.bibtex.base[c])
              map[c] = exports.bibtex.base[c];
          }
          if (options2.charmap)
            map = Object.assign(Object.assign({}, map), options2.charmap);
          this.mode = mode;
          this.map = map;
        }
        tolatex(text, options2 = {}) {
          const { bracemath, preservemacrospacers, packages } = Object.assign({ bracemath: false, preservemacrospacers: false, packages: /* @__PURE__ */ new Set() }, options2);
          let mode = "text";
          let braced = 0;
          const switchTo = {
            math: bracemath ? "{$" : "$",
            text: bracemath ? "$}" : "$"
          };
          let mapped;
          let switched;
          let m;
          let cd;
          let latex = "";
          text.normalize("NFD").replace(re3, (match, tie, cdpair, pair, single) => {
            mapped = null;
            if (tie && !this.map[tie]) {
              mapped = { text: "ia" };
            } else {
              mapped = this.map[tie] || this.map[pair] || this.map[single] || this.map[cdpair];
            }
            if (!mapped && this.mode !== "minimal" && cdpair) {
              let char = cdpair[0];
              let cdmode = "";
              cdpair = cdpair.substr(1).replace(combining_re, (cdc) => {
                cd = exports.combining.tolatex[permutations(cdc).find((p) => exports.combining.tolatex[p])];
                if (!cd)
                  return cdc;
                if (!cdmode) {
                  cdmode = cd.mode;
                  char = (this.map[char] || { text: char, math: char })[cdmode];
                }
                if (cdmode !== cd.mode)
                  return cdc;
                const cmd = cd.macro.match(/[a-z]/i);
                if (this.mode === "bibtex" && cd.mode === "text") {
                  char = `{\\${cd.macro}${cmd ? " " : ""}${char}}`;
                } else if (cmd && char.length === 1) {
                  char = `\\${cd.macro} ${char}`;
                } else if (cmd) {
                  char = `\\${cd.macro}{${char}}`;
                } else {
                  char = `\\${cd.macro}${char}`;
                }
                return "";
              });
              if (!cdpair)
                mapped = { [cdmode]: char };
            }
            if (!mapped)
              mapped = { text: match };
            if (!mapped[mode]) {
              mode = switchMode[mode];
              latex += switchTo[mode];
              switched = true;
            } else {
              switched = false;
            }
            switch (mapped[mode]) {
              case "\\{":
                braced += 1;
                break;
              case "\\}":
                braced -= 1;
                break;
            }
            if (braced < 0) {
              latex += "\\vphantom\\{";
              braced = 0;
            }
            if (switched && mode === "text" && (m = latex.match(/([\^_])\{(.)\}(\$\}?)$/))) {
              latex = latex.slice(0, latex.length - m[0].length) + m[1] + m[2] + m[3];
            }
            latex += mapped[mode];
            if (mapped.macrospacer)
              latex += "\0";
            if (!switched && mode === "math" && (m = latex.match(/(([\^_])\{[^{}]+)\}\2{(.\})$/))) {
              latex = latex.slice(0, latex.length - m[0].length) + m[1] + m[3];
            }
            if (mapped.alt) {
              for (const pkg of mapped.alt) {
                packages.add(pkg);
              }
            }
            return match;
          });
          switch (braced) {
            case 0:
              break;
            case 1:
              latex += "\\vphantom\\}";
              break;
            default:
              latex += `\\vphantom{${"\\}".repeat(braced)}}`;
              break;
          }
          if (mode === "math")
            latex += switchTo.text;
          if (!preservemacrospacers)
            latex = replace_macro_spacers(latex);
          return latex.normalize("NFC");
        }
      };
      exports.Transform = Transform;
    }
  });

  // node_modules/xregexp/tools/output/categories.js
  var require_categories = __commonJS({
    "node_modules/xregexp/tools/output/categories.js"(exports, module) {
      module.exports = [
        {
          "name": "C",
          "alias": "Other",
          "isBmpLast": true,
          "bmp": "\0-\x7F-\x9F\xAD\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EE\u05F5-\u0605\u061C\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB\u07FC\u082E\u082F\u083F\u085C\u085D\u085F\u086B-\u086F\u088F-\u0897\u08E2\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A77-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C0D\u0C11\u0C29\u0C3A\u0C3B\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B\u0C5C\u0C5E\u0C5F\u0C64\u0C65\u0C70-\u0C76\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDC\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D50-\u0D53\u0D64\u0D65\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u1716-\u171E\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180E\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ACF-\u1AFF\u1B4D-\u1B4F\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C89-\u1C8F\u1CBB\u1CBC\u1CC8-\u1CCF\u1CFB-\u1CFF\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20C1-\u20CF\u20F1-\u20FF\u218C-\u218F\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E5E-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u3130\u318F\u31E4-\u31EF\u321F\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7CB-\uA7CF\uA7D2\uA7D4\uA7DA-\uA7F1\uA82D-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C6-\uA8CD\uA8DA-\uA8DF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB6C-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC3-\uFBD2\uFD90\uFD91\uFDC8-\uFDCE\uFDD0-\uFDEF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF",
          "astral": "\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9D-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD7B\uDD8B\uDD93\uDD96\uDDA2\uDDB2\uDDBA\uDDBD-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDF7F\uDF86\uDFB1\uDFBB-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE49-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD28-\uDD2F\uDD3A-\uDE5F\uDE7F\uDEAA\uDEAE\uDEAF\uDEB2-\uDEFF\uDF28-\uDF2F\uDF5A-\uDF6F\uDF8A-\uDFAF\uDFCC-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC76-\uDC7E\uDCBD\uDCC3-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD48-\uDD4F\uDD77-\uDD7F\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5C\uDC62-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEBA-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF47-\uDFFF]|\uD806[\uDC3C-\uDC9F\uDCF3-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD47-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE5-\uDDFF\uDE48-\uDE4F\uDEA3-\uDEAF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF9-\uDFAF\uDFB1-\uDFBF\uDFF2-\uDFFE]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80E-\uD810\uD812-\uD819\uD824-\uD82A\uD82D\uD82E\uD830-\uD832\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80B[\uDC00-\uDF8F\uDFF3-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDEBF\uDECA-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE9B-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82B[\uDC00-\uDFEF\uDFF4\uDFFC\uDFFF]|\uD82C[\uDD23-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA0-\uDFFF]|\uD833[\uDC00-\uDEFF\uDF2E\uDF2F\uDF47-\uDF4F\uDFC4-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD73-\uDD7A\uDDEB-\uDDFF\uDE46-\uDEDF\uDEF4-\uDEFF\uDF57-\uDF5F\uDF79-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD837[\uDC00-\uDEFF\uDF1F-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD50-\uDE8F\uDEAF-\uDEBF\uDEFA-\uDEFE\uDF00-\uDFFF]|\uD839[\uDC00-\uDFDF\uDFE7\uDFEC\uDFEF\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDC70\uDCB5-\uDD00\uDD3E-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDDAE-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDE5F\uDE66-\uDEFF]|\uD83D[\uDED8-\uDEDC\uDEED-\uDEEF\uDEFD-\uDEFF\uDF74-\uDF7F\uDFD9-\uDFDF\uDFEC-\uDFEF\uDFF1-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE\uDCAF\uDCB2-\uDCFF\uDE54-\uDE5F\uDE6E\uDE6F\uDE75-\uDE77\uDE7D-\uDE7F\uDE87-\uDE8F\uDEAD-\uDEAF\uDEBB-\uDEBF\uDEC6-\uDECF\uDEDA-\uDEDF\uDEE8-\uDEEF\uDEF7-\uDEFF\uDF93\uDFCB-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEE0-\uDEFF]|\uD86D[\uDF39-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]"
        },
        {
          "name": "Cc",
          "alias": "Control",
          "bmp": "\0-\x7F-\x9F"
        },
        {
          "name": "Cf",
          "alias": "Format",
          "bmp": "\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB",
          "astral": "\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC38]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]"
        },
        {
          "name": "Cn",
          "alias": "Unassigned",
          "bmp": "\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EE\u05F5-\u05FF\u070E\u074B\u074C\u07B2-\u07BF\u07FB\u07FC\u082E\u082F\u083F\u085C\u085D\u085F\u086B-\u086F\u088F\u0892-\u0897\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A77-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C0D\u0C11\u0C29\u0C3A\u0C3B\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B\u0C5C\u0C5E\u0C5F\u0C64\u0C65\u0C70-\u0C76\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDC\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D50-\u0D53\u0D64\u0D65\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u1716-\u171E\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ACF-\u1AFF\u1B4D-\u1B4F\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C89-\u1C8F\u1CBB\u1CBC\u1CC8-\u1CCF\u1CFB-\u1CFF\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u2065\u2072\u2073\u208F\u209D-\u209F\u20C1-\u20CF\u20F1-\u20FF\u218C-\u218F\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E5E-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u3130\u318F\u31E4-\u31EF\u321F\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7CB-\uA7CF\uA7D2\uA7D4\uA7DA-\uA7F1\uA82D-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C6-\uA8CD\uA8DA-\uA8DF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB6C-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC3-\uFBD2\uFD90\uFD91\uFDC8-\uFDCE\uFDD0-\uFDEF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD\uFEFE\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFF8\uFFFE\uFFFF",
          "astral": "\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9D-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD7B\uDD8B\uDD93\uDD96\uDDA2\uDDB2\uDDBA\uDDBD-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDF7F\uDF86\uDFB1\uDFBB-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE49-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD28-\uDD2F\uDD3A-\uDE5F\uDE7F\uDEAA\uDEAE\uDEAF\uDEB2-\uDEFF\uDF28-\uDF2F\uDF5A-\uDF6F\uDF8A-\uDFAF\uDFCC-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC76-\uDC7E\uDCC3-\uDCCC\uDCCE\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD48-\uDD4F\uDD77-\uDD7F\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5C\uDC62-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEBA-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF47-\uDFFF]|\uD806[\uDC3C-\uDC9F\uDCF3-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD47-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE5-\uDDFF\uDE48-\uDE4F\uDEA3-\uDEAF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF9-\uDFAF\uDFB1-\uDFBF\uDFF2-\uDFFE]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80E-\uD810\uD812-\uD819\uD824-\uD82A\uD82D\uD82E\uD830-\uD832\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDB7F][\uDC00-\uDFFF]|\uD80B[\uDC00-\uDF8F\uDFF3-\uDFFF]|\uD80D[\uDC2F\uDC39-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDEBF\uDECA-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE9B-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82B[\uDC00-\uDFEF\uDFF4\uDFFC\uDFFF]|\uD82C[\uDD23-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA4-\uDFFF]|\uD833[\uDC00-\uDEFF\uDF2E\uDF2F\uDF47-\uDF4F\uDFC4-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDDEB-\uDDFF\uDE46-\uDEDF\uDEF4-\uDEFF\uDF57-\uDF5F\uDF79-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD837[\uDC00-\uDEFF\uDF1F-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD50-\uDE8F\uDEAF-\uDEBF\uDEFA-\uDEFE\uDF00-\uDFFF]|\uD839[\uDC00-\uDFDF\uDFE7\uDFEC\uDFEF\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDC70\uDCB5-\uDD00\uDD3E-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDDAE-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDE5F\uDE66-\uDEFF]|\uD83D[\uDED8-\uDEDC\uDEED-\uDEEF\uDEFD-\uDEFF\uDF74-\uDF7F\uDFD9-\uDFDF\uDFEC-\uDFEF\uDFF1-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE\uDCAF\uDCB2-\uDCFF\uDE54-\uDE5F\uDE6E\uDE6F\uDE75-\uDE77\uDE7D-\uDE7F\uDE87-\uDE8F\uDEAD-\uDEAF\uDEBB-\uDEBF\uDEC6-\uDECF\uDEDA-\uDEDF\uDEE8-\uDEEF\uDEF7-\uDEFF\uDF93\uDFCB-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEE0-\uDEFF]|\uD86D[\uDF39-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00\uDC02-\uDC1F\uDC80-\uDCFF\uDDF0-\uDFFF]|[\uDBBF\uDBFF][\uDFFE\uDFFF]"
        },
        {
          "name": "Co",
          "alias": "Private_Use",
          "bmp": "\uE000-\uF8FF",
          "astral": "[\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uDBBF\uDBFF][\uDC00-\uDFFD]"
        },
        {
          "name": "Cs",
          "alias": "Surrogate",
          "bmp": "\uD800-\uDFFF"
        },
        {
          "name": "L",
          "alias": "Letter",
          "bmp": "A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
          "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
        },
        {
          "name": "LC",
          "alias": "Cased_Letter",
          "bmp": "A-Za-z\xB5\xC0-\xD6\xD8-\xF6\xF8-\u01BA\u01BC-\u01BF\u01C4-\u0293\u0295-\u02AF\u0370-\u0373\u0376\u0377\u037B-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0560-\u0588\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FD-\u10FF\u13A0-\u13F5\u13F8-\u13FD\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2134\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C7B\u2C7E-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA640-\uA66D\uA680-\uA69B\uA722-\uA76F\uA771-\uA787\uA78B-\uA78E\uA790-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F5\uA7F6\uA7FA\uAB30-\uAB5A\uAB60-\uAB68\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A",
          "astral": "\uD801[\uDC00-\uDC4F\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC]|\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD806[\uDCA0-\uDCDF]|\uD81B[\uDE40-\uDE7F]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF09\uDF0B-\uDF1E]|\uD83A[\uDD00-\uDD43]"
        },
        {
          "name": "Ll",
          "alias": "Lowercase_Letter",
          "bmp": "a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0560-\u0588\u10D0-\u10FA\u10FD-\u10FF\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5F\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7AF\uA7B5\uA7B7\uA7B9\uA7BB\uA7BD\uA7BF\uA7C1\uA7C3\uA7C8\uA7CA\uA7D1\uA7D3\uA7D5\uA7D7\uA7D9\uA7F6\uA7FA\uAB30-\uAB5A\uAB60-\uAB68\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A",
          "astral": "\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD837[\uDF00-\uDF09\uDF0B-\uDF1E]|\uD83A[\uDD22-\uDD43]"
        },
        {
          "name": "Lm",
          "alias": "Modifier_Letter",
          "bmp": "\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u08C9\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F2-\uA7F4\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uAB69\uFF70\uFF9E\uFF9F",
          "astral": "\uD801[\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD838[\uDD37-\uDD3D]|\u{1E94B}"
        },
        {
          "name": "Lo",
          "alias": "Other_Letter",
          "bmp": "\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05EF-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C8\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1100-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
          "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF4A\uDF50]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\u{1DF0A}|\uD838[\uDD00-\uDD2C\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
        },
        {
          "name": "Lt",
          "alias": "Titlecase_Letter",
          "bmp": "\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC"
        },
        {
          "name": "Lu",
          "alias": "Uppercase_Letter",
          "bmp": "A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1C90-\u1CBA\u1CBD-\u1CBF\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2F\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uA7B8\uA7BA\uA7BC\uA7BE\uA7C0\uA7C2\uA7C4-\uA7C7\uA7C9\uA7D0\uA7D6\uA7D8\uA7F5\uFF21-\uFF3A",
          "astral": "\uD801[\uDC00-\uDC27\uDCB0-\uDCD3\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD81B[\uDE40-\uDE5F]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]"
        },
        {
          "name": "M",
          "alias": "Mark",
          "bmp": "\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F",
          "astral": "\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC82\uDCB0-\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD34\uDD45\uDD46\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDC9-\uDDCC\uDDCE\uDDCF\uDE2C-\uDE37\uDE3E\uDEDF-\uDEEA\uDF00-\uDF03\uDF3B\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDC5E\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDEAB-\uDEB7\uDF1D-\uDF2B]|\uD806[\uDC2C-\uDC3A\uDD30-\uDD35\uDD37\uDD38\uDD3B-\uDD3E\uDD40\uDD42\uDD43\uDDD1-\uDDD7\uDDDA-\uDDE0\uDDE4\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE3E\uDE47\uDE51-\uDE5B\uDE8A-\uDE99]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD8A-\uDD8E\uDD90\uDD91\uDD93-\uDD97\uDEF3-\uDEF6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF51-\uDF87\uDF8F-\uDF92\uDFE4\uDFF0\uDFF1]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]"
        },
        {
          "name": "Mc",
          "alias": "Spacing_Mark",
          "bmp": "\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BE-\u09C0\u09C7\u09C8\u09CB\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0D02\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2\u0DF3\u0F3E\u0F3F\u0F7F\u102B\u102C\u1031\u1038\u103B\u103C\u1056\u1057\u1062-\u1064\u1067-\u106D\u1083\u1084\u1087-\u108C\u108F\u109A-\u109C\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\u302E\u302F\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAA7B\uAA7D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC",
          "astral": "\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3E\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB0-\uDCB2\uDCB9\uDCBB-\uDCBE\uDCC1\uDDAF-\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF20\uDF21\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD30-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD65\uDD66\uDD6D-\uDD72]"
        },
        {
          "name": "Me",
          "alias": "Enclosing_Mark",
          "bmp": "\u0488\u0489\u1ABE\u20DD-\u20E0\u20E2-\u20E4\uA670-\uA672"
        },
        {
          "name": "Mn",
          "alias": "Nonspacing_Mark",
          "bmp": "\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F",
          "astral": "\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]"
        },
        {
          "name": "N",
          "alias": "Number",
          "bmp": "0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D58-\u0D5E\u0D66-\u0D78\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19",
          "astral": "\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDD30-\uDD39\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54\uDFC5-\uDFCB]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2\uDD50-\uDD59]|\uD807[\uDC50-\uDC6C\uDD50-\uDD59\uDDA0-\uDDA9\uDFC0-\uDFD4]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDEC0-\uDEC9\uDF50-\uDF59\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]"
        },
        {
          "name": "Nd",
          "alias": "Decimal_Number",
          "bmp": "0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19",
          "astral": "\uD801[\uDCA0-\uDCA9]|\uD803[\uDD30-\uDD39]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9\uDD50-\uDD59]|\uD807[\uDC50-\uDC59\uDD50-\uDD59\uDDA0-\uDDA9]|\uD81A[\uDE60-\uDE69\uDEC0-\uDEC9\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDD50-\uDD59]|\uD83E[\uDFF0-\uDFF9]"
        },
        {
          "name": "Nl",
          "alias": "Letter_Number",
          "bmp": "\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF",
          "astral": "\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]"
        },
        {
          "name": "No",
          "alias": "Other_Number",
          "bmp": "\xB2\xB3\xB9\xBC-\xBE\u09F4-\u09F9\u0B72-\u0B77\u0BF0-\u0BF2\u0C78-\u0C7E\u0D58-\u0D5E\u0D70-\u0D78\u0F2A-\u0F33\u1369-\u137C\u17F0-\u17F9\u19DA\u2070\u2074-\u2079\u2080-\u2089\u2150-\u215F\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA830-\uA835",
          "astral": "\uD800[\uDD07-\uDD33\uDD75-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54\uDFC5-\uDFCB]|\uD804[\uDC52-\uDC65\uDDE1-\uDDF4]|\uD805[\uDF3A\uDF3B]|\uD806[\uDCEA-\uDCF2]|\uD807[\uDC5A-\uDC6C\uDFC0-\uDFD4]|\uD81A[\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD83A[\uDCC7-\uDCCF]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C]"
        },
        {
          "name": "P",
          "alias": "Punctuation",
          "bmp": "!-#%-\\*,-\\/:;\\?@\\[-\\]_\\{\\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65",
          "astral": "\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\u{1056F}|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\u{1BC9F}|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]"
        },
        {
          "name": "Pc",
          "alias": "Connector_Punctuation",
          "bmp": "_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F"
        },
        {
          "name": "Pd",
          "alias": "Dash_Punctuation",
          "bmp": "\\-\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u2E40\u2E5D\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D",
          "astral": "\u{10EAD}"
        },
        {
          "name": "Pe",
          "alias": "Close_Punctuation",
          "bmp": "\\)\\]\\}\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u2E56\u2E58\u2E5A\u2E5C\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63"
        },
        {
          "name": "Pf",
          "alias": "Final_Punctuation",
          "bmp": "\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21"
        },
        {
          "name": "Pi",
          "alias": "Initial_Punctuation",
          "bmp": "\xAB\u2018\u201B\u201C\u201F\u2039\u2E02\u2E04\u2E09\u2E0C\u2E1C\u2E20"
        },
        {
          "name": "Po",
          "alias": "Other_Punctuation",
          "bmp": "!-#%-'\\*,\\.\\/:;\\?@\\\xA1\xA7\xB6\xB7\xBF\u037E\u0387\u055A-\u055F\u0589\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u166E\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u1805\u1807-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2016\u2017\u2020-\u2027\u2030-\u2038\u203B-\u203E\u2041-\u2043\u2047-\u2051\u2053\u2055-\u205E\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E06-\u2E08\u2E0B\u2E0E-\u2E16\u2E18\u2E19\u2E1B\u2E1E\u2E1F\u2E2A-\u2E2E\u2E30-\u2E39\u2E3C-\u2E3F\u2E41\u2E43-\u2E4F\u2E52-\u2E54\u3001-\u3003\u303D\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFE10-\uFE16\uFE19\uFE30\uFE45\uFE46\uFE49-\uFE4C\uFE50-\uFE52\uFE54-\uFE57\uFE5F-\uFE61\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF07\uFF0A\uFF0C\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3C\uFF61\uFF64\uFF65",
          "astral": "\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\u{1056F}|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\u{1BC9F}|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]"
        },
        {
          "name": "Ps",
          "alias": "Open_Punctuation",
          "bmp": "\\(\\[\\{\u0F3A\u0F3C\u169B\u201A\u201E\u2045\u207D\u208D\u2308\u230A\u2329\u2768\u276A\u276C\u276E\u2770\u2772\u2774\u27C5\u27E6\u27E8\u27EA\u27EC\u27EE\u2983\u2985\u2987\u2989\u298B\u298D\u298F\u2991\u2993\u2995\u2997\u29D8\u29DA\u29FC\u2E22\u2E24\u2E26\u2E28\u2E42\u2E55\u2E57\u2E59\u2E5B\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u3018\u301A\u301D\uFD3F\uFE17\uFE35\uFE37\uFE39\uFE3B\uFE3D\uFE3F\uFE41\uFE43\uFE47\uFE59\uFE5B\uFE5D\uFF08\uFF3B\uFF5B\uFF5F\uFF62"
        },
        {
          "name": "S",
          "alias": "Symbol",
          "bmp": "\\$\\+<->\\^`\\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD",
          "astral": "\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\u{1173F}|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\u{1BC9C}|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDD-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6\uDF00-\uDF92\uDF94-\uDFCA]"
        },
        {
          "name": "Sc",
          "alias": "Currency_Symbol",
          "bmp": "\\$\xA2-\xA5\u058F\u060B\u07FE\u07FF\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20C0\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6",
          "astral": "\uD807[\uDFDD-\uDFE0]|\u{1E2FF}|\u{1ECB0}"
        },
        {
          "name": "Sk",
          "alias": "Modifier_Symbol",
          "bmp": "\\^`\xA8\xAF\xB4\xB8\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u0888\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u309B\u309C\uA700-\uA716\uA720\uA721\uA789\uA78A\uAB5B\uAB6A\uAB6B\uFBB2-\uFBC2\uFF3E\uFF40\uFFE3",
          "astral": "\uD83C[\uDFFB-\uDFFF]"
        },
        {
          "name": "Sm",
          "alias": "Math_Symbol",
          "bmp": "\\+<->\\|~\xAC\xB1\xD7\xF7\u03F6\u0606-\u0608\u2044\u2052\u207A-\u207C\u208A-\u208C\u2118\u2140-\u2144\u214B\u2190-\u2194\u219A\u219B\u21A0\u21A3\u21A6\u21AE\u21CE\u21CF\u21D2\u21D4\u21F4-\u22FF\u2320\u2321\u237C\u239B-\u23B3\u23DC-\u23E1\u25B7\u25C1\u25F8-\u25FF\u266F\u27C0-\u27C4\u27C7-\u27E5\u27F0-\u27FF\u2900-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2AFF\u2B30-\u2B44\u2B47-\u2B4C\uFB29\uFE62\uFE64-\uFE66\uFF0B\uFF1C-\uFF1E\uFF5C\uFF5E\uFFE2\uFFE9-\uFFEC",
          "astral": "\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD83B[\uDEF0\uDEF1]"
        },
        {
          "name": "So",
          "alias": "Other_Symbol",
          "bmp": "\xA6\xA9\xAE\xB0\u0482\u058D\u058E\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09FA\u0B70\u0BF3-\u0BF8\u0BFA\u0C7F\u0D4F\u0D79\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116\u2117\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u214A\u214C\u214D\u214F\u218A\u218B\u2195-\u2199\u219C-\u219F\u21A1\u21A2\u21A4\u21A5\u21A7-\u21AD\u21AF-\u21CD\u21D0\u21D1\u21D3\u21D5-\u21F3\u2300-\u2307\u230C-\u231F\u2322-\u2328\u232B-\u237B\u237D-\u239A\u23B4-\u23DB\u23E2-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u25B6\u25B8-\u25C0\u25C2-\u25F7\u2600-\u266E\u2670-\u2767\u2794-\u27BF\u2800-\u28FF\u2B00-\u2B2F\u2B45\u2B46\u2B4D-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA828-\uA82B\uA836\uA837\uA839\uAA77-\uAA79\uFD40-\uFD4F\uFDCF\uFDFD-\uFDFF\uFFE4\uFFE8\uFFED\uFFEE\uFFFC\uFFFD",
          "astral": "\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\u{1173F}|\uD807[\uDFD5-\uDFDC\uDFE1-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\u{1BC9C}|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\u{1E14F}|\uD83B[\uDCAC\uDD2E]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFA]|\uD83D[\uDC00-\uDED7\uDEDD-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6\uDF00-\uDF92\uDF94-\uDFCA]"
        },
        {
          "name": "Z",
          "alias": "Separator",
          "bmp": " \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000"
        },
        {
          "name": "Zl",
          "alias": "Line_Separator",
          "bmp": "\u2028"
        },
        {
          "name": "Zp",
          "alias": "Paragraph_Separator",
          "bmp": "\u2029"
        },
        {
          "name": "Zs",
          "alias": "Space_Separator",
          "bmp": " \xA0\u1680\u2000-\u200A\u202F\u205F\u3000"
        }
      ];
    }
  });

  // node_modules/@retorquere/bibtex-parser/re.js
  var require_re = __commonJS({
    "node_modules/@retorquere/bibtex-parser/re.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.categories = exports.match = void 0;
      function match(cats, extra, neg = false) {
        return `[${neg ? "^" : ""}${cats.map((cat) => cat.bmp).join("")}${extra || ""}]`;
      }
      exports.match = match;
      exports.categories = require_categories();
    }
  });

  // node_modules/@retorquere/bibtex-parser/yield.js
  var require_yield = __commonJS({
    "node_modules/@retorquere/bibtex-parser/yield.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.playnice = void 0;
      async function playnice() {
        await new Promise((resolve) => setTimeout(resolve, 0));
      }
      exports.playnice = playnice;
    }
  });

  // node_modules/@retorquere/bibtex-parser/verbatim.js
  var require_verbatim = __commonJS({
    "node_modules/@retorquere/bibtex-parser/verbatim.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.promises = exports.parse = exports.Library = void 0;
      var rx = __importStar(require_re());
      var yield_1 = require_yield();
      var ParsingError = class extends Error {
        constructor(message, parser) {
          message += ` at ${parser.location()}`;
          if (parser.parsing)
            message += ` in ${JSON.stringify(parser.parsing)}`;
          super(message);
          this.name = "ParsingError";
        }
      };
      var letter = new RegExp(rx.match(rx.categories.filter((cat) => cat.name.match(/^L[utlmo]$/))));
      var Library = class {
        constructor(input, options2 = {}) {
          this.entries = [];
          this.strings = {};
          this.comments = [];
          this.errors = [];
          this.preambles = [];
          this.default_strings = {
            JAN: "01",
            JANUARY: "01",
            FEB: "02",
            FEBRUARY: "02",
            MAR: "03",
            MARCH: "03",
            APR: "04",
            APRIL: "04",
            MAY: "05",
            JUN: "06",
            JUNE: "06",
            JUL: "07",
            JULY: "07",
            AUG: "08",
            AUGUST: "08",
            SEP: "09",
            SEPTEMBER: "09",
            OCT: "10",
            OCTOBER: "10",
            NOV: "11",
            NOVEMBER: "11",
            DEC: "12",
            DECEMBER: "12",
            ACMCS: "ACM Computing Surveys",
            ACTA: "Acta Informatica",
            CACM: "Communications of the ACM",
            IBMJRD: "IBM Journal of Research and Development",
            IBMSJ: "IBM Systems Journal",
            IEEESE: "IEEE Transactions on Software Engineering",
            IEEETC: "IEEE Transactions on Computers",
            IEEETCAD: "IEEE Transactions on Computer-Aided Design of Integrated Circuits",
            IPL: "Information Processing Letters",
            JACM: "Journal of the ACM",
            JCSS: "Journal of Computer and System Sciences",
            SCP: "Science of Computer Programming",
            SICOMP: "SIAM Journal on Computing",
            TOCS: "ACM Transactions on Computer Systems",
            TODS: "ACM Transactions on Database Systems",
            TOG: "ACM Transactions on Graphics",
            TOMS: "ACM Transactions on Mathematical Software",
            TOOIS: "ACM Transactions on Office Information Systems",
            TOPLAS: "ACM Transactions on Programming Languages and Systems",
            TCS: "Theoretical Computer Science"
          };
          this.pos = 0;
          this.linebreaks = [];
          this.max_entries = options2.max_entries || 0;
          this.input = input;
          this.parsing = null;
          if (typeof options2.strings === "string") {
            this.input = options2.strings + "\n" + input;
          } else if (options2.strings) {
            for (const [k, v] of Object.entries(options2.strings)) {
              this.default_strings[k.toUpperCase()] = v;
            }
          }
          let pos = input.indexOf("\n");
          while (pos !== -1) {
            this.linebreaks.push(pos);
            pos = input.indexOf("\n", pos + 1);
          }
        }
        parse() {
          this.bibtex();
          this.entries.reverse();
        }
        async parseAsync() {
          await this.bibtexAsync();
          this.entries.reverse();
        }
        isWhitespace(s, horizontalOnly = false) {
          return s === " " || s === "	" || !horizontalOnly && (s === "\r" || s === "\n");
        }
        match(s, sws = true) {
          this.skipWhitespace();
          if (this.input.substr(this.pos, s.length) !== s) {
            throw new ParsingError(`Token mismatch, expected ${JSON.stringify(s)}, found ${JSON.stringify(this.input.substr(this.pos, 20))}...`, this);
          }
          this.pos += s.length;
          if (sws)
            this.skipWhitespace();
        }
        tryMatch(s, consume = false) {
          this.skipWhitespace();
          const match = this.input.substr(this.pos, s.length) === s;
          if (match && consume)
            this.pos += s.length;
          return match;
        }
        skipWhitespace() {
          while (this.pos < this.input.length && this.input[this.pos].match(/[ \t\r\n%]/)) {
            if (this.input[this.pos] === "%") {
              while (this.pos < this.input.length && this.input[this.pos] !== "\n")
                this.pos++;
            } else {
              this.pos++;
            }
          }
        }
        /*
        private fix_path() {
          // workaround for https://github.com/siefkenj/unified-latex/issues/94
          const path = '\\path|'
          const verb = path.replace('path', 'verb')
          if (this.input.substring(this.pos).startsWith(path)) {
            // eslint-disable-next-line prefer-template, no-magic-numbers
            this.input = this.input.substring(0, this.pos) + verb + this.input.substring(this.pos + path.length)
          }
        }
        */
        value_braces() {
          let bracecount = 0;
          this.match("{", false);
          const start = this.pos;
          let math = false;
          while (true) {
            switch (this.input[this.pos]) {
              case "\\":
                this.pos += 1;
                break;
              case "{":
                bracecount++;
                break;
              case "}":
                if (bracecount === 0) {
                  if (math)
                    throw new ParsingError("Unclosed math section", this);
                  this.pos++;
                  return this.input.substring(start, this.pos - 1);
                }
                bracecount--;
                break;
              case "$":
                math = !math;
                break;
            }
            this.pos++;
            if (this.pos >= this.input.length) {
              throw new ParsingError(`Unterminated brace-value ${JSON.stringify(this.input.substr(start, 20))}`, this);
            }
          }
        }
        value_quotes() {
          this.match('"', false);
          const start = this.pos;
          let bracecount = 0;
          while (true) {
            switch (this.input[this.pos]) {
              case "\\":
                this.pos += 1;
                break;
              case "{":
                bracecount++;
                break;
              case "}":
                bracecount--;
                break;
              case '"':
                if (bracecount <= 0) {
                  this.pos++;
                  return this.input.substring(start, this.pos - 1);
                }
            }
            this.pos++;
            if (this.pos >= this.input.length) {
              throw new ParsingError(`Unterminated quote-value ${JSON.stringify(this.input.substr(start, 20))}`, this);
            }
          }
        }
        single_value() {
          if (this.tryMatch("{")) {
            return this.value_braces();
          } else if (this.tryMatch('"')) {
            return this.value_quotes();
          } else {
            const bare = this.key();
            if (bare.match(/^\d+$/))
              return bare;
            const u_bare = bare.toUpperCase();
            const resolved = this.strings[u_bare] || this.default_strings[u_bare];
            if (typeof resolved === "undefined") {
              this.error({
                error: `Unresolved @string reference ${JSON.stringify(bare)}`,
                input: ""
              });
            }
            return resolved || `{{${bare}}}`;
          }
        }
        location() {
          const lines = this.input.substring(0, this.pos).split("\n");
          return `line ${lines.length}, column ${lines[lines.length - 1].length + 1}`;
        }
        error(err) {
          if (this.errors.find((e) => e.error === err.error))
            return;
          this.errors.push(err);
        }
        value() {
          const values = [];
          values.push(this.single_value());
          while (this.tryMatch("#")) {
            this.match("#");
            values.push(this.single_value());
          }
          return values.join("");
        }
        key(allow = "") {
          const start = this.pos;
          while (true) {
            if (this.pos === this.input.length) {
              throw new ParsingError("Runaway key", this);
            }
            if (this.input[this.pos].match(/[+'a-zA-Z0-9&;_:\\./-]/) || this.input[this.pos].match(letter) || allow.includes(this.input[this.pos])) {
              this.pos++;
            } else {
              return this.input.substring(start, this.pos);
            }
          }
        }
        key_equals_value(key) {
          key = key || this.key();
          if (!key)
            return;
          if (!this.tryMatch("=")) {
            throw new ParsingError(`${key} = value expected, equals sign missing: ${JSON.stringify(this.input.substr(this.pos, 20))}...`, this);
          }
          this.match("=");
          const val = this.value();
          if (this.parsing === "string") {
            this.strings[key.toUpperCase()] = val;
          } else {
            const bare = key.toLowerCase();
            let postfix = 0;
            while (typeof this.entries[0].fields[key = postfix ? `${bare}+duplicate-${postfix}` : bare] === "string") {
              postfix++;
            }
            this.entries[0].fields[key] = val;
          }
        }
        entry(d, guard) {
          if (this.tryMatch(guard))
            return;
          let key;
          if (this.tryMatch(",")) {
            key = "";
          } else {
            key = this.key('[]*"');
          }
          if (this.tryMatch("=")) {
            this.key_equals_value(key);
          } else {
            this.entries[0].key = key;
          }
          this.tryMatch(",", true);
          if (this.tryMatch(guard))
            return;
          this.key_equals_value();
          while (this.tryMatch(",", true)) {
            if (this.tryMatch(guard))
              return;
            this.key_equals_value();
          }
        }
        directive() {
          this.match("@");
          return this.key().toLowerCase();
        }
        string() {
          this.key_equals_value();
        }
        preamble() {
          this.preambles.push(this.value());
        }
        comment() {
          while (this.isWhitespace(this.input[this.pos], true))
            this.pos++;
          if (this.input[this.pos] === "{") {
            this.comments.push(this.value_braces());
          } else {
            const start = this.pos;
            while (this.input[this.pos] !== "\n" && this.pos < this.input.length)
              this.pos++;
            this.comments.push(this.input.substring(start, this.pos));
          }
        }
        hasMore() {
          if (this.max_entries && this.entries.length >= this.max_entries)
            return false;
          return this.pos < this.input.length;
        }
        bibtex() {
          while (this.hasMore()) {
            this.parseNext();
          }
        }
        async bibtexAsync() {
          let n = 1;
          while (this.hasMore()) {
            this.parseNext();
            if (n++ % 1e3 === 0)
              await (0, yield_1.playnice)();
          }
        }
        matchGuard() {
          for (const guard of ["{}", "()"]) {
            if (this.tryMatch(guard[0])) {
              this.match(guard[0]);
              return guard[1];
            }
          }
          throw new ParsingError(`Token mismatch, expected '{' or '(', found ${JSON.stringify(this.input.substr(this.pos, 20))}...`, this);
        }
        parseNext() {
          this.skipWhitespace();
          while (this.pos < this.input.length && this.input[this.pos] !== "@") {
            if (this.input[this.pos] === "%") {
              while (this.pos < this.input.length && this.input[this.pos] !== "\n")
                this.pos++;
            } else {
              this.pos++;
            }
          }
          if (this.pos >= this.input.length)
            return;
          let guard = "";
          const start = this.pos;
          try {
            const d = this.parsing = this.directive();
            switch (d) {
              case "string":
                guard = this.matchGuard();
                this.string();
                this.match(guard);
                break;
              case "preamble":
                this.preamble();
                break;
              case "comment":
                this.comment();
                break;
              default:
                guard = this.matchGuard();
                this.entries.unshift({ input: "", type: d, key: "", fields: {} });
                this.entry(d, guard);
                this.match(guard);
                this.entries[0].input = this.input.substring(start, this.pos).trim();
                break;
            }
          } catch (err) {
            if (err.name !== "ParsingError")
              throw err;
            this.pos = start + 1;
            while (this.pos < this.input.length && this.input[this.pos] !== "@")
              this.pos++;
            this.error({
              error: err.message,
              input: this.input.substring(start, this.pos)
            });
          }
        }
      };
      exports.Library = Library;
      function parse(input, options2 = {}) {
        const parser = new Library(input, options2);
        parser.parse();
        return parser;
      }
      exports.parse = parse;
      exports.promises = {
        async parse(input, options2 = {}) {
          const parser = new Library(input, options2);
          await parser.parseAsync();
          return parser;
        }
      };
    }
  });

  // node_modules/@retorquere/bibtex-parser/jabref.js
  var require_jabref = __commonJS({
    "node_modules/@retorquere/bibtex-parser/jabref.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parse = void 0;
      function decode(s, sep = ";") {
        s = s.replace(/\r?\n/g, "");
        let pos = 0;
        const records = [""];
        while (pos < s.length) {
          switch (s[pos]) {
            case "\\":
              pos++;
              records[0] += s[pos];
              break;
            case sep:
              records.unshift("");
              break;
            default:
              records[0] += s[pos];
          }
          pos++;
        }
        return records.reverse().filter((record) => record);
      }
      function parse(comments) {
        const result = {
          root: [],
          groups: {}
        };
        const levels = [];
        const decoded = {
          fileDirectory: null,
          groupsversion: null,
          groupstree: null,
          grouping: null,
          databaseType: null
        };
        comments = comments.filter((comment) => {
          const m = comment.match(/^jabref-meta:\s*([^:]+):([\s\S]*)/);
          if (m) {
            decoded[m[1]] = decode(m[2]);
            return false;
          }
          return true;
        });
        if (decoded.groupsversion)
          result.groupsversion = parseInt(decoded.groupsversion[0].trim()) || decoded.groupsversion[0];
        if (decoded.fileDirectory)
          result.fileDirectory = decoded.fileDirectory[0];
        if (decoded.databaseType)
          result.databaseType = decoded.databaseType[0];
        for (const tree of ["groupstree", "grouping"]) {
          if (!decoded[tree])
            continue;
          for (const encoded of decoded[tree]) {
            const fields = decode(encoded);
            const level_type_name = decode(fields.shift(), ":");
            const m = /^([0-9]+) (.+)/.exec(level_type_name[0]);
            if (!m)
              break;
            const level = parseInt(m[1]);
            const type = m[2];
            if (type === "AllEntriesGroup")
              continue;
            const name = level_type_name[1];
            const intersection = decode(fields.shift())[0];
            const keys = tree === "grouping" ? [] : fields.map((field) => decode(field)[0]);
            const group = {
              name,
              entries: keys,
              groups: []
            };
            result.groups[name] = result.groups[name] || group;
            if (levels.length < level) {
              levels.push(group);
            } else {
              levels[level - 1] = group;
            }
            if (level === 1) {
              result.root.push(group);
            } else {
              const parent = levels[level - 2];
              switch (intersection) {
                case "0":
                  break;
                case "1":
                  group.entries = group.entries.filter((key) => parent.entries.includes(key));
                  break;
                case "2":
                  group.entries = group.entries.concat(parent.entries.filter((key) => !group.entries.includes(key)));
                  break;
              }
              levels[level - 2].groups.push(group);
            }
          }
        }
        return { comments, jabref: result };
      }
      exports.parse = parse;
    }
  });

  // node_modules/moo/moo.js
  var require_moo = __commonJS({
    "node_modules/moo/moo.js"(exports, module) {
      (function(root, factory) {
        if (typeof define === "function" && define.amd) {
          define([], factory);
        } else if (typeof module === "object" && module.exports) {
          module.exports = factory();
        } else {
          root.moo = factory();
        }
      })(exports, function() {
        "use strict";
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var toString2 = Object.prototype.toString;
        var hasSticky = typeof new RegExp().sticky === "boolean";
        function isRegExp(o) {
          return o && toString2.call(o) === "[object RegExp]";
        }
        function isObject(o) {
          return o && typeof o === "object" && !isRegExp(o) && !Array.isArray(o);
        }
        function reEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        function reGroups(s) {
          var re3 = new RegExp("|" + s);
          return re3.exec("").length - 1;
        }
        function reCapture(s) {
          return "(" + s + ")";
        }
        function reUnion(regexps) {
          if (!regexps.length) return "(?!)";
          var source = regexps.map(function(s) {
            return "(?:" + s + ")";
          }).join("|");
          return "(?:" + source + ")";
        }
        function regexpOrLiteral(obj) {
          if (typeof obj === "string") {
            return "(?:" + reEscape(obj) + ")";
          } else if (isRegExp(obj)) {
            if (obj.ignoreCase) throw new Error("RegExp /i flag not allowed");
            if (obj.global) throw new Error("RegExp /g flag is implied");
            if (obj.sticky) throw new Error("RegExp /y flag is implied");
            if (obj.multiline) throw new Error("RegExp /m flag is implied");
            return obj.source;
          } else {
            throw new Error("Not a pattern: " + obj);
          }
        }
        function pad(s, length) {
          if (s.length > length) {
            return s;
          }
          return Array(length - s.length + 1).join(" ") + s;
        }
        function lastNLines(string, numLines) {
          var position = string.length;
          var lineBreaks = 0;
          while (true) {
            var idx = string.lastIndexOf("\n", position - 1);
            if (idx === -1) {
              break;
            } else {
              lineBreaks++;
            }
            position = idx;
            if (lineBreaks === numLines) {
              break;
            }
            if (position === 0) {
              break;
            }
          }
          var startPosition = lineBreaks < numLines ? 0 : position + 1;
          return string.substring(startPosition).split("\n");
        }
        function objectToRules(object) {
          var keys = Object.getOwnPropertyNames(object);
          var result = [];
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var thing = object[key];
            var rules = [].concat(thing);
            if (key === "include") {
              for (var j = 0; j < rules.length; j++) {
                result.push({ include: rules[j] });
              }
              continue;
            }
            var match = [];
            rules.forEach(function(rule) {
              if (isObject(rule)) {
                if (match.length) result.push(ruleOptions(key, match));
                result.push(ruleOptions(key, rule));
                match = [];
              } else {
                match.push(rule);
              }
            });
            if (match.length) result.push(ruleOptions(key, match));
          }
          return result;
        }
        function arrayToRules(array) {
          var result = [];
          for (var i = 0; i < array.length; i++) {
            var obj = array[i];
            if (obj.include) {
              var include = [].concat(obj.include);
              for (var j = 0; j < include.length; j++) {
                result.push({ include: include[j] });
              }
              continue;
            }
            if (!obj.type) {
              throw new Error("Rule has no type: " + JSON.stringify(obj));
            }
            result.push(ruleOptions(obj.type, obj));
          }
          return result;
        }
        function ruleOptions(type, obj) {
          if (!isObject(obj)) {
            obj = { match: obj };
          }
          if (obj.include) {
            throw new Error("Matching rules cannot also include states");
          }
          var options2 = {
            defaultType: type,
            lineBreaks: !!obj.error || !!obj.fallback,
            pop: false,
            next: null,
            push: null,
            error: false,
            fallback: false,
            value: null,
            type: null,
            shouldThrow: false
          };
          for (var key in obj) {
            if (hasOwnProperty.call(obj, key)) {
              options2[key] = obj[key];
            }
          }
          if (typeof options2.type === "string" && type !== options2.type) {
            throw new Error("Type transform cannot be a string (type '" + options2.type + "' for token '" + type + "')");
          }
          var match = options2.match;
          options2.match = Array.isArray(match) ? match : match ? [match] : [];
          options2.match.sort(function(a, b) {
            return isRegExp(a) && isRegExp(b) ? 0 : isRegExp(b) ? -1 : isRegExp(a) ? 1 : b.length - a.length;
          });
          return options2;
        }
        function toRules(spec) {
          return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec);
        }
        var defaultErrorRule = ruleOptions("error", { lineBreaks: true, shouldThrow: true });
        function compileRules(rules, hasStates) {
          var errorRule = null;
          var fast = /* @__PURE__ */ Object.create(null);
          var fastAllowed = true;
          var unicodeFlag = null;
          var groups = [];
          var parts = [];
          for (var i = 0; i < rules.length; i++) {
            if (rules[i].fallback) {
              fastAllowed = false;
            }
          }
          for (var i = 0; i < rules.length; i++) {
            var options2 = rules[i];
            if (options2.include) {
              throw new Error("Inheritance is not allowed in stateless lexers");
            }
            if (options2.error || options2.fallback) {
              if (errorRule) {
                if (!options2.fallback === !errorRule.fallback) {
                  throw new Error("Multiple " + (options2.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options2.defaultType + "')");
                } else {
                  throw new Error("fallback and error are mutually exclusive (for token '" + options2.defaultType + "')");
                }
              }
              errorRule = options2;
            }
            var match = options2.match.slice();
            if (fastAllowed) {
              while (match.length && typeof match[0] === "string" && match[0].length === 1) {
                var word = match.shift();
                fast[word.charCodeAt(0)] = options2;
              }
            }
            if (options2.pop || options2.push || options2.next) {
              if (!hasStates) {
                throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options2.defaultType + "')");
              }
              if (options2.fallback) {
                throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options2.defaultType + "')");
              }
            }
            if (match.length === 0) {
              continue;
            }
            fastAllowed = false;
            groups.push(options2);
            for (var j = 0; j < match.length; j++) {
              var obj = match[j];
              if (!isRegExp(obj)) {
                continue;
              }
              if (unicodeFlag === null) {
                unicodeFlag = obj.unicode;
              } else if (unicodeFlag !== obj.unicode && options2.fallback === false) {
                throw new Error("If one rule is /u then all must be");
              }
            }
            var pat = reUnion(match.map(regexpOrLiteral));
            var regexp = new RegExp(pat);
            if (regexp.test("")) {
              throw new Error("RegExp matches empty string: " + regexp);
            }
            var groupCount = reGroups(pat);
            if (groupCount > 0) {
              throw new Error("RegExp has capture groups: " + regexp + "\nUse (?: \u2026 ) instead");
            }
            if (!options2.lineBreaks && regexp.test("\n")) {
              throw new Error("Rule should declare lineBreaks: " + regexp);
            }
            parts.push(reCapture(pat));
          }
          var fallbackRule = errorRule && errorRule.fallback;
          var flags = hasSticky && !fallbackRule ? "ym" : "gm";
          var suffix = hasSticky || fallbackRule ? "" : "|";
          if (unicodeFlag === true) flags += "u";
          var combined = new RegExp(reUnion(parts) + suffix, flags);
          return { regexp: combined, groups, fast, error: errorRule || defaultErrorRule };
        }
        function compile(rules) {
          var result = compileRules(toRules(rules));
          return new Lexer({ start: result }, "start");
        }
        function checkStateGroup(g, name, map) {
          var state = g && (g.push || g.next);
          if (state && !map[state]) {
            throw new Error("Missing state '" + state + "' (in token '" + g.defaultType + "' of state '" + name + "')");
          }
          if (g && g.pop && +g.pop !== 1) {
            throw new Error("pop must be 1 (in token '" + g.defaultType + "' of state '" + name + "')");
          }
        }
        function compileStates(states, start) {
          var all = states.$all ? toRules(states.$all) : [];
          delete states.$all;
          var keys = Object.getOwnPropertyNames(states);
          if (!start) start = keys[0];
          var ruleMap = /* @__PURE__ */ Object.create(null);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            ruleMap[key] = toRules(states[key]).concat(all);
          }
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var rules = ruleMap[key];
            var included = /* @__PURE__ */ Object.create(null);
            for (var j = 0; j < rules.length; j++) {
              var rule = rules[j];
              if (!rule.include) continue;
              var splice = [j, 1];
              if (rule.include !== key && !included[rule.include]) {
                included[rule.include] = true;
                var newRules = ruleMap[rule.include];
                if (!newRules) {
                  throw new Error("Cannot include nonexistent state '" + rule.include + "' (in state '" + key + "')");
                }
                for (var k = 0; k < newRules.length; k++) {
                  var newRule = newRules[k];
                  if (rules.indexOf(newRule) !== -1) continue;
                  splice.push(newRule);
                }
              }
              rules.splice.apply(rules, splice);
              j--;
            }
          }
          var map = /* @__PURE__ */ Object.create(null);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            map[key] = compileRules(ruleMap[key], true);
          }
          for (var i = 0; i < keys.length; i++) {
            var name = keys[i];
            var state = map[name];
            var groups = state.groups;
            for (var j = 0; j < groups.length; j++) {
              checkStateGroup(groups[j], name, map);
            }
            var fastKeys = Object.getOwnPropertyNames(state.fast);
            for (var j = 0; j < fastKeys.length; j++) {
              checkStateGroup(state.fast[fastKeys[j]], name, map);
            }
          }
          return new Lexer(map, start);
        }
        function keywordTransform(map) {
          var isMap = typeof Map !== "undefined";
          var reverseMap = isMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
          var types = Object.getOwnPropertyNames(map);
          for (var i = 0; i < types.length; i++) {
            var tokenType = types[i];
            var item = map[tokenType];
            var keywordList = Array.isArray(item) ? item : [item];
            keywordList.forEach(function(keyword) {
              if (typeof keyword !== "string") {
                throw new Error("keyword must be string (in keyword '" + tokenType + "')");
              }
              if (isMap) {
                reverseMap.set(keyword, tokenType);
              } else {
                reverseMap[keyword] = tokenType;
              }
            });
          }
          return function(k) {
            return isMap ? reverseMap.get(k) : reverseMap[k];
          };
        }
        var Lexer = function(states, state) {
          this.startState = state;
          this.states = states;
          this.buffer = "";
          this.stack = [];
          this.reset();
        };
        Lexer.prototype.reset = function(data, info) {
          this.buffer = data || "";
          this.index = 0;
          this.line = info ? info.line : 1;
          this.col = info ? info.col : 1;
          this.queuedToken = info ? info.queuedToken : null;
          this.queuedText = info ? info.queuedText : "";
          this.queuedThrow = info ? info.queuedThrow : null;
          this.setState(info ? info.state : this.startState);
          this.stack = info && info.stack ? info.stack.slice() : [];
          return this;
        };
        Lexer.prototype.save = function() {
          return {
            line: this.line,
            col: this.col,
            state: this.state,
            stack: this.stack.slice(),
            queuedToken: this.queuedToken,
            queuedText: this.queuedText,
            queuedThrow: this.queuedThrow
          };
        };
        Lexer.prototype.setState = function(state) {
          if (!state || this.state === state) return;
          this.state = state;
          var info = this.states[state];
          this.groups = info.groups;
          this.error = info.error;
          this.re = info.regexp;
          this.fast = info.fast;
        };
        Lexer.prototype.popState = function() {
          this.setState(this.stack.pop());
        };
        Lexer.prototype.pushState = function(state) {
          this.stack.push(this.state);
          this.setState(state);
        };
        var eat = hasSticky ? function(re3, buffer) {
          return re3.exec(buffer);
        } : function(re3, buffer) {
          var match = re3.exec(buffer);
          if (match[0].length === 0) {
            return null;
          }
          return match;
        };
        Lexer.prototype._getGroup = function(match) {
          var groupCount = this.groups.length;
          for (var i = 0; i < groupCount; i++) {
            if (match[i + 1] !== void 0) {
              return this.groups[i];
            }
          }
          throw new Error("Cannot find token type for matched text");
        };
        function tokenToString() {
          return this.value;
        }
        Lexer.prototype.next = function() {
          var index = this.index;
          if (this.queuedGroup) {
            var token = this._token(this.queuedGroup, this.queuedText, index);
            this.queuedGroup = null;
            this.queuedText = "";
            return token;
          }
          var buffer = this.buffer;
          if (index === buffer.length) {
            return;
          }
          var group = this.fast[buffer.charCodeAt(index)];
          if (group) {
            return this._token(group, buffer.charAt(index), index);
          }
          var re3 = this.re;
          re3.lastIndex = index;
          var match = eat(re3, buffer);
          var error = this.error;
          if (match == null) {
            return this._token(error, buffer.slice(index, buffer.length), index);
          }
          var group = this._getGroup(match);
          var text = match[0];
          if (error.fallback && match.index !== index) {
            this.queuedGroup = group;
            this.queuedText = text;
            return this._token(error, buffer.slice(index, match.index), index);
          }
          return this._token(group, text, index);
        };
        Lexer.prototype._token = function(group, text, offset) {
          var lineBreaks = 0;
          if (group.lineBreaks) {
            var matchNL = /\n/g;
            var nl = 1;
            if (text === "\n") {
              lineBreaks = 1;
            } else {
              while (matchNL.exec(text)) {
                lineBreaks++;
                nl = matchNL.lastIndex;
              }
            }
          }
          var token = {
            type: typeof group.type === "function" && group.type(text) || group.defaultType,
            value: typeof group.value === "function" ? group.value(text) : text,
            text,
            toString: tokenToString,
            offset,
            lineBreaks,
            line: this.line,
            col: this.col
          };
          var size = text.length;
          this.index += size;
          this.line += lineBreaks;
          if (lineBreaks !== 0) {
            this.col = size - nl + 1;
          } else {
            this.col += size;
          }
          if (group.shouldThrow) {
            var err = new Error(this.formatError(token, "invalid syntax"));
            throw err;
          }
          if (group.pop) this.popState();
          else if (group.push) this.pushState(group.push);
          else if (group.next) this.setState(group.next);
          return token;
        };
        if (typeof Symbol !== "undefined" && Symbol.iterator) {
          var LexerIterator = function(lexer) {
            this.lexer = lexer;
          };
          LexerIterator.prototype.next = function() {
            var token = this.lexer.next();
            return { value: token, done: !token };
          };
          LexerIterator.prototype[Symbol.iterator] = function() {
            return this;
          };
          Lexer.prototype[Symbol.iterator] = function() {
            return new LexerIterator(this);
          };
        }
        Lexer.prototype.formatError = function(token, message) {
          if (token == null) {
            var text = this.buffer.slice(this.index);
            var token = {
              text,
              offset: this.index,
              lineBreaks: text.indexOf("\n") === -1 ? 0 : 1,
              line: this.line,
              col: this.col
            };
          }
          var numLinesAround = 2;
          var firstDisplayedLine = Math.max(token.line - numLinesAround, 1);
          var lastDisplayedLine = token.line + numLinesAround;
          var lastLineDigits = String(lastDisplayedLine).length;
          var displayedLines = lastNLines(
            this.buffer,
            this.line - token.line + numLinesAround + 1
          ).slice(0, 5);
          var errorLines = [];
          errorLines.push(message + " at line " + token.line + " col " + token.col + ":");
          errorLines.push("");
          for (var i = 0; i < displayedLines.length; i++) {
            var line = displayedLines[i];
            var lineNo = firstDisplayedLine + i;
            errorLines.push(pad(String(lineNo), lastLineDigits) + "  " + line);
            if (lineNo === token.line) {
              errorLines.push(pad("", lastLineDigits + token.col + 1) + "^");
            }
          }
          return errorLines.join("\n");
        };
        Lexer.prototype.clone = function() {
          return new Lexer(this.states, this.state);
        };
        Lexer.prototype.has = function(tokenType) {
          return true;
        };
        return {
          compile,
          states: compileStates,
          error: Object.freeze({ error: true }),
          fallback: Object.freeze({ fallback: true }),
          keywords: keywordTransform
        };
      });
    }
  });

  // node_modules/@retorquere/bibtex-parser/prepositions.json
  var require_prepositions = __commonJS({
    "node_modules/@retorquere/bibtex-parser/prepositions.json"(exports, module) {
      module.exports = ["a", "about", "above", "according to", "across", "after", "against", "ahead of", "along", "although", "among", "an", "and", "apart from", "around", "as for", "as if", "as long as", "as of", "as per", "as regards", "as soon as", "as", "aside from", "at", "back to", "because of", "because", "before", "behind", "below", "beneath", "beside", "between", "but", "by", "close to", "down", "due to", "during", "except for", "far from", "for", "from", "if", "in", "inside of", "inside", "instead of", "into", "like", "near", "next to", "nor", "of", "off", "on", "onto", "or", "out", "outside of", "over", "owing to", "prior to", "pursuant to", "regardless of", "right of", "since", "so", "subsequent to", "the", "through", "to", "towards", "under", "underneath", "unless", "until", "up", "upon", "when", "while", "with", "within", "without", "yet"];
    }
  });

  // node_modules/@retorquere/bibtex-parser/tokenizer.js
  var require_tokenizer = __commonJS({
    "node_modules/@retorquere/bibtex-parser/tokenizer.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.tokenize = void 0;
      var moo_1 = __importDefault(require_moo());
      var rx = __importStar(require_re());
      var L = rx.match(rx.categories.filter((cat) => cat.name === "L"));
      var LNM = rx.match(rx.categories.filter((cat) => cat.name.match(/^[LNM]/)), "\xAD\u2060");
      var W = `${LNM}*?${L}${LNM}*`;
      var B = `(?=(?:${rx.match(rx.categories.filter((cat) => cat.name.match(/^[LNM]/)), "\xAD\u2060").replace(/^./, "[^")}|$))`;
      var Word = new RegExp(`${W}${B}`);
      var P = new RegExp(rx.match(rx.categories.filter((cat) => cat.name.match(/^P/))));
      var Lu = rx.match(rx.categories.filter((cat) => cat.name === "Lu" || cat.name === "Lt"), "\u2060");
      var Acronym = new RegExp(`(?:(?:(?:${Lu}[.]){2,}${B})|(?:(?:vs?[.])(?=[
\r\xA0])))`);
      var Contraction = new RegExp(`${W}['\u2019]${W}${B}`);
      var Whitespace = /[ \t\n\r\u00A0]+/;
      var Ordinal = new RegExp(`\\d+(?:st|nd|rd|th)${B}`);
      var Email = new RegExp(`[A-Za-z0-9._%+-]+@[A-Za-z0-9-]+(?:[.][A-Za-z0-9-]+)+${B}`);
      var Handle = new RegExp(`@[A-Za-z0-9-]{2,}${B}`);
      var Int = new RegExp(`\\d+${B}`);
      var Domain = new RegExp(`${W}(?:[.]${W})+${B}`);
      var Website = new RegExp(`https?://${W}(?:[.]${W})+(?:[^.!?
\r\xA0]+|[.!?]${LNM})+`);
      var ComplexPreposition = /^([^ \t\n\r\u00A0]+)([ \t\n\r\u00A0]+)([^ \t\n\r\u00A0]+)(?:([ \t\n\r\u00A0]+)([^ \t\n\r\u00A0]+))?$/;
      function ci(s) {
        return s.replace(/[a-z]/ig, (match) => `[${match.toUpperCase()}${match.toLowerCase()}]`).replace(" ", Whitespace.source);
      }
      var prepositions = require_prepositions().sort().reverse().map(ci).join("|");
      var Preposition = new RegExp(`(?:${prepositions})${B}`);
      var lexer = moo_1.default.compile({
        "word-preposition": Preposition,
        "word-acronym": Acronym,
        "word-contraction": Contraction,
        "word-ordinal": Ordinal,
        email: Email,
        handle: Handle,
        website: Website,
        domain: Domain,
        word: Word,
        number: Int,
        // eslint-disable-line id-blacklist
        "punctuation-end": /[?.!](?=[ \t\n\r\u00A0]|$)/,
        "punctuation-colon": /:(?=[ \t\n\r\u00A0])/,
        "punctuation-ellipsis": /[.][.][.]/,
        punctuation: P,
        whitespace: { match: /[ \t\n\r\u00A0]/, lineBreaks: true },
        other: { match: /[\s\S]/, lineBreaks: true }
      });
      var Shape = new class {
        constructor() {
          this.shapes = {};
          this.re = {
            X: new RegExp(rx.match(rx.categories.filter((cat) => cat.name === "Lu" || cat.name === "Lt"))),
            x: new RegExp(rx.match(rx.categories.filter((cat) => cat.name.match(/^L[^Cut]/)))),
            d: new RegExp(rx.match(rx.categories.filter((cat) => cat.name[0] === "N")))
          };
        }
        match(c) {
          if (c.match(this.re.d))
            return "d";
          if (c.toLowerCase() === c.toUpperCase())
            return c;
          if (c.match(this.re.X))
            return "X";
          if (c.match(this.re.x))
            return "x";
          if (c === "\u2019")
            return "'";
          if (c === "\u2013")
            return "-";
          if (c === "\u2060" || c === "\xAD")
            return "";
          return c;
        }
        fetch(c) {
          if (typeof this.shapes[c] === "undefined")
            this.shapes[c] = this.match(c);
          return this.shapes[c];
        }
        shape(t) {
          if (!this.shapes[t])
            this.shapes[t] = Array.from(t).map((c) => this.fetch(c)).join("");
          return this.shapes[t];
        }
      }();
      function combine(tokens) {
        const combined = Object.assign({}, tokens[0]);
        for (const t of tokens.slice(1)) {
          combined.text += t.text;
          combined.end = t.end;
          combined.shape += t.shape;
        }
        return combined;
      }
      function hyphenate(t) {
        if (t.type === "word")
          return "w";
        if (t.text === "-" || t.text === "\u2013")
          return "-";
        return " ";
      }
      function tokenize(title, markup) {
        if (markup)
          title = title.replace(markup, (match) => "\u2060".repeat(match.length));
        lexer.reset(title);
        const tokens = [];
        let sentenceStart = true;
        let subSentenceStart = false;
        for (const token of lexer) {
          const [type, subtype] = (token.type.includes("-") ? token.type : `${token.type}-`).split("-");
          tokens.push({
            type,
            subtype,
            text: token.text,
            start: token.offset,
            end: token.offset + token.text.length - 1,
            shape: Shape.shape(token.text),
            sentenceStart: type === "word" && sentenceStart,
            subSentenceStart: type === "word" && subSentenceStart
          });
          switch (token.type) {
            case "punctuation-end":
              sentenceStart = true;
              break;
            case "punctuation-colon":
              subSentenceStart = true;
              break;
            default:
              if (type.match(/word|number|handle|domain|website/)) {
                sentenceStart = false;
                subSentenceStart = false;
              }
              break;
          }
        }
        const stack = tokens.splice(0);
        let cpt;
        let cps;
        while (stack.length) {
          if (stack[0].subtype === "preposition" && (cpt = stack[0].text.match(ComplexPreposition)) && (cps = stack[0].shape.match(ComplexPreposition))) {
            const complex = stack.shift();
            let start = complex.start;
            let end;
            for (const i of Array.from({ length: 5 }, (_, n) => n + 1)) {
              if (!cpt[i])
                break;
              end = start + cps[i].length - 1;
              tokens.push(Object.assign(Object.assign({}, complex), {
                text: cpt[i],
                shape: cps[i],
                start,
                end,
                type: i % 2 ? complex.type : "whitespace",
                subtype: i % 2 ? complex.type : ""
              }));
              start = end + 1;
            }
            continue;
          }
          const pat = stack.map((t) => hyphenate(t)).join("");
          if (cpt = pat.match(/^w(-w)+(?= |$)/)) {
            const hyphenated = stack.splice(0, cpt[0].length);
            tokens.push(Object.assign(Object.assign({}, combine(hyphenated)), { hyphenated }));
            continue;
          }
          tokens.push(stack.shift());
        }
        return markup ? tokens.map((token) => Object.assign(Object.assign({}, token), { text: title.substring(token.start, token.end + 1) })) : tokens;
      }
      exports.tokenize = tokenize;
    }
  });

  // node_modules/lodash.merge/index.js
  var require_lodash = __commonJS({
    "node_modules/lodash.merge/index.js"(exports, module) {
      var LARGE_ARRAY_SIZE = 200;
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var HOT_COUNT = 800;
      var HOT_SPAN = 16;
      var MAX_SAFE_INTEGER = 9007199254740991;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var asyncTag = "[object AsyncFunction]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var nullTag = "[object Null]";
      var objectTag = "[object Object]";
      var proxyTag = "[object Proxy]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var undefinedTag = "[object Undefined]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var arrayProto = Array.prototype;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var coreJsData = root["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object);
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var Symbol2 = root.Symbol;
      var Uint8Array2 = root.Uint8Array;
      var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      var objectCreate = Object.create;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var splice = arrayProto.splice;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var nativeMax = Math.max;
      var nativeNow = Date.now;
      var Map2 = getNative(root, "Map");
      var nativeCreate = getNative(Object, "create");
      var baseCreate = /* @__PURE__ */ function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function assignMergeValue(object, key, value) {
        if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      var baseFor = createBaseFor();
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
        return result;
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform) {
        start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array);
          return apply(func, this, otherArgs);
        };
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setToString = shortOut(baseSetToString);
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array.isArray;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      function constant(value) {
        return function() {
          return value;
        };
      }
      function identity(value) {
        return value;
      }
      function stubFalse() {
        return false;
      }
      module.exports = merge;
    }
  });

  // node_modules/@retorquere/bibtex-parser/merge.js
  var require_merge = __commonJS({
    "node_modules/@retorquere/bibtex-parser/merge.js"(exports) {
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.merge = void 0;
      var lodash_merge_1 = __importDefault(require_lodash());
      function merge(options2, defaults2) {
        return (0, lodash_merge_1.default)(defaults2, options2);
      }
      exports.merge = merge;
    }
  });

  // node_modules/@retorquere/bibtex-parser/sentence-case.js
  var require_sentence_case = __commonJS({
    "node_modules/@retorquere/bibtex-parser/sentence-case.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toSentenceCase = void 0;
      var tokenizer_1 = require_tokenizer();
      var merge_1 = require_merge();
      var rx = __importStar(require_re());
      var Lu = rx.match(rx.categories.filter((cat) => cat.name === "Lu" || cat.name === "Lt"));
      var Ll = rx.match(rx.categories.filter((cat) => cat.name === "Ll"));
      var connectedInnerWord = new RegExp(`-${Lu}${Ll}*(?=-|$)`, "g");
      function titleCase2(s) {
        return s.replace(/^(.)(.+)/, (match, car, cdr) => `${car}${cdr.toLowerCase()}`);
      }
      function wordSC(token, allCaps, subSentence, hyphenated) {
        if (token.type === "domain")
          return token.text.toLowerCase();
        if (token.type !== "word")
          return token.text;
        if (token.text.match(/^I'/))
          return titleCase2(token.text);
        if (subSentence && token.subSentenceStart && token.text.match(/^a$/i))
          return "a";
        if (subSentence && token.subSentenceStart || token.sentenceStart) {
          return allCaps ? titleCase2(token.text) : token.text.replace(connectedInnerWord, (match) => match.toLowerCase());
        }
        if (token.subtype === "preposition")
          return token.text.toLowerCase();
        if (token.subtype === "acronym")
          return token.text;
        if (token.text.match(/^[B-Z]$/))
          return hyphenated ? token.text.toLowerCase() : token.text;
        const shape = token.shape.replace(/[^-Xxd]/g, "");
        if (shape.match(/^[Xd]+$/))
          return allCaps ? token.text.toLowerCase() : token.text;
        if (shape.match(/x.*X/))
          return token.text;
        return token.text.toLowerCase();
      }
      function toSentenceCase2(title, options2 = {}) {
        options2 = (0, merge_1.merge)(options2, {
          preserveQuoted: true,
          subSentenceCapitalization: true,
          guess: false
        });
        const allCaps = title === title.toUpperCase();
        const allLower = title === title.toLowerCase();
        if (options2.guess && !allCaps && !allLower) {
          let $title = title;
          if (options2.nocase)
            $title = $title.replace(options2.nocase, (match) => match.match(/\s/) ? " " : "");
          if (options2.markup)
            $title = $title.replace(options2.markup, "");
          const guess = {
            words: (0, tokenizer_1.tokenize)($title),
            sc: 0,
            other: 0
          };
          guess.words.forEach((token, i) => {
            if (token.type === "word" && token.text.length > 1 && !token.subtype.match(/preposition|acronym|ordinal/) && (i === 0 || guess.words[i - 1].type === "whitespace")) {
              guess[token.shape.match(/^[^X]*x[^X]*$/) ? "sc" : "other"] += 1;
            }
          });
          if (guess.sc && guess.sc >= guess.other)
            return title;
        }
        if (allCaps && !title.match(/\s/))
          return title;
        const tokens = (0, tokenizer_1.tokenize)(title, options2.markup);
        let sentenceCased = "";
        for (const token of tokens) {
          if (token.hyphenated && token.shape[0] === "x") {
            sentenceCased += token.text;
          } else if (token.hyphenated) {
            for (const t of token.hyphenated) {
              sentenceCased += wordSC(t, allCaps, options2.subSentenceCapitalization, true);
            }
          } else {
            sentenceCased += wordSC(token, allCaps, options2.subSentenceCapitalization, false);
          }
        }
        if (options2.markup) {
          for (const match of title.matchAll(options2.markup)) {
            sentenceCased = sentenceCased.substring(0, match.index) + match[0] + sentenceCased.substring(match.index + match[0].length);
          }
        }
        if (options2.nocase) {
          sentenceCased = sentenceCased.replace(options2.nocase, (match, tag, offset) => title.substring(offset, offset + match.length));
        }
        if (options2.preserveQuoted) {
          for (const q of [/“.*?”/g, /‘.*?’/g, /".*?"/g]) {
            sentenceCased = sentenceCased.replace(q, (match, offset) => title.substring(offset, offset + match.length));
          }
        }
        return sentenceCased;
      }
      exports.toSentenceCase = toSentenceCase2;
    }
  });

  // node_modules/@retorquere/bibtex-parser/crossref.json
  var require_crossref = __commonJS({
    "node_modules/@retorquere/bibtex-parser/crossref.json"(exports, module) {
      module.exports = { "*": { "*": { "verbb": "verba" } }, "article": { "periodical": { "journalsubtitle": "subtitle", "journaltitle": "title" } }, "book": { "mvbook": { "mainsubtitle": "subtitle", "maintitle": "title", "maintitleaddon": "titleaddon" } }, "bookinbook": { "book": { "author": "author", "bookauthor": "author", "booksubtitle": "subtitle", "booktitle": "title", "booktitleaddon": "titleaddon" }, "mvbook": { "author": "author", "bookauthor": "author", "mainsubtitle": "subtitle", "maintitle": "title", "maintitleaddon": "titleaddon" } }, "collection": { "mvcollection": { "mainsubtitle": "subtitle", "maintitle": "title", "maintitleaddon": "titleaddon" }, "mvreference": { "mainsubtitle": "subtitle", "maintitle": "title", "maintitleaddon": "titleaddon" } }, "inbook": { "*": { "bookauthor": "author" }, "book": { "author": "author", "bookauthor": "author", "booksubtitle": "subtitle", "booktitle": "title", "booktitleaddon": "titleaddon" }, "mvbook": { "author": "author", "bookauthor": "author", "mainsubtitle": "subtitle", "maintitle": "title", "maintitleaddon": "titleaddon" } }, "incollection": { "collection": { "booksubtitle": "subtitle", "booktitle": "title", "booktitleaddon": "titleaddon" }, "mvcollection": { "mainsubtitle": "subtitle", "maintitle": "title", "maintitleaddon": "titleaddon" }, "mvreference": { "mainsubtitle": "subtitle", "maintitle": "title", "maintitleaddon": "titleaddon" }, "reference": { "booksubtitle": "subtitle", "booktitle": "title", "booktitleaddon": "titleaddon" } }, "inproceedings": { "mvproceedings": { "mainsubtitle": "subtitle", "maintitle": "title", "maintitleaddon": "titleaddon" }, "proceedings": { "booksubtitle": "subtitle", "booktitle": "title", "booktitleaddon": "titleaddon" } }, "inreference": { "collection": { "booksubtitle": "subtitle", "booktitle": "title", "booktitleaddon": "titleaddon" }, "mvcollection": { "mainsubtitle": "subtitle", "maintitle": "title", "maintitleaddon": "titleaddon" }, "mvreference": { "mainsubtitle": "subtitle", "maintitle": "title", "maintitleaddon": "titleaddon" }, "reference": { "booksubtitle": "subtitle", "booktitle": "title", "booktitleaddon": "titleaddon" } }, "proceedings": { "mvproceedings": { "mainsubtitle": "subtitle", "maintitle": "title", "maintitleaddon": "titleaddon" } }, "reference": { "mvcollection": { "mainsubtitle": "subtitle", "maintitle": "title", "maintitleaddon": "titleaddon" }, "mvreference": { "mainsubtitle": "subtitle", "maintitle": "title", "maintitleaddon": "titleaddon" } }, "suppbook": { "book": { "author": "author", "bookauthor": "author", "booksubtitle": "subtitle", "booktitle": "title", "booktitleaddon": "titleaddon" }, "mvbook": { "author": "author", "bookauthor": "author", "mainsubtitle": "subtitle", "maintitle": "title", "maintitleaddon": "titleaddon" } }, "suppcollection": { "collection": { "booksubtitle": "subtitle", "booktitle": "title", "booktitleaddon": "titleaddon" }, "mvcollection": { "mainsubtitle": "subtitle", "maintitle": "title", "maintitleaddon": "titleaddon" }, "mvreference": { "mainsubtitle": "subtitle", "maintitle": "title", "maintitleaddon": "titleaddon" }, "reference": { "booksubtitle": "subtitle", "booktitle": "title", "booktitleaddon": "titleaddon" } }, "suppperiodical": { "periodical": { "journalsubtitle": "subtitle", "journaltitle": "title" } } };
    }
  });

  // node_modules/@retorquere/bibtex-parser/fields.json
  var require_fields = __commonJS({
    "node_modules/@retorquere/bibtex-parser/fields.json"(exports, module) {
      module.exports = { "article": ["abstract", "addendum", "annotation", "annotator", "author", "authortype", "bookpagination", "commentator", "crossref", "day", "doi", "editor", "editora", "editoratype", "editorb", "editorbtype", "editorc", "editorctype", "editortype", "eid", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "issn", "issue", "issuesubtitle", "issuetitle", "issuetitleaddon", "iswc", "journalsubtitle", "journaltitle", "journaltitleaddon", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlanguage", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pages", "pagination", "presort", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "translator", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "version", "volume", "xdata", "xref", "year", "yeardivision"], "artwork": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "audio": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "bibnote": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "book": ["abstract", "addendum", "afterword", "annotation", "annotator", "author", "authortype", "bookpagination", "chapter", "commentator", "crossref", "day", "doi", "edition", "editor", "editora", "editoratype", "editorb", "editorbtype", "editorc", "editorctype", "editortype", "eid", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "foreword", "gender", "hour", "ids", "indexsorttitle", "indextitle", "introduction", "isan", "isbn", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "mainsubtitle", "maintitle", "maintitleaddon", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlanguage", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pages", "pagetotal", "pagination", "part", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "translator", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "volume", "volumes", "xdata", "xref", "year", "yeardivision"], "bookinbook": ["abstract", "addendum", "afterword", "annotation", "annotator", "author", "authortype", "bookauthor", "bookpagination", "booksubtitle", "booktitle", "booktitleaddon", "chapter", "commentator", "crossref", "day", "doi", "edition", "editor", "editora", "editoratype", "editorb", "editorbtype", "editorc", "editorctype", "editortype", "eid", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "foreword", "gender", "hour", "ids", "indexsorttitle", "indextitle", "introduction", "isan", "isbn", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "mainsubtitle", "maintitle", "maintitleaddon", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlanguage", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pages", "pagination", "part", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "translator", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "volume", "volumes", "xdata", "xref", "year", "yeardivision"], "booklet": ["abstract", "addendum", "annotation", "author", "authortype", "bookpagination", "chapter", "crossref", "day", "doi", "editor", "editortype", "eid", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "howpublished", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pages", "pagetotal", "pagination", "presort", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "type", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "collection": ["abstract", "addendum", "afterword", "annotation", "annotator", "authortype", "bookpagination", "chapter", "commentator", "crossref", "day", "doi", "edition", "editor", "editora", "editoratype", "editorb", "editorbtype", "editorc", "editorctype", "editortype", "eid", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "foreword", "gender", "hour", "ids", "indexsorttitle", "indextitle", "introduction", "isan", "isbn", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "mainsubtitle", "maintitle", "maintitleaddon", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlanguage", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pages", "pagetotal", "pagination", "part", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "translator", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "volume", "volumes", "xdata", "xref", "year", "yeardivision"], "commentary": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "customa": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "customb": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "customc": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "customd": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "custome": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "customf": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "dataset": ["abstract", "addendum", "annotation", "author", "authortype", "bookpagination", "crossref", "day", "doi", "edition", "editor", "editortype", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "organization", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "type", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "version", "xdata", "xref", "year", "yeardivision"], "image": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "inbook": ["abstract", "addendum", "afterword", "annotation", "annotator", "author", "authortype", "bookauthor", "bookpagination", "booksubtitle", "booktitle", "booktitleaddon", "chapter", "commentator", "crossref", "day", "doi", "edition", "editor", "editora", "editoratype", "editorb", "editorbtype", "editorc", "editorctype", "editortype", "eid", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "foreword", "gender", "hour", "ids", "indexsorttitle", "indextitle", "introduction", "isan", "isbn", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "mainsubtitle", "maintitle", "maintitleaddon", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlanguage", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pages", "pagination", "part", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "translator", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "volume", "volumes", "xdata", "xref", "year", "yeardivision"], "incollection": ["abstract", "addendum", "afterword", "annotation", "annotator", "author", "authortype", "bookpagination", "booksubtitle", "booktitle", "booktitleaddon", "chapter", "commentator", "crossref", "day", "doi", "edition", "editor", "editora", "editoratype", "editorb", "editorbtype", "editorc", "editorctype", "editortype", "eid", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "foreword", "gender", "hour", "ids", "indexsorttitle", "indextitle", "introduction", "isan", "isbn", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "mainsubtitle", "maintitle", "maintitleaddon", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlanguage", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pages", "pagination", "part", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "translator", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "volume", "volumes", "xdata", "xref", "year", "yeardivision"], "inproceedings": ["abstract", "addendum", "annotation", "author", "authortype", "bookpagination", "booksubtitle", "booktitle", "booktitleaddon", "chapter", "crossref", "day", "doi", "editor", "editortype", "eid", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "eventday", "eventendday", "eventendhour", "eventendminute", "eventendmonth", "eventendsecond", "eventendtimezone", "eventendyear", "eventendyeardivision", "eventhour", "eventminute", "eventmonth", "eventsecond", "eventtimezone", "eventtitle", "eventtitleaddon", "eventyear", "eventyeardivision", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "isbn", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "mainsubtitle", "maintitle", "maintitleaddon", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "organization", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pages", "pagination", "part", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "venue", "verba", "verbb", "verbc", "volume", "volumes", "xdata", "xref", "year", "yeardivision"], "inreference": ["abstract", "addendum", "afterword", "annotation", "annotator", "author", "authortype", "bookpagination", "booksubtitle", "booktitle", "booktitleaddon", "chapter", "commentator", "crossref", "day", "doi", "edition", "editor", "editora", "editoratype", "editorb", "editorbtype", "editorc", "editorctype", "editortype", "eid", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "foreword", "gender", "hour", "ids", "indexsorttitle", "indextitle", "introduction", "isan", "isbn", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "mainsubtitle", "maintitle", "maintitleaddon", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlanguage", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pages", "pagination", "part", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "translator", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "volume", "volumes", "xdata", "xref", "year", "yeardivision"], "jurisdiction": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "legal": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "legislation": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "letter": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "manual": ["abstract", "addendum", "annotation", "author", "authortype", "bookpagination", "chapter", "crossref", "day", "doi", "edition", "editor", "editortype", "eid", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "isbn", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "organization", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pages", "pagetotal", "pagination", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "type", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "version", "xdata", "xref", "year", "yeardivision"], "misc": ["abstract", "addendum", "annotation", "author", "authortype", "bookpagination", "crossref", "day", "doi", "editor", "editortype", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "howpublished", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "options", "organization", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "type", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "version", "xdata", "xref", "year", "yeardivision"], "movie": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "music": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "mvbook": ["abstract", "addendum", "afterword", "annotation", "annotator", "author", "authortype", "bookpagination", "commentator", "crossref", "day", "doi", "edition", "editor", "editora", "editoratype", "editorb", "editorbtype", "editorc", "editorctype", "editortype", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "foreword", "gender", "hour", "ids", "indexsorttitle", "indextitle", "introduction", "isan", "isbn", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlanguage", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagetotal", "pagination", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "translator", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "volume", "volumes", "xdata", "xref", "year", "yeardivision"], "mvcollection": ["abstract", "addendum", "afterword", "annotation", "annotator", "author", "authortype", "bookpagination", "commentator", "crossref", "day", "doi", "edition", "editor", "editora", "editoratype", "editorb", "editorbtype", "editorc", "editorctype", "editortype", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "foreword", "gender", "hour", "ids", "indexsorttitle", "indextitle", "introduction", "isan", "isbn", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlanguage", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "translator", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "volume", "volumes", "xdata", "xref", "year", "yeardivision"], "mvproceedings": ["abstract", "addendum", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "editor", "editortype", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "eventday", "eventendday", "eventendhour", "eventendminute", "eventendmonth", "eventendsecond", "eventendtimezone", "eventendyear", "eventendyeardivision", "eventhour", "eventminute", "eventmonth", "eventsecond", "eventtimezone", "eventtitle", "eventtitleaddon", "eventyear", "eventyeardivision", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "isbn", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "organization", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagetotal", "pagination", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "venue", "verba", "verbb", "verbc", "volumes", "xdata", "xref", "year", "yeardivision"], "mvreference": ["abstract", "addendum", "afterword", "annotation", "annotator", "author", "authortype", "bookpagination", "commentator", "crossref", "day", "doi", "edition", "editor", "editora", "editoratype", "editorb", "editorbtype", "editorc", "editorctype", "editortype", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "foreword", "gender", "hour", "ids", "indexsorttitle", "indextitle", "introduction", "isan", "isbn", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlanguage", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "translator", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "volume", "volumes", "xdata", "xref", "year", "yeardivision"], "online": ["abstract", "addendum", "annotation", "author", "authortype", "bookpagination", "crossref", "day", "doi", "editor", "editortype", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "options", "organization", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "version", "xdata", "xref", "year", "yeardivision"], "patent": ["abstract", "addendum", "annotation", "author", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "holder", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "type", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "version", "xdata", "xref", "year", "yeardivision"], "performance": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "periodical": ["abstract", "addendum", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "editor", "editora", "editoratype", "editorb", "editorbtype", "editorc", "editorctype", "editortype", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "issn", "issue", "issuesubtitle", "issuetitle", "issuetitleaddon", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "volume", "xdata", "xref", "year", "yeardivision"], "proceedings": ["abstract", "addendum", "annotation", "authortype", "bookpagination", "chapter", "crossref", "day", "doi", "editor", "editortype", "eid", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "eventday", "eventendday", "eventendhour", "eventendminute", "eventendmonth", "eventendsecond", "eventendtimezone", "eventendyear", "eventendyeardivision", "eventhour", "eventminute", "eventmonth", "eventsecond", "eventtimezone", "eventtitle", "eventtitleaddon", "eventyear", "eventyeardivision", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "isbn", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "mainsubtitle", "maintitle", "maintitleaddon", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "organization", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pages", "pagetotal", "pagination", "part", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "venue", "verba", "verbb", "verbc", "volume", "volumes", "xdata", "xref", "year", "yeardivision"], "reference": ["abstract", "addendum", "afterword", "annotation", "annotator", "authortype", "bookpagination", "chapter", "commentator", "crossref", "day", "doi", "edition", "editor", "editora", "editoratype", "editorb", "editorbtype", "editorc", "editorctype", "editortype", "eid", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "foreword", "gender", "hour", "ids", "indexsorttitle", "indextitle", "introduction", "isan", "isbn", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "mainsubtitle", "maintitle", "maintitleaddon", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlanguage", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pages", "pagetotal", "pagination", "part", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "translator", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "volume", "volumes", "xdata", "xref", "year", "yeardivision"], "report": ["abstract", "addendum", "annotation", "author", "authortype", "bookpagination", "chapter", "crossref", "day", "doi", "eid", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "institution", "isan", "ismn", "isrn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pages", "pagetotal", "pagination", "presort", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "type", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "version", "xdata", "xref", "year", "yeardivision"], "review": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "set": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "software": ["abstract", "addendum", "annotation", "author", "authortype", "bookpagination", "crossref", "day", "doi", "editor", "editortype", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "howpublished", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "options", "organization", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "type", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "version", "xdata", "xref", "year", "yeardivision"], "standard": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "suppbook": ["abstract", "addendum", "afterword", "annotation", "annotator", "author", "authortype", "bookauthor", "bookpagination", "booksubtitle", "booktitle", "booktitleaddon", "chapter", "commentator", "crossref", "day", "doi", "edition", "editor", "editora", "editoratype", "editorb", "editorbtype", "editorc", "editorctype", "editortype", "eid", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "foreword", "gender", "hour", "ids", "indexsorttitle", "indextitle", "introduction", "isan", "isbn", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "mainsubtitle", "maintitle", "maintitleaddon", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlanguage", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pages", "pagination", "part", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "translator", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "volume", "volumes", "xdata", "xref", "year", "yeardivision"], "suppcollection": ["abstract", "addendum", "afterword", "annotation", "annotator", "author", "authortype", "bookpagination", "booksubtitle", "booktitle", "booktitleaddon", "chapter", "commentator", "crossref", "day", "doi", "edition", "editor", "editora", "editoratype", "editorb", "editorbtype", "editorc", "editorctype", "editortype", "eid", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "foreword", "gender", "hour", "ids", "indexsorttitle", "indextitle", "introduction", "isan", "isbn", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "mainsubtitle", "maintitle", "maintitleaddon", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "number", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlanguage", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pages", "pagination", "part", "presort", "publisher", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "series", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "translator", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "volume", "volumes", "xdata", "xref", "year", "yeardivision"], "suppperiodical": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "thesis": ["abstract", "addendum", "annotation", "author", "authortype", "bookpagination", "chapter", "crossref", "day", "doi", "eid", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "institution", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pages", "pagetotal", "pagination", "presort", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "type", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "unpublished": ["abstract", "addendum", "annotation", "author", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "eventday", "eventendday", "eventendhour", "eventendminute", "eventendmonth", "eventendsecond", "eventendtimezone", "eventendyear", "eventendyeardivision", "eventhour", "eventminute", "eventmonth", "eventsecond", "eventtimezone", "eventtitle", "eventtitleaddon", "eventyear", "eventyeardivision", "execute", "file", "gender", "hour", "howpublished", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "language", "library", "lista", "listb", "listc", "listd", "liste", "listf", "location", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "note", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "pubstate", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "subtitle", "timezone", "title", "titleaddon", "type", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "venue", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "video": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"], "xdata": ["abstract", "annotation", "authortype", "bookpagination", "crossref", "day", "doi", "endday", "endhour", "endminute", "endmonth", "endsecond", "endtimezone", "endyear", "endyeardivision", "entryset", "entrysubtype", "eprint", "eprintclass", "eprinttype", "execute", "file", "gender", "hour", "ids", "indexsorttitle", "indextitle", "isan", "ismn", "iswc", "keywords", "label", "langid", "langidopts", "library", "lista", "listb", "listc", "listd", "liste", "listf", "minute", "month", "namea", "nameaddon", "nameatype", "nameb", "namebtype", "namec", "namectype", "options", "origday", "origendday", "origendhour", "origendminute", "origendmonth", "origendsecond", "origendtimezone", "origendyear", "origendyeardivision", "orighour", "origlocation", "origminute", "origmonth", "origpublisher", "origsecond", "origtimezone", "origtitle", "origyear", "origyeardivision", "pagination", "presort", "related", "relatedoptions", "relatedstring", "relatedtype", "second", "shortauthor", "shorteditor", "shorthand", "shorthandintro", "shortjournal", "shortseries", "shorttitle", "sortkey", "sortname", "sortshorthand", "sorttitle", "sortyear", "timezone", "url", "urlday", "urlendday", "urlendhour", "urlendminute", "urlendmonth", "urlendsecond", "urlendtimezone", "urlendyear", "urlhour", "urlminute", "urlmonth", "urlsecond", "urltimezone", "urlyear", "usera", "userb", "userc", "userd", "usere", "userf", "verba", "verbb", "verbc", "xdata", "xref", "year", "yeardivision"] };
    }
  });

  // node_modules/@retorquere/bibtex-parser/index.js
  var require_bibtex_parser = __commonJS({
    "node_modules/@retorquere/bibtex-parser/index.js"(exports) {
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseAsync = exports.parse = exports.English = exports.FieldMode = exports.toSentenceCase = void 0;
      var unified_latex_util_replace_1 = require_unified_latex_util_replace();
      var unified_latex_util_pegjs_1 = require_unified_latex_util_pegjs();
      var unified_latex_util_visit_1 = require_unified_latex_util_visit();
      var unified_latex_util_print_raw_1 = require_unified_latex_util_print_raw();
      var unicode2latex_1 = require_unicode2latex();
      var bibtex = __importStar(require_verbatim());
      var JabRef = __importStar(require_jabref());
      var sentence_case_1 = require_sentence_case();
      Object.defineProperty(exports, "toSentenceCase", { enumerable: true, get: function() {
        return sentence_case_1.toSentenceCase;
      } });
      var sentence_case_2 = require_sentence_case();
      var tokenizer_1 = require_tokenizer();
      var yield_1 = require_yield();
      var crossref_json_1 = __importDefault(require_crossref());
      var fields_json_1 = __importDefault(require_fields());
      var merge_1 = require_merge();
      function latexMode(node) {
        return node._renderInfo.mode;
      }
      function latex2unicode(tex, node) {
        const text = unicode2latex_1.latex2unicode[tex];
        if (typeof text === "string")
          return text;
        return text && text[latexMode(node)];
      }
      var open = {};
      var close = {};
      for (const tag of ["i", "b", "sc", "nc", "ncx", "br", "p", "li", "code"]) {
        open[tag] = `${tag}`;
        close[tag] = `/${tag}`;
      }
      var collapsable = /\x0E\/([a-z]+)\x0F(\s*)\x0E\1\x0F/ig;
      var Month = {
        jan: "1",
        january: "1",
        feb: "2",
        february: "2",
        mar: "3",
        march: "3",
        apr: "4",
        april: "4",
        may: "5",
        jun: "6",
        june: "6",
        jul: "7",
        july: "7",
        aug: "8",
        august: "8",
        sep: "9",
        september: "9",
        oct: "10",
        october: "10",
        nov: "11",
        november: "11",
        dec: "12",
        december: "12"
      };
      exports.FieldMode = {
        creatorlist: [
          "author",
          "bookauthor",
          "collaborator",
          "commentator",
          "director",
          "editor",
          "editora",
          "editorb",
          "editors",
          "holder",
          "scriptwriter",
          "translator"
        ],
        title: [
          "title",
          "subtitle",
          "series",
          "shorttitle",
          "booktitle",
          // 'type',
          "origtitle",
          "maintitle",
          "eventtitle"
        ],
        verbatim: [
          "doi",
          "eprint",
          "file",
          "files",
          "pdf",
          "groups",
          // jabref unilaterally decided to make this non-standard field verbatim
          "ids",
          "url",
          "verba",
          "verbb",
          "verbc",
          /^keywords([+]duplicate-\d+)?$/,
          /^citeulike-linkout-[0-9]+$/,
          /^bdsk-url-[0-9]+$/
        ],
        richtext: [
          "annotation",
          "comment",
          "annote",
          "review",
          "notes",
          "note"
        ],
        literallist: [
          "institution",
          "publisher",
          "origpublisher",
          "organization",
          "location",
          "origlocation"
        ]
      };
      exports.English = [
        "",
        "american",
        "british",
        "canadian",
        "english",
        "australian",
        "newzealand",
        "usenglish",
        "ukenglish",
        "en",
        "eng",
        "en-au",
        "en-bz",
        "en-ca",
        "en-cb",
        "en-gb",
        "en-ie",
        "en-jm",
        "en-nz",
        "en-ph",
        "en-tt",
        "en-us",
        "en-za",
        "en-zw",
        "anglais"
        // don't do this people
      ];
      var FieldAction = {
        removeOuterBraces: [
          "doi"
          // 'publisher',
          // 'location',
        ],
        parseInt: [
          "year",
          "month"
        ],
        noCrossRef: [
          "file"
        ]
      };
      var narguments = {
        advance: 1,
        ElsevierGlyph: 1,
        bar: 1,
        bibcyr: 1,
        bibstring: 1,
        chsf: 1,
        cite: 1,
        citeauthor: 1,
        cyrchar: 1,
        ding: 1,
        emph: 1,
        enquote: 1,
        frac: 2,
        hbox: 1,
        href: 2,
        hskip: 1,
        hspace: 1,
        ht: 1,
        mathrm: 1,
        mbox: 1,
        mkbibbold: 1,
        mkbibemph: 1,
        mkbibitalic: 1,
        mkbibquote: 1,
        newcommand: 2,
        noopsort: 1,
        ocirc: 1,
        overline: 1,
        ProvideTextCommandDefault: 2,
        rlap: 1,
        sb: 1,
        section: 1,
        sp: 1,
        subsection: 1,
        subsubsection: 1,
        subsubsubsection: 1,
        t: 1,
        textbf: 1,
        textcite: 1,
        textit: 1,
        textrm: 1,
        textsc: 1,
        textsl: 1,
        textsubscript: 1,
        textsuperscript: 1,
        texttt: 1,
        textup: 1,
        url: 1,
        vphantom: 1,
        vspace: 1,
        wd: 1,
        // math
        "math	_": 1,
        "math	^": 1
      };
      for (const m in unicode2latex_1.combining.tounicode) {
        narguments[m] = 1;
      }
      var BibTeXParser = class {
        constructor() {
          this.newcommands = {};
          this.unhandled = /* @__PURE__ */ new Set();
        }
        split(ast, sep, split) {
          const roots = [];
          const nodes = [...ast.content];
          const types = nodes.map((node) => {
            if (node.type === "whitespace")
              return " ";
            if (node.type === "string" && node.content.match(sep))
              return "&";
            return ".";
          }).join("");
          types.split(split).forEach((match, i) => {
            const content = match.length ? nodes.splice(0, match.length) : [];
            if (i % 2 === 0)
              roots.push({ type: "root", content });
          });
          return roots;
        }
        trimCreator(cr) {
          return JSON.parse(JSON.stringify(cr, (k, v) => typeof v === "string" ? v.trim() || void 0 : v));
        }
        parseCreator(ast) {
          if (ast.content.length === 1 && ast.content[0].type === "group")
            return this.trimCreator({ name: this.stringify(ast, { mode: "creatorlist" }) });
          if (ast.content.find((node) => node.type === "string" && node.content === ",")) {
            const nameparts = this.split(ast, /^,$/, /(&)/).map((part) => this.stringify(part, { mode: "creatorlist" }).trim());
            const extended = nameparts.every((p) => p.match(/^[a-z][-a-z]+\s*=/i));
            if (!extended) {
              if (nameparts.length === 3 && nameparts[2] === "")
                nameparts.pop();
              if (nameparts.length > 3) {
                const key = this.current.key ? `@${this.current.key}: ` : "";
                this.bib.errors.push({
                  // eslint-disable-next-line no-magic-numbers
                  error: `${key}unexpected ${nameparts.length}-part name "${nameparts.join(", ")}", dropping "${nameparts.slice(3).join(", ")}"`,
                  input: nameparts.join(", ")
                });
              }
              let [lastName, suffix, firstName] = nameparts.length === 2 ? [nameparts[0], void 0, nameparts[1]] : nameparts.slice(0, 3);
              let prefix;
              const m = lastName.match(/^([a-z'. ]+) (.+)/);
              if (m) {
                prefix = m[1];
                lastName = m[2];
              }
              return this.trimCreator({
                lastName,
                firstName,
                prefix,
                suffix
              });
            }
            const name = {};
            for (let [attr, value] of nameparts.map((p) => {
              var _a2;
              return (_a2 = p.match(/^([^=]+)=(.*)/)) === null || _a2 === void 0 ? void 0 : _a2.slice(1, 3);
            })) {
              attr = attr.toLowerCase();
              switch (attr) {
                case "":
                  break;
                case "given":
                  name.firstName = value;
                  break;
                case "family":
                  name.lastName = value;
                  break;
                case "given-i":
                  name.initial = value;
                  break;
                case "useprefix":
                case "juniorcomma":
                  name[attr] = value.toLowerCase() === "true";
                  break;
                default:
                  name[attr] = value;
                  break;
              }
            }
            return this.trimCreator(name);
          } else {
            const nameparts = this.split(ast, /^$/, /( )/).map((part) => this.stringify(part, { mode: "creatorlist" })).filter((n) => n);
            if (nameparts.length === 1)
              return this.trimCreator({ lastName: nameparts[0] });
            const prefix = nameparts.findIndex((n) => n.match(/^[a-z]/));
            const postfix = prefix <= 0 ? -1 : nameparts.findIndex((n, i) => i > prefix && !n.match(/^[a-z]/));
            if (postfix === -1) {
              const lastName = nameparts.pop();
              return this.trimCreator({ lastName, firstName: nameparts.join(" ") });
            }
            return this.trimCreator({
              firstName: nameparts.slice(0, prefix).join(" "),
              prefix: nameparts.slice(prefix, postfix).join(" "),
              lastName: nameparts.slice(postfix).join(" ")
            });
          }
        }
        ligature(nodes) {
          if (latexMode(nodes[0]) !== "text")
            return null;
          const max = 3;
          const slice = nodes.slice(0, max);
          const type = slice.map((n) => n.type === "string" ? "s" : " ").join("");
          if (type[0] !== "s")
            return null;
          const content = slice.map((n) => n.type === "string" ? n.content : "");
          let latex;
          while (content.length) {
            if (type.startsWith("s".repeat(content.length)) && (latex = latex2unicode(content.join(""), slice[0]))) {
              try {
                return { type: "string", content: latex, _renderInfo: {} };
              } finally {
                nodes.splice(0, content.length);
              }
            }
            content.pop();
          }
          return null;
        }
        wraparg(node, macro) {
          if (macro.content.match(/^(itshape|textsl|textit|emph|mkbibemph)$/))
            node._renderInfo.emph = true;
          if (macro.content.match(/^(textbf|mkbibbold|bfseries)$/))
            node._renderInfo.bold = true;
          if (macro.content.match(/^(textsc)$/))
            node._renderInfo.smallCaps = true;
          if (macro.content.match(/^(texttt)$/))
            node._renderInfo.code = true;
          return { type: "argument", content: [node], openMark: "", closeMark: "", _renderInfo: { mode: node._renderInfo.mode } };
        }
        argtogroup(node) {
          if (node.content.length === 1 && node.content[0].type === "group")
            return node.content[0];
          return { type: "group", content: node.content };
        }
        argument(nodes, macro) {
          if (!nodes.length)
            return null;
          if (nodes[0].type === "whitespace")
            nodes.shift();
          if (!nodes.length)
            return null;
          if (nodes[0].type === "string") {
            const char = nodes[0].content[0];
            nodes[0].content = nodes[0].content.substr(1);
            const arg = Object.assign(Object.assign({}, nodes[0]), { content: char });
            if (!nodes[0].content)
              nodes.shift();
            return this.wraparg(arg, macro);
          }
          return this.wraparg(nodes.shift(), macro);
        }
        unsupported(node) {
          var _a2;
          const tex = (0, unified_latex_util_print_raw_1.printRaw)(node);
          if (this.fallback)
            return (_a2 = this.fallback(node, tex, this.current)) !== null && _a2 !== void 0 ? _a2 : "";
          let id;
          switch (node.type) {
            case "macro":
              id = `${node.type}.${node.content}`;
              if (!this.unhandled.has(id)) {
                this.unhandled.add(id);
                this.bib.errors.push({ error: `unhandled ${node.type} ${(0, unified_latex_util_print_raw_1.printRaw)(node)}`, input: (0, unified_latex_util_print_raw_1.printRaw)(node) });
              }
              break;
            case "environment":
              id = `${node.type}.${node.env}`;
              if (!this.unhandled.has(id)) {
                this.unhandled.add(id);
                this.bib.errors.push({ error: `unhandled ${node.type} ${node.env} (${(0, unified_latex_util_print_raw_1.printRaw)(node)})`, input: (0, unified_latex_util_print_raw_1.printRaw)(node) });
              }
              break;
            default:
              this.bib.errors.push({ error: `unhandled ${node.type} (${(0, unified_latex_util_print_raw_1.printRaw)(node)})`, input: (0, unified_latex_util_print_raw_1.printRaw)(node) });
              break;
          }
          return tex;
        }
        wrap(text, tag, wrap = true) {
          if (!text || !wrap)
            return text || "";
          return `${tag}${text}/${tag}`;
        }
        registercommand(node) {
          const types = (nodes) => nodes.map((n) => n.type).join(".");
          const group = (arg, kind) => {
            if (!arg)
              throw new Error(`missing ${kind} for ${(0, unified_latex_util_print_raw_1.printRaw)(node)} @ ${JSON.stringify(node.position)}`);
            if (types(arg.content) !== "group")
              throw new Error(`Malformed ${kind} for ${(0, unified_latex_util_print_raw_1.printRaw)(node)} @ ${JSON.stringify(node.position)}`);
            return arg.content[0].content;
          };
          if (!node.args)
            throw new Error(`No arguments for ${(0, unified_latex_util_print_raw_1.printRaw)(node)} @ ${JSON.stringify(node.position)}`);
          const namearg = group(node.args[0], "name");
          if (types(namearg) !== "macro")
            throw new Error(`Unexpected name for ${(0, unified_latex_util_print_raw_1.printRaw)(node)} @ ${JSON.stringify(node.position)}`);
          this.newcommands[namearg[0].content] = node.args[1];
          return "";
        }
        subp(text, macro) {
          let subp = "";
          for (let char of text) {
            char = unicode2latex_1.latex2unicode[`${macro}{${char}}`];
            if (char) {
              subp += char;
            } else {
              const tag = { _: "sub", "^": "sup" }[macro];
              return `${tag}${text}/${tag}`;
            }
          }
          return subp;
        }
        macro(node, context) {
          var _a2, _b, _c, _d, _e, _f, _g;
          const text = latex2unicode((0, unified_latex_util_print_raw_1.printRaw)(node), node);
          if (text)
            return text;
          let url;
          let label;
          let arg;
          let resolved;
          switch (node.content) {
            case "newcommand":
            case "ProvideTextCommandDefault":
              return this.registercommand(node);
            case "raise":
            case "accent":
            case "def":
            case "hss":
            case "ifmmode":
            case "makeatletter":
            case "makeatother":
            case "scriptscriptstyle":
            case "setbox":
            case "dimen":
            case "advance":
              return "";
            case "vphantom":
            case "noopsort":
            case "left":
            case "right":
            case "ensuremath":
            case "wd":
            case "ht":
              return "";
            case "path":
              return "";
            case "hspace":
            case "hskip":
              if (node.args && node.args.length) {
                if ((0, unified_latex_util_print_raw_1.printRaw)(node.args).match(/^[{]?0[a-z]*$/))
                  return "";
                return " ";
              }
              return "";
            case "overline":
            case "bar":
              return node.args.map((a) => this.stringify(a, context)).join("").replace(/[a-z0-9]/ig, (m) => `${m}\u0305`);
            case "textup":
            case "textsc":
            case "textrm":
            case "texttt":
            case "mathrm":
            case "mbox":
            case "hbox":
            case "rlap":
              return node.args.map((n) => this.stringify(n, context)).join("");
            case "href":
            case "url":
              if (node.args) {
                url = node.args[0];
                label = node.args[node.content === "url" ? 0 : 1];
              }
              return `<a href="${this.stringify(url, context)}">${this.stringify(label, context)}</a>`;
            case "relax":
            case "aftergroup":
            case "ignorespaces":
            case "em":
            case "it":
            case "tt":
            case "sl":
              return "";
            case "rm":
            case "sc":
              return "";
            case "textbf":
            case "mkbibbold":
            case "textit":
            case "emph":
            case "mkbibemph":
              return this.stringify((_a2 = node.args) === null || _a2 === void 0 ? void 0 : _a2[0], context);
            case "textsuperscript":
              return this.subp(this.stringify((_b = node.args) === null || _b === void 0 ? void 0 : _b[0], context), "^");
            case "textsubscript":
              return this.subp(this.stringify((_c = node.args) === null || _c === void 0 ? void 0 : _c[0], context), "_");
            case "_":
            case "^":
              switch (latexMode(node)) {
                case "math":
                  return this.subp(this.stringify((_d = node.args) === null || _d === void 0 ? void 0 : _d[0], context), node.content);
                default:
                  return node.content;
              }
            case "LaTeX":
              return this.wrap(`L${this.subp("A", "^")}T${this.subp("E", "_")}X`, "ncx");
            case "enquote":
            case "mkbibquote":
              return this.wrap(this.stringify((_e = node.args) === null || _e === void 0 ? void 0 : _e[0], context), "enquote");
            case "\\":
              return context.mode === "richtext" ? open.br : " ";
            case "par":
              return context.mode === "richtext" ? open.p : " ";
            case "item":
              return context.mode === "richtext" ? open.li : " ";
            case "section":
            case "subsection":
            case "subsubsection":
            case "subsubsubsection":
              return this.wrap(this.stringify((_f = node.args) === null || _f === void 0 ? void 0 : _f[0], context), `h${node.content.split("sub").length}`);
            case "frac":
              arg = node.args.map((a) => this.stringify(a, context));
              if (arg.length === 2 && (resolved = unicode2latex_1.latex2unicode[`\\frac${arg.map((a) => `{${a}}`).join("")}`]))
                return resolved;
              return arg.map((part, i) => this.subp(part, i ? "_" : "^")).join("\u2044");
            case "chsf":
            case "bibstring":
            case "cite":
            case "textcite":
            case "citeauthor":
              return this.wrap(this.stringify((_g = node.args) === null || _g === void 0 ? void 0 : _g[0], context), "ncx", context.mode === "title");
            default:
              if (this.newcommands[node.content])
                return this.stringify(this.newcommands[node.content], context);
              return this.unsupported(node);
          }
        }
        what(node) {
          var _a2;
          if (!node)
            return "";
          switch (node.type) {
            case "macro":
              return `macro:${(_a2 = node._renderInfo.mode) !== null && _a2 !== void 0 ? _a2 : "text"}:${node.content}`;
            case "environment":
              return `env:${node.env}`;
            default:
              return node.type;
          }
        }
        environment(node, context) {
          while (node.content.length && this.what(node.content[0]).match(/^parbreak|whitespace|macro:text:par$/))
            node.content.shift();
          while (node.content.length && this.what(node.content[node.content.length - 1]).match(/^parbreak|whitespace|macro:text:par$/))
            node.content.pop();
          switch (node.env) {
            case "quotation":
              return this.wrap(node.content.map((n) => this.stringify(n, context)).join(""), "blockquote", context.mode === "richtext");
            case "itemize":
              return this.wrap(node.content.map((n) => this.stringify(n, context)).join(""), "ul", context.mode === "richtext");
            case "em":
              return this.wrap(node.content.map((n) => this.stringify(n, context)).join(""), "i", context.mode === "richtext");
            default:
              return this.unsupported(node);
          }
        }
        stringify(node, context) {
          let content = this.stringifyContent(node, context);
          if (content && node._renderInfo) {
            if (node._renderInfo.emph)
              content = `${open.i}${content}${close.i}`;
            if (node._renderInfo.bold)
              content = `${open.b}${content}${close.b}`;
            if (node._renderInfo.smallCaps)
              content = `${open.sc}${content}${close.sc}`;
            if (node._renderInfo.code)
              content = `${open.code}${content}${close.code}`;
            if (this.english && node._renderInfo.protectCase)
              content = `${open.nc}${content}${close.nc}`;
          }
          return content;
        }
        stringifyContent(node, context) {
          if (!node)
            return "";
          switch (node.type) {
            case "root":
            case "argument":
            case "group":
            case "inlinemath":
              return node.content.map((n) => this.stringify(n, context)).join("");
            case "string":
            case "verbatim":
              return node.content;
            case "macro":
              return this.macro(node, context);
            case "parbreak":
              return context.mode === "richtext" ? open.p : " ";
            case "whitespace":
              return node._renderInfo.mode === "math" ? "" : " ";
            case "comment":
              return "";
            case "environment":
              return this.environment(node, context);
            case "verb":
              return node.content;
            default:
              return this.unsupported(node);
          }
        }
        protect(node) {
          if (node.type === "inlinemath")
            return true;
          if (node.type !== "group")
            return false;
          if (!node.content.length)
            return false;
          return node.content[0].type !== "macro";
        }
        mode(field) {
          if (this.options.verbatimFields && this.options.verbatimFields.find((name) => typeof name === "string" ? name === field : field.match(name)))
            return "verbatim";
          let mode = "literal";
          for (const [selected, fields] of Object.entries(this.fieldMode)) {
            if (fields.find((match) => typeof match === "string" ? field === match : field.match(match)))
              mode = selected;
          }
          return mode;
        }
        restoreMarkup(s) {
          if (!s.includes(""))
            return s;
          const restored = [s.replace(/\x0E\/?ncx\x0F/ig, "")];
          while (restored[0] !== restored[1]) {
            restored.unshift(restored[0].replace(collapsable, "$2"));
          }
          return restored[0].replace(/(\x0Ep\x0F\s*){2,}/ig, "p").replace(/\s*(\x0E\/p\x0F){2,}/ig, "/p").replace(/\x0Eenquote\x0F/ig, "\u201C").replace(/\x0E\/enquote\x0F/ig, "\u201D").replace(/\x0Esc\x0F/ig, '<span style="font-variant:small-caps;">').replace(/\x0E\/sc\x0F/ig, "</span>").replace(/\x0Enc\x0F/ig, '<span class="nocase">').replace(/\x0E\/nc\x0F/ig, "</span>").replace(/\x0E/ig, "<").replace(/\x0F/ig, ">");
        }
        stringField(field, value, mode, guessSC) {
          if (field === "crossref")
            return value;
          if (FieldAction.parseInt.includes(field) && value.trim().match(/^-?\d+$/))
            return `${parseInt(value)}`;
          if (this.english && mode === "title") {
            value = (0, sentence_case_2.toSentenceCase)(value, {
              preserveQuoted: this.options.sentenceCase.preserveQuoted,
              subSentenceCapitalization: this.options.sentenceCase.subSentence,
              markup: /\x0E\/?([a-z]+)\x0F/ig,
              nocase: /\x0E(ncx?)\x0F.*?\x0E\/\1\x0F/ig,
              guess: guessSC
            });
            let cancel = (_match, stripped) => stripped;
            switch (this.options.caseProtection) {
              case "strict":
                cancel = (match, _stripped) => match;
                break;
              case "as-needed":
                cancel = (match, stripped) => {
                  const words = (0, tokenizer_1.tokenize)(stripped, /\x0E\/?([a-z]+)\x0F/ig);
                  return words.find((w) => w.shape.match(/^(?!.*X).*x.*$/)) ? match : this.wrap(stripped, "ncx");
                };
                break;
            }
            return value.replace(/\x0Enc\x0F(.*?)\x0E\/nc\x0F/ig, cancel);
          }
          return value;
        }
        field(entry, field, value) {
          const mode = entry.mode[field] = this.mode(field);
          const caseProtection = {
            present: false,
            intuitive: 0
            // a lot of people don't realise `some text \textit{in italics}` will protect 'in italics'
          };
          const ast = unified_latex_util_pegjs_1.LatexPegParser.parse(value);
          if (this.options.removeOuterBraces.includes(field) && ast.content.length === 1 && ast.content[0].type === "group") {
            ast.content = ast.content[0].content;
          }
          if (mode === "verbatim") {
            entry.fields[field] = (0, unified_latex_util_print_raw_1.printRaw)(ast);
            return;
          }
          if (this.options.raw) {
            switch (mode) {
              case "creatorlist":
                entry.fields[field] = this.split(ast, /^and$/i, /(^& | & | &$)/).map((cr) => ({ name: (0, unified_latex_util_print_raw_1.printRaw)(cr) })).filter((cr) => cr.name);
                return;
              case "literallist":
                entry.fields[field] = this.split(ast, /^and$/i, /(^& | & | &$)/).map((elt) => (0, unified_latex_util_print_raw_1.printRaw)(elt));
                return;
              default:
                entry.fields[field] = (0, unified_latex_util_print_raw_1.printRaw)(ast);
                return;
            }
          }
          if (this.english && mode === "title") {
            let root = [...ast.content];
            while (root.length) {
              const node = root.shift();
              if (this.protect(node))
                node._renderInfo = { root: true };
              if (node.type === "environment")
                root = [...root, ...node.content];
            }
          }
          (0, unified_latex_util_visit_1.visit)(ast, (node, info) => {
            if (!node._renderInfo)
              node._renderInfo = {};
            node._renderInfo.mode = info.context.inMathMode ? "math" : "text";
            if (mode === "title" && node.type === "inlinemath" && !info.parents.find((p) => p._renderInfo.protectCase))
              node._renderInfo.protectCase = true;
            if (!info.context.inMathMode) {
              if (mode === "title" && node._renderInfo.root && (node.type !== "group" || node.content[0].type !== "macro")) {
                node._renderInfo.protectCase = true;
                if (node.type === "group") {
                  caseProtection.present = true;
                  caseProtection.intuitive += 1;
                }
              }
              if (node.type === "macro" && typeof node.escapeToken !== "string")
                node.escapeToken = "\\";
              if (node.type === "environment" && node.env === "em")
                node._renderInfo.emph = true;
            }
          });
          (0, unified_latex_util_visit_1.visit)(ast, (nodes, info) => {
            var _a2;
            let node;
            const compacted = [];
            let inif = 0;
            while (nodes.length) {
              if (node = this.ligature(nodes)) {
                compacted.push(node);
                continue;
              }
              node = nodes.shift();
              if (node.type === "macro" && node.content === "ifdefined") {
                inif += 1;
                continue;
              } else if (node.type === "macro" && node.content === "else") {
                continue;
              } else if (node.type === "macro" && node.content === "fi") {
                inif = Math.max(inif - 1, 0);
                continue;
              } else if (inif) {
                continue;
              }
              const nargs = node.type === "macro" ? narguments[node.content] || narguments[`${info.context.inMathMode ? "math" : "text"}	${node.content}`] : 0;
              if (node.type === "macro" && nargs) {
                node.args = Array(nargs).fill(void 0).map((_i) => this.argument(nodes, node)).filter((arg) => arg);
                if (node.content.match(/^(url|href)$/) && node.args.length) {
                  let url = node.args[0].content;
                  if (url.length === 1 && url[0].type === "group")
                    url = url[0].content;
                  node.args[0] = this.wraparg({ type: "string", content: (0, unified_latex_util_print_raw_1.printRaw)(url), _renderInfo: { mode: url[0]._renderInfo.mode } }, node);
                }
                caseProtection.intuitive -= node.args.filter((arg) => arg.content[0].type === "group" && arg.content[0]._renderInfo.protectCase).length;
              } else if (node.type === "macro" && node.content.match(/^[a-z]+$/i) && ((_a2 = nodes[0]) === null || _a2 === void 0 ? void 0 : _a2.type) === "whitespace") {
                nodes.shift();
              }
              compacted.push(node);
            }
            if (!info.context.inMathMode) {
              for (const [macro, markup] of Object.entries({ em: "emph", it: "emph", sl: "emph", bf: "bold", sc: "smallCaps", tt: "code" })) {
                if (info.parents.find((p) => p._renderInfo[markup]))
                  continue;
                compacted.forEach((markup_node, i) => {
                  if (markup_node.type === "macro" && markup_node.content === macro) {
                    compacted.slice(i + 1).forEach((n) => n._renderInfo[markup] = true);
                  }
                });
              }
            }
            nodes.push(...compacted);
          }, { test: Array.isArray, includeArrays: true });
          (0, unified_latex_util_replace_1.replaceNode)(ast, (node, _info) => {
            if (node.type !== "macro")
              return;
            if (node.escapeToken && unicode2latex_1.combining.tounicode[node.content]) {
              let arg;
              if (!node.args || node.args.length === 0 || node.args[0].content.length === 0) {
                arg = { type: "string", content: " ", _renderInfo: {} };
              } else if (node.args.length !== 1 || node.args[0].content.length !== 1) {
                return;
              } else {
                arg = node.args[0].content[0];
              }
              if (arg.type === "group") {
                switch (arg.content.length) {
                  case 0:
                    arg = { type: "string", content: " ", _renderInfo: {} };
                    break;
                  case 1:
                    arg = arg.content[0];
                    break;
                  default:
                    return;
                }
              }
              switch (arg.type) {
                case "verbatim":
                case "string":
                  return { type: "string", content: `${arg.content}${unicode2latex_1.combining.tounicode[node.content]}`, _renderInfo: {} };
                default:
                  return;
              }
            }
            let latex = `${node.escapeToken}${node.content}`;
            latex += (node.args || []).map((arg) => (0, unified_latex_util_print_raw_1.printRaw)(this.argtogroup(arg))).join("");
            if (latex in unicode2latex_1.latex2unicode)
              return { type: "string", content: latex2unicode(latex, node), _renderInfo: {} };
          });
          switch (mode) {
            case "creatorlist":
              entry.fields[field] = this.split(ast, /^and$/i, /(^& | & | &$)/).map((cr) => this.parseCreator(cr)).filter((cr) => Object.keys(cr).length);
              break;
            case "literallist":
              entry.fields[field] = this.split(ast, /^and$/i, /(^& | & | &$)/).map((elt) => this.stringify(elt, { mode: "literal" }).trim());
              break;
            default:
              entry.fields[field] = this.stringField(
                field,
                this.stringify(ast, { mode }),
                mode,
                this.options.sentenceCase.guess
                // && (!caseProtection.present || caseProtection.intuitive > 0)
              );
              break;
          }
          entry.fields[field] = JSON.parse(JSON.stringify(entry.fields[field], (k, v) => typeof v === "string" ? this.restoreMarkup(v) : v));
        }
        reset(options2 = {}) {
          var _a2;
          this.options = (0, merge_1.merge)(options2, {
            caseProtection: "as-needed",
            applyCrossRef: (_a2 = options2.applyCrossRef) !== null && _a2 !== void 0 ? _a2 : true,
            fieldMode: {},
            english: exports.English,
            sentenceCase: {
              guess: true,
              preserveQuoted: true
            }
          });
          if (this.options.caseProtection === true)
            this.options.caseProtection = "as-needed";
          if (this.options.verbatimFields)
            this.options.verbatimFields = this.options.verbatimFields.map((f) => typeof f === "string" ? f.toLowerCase() : new RegExp(f.source, f.flags + (f.flags.includes("i") ? "" : "i")));
          if (typeof this.options.english === "boolean")
            this.options.english = this.options.english ? exports.English : [];
          this.options.english = this.options.english.map((langid) => langid.toLowerCase());
          this.fieldMode = Object.entries(exports.FieldMode).reduce((acc, [mode, test]) => {
            const strings = test.filter((fieldname_or_regex) => typeof fieldname_or_regex === "string" && !this.options.fieldMode[fieldname_or_regex]);
            const regexes = test.filter((fieldname_or_regex) => typeof fieldname_or_regex !== "string");
            acc[mode] = [...strings, ...regexes];
            return acc;
          }, {});
          for (const [field, mode] of Object.entries(this.options.fieldMode)) {
            this.fieldMode[mode].unshift(field);
          }
          if (!this.options.removeOuterBraces) {
            this.options.removeOuterBraces = [
              ...FieldAction.removeOuterBraces,
              ...this.fieldMode.title,
              ...this.fieldMode.verbatim
            ].filter((field) => typeof field === "string");
          }
          this.fallback = options2.unsupported === "ignore" ? (_node, _tex) => "" : options2.unsupported;
          this.bib = {
            errors: [],
            entries: [],
            comments: [],
            strings: {},
            preamble: [],
            jabref: null
          };
        }
        reparse(verbatim) {
          let langid = (verbatim.fields.langid || verbatim.fields.hyphenation || "").toLowerCase();
          if (!langid && this.options.languageAsLangid && verbatim.fields.language)
            langid = verbatim.fields.language.toLowerCase();
          this.english = this.options.english.includes(langid);
          const entry = this.current = {
            type: verbatim.type,
            key: verbatim.key,
            fields: {},
            mode: {},
            input: verbatim.input
          };
          let keywords = [];
          try {
            for (let [field, value] of Object.entries(verbatim.fields)) {
              if (!value.trim())
                continue;
              if (field.match(/^keywords([+]duplicate-\d+)?$/))
                field = "keywords";
              this.field(entry, field, value);
              if (field === "keywords") {
                keywords = [...keywords, ...entry.fields.keywords.split(/\s*[,;]\s*/)].map((k) => k.trim()).filter((k) => k);
                delete entry.fields.keywords;
              }
              if (!this.options.raw && typeof entry.fields[field] === "string") {
                entry.fields[field] = entry.fields[field].trim();
                if (field === "month")
                  entry.fields[field] = Month[entry.fields[field].toLowerCase()] || entry.fields[field];
              }
            }
            if (keywords.length) {
              entry.fields.keywords = [...new Set(keywords)].sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
              entry.mode.keywords = "verbatimlist";
            }
            this.bib.entries.push(entry);
          } catch (err) {
            this.bib.errors.push({ error: `${err.message}
${entry.input}`, input: entry.input });
          }
        }
        content(tex) {
          const entry = { key: "", type: "", fields: {}, mode: {}, input: tex };
          const english = this.english;
          this.english = false;
          this.field(entry, "tex", tex);
          this.english = english;
          return entry.fields.tex;
        }
        prep(base) {
          for (const preamble of base.preambles) {
            try {
              this.content(preamble);
            } catch (err) {
            }
          }
          for (const [k, v] of Object.entries(base.strings)) {
            this.bib.strings[k] = this.content(v);
          }
        }
        finalize(base) {
          var _a2;
          if (this.options.applyCrossRef) {
            const entries = {};
            for (const entry of this.bib.entries) {
              if (entry.key)
                entries[entry.key.toUpperCase()] = entry;
            }
            const order = [];
            for (const entry of this.bib.entries) {
              if (!entry.key || typeof entry.fields.crossref !== "string")
                continue;
              const crossref = entry.fields.crossref.toUpperCase();
              if (!entries[crossref])
                continue;
              const key = entry.key.toUpperCase();
              if (!order.includes(crossref))
                order.unshift(crossref);
              if (!order.includes(key))
                order.push(key);
            }
            const add = (obj, kind, field) => {
              obj[kind] = [.../* @__PURE__ */ new Set([...obj[kind], field])].sort();
            };
            for (const key of order) {
              const child = entries[key.toUpperCase()];
              const parent = entries[(_a2 = child.fields.crossref) === null || _a2 === void 0 ? void 0 : _a2.toUpperCase()];
              if (!parent)
                continue;
              child.crossref = child.crossref || { donated: [], inherited: [] };
              parent.crossref = parent.crossref || { donated: [], inherited: [] };
              for (const mappings of [crossref_json_1.default[child.type], crossref_json_1.default["*"]].filter((m) => m)) {
                for (const mapping2 of [mappings[parent.type], mappings["*"]].filter((m) => m)) {
                  for (const [childfield, parentfield] of Object.entries(mapping2)) {
                    if (!child.fields[childfield] && parent.fields[parentfield]) {
                      child.fields[childfield] = parent.fields[parentfield];
                      add(child.crossref, "inherited", childfield);
                      add(parent.crossref, "donated", parentfield);
                    }
                  }
                  for (const field of fields_json_1.default[child.type] || []) {
                    if (FieldAction.noCrossRef.includes(field))
                      continue;
                    if (!child.fields[field] && parent.fields[field]) {
                      child.fields[field] = parent.fields[field];
                      add(child.crossref, "inherited", field);
                      add(parent.crossref, "donated", field);
                    }
                  }
                }
              }
            }
            for (const entry of this.bib.entries) {
              if (entry.crossref && !entry.crossref.donated.length && !entry.crossref.inherited.length)
                delete entry.crossref;
            }
          }
          const { comments, jabref } = JabRef.parse(base.comments);
          this.bib.comments = comments;
          this.bib.jabref = jabref;
          this.bib.preamble = base.preambles;
          this.bib.errors = [...base.errors, ...this.bib.errors];
        }
        parse(input, options2 = {}) {
          this.reset(options2);
          const base = bibtex.parse(input, { strings: options2.strings });
          this.prep(base);
          for (const entry of base.entries) {
            this.reparse(entry);
          }
          this.finalize(base);
          return this.bib;
        }
        async parseAsync(input, options2 = {}) {
          this.reset(options2);
          const base = await bibtex.promises.parse(input, { strings: options2.strings });
          this.prep(base);
          let n = 1;
          for (const entry of base.entries) {
            this.reparse(entry);
            if (n++ % 1e3 === 0)
              await (0, yield_1.playnice)();
          }
          this.finalize(base);
          return this.bib;
        }
      };
      function parse(input, options2 = {}) {
        const parser = new BibTeXParser();
        return parser.parse(input, options2);
      }
      exports.parse = parse;
      async function parseAsync(input, options2 = {}) {
        const parser = new BibTeXParser();
        return await parser.parseAsync(input, options2);
      }
      exports.parseAsync = parseAsync;
    }
  });

  // node_modules/citeproc/citeproc_commonjs.js
  var require_citeproc_commonjs = __commonJS({
    "node_modules/citeproc/citeproc_commonjs.js"(exports, module) {
      var CSL3 = {
        PROCESSOR_VERSION: "1.4.61",
        error: function(str) {
          if ("undefined" === typeof Error) {
            throw new Error("citeproc-js error: " + str);
          } else {
            throw "citeproc-js error: " + str;
          }
        },
        debug: function(str) {
          if ("undefined" === typeof console) {
            dump("CSL: " + str + "\n");
          } else {
            console.log("citeproc-js warning: " + str);
          }
        },
        toLocaleUpperCase(str) {
          var arr = this.tmp.lang_array;
          try {
            str = str.toLocaleUpperCase(arr);
          } catch (e) {
            str = str.toUpperCase();
          }
          return str;
        },
        toLocaleLowerCase(str) {
          var arr = this.tmp.lang_array;
          try {
            str = str.toLocaleLowerCase(arr);
          } catch (e) {
            str = str.toLowerCase();
          }
          return str;
        },
        LOCATOR_LABELS_REGEXP: new RegExp("^((vrs|sv|subpara|op|subch|add|amend|annot|app|art|bibliog|bk|ch|cl|col|cmt|dec|dept|div|ex|fig|fld|fol|n|hypo|illus|intro|l|no|p|pp|para|pt|pmbl|princ|pub|r|rn|sched|sec|ser|subdiv|subsec|supp|tbl|tit|vol)\\.)\\s+(.*)"),
        STATUTE_SUBDIV_PLAIN_REGEX: /(?:(?:^| )(?:vrs|sv|subpara|op|subch|add|amend|annot|app|art|bibliog|bk|ch|cl|col|cmt|dec|dept|div|ex|fig|fld|fol|n|hypo|illus|intro|l|no|p|pp|para|pt|pmbl|princ|pub|r|rn|sched|sec|ser|subdiv|subsec|supp|tbl|tit|vol)\. *)/,
        STATUTE_SUBDIV_PLAIN_REGEX_FRONT: /(?:^\s*[.,;]*\s*(?:vrs|sv|subpara|op|subch|add|amend|annot|app|art|bibliog|bk|ch|cl|col|cmt|dec|dept|div|ex|fig|fld|fol|n|hypo|illus|intro|l|no|p|pp|para|pt|pmbl|princ|pub|r|rn|sched|sec|ser|subdiv|subsec|supp|tbl|tit|vol)\. *)/,
        STATUTE_SUBDIV_STRINGS: {
          "vrs.": "verse",
          "sv.": "sub-verbo",
          "subpara.": "subparagraph",
          "op.": "opus",
          "subch.": "subchapter",
          "add.": "addendum",
          "amend.": "amendment",
          "annot.": "annotation",
          "app.": "appendix",
          "art.": "article",
          "bibliog.": "bibliography",
          "bk.": "book",
          "ch.": "chapter",
          "cl.": "clause",
          "col.": "column",
          "cmt.": "comment",
          "dec.": "decision",
          "dept.": "department",
          "ex.": "example",
          "fig.": "figure",
          "fld.": "field",
          "fol.": "folio",
          "n.": "note",
          "hypo.": "hypothetical",
          "illus.": "illustration",
          "intro.": "introduction",
          "l.": "line",
          "no.": "issue",
          "p.": "page",
          "pp.": "page",
          "para.": "paragraph",
          "pt.": "part",
          "pmbl.": "preamble",
          "princ.": "principle",
          "pub.": "publication",
          "r.": "rule",
          "rn.": "randnummer",
          "sched.": "schedule",
          "sec.": "section",
          "ser.": "series,",
          "subdiv.": "subdivision",
          "subsec.": "subsection",
          "supp.": "supplement",
          "tbl.": "table",
          "tit.": "title",
          "vol.": "volume"
        },
        STATUTE_SUBDIV_STRINGS_REVERSE: {
          "verse": "vrs.",
          "sub-verbo": "sv.",
          "sub verbo": "sv.",
          "subparagraph": "subpara.",
          "opus": "op.",
          "subchapter": "subch.",
          "addendum": "add.",
          "amendment": "amend.",
          "annotation": "annot.",
          "appendix": "app.",
          "article": "art.",
          "bibliography": "bibliog.",
          "book": "bk.",
          "chapter": "ch.",
          "clause": "cl.",
          "column": "col.",
          "comment": "cmt.",
          "decision": "dec.",
          "department": "dept.",
          "example": "ex.",
          "figure": "fig.",
          "field": "fld.",
          "folio": "fol.",
          "note": "n.",
          "hypothetical": "hypo.",
          "illustration": "illus.",
          "introduction": "intro.",
          "line": "l.",
          "issue": "no.",
          "page": "p.",
          "paragraph": "para.",
          "part": "pt.",
          "preamble": "pmbl.",
          "principle": "princ.",
          "publication": "pub.",
          "rule": "r.",
          "randnummer": "rn.",
          "schedule": "sched.",
          "section": "sec.",
          "series,": "ser.",
          "subdivision": "subdiv.",
          "subsection": "subsec.",
          "supplement": "supp.",
          "table": "tbl.",
          "title": "tit.",
          "volume": "vol."
        },
        LOCATOR_LABELS_MAP: {
          "vrs": "verse",
          "sv": "sub-verbo",
          "subpara": "subparagraph",
          "op": "opus",
          "subch": "subchapter",
          "add": "addendum",
          "amend": "amendment",
          "annot": "annotation",
          "app": "appendix",
          "art": "article",
          "bibliog": "bibliography",
          "bk": "book",
          "ch": "chapter",
          "cl": "clause",
          "col": "column",
          "cmt": "comment",
          "dec": "decision",
          "dept": "department",
          "ex": "example",
          "fig": "figure",
          "fld": "field",
          "fol": "folio",
          "n": "note",
          "hypo": "hypothetical",
          "illus": "illustration",
          "intro": "introduction",
          "l": "line",
          "no": "issue",
          "p": "page",
          "pp": "page",
          "para": "paragraph",
          "pt": "part",
          "pmbl": "preamble",
          "princ": "principle",
          "pub": "publication",
          "r": "rule",
          "rn": "randnummer",
          "sched": "schedule",
          "sec": "section",
          "ser": "series,",
          "subdiv": "subdivision",
          "subsec": "subsection",
          "supp": "supplement",
          "tbl": "table",
          "tit": "title",
          "vol": "volume"
        },
        MODULE_MACROS: {
          "juris-pretitle": true,
          "juris-title": true,
          "juris-pretitle-short": true,
          "juris-title-short": true,
          "juris-main": true,
          "juris-main-short": true,
          "juris-tail": true,
          "juris-tail-short": true,
          "juris-locator": true
        },
        MODULE_TYPES: {
          "legal_case": true,
          "legislation": true,
          "bill": true,
          "hearing": true,
          "gazette": true,
          "report": true,
          "regulation": true,
          "standard": true,
          "patent": true,
          "locator": true
        },
        checkNestedBrace: function(state) {
          if (state.opt.xclass === "note") {
            this.depth = 0;
            this.update = function(str) {
              var str = str ? str : "";
              var lst = str.split(/([\(\)])/);
              for (var i = 1, ilen = lst.length; i < ilen; i += 2) {
                if (lst[i] === "(") {
                  if (1 === this.depth % 2) {
                    lst[i] = "[";
                  }
                  this.depth += 1;
                } else if (lst[i] === ")") {
                  if (0 === this.depth % 2) {
                    lst[i] = "]";
                  }
                  this.depth -= 1;
                }
              }
              var ret = lst.join("");
              return ret;
            };
          } else {
            this.update = function(str) {
              return str;
            };
          }
        },
        MULTI_FIELDS: ["event", "publisher", "publisher-place", "event-place", "title", "container-title", "collection-title", "authority", "genre", "title-short", "medium", "country", "jurisdiction", "archive", "archive-place"],
        LangPrefsMap: {
          "title": "titles",
          "title-short": "titles",
          "event": "titles",
          "genre": "titles",
          "medium": "titles",
          "container-title": "journals",
          "collection-title": "titles",
          "archive": "journals",
          "publisher": "publishers",
          "authority": "publishers",
          "publisher-place": "places",
          "event-place": "places",
          "archive-place": "places",
          "jurisdiction": "places",
          "number": "places",
          "edition": "places",
          "issue": "places",
          "volume": "places"
        },
        AbbreviationSegments: function() {
          this["container-title"] = {};
          this["collection-title"] = {};
          this["institution-entire"] = {};
          this["institution-part"] = {};
          this.nickname = {};
          this.number = {};
          this.title = {};
          this.place = {};
          this.hereinafter = {};
          this.classic = {};
          this["container-phrase"] = {};
          this["title-phrase"] = {};
        },
        getAbbrevsDomain: function(state, country, lang) {
          var domain = null;
          if (state.opt.availableAbbrevDomains && country && country !== "default") {
            var globalDomainPreference = state.locale[state.opt.lang].opts["jurisdiction-preference"];
            var itemDomainPreference = null;
            if (state.locale[lang]) {
              itemDomainPreference = state.locale[lang].opts["jurisdiction-preference"];
            }
            if (itemDomainPreference) {
              for (var j = itemDomainPreference.length - 1; j > -1; j--) {
                if (state.opt.availableAbbrevDomains[country].indexOf(itemDomainPreference[j]) > -1) {
                  domain = itemDomainPreference[j];
                  break;
                }
              }
            }
            if (!domain && globalDomainPreference) {
              for (var j = globalDomainPreference.length - 1; j > -1; j--) {
                if (state.opt.availableAbbrevDomains[country].indexOf(globalDomainPreference[j]) > -1) {
                  domain = globalDomainPreference[j];
                  break;
                }
              }
            }
          }
          return domain;
        },
        FIELD_CATEGORY_REMAP: {
          "title": "title",
          "container-title": "container-title",
          "collection-title": "collection-title",
          "country": "place",
          "number": "number",
          "place": "place",
          "archive": "container-title",
          "title-short": "title",
          "genre": "title",
          "event": "title",
          "medium": "title",
          "archive-place": "place",
          "publisher-place": "place",
          "event-place": "place",
          "jurisdiction": "place",
          "language-name": "place",
          "language-name-original": "place",
          "call-number": "number",
          "chapter-number": "number",
          "collection-number": "number",
          "edition": "number",
          "page": "number",
          "issue": "number",
          "locator": "number",
          "locator-extra": "number",
          "number-of-pages": "number",
          "number-of-volumes": "number",
          "volume": "number",
          "citation-number": "number",
          "publisher": "institution-part"
        },
        parseLocator: function(item) {
          if (this.opt.development_extensions.locator_date_and_revision) {
            if (item.locator) {
              item.locator = "" + item.locator;
              var idx = item.locator.indexOf("|");
              if (idx > -1) {
                var raw_locator = item.locator;
                item.locator = raw_locator.slice(0, idx);
                raw_locator = raw_locator.slice(idx + 1);
                var m = raw_locator.match(/^([0-9]{4}-[0-9]{2}-[0-9]{2}).*/);
                if (m) {
                  item["locator-date"] = this.fun.dateparser.parseDateToObject(m[1]);
                  raw_locator = raw_locator.slice(m[1].length);
                }
                item["locator-extra"] = raw_locator.replace(/^\s+/, "").replace(/\s+$/, "");
              }
            }
          }
          if (item.locator) {
            item.locator = ("" + item.locator).replace(/\s+$/, "");
          }
          return item;
        },
        normalizeLocaleStr: function(str) {
          if (!str) {
            return;
          }
          var lst = str.split("-");
          lst[0] = lst[0].toLowerCase();
          if (lst[1]) {
            lst[1] = lst[1].toUpperCase();
          }
          return lst.join("-");
        },
        parseNoteFieldHacks: function(Item, validFieldsForType, allowDateOverride) {
          if ("string" !== typeof Item.note) {
            return;
          }
          var elems = [];
          var lines = Item.note.split("\n");
          for (var i = 0, ilen = lines.length; i < ilen; i++) {
            var line = lines[i];
            var elems = [];
            var m = line.match(CSL3.NOTE_FIELDS_REGEXP);
            if (m) {
              var splt = line.split(CSL3.NOTE_FIELDS_REGEXP);
              for (var j = 0, jlen = splt.length - 1; j < jlen; j++) {
                elems.push(splt[j]);
                elems.push(m[j]);
              }
              elems.push(splt[splt.length - 1]);
              for (var j = 1, jlen = elems.length; j < jlen; j += 2) {
                if (elems[j - 1].trim() && (i > 0 || j > 1) && !elems[j - 1].match(CSL3.NOTE_FIELD_REGEXP)) {
                  break;
                } else {
                  elems[j] = "\n" + elems[j].slice(2, -1).trim() + "\n";
                }
              }
              lines[i] = elems.join("");
            }
          }
          lines = lines.join("\n").split("\n");
          var offset = 0;
          var names = {};
          for (var i = 0, ilen = lines.length; i < ilen; i++) {
            var line = lines[i];
            var mm = line.match(CSL3.NOTE_FIELD_REGEXP);
            if (!line.trim()) {
              continue;
            } else if (!mm) {
              if (i === 0) {
                continue;
              } else {
                offset = i;
                break;
              }
            }
            var key = mm[1];
            var val = mm[2].replace(/^\s+/, "").replace(/\s+$/, "");
            if (key === "type") {
              Item.type = val;
              lines[i] = "";
            } else if (CSL3.DATE_VARIABLES.indexOf(key.replace(/^alt-/, "")) > -1) {
              if (!Item[key] || allowDateOverride) {
                Item[key] = CSL3.DateParser.parseDateToArray(val);
                if (!validFieldsForType || validFieldsForType[key] && this.isDateString(val)) {
                  lines[i] = "";
                }
              }
            } else if (!Item[key]) {
              if (CSL3.NAME_VARIABLES.indexOf(key.replace(/^alt-/, "")) > -1) {
                if (!names[key]) {
                  names[key] = [];
                }
                var lst = val.split(/\s*\|\|\s*/);
                if (lst.length === 1) {
                  names[key].push({ literal: lst[0] });
                } else if (lst.length === 2) {
                  var name = { family: lst[0], given: lst[1] };
                  CSL3.parseParticles(name);
                  names[key].push(name);
                }
              } else {
                Item[key] = val;
              }
              if (!validFieldsForType || validFieldsForType[key]) {
                lines[i] = "";
              }
            }
          }
          for (var key in names) {
            Item[key] = names[key];
          }
          if (validFieldsForType) {
            if (lines[offset].trim()) {
              lines[offset] = "\n" + lines[offset];
            }
            for (var i = offset - 1; i > -1; i--) {
              if (!lines[i].trim()) {
                lines = lines.slice(0, i).concat(lines.slice(i + 1));
              }
            }
          }
          Item.note = lines.join("\n").trim();
        },
        checkPrefixSpaceAppend: function(state, prefix) {
          if (!prefix) {
            prefix = "";
          }
          var sp = "";
          var test_prefix = prefix.replace(/<[^>]+>/g, "").replace(/["'\u201d\u2019\u00bb\u202f\u00a0 ]+$/g, "");
          var test_char = test_prefix.slice(-1);
          if (test_prefix.match(CSL3.ENDSWITH_ROMANESQUE_REGEXP)) {
            sp = " ";
          } else if (CSL3.TERMINAL_PUNCTUATION.slice(0, -1).indexOf(test_char) > -1) {
            sp = " ";
          } else if (test_char.match(/[\)\],0-9]/)) {
            sp = " ";
          }
          var prefix = (prefix + sp).replace(/\s+/g, " ");
          return prefix;
        },
        checkIgnorePredecessor: function(state, prefix) {
          var ignorePredecessor = false;
          var test_prefix = prefix.replace(/<[^>]+>/g, "").replace(/["'\u201d\u2019\u00bb\u202f\u00a0 ]+$/g, "");
          var test_char = test_prefix.slice(-1);
          if (CSL3.TERMINAL_PUNCTUATION.slice(0, -1).indexOf(test_char) > -1 && prefix.trim().indexOf(" ") > -1) {
            state.tmp.term_predecessor = false;
            return true;
          }
          return false;
        },
        checkSuffixSpacePrepend: function(state, suffix) {
          if (!suffix) {
            return "";
          }
          if (suffix.match(CSL3.STARTSWITH_ROMANESQUE_REGEXP) || ["[", "("].indexOf(suffix.slice(0, 1)) > -1) {
            suffix = " " + suffix;
          }
          return suffix;
        },
        GENDERS: ["masculine", "feminine"],
        ERROR_NO_RENDERED_FORM: 1,
        PREVIEW: "Just for laughs.",
        ASSUME_ALL_ITEMS_REGISTERED: 2,
        START: 0,
        END: 1,
        SINGLETON: 2,
        SEEN: 6,
        SUCCESSOR: 3,
        SUCCESSOR_OF_SUCCESSOR: 4,
        SUPPRESS: 5,
        SINGULAR: 0,
        PLURAL: 1,
        LITERAL: true,
        BEFORE: 1,
        AFTER: 2,
        DESCENDING: 1,
        ASCENDING: 2,
        PRIMARY: 1,
        SECONDARY: 2,
        POSITION_FIRST: 0,
        POSITION_SUBSEQUENT: 1,
        POSITION_IBID: 2,
        POSITION_IBID_WITH_LOCATOR: 3,
        POSITION_CONTAINER_SUBSEQUENT: 4,
        POSITION_MAP: {
          "0": 0,
          "4": 1,
          "1": 2,
          "2": 3,
          "3": 4
        },
        POSITION_TEST_VARS: ["position", "first-reference-note-number", "near-note"],
        AREAS: ["citation", "citation_sort", "bibliography", "bibliography_sort", "intext"],
        CITE_FIELDS: ["first-reference-note-number", "first-container-reference-note-number", "locator", "locator-extra"],
        SWAPPING_PUNCTUATION: [".", "!", "?", ":", ","],
        TERMINAL_PUNCTUATION: [":", ".", ";", "!", "?", " "],
        // update modes
        NONE: 0,
        NUMERIC: 1,
        POSITION: 2,
        TRIGRAPH: 3,
        DATE_PARTS: ["year", "month", "day"],
        DATE_PARTS_ALL: ["year", "month", "day", "season"],
        DATE_PARTS_INTERNAL: ["year", "month", "day", "year_end", "month_end", "day_end"],
        NAME_PARTS: ["non-dropping-particle", "family", "given", "dropping-particle", "suffix", "literal"],
        DISAMBIGUATE_OPTIONS: [
          "disambiguate-add-names",
          "disambiguate-add-givenname",
          "disambiguate-add-year-suffix"
        ],
        GIVENNAME_DISAMBIGUATION_RULES: [
          "all-names",
          "all-names-with-initials",
          "primary-name",
          "primary-name-with-initials",
          "by-cite"
        ],
        NAME_ATTRIBUTES: [
          "and",
          "delimiter-precedes-last",
          "delimiter-precedes-et-al",
          "initialize-with",
          "initialize",
          "name-as-sort-order",
          "sort-separator",
          "et-al-min",
          "et-al-use-first",
          "et-al-subsequent-min",
          "et-al-subsequent-use-first",
          "form",
          "prefix",
          "suffix",
          "delimiter"
        ],
        LOOSE: 0,
        STRICT: 1,
        TOLERANT: 2,
        PREFIX_PUNCTUATION: /[.;:]\s*$/,
        SUFFIX_PUNCTUATION: /^\s*[.;:,\(\)]/,
        NUMBER_REGEXP: /(?:^\d+|\d+$)/,
        //
        // \u0400-\u042f are cyrillic and extended cyrillic capitals
        // this is not fully smart yet.  can't do what this was trying to do
        // with regexps, actually; we want to identify strings with a leading
        // capital letter, and any subsequent capital letters.  Have to compare
        // locale caps version with existing version, character by character.
        // hard stuff, but if it breaks, that's what to do.
        // \u0600-\u06ff is Arabic/Persian
        // \u200c-\u200e and \u202a-\u202e are special spaces and left-right
        // control characters
        NAME_INITIAL_REGEXP: /^([A-Z\u0e01-\u0e5b\u00c0-\u017f\u0400-\u042f\u0590-\u05d4\u05d6-\u05ff\u0600-\u06ff\u0370\u0372\u0376\u0386\u0388-\u03ab\u03e2\u03e4\u03e6\u03e8\u03ea\u03ec\u03ee\u03f4\u03f7\u03fd-\u03ff])([a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0400-\u052f\u0600-\u06ff\u0370-\u03ff\u1f00-\u1fff]*|)(\.)*/,
        ROMANESQUE_REGEXP: /[-0-9a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]/,
        ROMANESQUE_NOT_REGEXP: /[^a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]/g,
        STARTSWITH_ROMANESQUE_REGEXP: /^[&a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]/,
        ENDSWITH_ROMANESQUE_REGEXP: /[.;:&a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]$/,
        ALL_ROMANESQUE_REGEXP: /^[a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]+$/,
        VIETNAMESE_SPECIALS: /[\u00c0-\u00c3\u00c8-\u00ca\u00cc\u00cd\u00d2-\u00d5\u00d9\u00da\u00dd\u00e0-\u00e3\u00e8-\u00ea\u00ec\u00ed\u00f2-\u00f5\u00f9\u00fa\u00fd\u0101\u0103\u0110\u0111\u0128\u0129\u0168\u0169\u01a0\u01a1\u01af\u01b0\u1ea0-\u1ef9]/,
        VIETNAMESE_NAMES: /^(?:(?:[.AaBbCcDdEeGgHhIiKkLlMmNnOoPpQqRrSsTtUuVvXxYy \u00c0-\u00c3\u00c8-\u00ca\u00cc\u00cd\u00d2-\u00d5\u00d9\u00da\u00dd\u00e0-\u00e3\u00e8-\u00ea\u00ec\u00ed\u00f2-\u00f5\u00f9\u00fa\u00fd\u0101\u0103\u0110\u0111\u0128\u0129\u0168\u0169\u01a0\u01a1\u01af\u01b0\u1ea0-\u1ef9]{2,6})(\s+|$))+$/,
        NOTE_FIELDS_REGEXP: /\{:(?:[\-_a-z]+|[A-Z]+):[^\}]+\}/g,
        NOTE_FIELD_REGEXP: /^([\-_a-z]+|[A-Z]+):\s*([^\}]+)$/,
        PARTICLE_GIVEN_REGEXP: /^([^ ]+(?:\u02bb |\u2019 | |\' ) *)(.+)$/,
        PARTICLE_FAMILY_REGEXP: /^([^ ]+(?:\-|\u02bb|\u2019| |\') *)(.+)$/,
        DISPLAY_CLASSES: ["block", "left-margin", "right-inline", "indent"],
        NAME_VARIABLES: [
          "author",
          "chair",
          "collection-editor",
          "compiler",
          "composer",
          "container-author",
          "contributor",
          "curator",
          "director",
          "editor",
          "editor-translator",
          "editorial-director",
          "executive-producer",
          "guest",
          "host",
          "illustrator",
          "interviewer",
          "narrator",
          "organizer",
          "original-author",
          "performer",
          "producer",
          "recipient",
          "reviewed-author",
          "script-writer",
          "series-creator",
          "translator",
          "commenter"
        ],
        CREATORS: [
          "author",
          "chair",
          "collection-editor",
          "compiler",
          "composer",
          "container-author",
          "contributor",
          "curator",
          "director",
          "editor",
          "editor-translator",
          "editorial-director",
          "executive-producer",
          "guest",
          "host",
          "illustrator",
          "interviewer",
          "narrator",
          "organizer",
          "original-author",
          "performer",
          "producer",
          "recipient",
          "reviewed-author",
          "script-writer",
          "series-creator",
          "translator",
          "commenter"
        ],
        NUMERIC_VARIABLES: [
          "call-number",
          "chapter-number",
          "collection-number",
          "division",
          "edition",
          "page",
          "issue",
          "locator",
          "locator-extra",
          "number",
          "number-of-pages",
          "number-of-volumes",
          "part-number",
          "printing-number",
          "section",
          "supplement-number",
          "version",
          "volume",
          "supplement",
          // maybe deprecated this? supplement-number should serve this purpose in standard CSL.
          "citation-number"
        ],
        //var x = new Array();
        //x = x.concat(["title","container-title","issued","page"]);
        //x = x.concat(["locator","collection-number","original-date"]);
        //x = x.concat(["reporting-date","decision-date","filing-date"]);
        //x = x.concat(["revision-date"]);
        //NUMERIC_VARIABLES = x.slice();
        DATE_VARIABLES: [
          "locator-date",
          "issued",
          "event-date",
          "accessed",
          "original-date",
          "publication-date",
          "available-date",
          "submitted",
          "alt-issued",
          "alt-event"
        ],
        VARIABLES_WITH_SHORT_FORM: [
          "title",
          "container-title"
        ],
        TITLE_FIELD_SPLITS: function(seg) {
          var keys = ["title", "short", "main", "sub", "subjoin"];
          var ret = {};
          for (var i = 0, ilen = keys.length; i < ilen; i++) {
            ret[keys[i]] = seg + "title" + (keys[i] === "title" ? "" : "-" + keys[i]);
          }
          return ret;
        },
        demoteNoiseWords: function(state, fld, drop_or_demote) {
          var SKIP_WORDS2 = state.locale[state.opt.lang].opts["leading-noise-words"];
          if (fld && drop_or_demote) {
            fld = fld.split(/\s+/);
            fld.reverse();
            var toEnd = [];
            for (var j = fld.length - 1; j > -1; j += -1) {
              if (SKIP_WORDS2.indexOf(fld[j].toLowerCase()) > -1) {
                toEnd.push(fld.pop());
              } else {
                break;
              }
            }
            fld.reverse();
            var start = fld.join(" ");
            var end = toEnd.join(" ");
            if ("drop" === drop_or_demote || !end) {
              fld = start;
            } else if ("demote" === drop_or_demote) {
              fld = [start, end].join(", ");
            }
          }
          return fld;
        },
        extractTitleAndSubtitle: function(Item, narrowSpaceLocale) {
          var narrowSpace = narrowSpaceLocale ? "\u202F" : "";
          var segments = [""];
          if (this.opt.development_extensions.split_container_title) {
            segments.push("container-");
          }
          for (var i = 0, ilen = segments.length; i < ilen; i++) {
            var seg = segments[i];
            var title = CSL3.TITLE_FIELD_SPLITS(seg);
            var langs = [false];
            if (Item.multi) {
              for (var lang in Item.multi._keys[title.short]) {
                langs.push(lang);
              }
            }
            for (var j = 0, jlen = langs.length; j < jlen; j++) {
              var lang = langs[j];
              var vals = {};
              if (lang) {
                if (Item.multi._keys[title.title]) {
                  vals[title.title] = Item.multi._keys[title.title][lang];
                }
                if (Item.multi._keys[title["short"]]) {
                  vals[title["short"]] = Item.multi._keys[title["short"]][lang];
                }
              } else {
                vals[title.title] = Item[title.title];
                vals[title["short"]] = Item[title["short"]];
              }
              vals[title.main] = vals[title.title];
              vals[title.sub] = false;
              var shortTitle = vals[title["short"]];
              if (vals[title.title]) {
                if (shortTitle && shortTitle.toLowerCase() === vals[title.title].toLowerCase()) {
                  vals[title.main] = vals[title.title];
                  vals[title.subjoin] = "";
                  vals[title.sub] = "";
                } else if (shortTitle) {
                  var tail = vals[title.title].slice(shortTitle.replace(/[\?\!]+$/, "").length);
                  var top = vals[title.title].replace(tail.replace(/^[\?\!]+/, ""), "").trim();
                  var m = CSL3.TITLE_SPLIT_REGEXP.matchfirst.exec(tail);
                  if (m && top.toLowerCase() === shortTitle.toLowerCase()) {
                    vals[title.main] = top;
                    vals[title.subjoin] = m[1].replace(/[\?\!]+(\s*)$/, "$1");
                    vals[title.sub] = tail.replace(CSL3.TITLE_SPLIT_REGEXP.matchfirst, "");
                    if (this.opt.development_extensions.force_short_title_casing_alignment) {
                      vals[title["short"]] = vals[title.main];
                    }
                  } else {
                    var splitTitle = CSL3.TITLE_SPLIT(vals[title.title]);
                    if (splitTitle.length == 3) {
                      vals[title.main] = splitTitle[0];
                      vals[title.subjoin] = splitTitle[1];
                      vals[title.sub] = splitTitle[2];
                    } else {
                      vals[title.main] = vals[title.title];
                      vals[title.subjoin] = "";
                      vals[title.sub] = "";
                    }
                  }
                } else {
                  var splitTitle = CSL3.TITLE_SPLIT(vals[title.title]);
                  if (splitTitle.length == 3) {
                    vals[title.main] = splitTitle[0];
                    vals[title.subjoin] = splitTitle[1];
                    vals[title.sub] = splitTitle[2];
                    if (this.opt.development_extensions.implicit_short_title && Item.type !== "legal_case") {
                      if (!Item[title.short] && !vals[title.main].match(/^[\-\.[0-9]+$/)) {
                        var punct = vals[title.subjoin].trim();
                        if (["?", "!"].indexOf(punct) === -1) {
                          punct = "";
                        }
                        vals[title.short] = vals[title.main] + punct;
                      }
                    }
                  } else {
                    vals[title.main] = vals[title.title];
                    vals[title.subjoin] = "";
                    vals[title.sub] = "";
                  }
                }
                if (vals[title.subjoin]) {
                  if (vals[title.subjoin].match(/([\?\!])/)) {
                    var m = vals[title.subjoin].match(/(\s*)$/);
                    vals[title.main] = vals[title.main] + narrowSpace + vals[title.subjoin].trim();
                    vals[title.subjoin] = m[1];
                  }
                }
              }
              if (vals[title.subjoin]) {
                if (vals[title.subjoin].indexOf(":") > -1) {
                  vals[title.subjoin] = narrowSpace + ": ";
                }
                if (vals[title.subjoin].indexOf("-") > -1 || vals[title.subjoin].indexOf("\u2014") > -1) {
                  vals[title.subjoin] = "\u2014";
                }
              }
              if (lang) {
                for (var key in vals) {
                  if (!Item.multi._keys[key]) {
                    Item.multi._keys[key] = {};
                  }
                  Item.multi._keys[key][lang] = vals[key];
                }
              } else {
                for (var key in vals) {
                  Item[key] = vals[key];
                }
              }
            }
          }
        },
        titlecaseSentenceOrNormal: function(state, Item, seg, lang, sentenceCase) {
          var title = CSL3.TITLE_FIELD_SPLITS(seg);
          var vals = {};
          if (lang && Item.multi) {
            if (Item.multi._keys[title.title]) {
              vals[title.title] = Item.multi._keys[title.title][lang];
            }
            if (Item.multi._keys[title.main]) {
              vals[title.main] = Item.multi._keys[title.main][lang];
            }
            if (Item.multi._keys[title.sub]) {
              vals[title.sub] = Item.multi._keys[title.sub][lang];
            }
            if (Item.multi._keys[title.subjoin]) {
              vals[title.subjoin] = Item.multi._keys[title.subjoin][lang];
            }
          } else {
            vals[title.title] = Item[title.title];
            vals[title.main] = Item[title.main];
            vals[title.sub] = Item[title.sub];
            vals[title.subjoin] = Item[title.subjoin];
          }
          if (vals[title.main] && vals[title.sub]) {
            var mainTitle = vals[title.main];
            var subJoin = vals[title.subjoin];
            var subTitle = vals[title.sub];
            if (sentenceCase) {
              mainTitle = CSL3.Output.Formatters.sentence(state, mainTitle);
              subTitle = CSL3.Output.Formatters.sentence(state, subTitle);
            } else if (state.opt.development_extensions.uppercase_subtitles) {
              subTitle = CSL3.Output.Formatters["capitalize-first"](state, subTitle);
            }
            return [mainTitle, subJoin, subTitle].join("");
          } else if (vals[title.title]) {
            if (sentenceCase) {
              return CSL3.Output.Formatters.sentence(state, vals[title.title]);
            } else if (state.opt.development_extensions.uppercase_subtitles) {
              var splits = CSL3.TITLE_SPLIT(vals[title.title]);
              for (var i = 0, ilen = splits.length; i < ilen; i += 2) {
                splits[i] = CSL3.Output.Formatters["capitalize-first"](state, splits[i]);
              }
              for (var i = 1, ilen = splits.length - 1; i < ilen; i += 2) {
                var m = splits[i].match(/([:\?\!] )/);
                if (m) {
                  var narrowSpace = state.opt["default-locale"][0].slice(0, 2).toLowerCase() === "fr" ? "\u202F" : "";
                  splits[i] = narrowSpace + m[1];
                }
                if (splits[i].indexOf("-") > -1 || splits[i].indexOf("\u2014") > -1) {
                  splits[i] = "\u2014";
                }
              }
              vals[title.title] = splits.join("");
              return vals[title.title];
            } else {
              return vals[title.title];
            }
          } else {
            return "";
          }
        },
        getSafeEscape: function(state) {
          if (["bibliography", "citation"].indexOf(state.tmp.area) > -1) {
            var callbacks = [];
            if (state.opt.development_extensions.thin_non_breaking_space_html_hack && state.opt.mode === "html") {
              callbacks.push(function(txt) {
                return txt.replace(/\u202f/g, '<span style="white-space:nowrap">&thinsp;</span>');
              });
            }
            if (callbacks.length) {
              return function(txt) {
                for (var i = 0, ilen = callbacks.length; i < ilen; i += 1) {
                  txt = callbacks[i](txt);
                }
                return CSL3.Output.Formats[state.opt.mode].text_escape(txt);
              };
            } else {
              return CSL3.Output.Formats[state.opt.mode].text_escape;
            }
          } else {
            return function(txt) {
              return txt;
            };
          }
        },
        SKIP_WORDS: ["about", "above", "across", "afore", "after", "against", "al", "along", "alongside", "amid", "amidst", "among", "amongst", "anenst", "apropos", "apud", "around", "as", "aside", "astride", "at", "athwart", "atop", "barring", "before", "behind", "below", "beneath", "beside", "besides", "between", "beyond", "but", "by", "circa", "despite", "down", "during", "et", "except", "for", "forenenst", "from", "given", "in", "inside", "into", "lest", "like", "modulo", "near", "next", "notwithstanding", "of", "off", "on", "onto", "out", "over", "per", "plus", "pro", "qua", "sans", "since", "than", "through", " thru", "throughout", "thruout", "till", "to", "toward", "towards", "under", "underneath", "until", "unto", "up", "upon", "versus", "vs.", "v.", "vs", "v", "via", "vis-\xE0-vis", "with", "within", "without", "according to", "ahead of", "apart from", "as for", "as of", "as per", "as regards", "aside from", "back to", "because of", "close to", "due to", "except for", "far from", "inside of", "instead of", "near to", "next to", "on to", "out from", "out of", "outside of", "prior to", "pursuant to", "rather than", "regardless of", "such as", "that of", "up to", "where as", "or", "yet", "so", "for", "and", "nor", "a", "an", "the", "de", "d'", "von", "van", "c", "ca"],
        FORMAT_KEY_SEQUENCE: [
          "@strip-periods",
          "@font-style",
          "@font-variant",
          "@font-weight",
          "@text-decoration",
          "@vertical-align",
          "@quotes"
        ],
        INSTITUTION_KEYS: [
          "font-style",
          "font-variant",
          "font-weight",
          "text-decoration",
          "text-case"
        ],
        SUFFIX_CHARS: "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z",
        ROMAN_NUMERALS: [
          ["", "i", "ii", "iii", "iv", "v", "vi", "vii", "viii", "ix"],
          ["", "x", "xx", "xxx", "xl", "l", "lx", "lxx", "lxxx", "xc"],
          ["", "c", "cc", "ccc", "cd", "d", "dc", "dcc", "dccc", "cm"],
          ["", "m", "mm", "mmm", "mmmm", "mmmmm"]
        ],
        LANGS: {
          "af-ZA": "Afrikaans",
          "ar": "Arabic",
          "bg-BG": "Bulgarian",
          "ca-AD": "Catalan",
          "cs-CZ": "Czech",
          "da-DK": "Danish",
          "de-AT": "Austrian",
          "de-CH": "German (CH)",
          "de-DE": "German (DE)",
          "el-GR": "Greek",
          "en-GB": "English (GB)",
          "en-US": "English (US)",
          "es-ES": "Spanish",
          "et-EE": "Estonian",
          "eu": "European",
          "fa-IR": "Persian",
          "fi-FI": "Finnish",
          "fr-CA": "French (CA)",
          "fr-FR": "French (FR)",
          "he-IL": "Hebrew",
          "hr-HR": "Croatian",
          "hu-HU": "Hungarian",
          "is-IS": "Icelandic",
          "it-IT": "Italian",
          "ja-JP": "Japanese",
          "km-KH": "Khmer",
          "ko-KR": "Korean",
          "lt-LT": "Lithuanian",
          "lv-LV": "Latvian",
          "mn-MN": "Mongolian",
          "nb-NO": "Norwegian (Bokm\xE5l)",
          "nl-NL": "Dutch",
          "nn-NO": "Norwegian (Nynorsk)",
          "pl-PL": "Polish",
          "pt-BR": "Portuguese (BR)",
          "pt-PT": "Portuguese (PT)",
          "ro-RO": "Romanian",
          "ru-RU": "Russian",
          "sk-SK": "Slovak",
          "sl-SI": "Slovenian",
          "sr-RS": "Serbian",
          "sv-SE": "Swedish",
          "th-TH": "Thai",
          "tr-TR": "Turkish",
          "uk-UA": "Ukrainian",
          "vi-VN": "Vietnamese",
          "zh-CN": "Chinese (CN)",
          "zh-TW": "Chinese (TW)"
        },
        LANG_BASES: {
          af: "af_ZA",
          ar: "ar",
          bg: "bg_BG",
          ca: "ca_AD",
          cs: "cs_CZ",
          da: "da_DK",
          de: "de_DE",
          el: "el_GR",
          en: "en_US",
          es: "es_ES",
          et: "et_EE",
          eu: "eu",
          fa: "fa_IR",
          fi: "fi_FI",
          fr: "fr_FR",
          he: "he_IL",
          hr: "hr-HR",
          hu: "hu_HU",
          is: "is_IS",
          it: "it_IT",
          ja: "ja_JP",
          km: "km_KH",
          ko: "ko_KR",
          lt: "lt_LT",
          lv: "lv-LV",
          mn: "mn_MN",
          nb: "nb_NO",
          nl: "nl_NL",
          nn: "nn-NO",
          pl: "pl_PL",
          pt: "pt_PT",
          ro: "ro_RO",
          ru: "ru_RU",
          sk: "sk_SK",
          sl: "sl_SI",
          sr: "sr_RS",
          sv: "sv_SE",
          th: "th_TH",
          tr: "tr_TR",
          uk: "uk_UA",
          vi: "vi_VN",
          zh: "zh_CN"
        },
        SUPERSCRIPTS: {
          "\xAA": "a",
          "\xB2": "2",
          "\xB3": "3",
          "\xB9": "1",
          "\xBA": "o",
          "\u02B0": "h",
          "\u02B1": "\u0266",
          "\u02B2": "j",
          "\u02B3": "r",
          "\u02B4": "\u0279",
          "\u02B5": "\u027B",
          "\u02B6": "\u0281",
          "\u02B7": "w",
          "\u02B8": "y",
          "\u02E0": "\u0263",
          "\u02E1": "l",
          "\u02E2": "s",
          "\u02E3": "x",
          "\u02E4": "\u0295",
          "\u1D2C": "A",
          "\u1D2D": "\xC6",
          "\u1D2E": "B",
          "\u1D30": "D",
          "\u1D31": "E",
          "\u1D32": "\u018E",
          "\u1D33": "G",
          "\u1D34": "H",
          "\u1D35": "I",
          "\u1D36": "J",
          "\u1D37": "K",
          "\u1D38": "L",
          "\u1D39": "M",
          "\u1D3A": "N",
          "\u1D3C": "O",
          "\u1D3D": "\u0222",
          "\u1D3E": "P",
          "\u1D3F": "R",
          "\u1D40": "T",
          "\u1D41": "U",
          "\u1D42": "W",
          "\u1D43": "a",
          "\u1D44": "\u0250",
          "\u1D45": "\u0251",
          "\u1D46": "\u1D02",
          "\u1D47": "b",
          "\u1D48": "d",
          "\u1D49": "e",
          "\u1D4A": "\u0259",
          "\u1D4B": "\u025B",
          "\u1D4C": "\u025C",
          "\u1D4D": "g",
          "\u1D4F": "k",
          "\u1D50": "m",
          "\u1D51": "\u014B",
          "\u1D52": "o",
          "\u1D53": "\u0254",
          "\u1D54": "\u1D16",
          "\u1D55": "\u1D17",
          "\u1D56": "p",
          "\u1D57": "t",
          "\u1D58": "u",
          "\u1D59": "\u1D1D",
          "\u1D5A": "\u026F",
          "\u1D5B": "v",
          "\u1D5C": "\u1D25",
          "\u1D5D": "\u03B2",
          "\u1D5E": "\u03B3",
          "\u1D5F": "\u03B4",
          "\u1D60": "\u03C6",
          "\u1D61": "\u03C7",
          "\u2070": "0",
          "\u2071": "i",
          "\u2074": "4",
          "\u2075": "5",
          "\u2076": "6",
          "\u2077": "7",
          "\u2078": "8",
          "\u2079": "9",
          "\u207A": "+",
          "\u207B": "\u2212",
          "\u207C": "=",
          "\u207D": "(",
          "\u207E": ")",
          "\u207F": "n",
          "\u2120": "SM",
          "\u2122": "TM",
          "\u3192": "\u4E00",
          "\u3193": "\u4E8C",
          "\u3194": "\u4E09",
          "\u3195": "\u56DB",
          "\u3196": "\u4E0A",
          "\u3197": "\u4E2D",
          "\u3198": "\u4E0B",
          "\u3199": "\u7532",
          "\u319A": "\u4E59",
          "\u319B": "\u4E19",
          "\u319C": "\u4E01",
          "\u319D": "\u5929",
          "\u319E": "\u5730",
          "\u319F": "\u4EBA",
          "\u02C0": "\u0294",
          "\u02C1": "\u0295",
          "\u06E5": "\u0648",
          "\u06E6": "\u064A"
        },
        SUPERSCRIPTS_REGEXP: new RegExp("[\xAA\xB2\xB3\xB9\xBA\u02B0\u02B1\u02B2\u02B3\u02B4\u02B5\u02B6\u02B7\u02B8\u02E0\u02E1\u02E2\u02E3\u02E4\u1D2C\u1D2D\u1D2E\u1D30\u1D31\u1D32\u1D33\u1D34\u1D35\u1D36\u1D37\u1D38\u1D39\u1D3A\u1D3C\u1D3D\u1D3E\u1D3F\u1D40\u1D41\u1D42\u1D43\u1D44\u1D45\u1D46\u1D47\u1D48\u1D49\u1D4A\u1D4B\u1D4C\u1D4D\u1D4F\u1D50\u1D51\u1D52\u1D53\u1D54\u1D55\u1D56\u1D57\u1D58\u1D59\u1D5A\u1D5B\u1D5C\u1D5D\u1D5E\u1D5F\u1D60\u1D61\u2070\u2071\u2074\u2075\u2076\u2077\u2078\u2079\u207A\u207B\u207C\u207D\u207E\u207F\u2120\u2122\u3192\u3193\u3194\u3195\u3196\u3197\u3198\u3199\u319A\u319B\u319C\u319D\u319E\u319F\u02C0\u02C1\u06E5\u06E6]", "g"),
        // I think we need to have separate args for prefix and term,
        // since they have different effects between comma-safe and comma-safe-numbers-only.
        // Either that, or -- oh, we could just bang the two together for the test where
        // necessary.
        UPDATE_GROUP_CONTEXT_CONDITION: function(state, str, valueTerm, token, value) {
          if (!state.opt.use_context_condition) return;
          var flags = state.tmp.group_context.tip;
          if (flags.condition) {
            if (!flags.condition.termtxt) {
              flags.condition.termtxt = str;
              flags.condition.valueTerm = valueTerm;
            }
            if (!flags.value_seen && flags.condition.test === "comma-safe-numbers-only") {
              if (value) {
                flags.value_seen = true;
                if (!value.match(/^[0-9]/)) {
                  state.tmp.just_did_number = false;
                }
              }
            }
          } else {
            if (token && token.decorations.filter((o) => o[0] === "@vertical-align").length > 0) {
              state.tmp.just_did_number = false;
            } else if (token && token.strings.suffix) {
              state.tmp.just_did_number = false;
            } else if (str) {
              if (str.match(/[0-9]$/)) {
                state.tmp.just_did_number = true;
              } else {
                state.tmp.just_did_number = false;
              }
            }
          }
        },
        EVALUATE_GROUP_CONDITION: function(state, flags) {
          if (!state.opt.use_context_condition) return;
          var testres;
          var numbersOnly = flags.condition.test === "comma-safe-numbers-only";
          if (flags.condition.test === "empty-label") {
            testres = !flags.condition.termtxt;
          } else if (flags.condition.test === "empty-label-no-decor") {
            testres = !flags.condition.termtxt || flags.condition.termtxt.indexOf("%s") > -1;
          } else if (["comma-safe", "comma-safe-numbers-only"].indexOf(flags.condition.test) > -1) {
            var locale_term = flags.condition.termtxt;
            var termStartAlpha = false;
            if (flags.condition.termtxt) {
              termStartAlpha = flags.condition.termtxt.slice(0, 1).match(CSL3.ALL_ROMANESQUE_REGEXP);
            }
            var num = state.tmp.just_did_number;
            if (num) {
              if (flags.condition.valueTerm) {
                testres = numbersOnly ? false : true;
              } else if (!locale_term) {
                testres = true;
              } else if (termStartAlpha) {
                testres = numbersOnly ? false : true;
              } else if (["always", "after-number"].indexOf(state.opt.require_comma_on_symbol) > -1) {
                testres = true;
              } else {
                testres = false;
              }
            } else {
              if (flags.condition.valueTerm) {
                testres = false;
              } else if (!locale_term) {
                testres = false;
              } else if (termStartAlpha) {
                testres = numbersOnly ? false : true;
              } else if (state.opt.require_comma_on_symbol === "always") {
                testres = true;
              } else {
                testres = false;
              }
            }
          }
          if (testres) {
            var force_suppress = false;
          } else {
            var force_suppress = true;
          }
          if (flags.condition.not) {
            force_suppress = !force_suppress;
          }
          return force_suppress;
        },
        SYS_OPTIONS: [
          "prioritize_disambiguate_condition",
          "csl_reverse_lookup_support",
          "main_title_from_short_title",
          "uppercase_subtitles",
          "force_short_title_casing_alignment",
          "implicit_short_title",
          "split_container_title"
        ],
        TITLE_SPLIT_REGEXP: function() {
          var splits = [
            "\\.\\s+",
            "\\!\\s+",
            "\\?\\s+",
            "\\s*::*\\s+",
            "\\s*\u2014\\s*",
            "\\s+\\-\\s+",
            "\\s*\\-\\-\\-*\\s*"
          ];
          return {
            match: new RegExp("(" + splits.join("|") + ")", "g"),
            matchfirst: new RegExp("^(" + splits.join("|") + ")"),
            split: new RegExp("(?:" + splits.join("|") + ")")
          };
        }(),
        TITLE_SPLIT: function(str) {
          if (!str) {
            return str;
          }
          var m = str.match(CSL3.TITLE_SPLIT_REGEXP.match);
          var lst = str.split(CSL3.TITLE_SPLIT_REGEXP.split);
          for (var i = lst.length - 2; i > -1; i--) {
            lst[i] = lst[i].trim();
            if (lst[i] && lst[i].slice(-1).toLowerCase() !== lst[i].slice(-1)) {
              lst[i] = lst[i] + m[i] + lst[i + 1];
              lst = lst.slice(0, i + 1).concat(lst.slice(i + 2));
            } else {
              lst = lst.slice(0, i + 1).concat([m[i]]).concat(lst.slice(i + 1));
            }
          }
          return lst;
        },
        GET_COURT_CLASS: function(state, Item, sortKey) {
          var cls = "";
          var authority = null;
          var country = Item.jurisdiction ? Item.jurisdiction.split(":")[0] : null;
          var classType = "court_condition_classes";
          if (sortKey) {
            classType = "court_key_classes";
          }
          if (country && Item.authority) {
            if ("string" === typeof Item.authority) {
              authority = Item.authority;
            } else {
              if (Item.authority[0] && Item.authority[0].literal) {
                authority = Item.authority[0].literal;
              }
            }
          }
          if (authority) {
            if (this.lang && state.locale[this.lang].opts[classType] && state.locale[this.lang].opts[classType][country] && state.locale[this.lang].opts[classType][country][authority]) {
              cls = state.locale[this.lang].opts[classType][country][authority];
            } else if (state.locale[state.opt["default-locale"][0]].opts[classType] && state.locale[state.opt["default-locale"][0]].opts[classType][country] && state.locale[state.opt["default-locale"][0]].opts[classType][country][authority]) {
              cls = state.locale[state.opt["default-locale"][0]].opts[classType][country][authority];
            }
          }
          return cls;
        },
        SET_COURT_CLASSES: function(state, lang, myxml, dataObj) {
          var nodes = myxml.getNodesByName(dataObj, "court-class");
          for (var pos = 0, len = myxml.numberofnodes(nodes); pos < len; pos += 1) {
            var courtclass = nodes[pos];
            var attributes = myxml.attributes(courtclass);
            var cls = attributes["@name"];
            var country = attributes["@country"];
            var courts = attributes["@courts"];
            var classType = "court_key_classes";
            if (state.registry) {
              classType = "court_condition_classes";
            }
            if (cls && country && courts) {
              courts = courts.trim().split(/\s+/);
              if (!state.locale[lang].opts[classType]) {
                state.locale[lang].opts[classType] = {};
              }
              if (!state.locale[lang].opts[classType][country]) {
                state.locale[lang].opts[classType][country] = {};
              }
              for (var i = 0, ilen = courts.length; i < ilen; i++) {
                state.locale[lang].opts[classType][country][courts[i]] = cls;
              }
            }
          }
        },
        INIT_JURISDICTION_MACROS: function(state, Item, item, macroName) {
          if (Item["best-jurisdiction"]) {
            return true;
          }
          if (!state.sys.retrieveStyleModule || !CSL3.MODULE_MACROS[macroName] || !Item.jurisdiction) {
            return false;
          }
          var jurisdictionList = state.getJurisdictionList(Item.jurisdiction);
          if (!state.opt.jurisdictions_seen[jurisdictionList[0]]) {
            var res = state.retrieveAllStyleModules(jurisdictionList);
            for (var jurisdiction in res) {
              var fallback = state.loadStyleModule(jurisdiction, res[jurisdiction]);
              if (fallback) {
                if (!res[fallback]) {
                  Object.assign(res, state.retrieveAllStyleModules([fallback]));
                  state.loadStyleModule(fallback, res[fallback], true);
                }
              }
            }
          }
          var jurisdictionList = state.getJurisdictionList(Item.jurisdiction);
          if (state.opt.parallel.enable) {
            if (!state.parallel) {
              state.parallel = new CSL3.Parallel(state);
            }
          }
          for (var i = 0, ilen = jurisdictionList.length; i < ilen; i++) {
            var jurisdiction = jurisdictionList[i];
            if (item) {
              if (state.juris[jurisdiction] && !item["best-jurisdiction"] && state.juris[jurisdiction].types.locator) {
                Item["best-jurisdiction"] = jurisdiction;
              }
            }
            if (state.juris[jurisdiction] && state.juris[jurisdiction].types[Item.type]) {
              Item["best-jurisdiction"] = jurisdiction;
              return true;
            }
          }
          return false;
        }
      };
      CSL3.XmlJSON = function(dataObj) {
        this.dataObj = dataObj;
        this.institution = {
          name: "institution",
          attrs: {
            "institution-parts": "long",
            "delimiter": ", "
          },
          children: [
            {
              name: "institution-part",
              attrs: {
                name: "long"
              },
              children: []
            }
          ]
        };
      };
      CSL3.XmlJSON.prototype.clean = function(json) {
        return json;
      };
      CSL3.XmlJSON.prototype.getStyleId = function(myjson, styleName) {
        var tagName = "id";
        if (styleName) {
          tagName = "title";
        }
        var ret = "";
        var children = myjson.children;
        for (var i = 0, ilen = children.length; i < ilen; i++) {
          if (children[i].name === "info") {
            var grandkids = children[i].children;
            for (var j = 0, jlen = grandkids.length; j < jlen; j++) {
              if (grandkids[j].name === tagName) {
                ret = grandkids[j].children[0];
              }
            }
          }
        }
        return ret;
      };
      CSL3.XmlJSON.prototype.children = function(myjson) {
        if (myjson && myjson.children.length) {
          return myjson.children.slice();
        } else {
          return false;
        }
      };
      CSL3.XmlJSON.prototype.nodename = function(myjson) {
        return myjson ? myjson.name : null;
      };
      CSL3.XmlJSON.prototype.attributes = function(myjson) {
        var ret = {};
        for (var attrname in myjson.attrs) {
          ret["@" + attrname] = myjson.attrs[attrname];
        }
        return ret;
      };
      CSL3.XmlJSON.prototype.content = function(myjson) {
        var ret = "";
        if (!myjson || !myjson.children) {
          return ret;
        }
        for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
          if ("string" === typeof myjson.children[i]) {
            ret += myjson.children[i];
          }
        }
        return ret;
      };
      CSL3.XmlJSON.prototype.namespace = {};
      CSL3.XmlJSON.prototype.numberofnodes = function(myjson) {
        if (myjson && "number" == typeof myjson.length) {
          return myjson.length;
        } else {
          return 0;
        }
      };
      CSL3.XmlJSON.prototype.getAttributeValue = function(myjson, name, namespace) {
        var ret = "";
        if (namespace) {
          name = namespace + ":" + name;
        }
        if (myjson) {
          if (myjson.attrs) {
            if (myjson.attrs[name]) {
              ret = myjson.attrs[name];
            } else {
              ret = "";
            }
          }
        }
        return ret;
      };
      CSL3.XmlJSON.prototype.getNodeValue = function(myjson, name) {
        var ret = "";
        if (name) {
          for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
            if (myjson.children[i].name === name) {
              if (myjson.children[i].children.length) {
                ret = myjson.children[i];
              } else {
                ret = "";
              }
            }
          }
        } else if (myjson) {
          ret = myjson;
        }
        if (ret && ret.children && ret.children.length == 1 && "string" === typeof ret.children[0]) {
          ret = ret.children[0];
        }
        return ret;
      };
      CSL3.XmlJSON.prototype.setAttributeOnNodeIdentifiedByNameAttribute = function(myjson, nodename, partname, attrname, val) {
        var pos, len, xml, nodes, node;
        if (attrname.slice(0, 1) === "@") {
          attrname = attrname.slice(1);
        }
        for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
          if (myjson.children[i].name === nodename && myjson.children[i].attrs.name === partname) {
            myjson.children[i].attrs[attrname] = val;
          }
        }
      };
      CSL3.XmlJSON.prototype.deleteNodeByNameAttribute = function(myjson, val) {
        var i, ilen;
        for (i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
          if (!myjson.children[i] || "string" === typeof myjson.children[i]) {
            continue;
          }
          if (myjson.children[i].attrs.name == val) {
            myjson.children = myjson.children.slice(0, i).concat(myjson.children.slice(i + 1));
          }
        }
      };
      CSL3.XmlJSON.prototype.deleteAttribute = function(myjson, attrname) {
        var i, ilen;
        if ("undefined" !== typeof myjson.attrs[attrname]) {
          myjson.attrs.pop(attrname);
        }
      };
      CSL3.XmlJSON.prototype.setAttribute = function(myjson, attr, val) {
        myjson.attrs[attr] = val;
        return false;
      };
      CSL3.XmlJSON.prototype.nodeCopy = function(myjson, clone) {
        if (!clone) {
          var clone = {};
        }
        if ("object" === typeof clone && "undefined" === typeof clone.length) {
          for (var key in myjson) {
            if ("string" === typeof myjson[key]) {
              clone[key] = myjson[key];
            } else if ("object" === typeof myjson[key]) {
              if ("undefined" === typeof myjson[key].length) {
                clone[key] = this.nodeCopy(myjson[key], {});
              } else {
                clone[key] = this.nodeCopy(myjson[key], []);
              }
            }
          }
        } else {
          for (var i = 0, ilen = myjson.length; i < ilen; i += 1) {
            if ("string" === typeof myjson[i]) {
              clone[i] = myjson[i];
            } else {
              clone[i] = this.nodeCopy(myjson[i], {});
            }
          }
        }
        return clone;
      };
      CSL3.XmlJSON.prototype.getNodesByName = function(myjson, name, nameattrval, ret) {
        var nodes, node, pos, len;
        if (!ret) {
          var ret = [];
        }
        if (!myjson || !myjson.children) {
          return ret;
        }
        if (name === myjson.name) {
          if (nameattrval) {
            if (nameattrval === myjson.attrs.name) {
              ret.push(myjson);
            }
          } else {
            ret.push(myjson);
          }
        }
        for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
          if ("object" !== typeof myjson.children[i]) {
            continue;
          }
          this.getNodesByName(myjson.children[i], name, nameattrval, ret);
        }
        return ret;
      };
      CSL3.XmlJSON.prototype.nodeNameIs = function(myjson, name) {
        if (typeof myjson === "undefined") {
          return false;
        }
        if (name == myjson.name) {
          return true;
        }
        return false;
      };
      CSL3.XmlJSON.prototype.makeXml = function(myjson) {
        if ("string" === typeof myjson) {
          if (myjson.slice(0, 1) === "<") {
            myjson = this.jsonStringWalker.walkToObject(myjson);
          } else {
            myjson = JSON.parse(myjson);
          }
        }
        return myjson;
      };
      CSL3.XmlJSON.prototype.insertChildNodeAfter = function(parent, node, pos, datejson) {
        for (var i = 0, ilen = parent.children.length; i < ilen; i += 1) {
          if (node === parent.children[i]) {
            parent.children = parent.children.slice(0, i).concat([datejson]).concat(parent.children.slice(i + 1));
            break;
          }
        }
        return parent;
      };
      CSL3.XmlJSON.prototype.insertPublisherAndPlace = function(myjson) {
        if (myjson.name === "group") {
          var useme = true;
          var mustHaves = ["publisher", "publisher-place"];
          for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
            var haveVarname = mustHaves.indexOf(myjson.children[i].attrs.variable);
            var isText = myjson.children[i].name === "text";
            if (isText && haveVarname > -1 && !myjson.children[i].attrs.prefix && !myjson.children[i].attrs.suffix) {
              mustHaves = mustHaves.slice(0, haveVarname).concat(mustHaves.slice(haveVarname + 1));
            } else {
              useme = false;
              break;
            }
          }
          if (useme && !mustHaves.length) {
            myjson.attrs["has-publisher-and-publisher-place"] = true;
          }
        }
        for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
          if ("object" === typeof myjson.children[i]) {
            this.insertPublisherAndPlace(myjson.children[i]);
          }
        }
      };
      CSL3.XmlJSON.prototype.isChildOfSubstitute = function(parents) {
        if (parents.length > 0) {
          var myparents = parents.slice();
          var parent = myparents.pop();
          if (parent === "substitute") {
            return true;
          } else {
            return this.isChildOfSubstitute(myparents);
          }
        }
        return false;
      };
      CSL3.XmlJSON.prototype.addMissingNameNodes = function(myjson, parents) {
        if (!parents) {
          parents = [];
        }
        if (myjson.name === "names") {
          if (!this.isChildOfSubstitute(parents)) {
            var addName = true;
            for (var i = 0, ilen = myjson.children.length; i < ilen; i++) {
              if (myjson.children[i].name === "name") {
                addName = false;
                break;
              }
            }
            if (addName) {
              myjson.children = [{ name: "name", attrs: {}, children: [] }].concat(myjson.children);
            }
          }
        }
        parents.push(myjson.name);
        for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
          if ("object" === typeof myjson.children[i]) {
            this.addMissingNameNodes(myjson.children[i], parents);
          }
        }
        parents.pop();
      };
      CSL3.XmlJSON.prototype.addInstitutionNodes = function(myjson) {
        var names, thenames, institution, theinstitution, name, thename, xml, pos, len;
        if (myjson.name === "names") {
          var attributes = {};
          var insertPos = -1;
          for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
            if (myjson.children[i].name == "name") {
              for (var key in myjson.children[i].attrs) {
                attributes[key] = myjson.children[i].attrs[key];
              }
              attributes.delimiter = myjson.children[i].attrs.delimiter;
              attributes.and = myjson.children[i].attrs.and;
              insertPos = i;
              for (var k = 0, klen = myjson.children[i].children.length; k < klen; k += 1) {
                if (myjson.children[i].children[k].attrs.name !== "family") {
                  continue;
                }
                for (var key in myjson.children[i].children[k].attrs) {
                  attributes[key] = myjson.children[i].children[k].attrs[key];
                }
              }
            }
            if (myjson.children[i].name == "institution") {
              insertPos = -1;
              break;
            }
          }
          if (insertPos > -1) {
            var institution = this.nodeCopy(this.institution);
            for (var i = 0, ilen = CSL3.INSTITUTION_KEYS.length; i < ilen; i += 1) {
              var attrname = CSL3.INSTITUTION_KEYS[i];
              if ("undefined" !== typeof attributes[attrname]) {
                institution.children[0].attrs[attrname] = attributes[attrname];
              }
              if (attributes.delimiter) {
                institution.attrs.delimiter = attributes.delimiter;
              }
              if (attributes.and) {
                institution.attrs.and = attributes.and;
              }
            }
            myjson.children = myjson.children.slice(0, insertPos + 1).concat([institution]).concat(myjson.children.slice(insertPos + 1));
          }
        }
        for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
          if ("string" === typeof myjson.children[i]) {
            continue;
          }
          this.addInstitutionNodes(myjson.children[i]);
        }
      };
      CSL3.XmlJSON.prototype.flagDateMacros = function(myjson) {
        for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
          if (myjson.children[i].name === "macro") {
            if (this.inspectDateMacros(myjson.children[i])) {
              myjson.children[i].attrs["macro-has-date"] = "true";
            }
          }
        }
      };
      CSL3.XmlJSON.prototype.inspectDateMacros = function(myjson) {
        if (!myjson || !myjson.children) {
          return false;
        }
        if (myjson.name === "date") {
          return true;
        } else {
          for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
            if (this.inspectDateMacros(myjson.children[i])) {
              return true;
            }
          }
        }
        return false;
      };
      CSL3.stripXmlProcessingInstruction = function(xml) {
        if (!xml) {
          return xml;
        }
        xml = xml.replace(/^<\?[^?]+\?>/, "");
        xml = xml.replace(/<!--[^>]+-->/g, "");
        xml = xml.replace(/^\s+/g, "");
        xml = xml.replace(/\s+$/g, "");
        return xml;
      };
      CSL3.parseXml = function(str) {
        var _pos = 0;
        var _obj = { children: [] };
        var _stack = [_obj.children];
        function _listifyString(str2) {
          str2 = str2.split(/(?:\r\n|\n|\r)/).join(" ").replace(/>[	 ]+</g, "><").replace(/<\!--.*?-->/g, "");
          var lst2 = str2.split("><");
          var stylePos = null;
          for (var i2 = 0, ilen2 = lst2.length; i2 < ilen2; i2++) {
            if (i2 > 0) {
              lst2[i2] = "<" + lst2[i2];
            }
            if (i2 < lst2.length - 1) {
              lst2[i2] = lst2[i2] + ">";
            }
            if ("number" != typeof stylePos) {
              if (lst2[i2].slice(0, 7) === "<style " || lst2[i2].slice(0, 8) == "<locale ") {
                stylePos = i2;
              }
            }
          }
          lst2 = lst2.slice(stylePos);
          for (var i2 = lst2.length - 2; i2 > -1; i2--) {
            if (lst2[i2].slice(1).indexOf("<") === -1) {
              var stub = lst2[i2].slice(0, 5);
              if (lst2[i2].slice(-2) !== "/>") {
                if (stub === "<term") {
                  if (lst2[i2 + 1].slice(0, 6) === "</term") {
                    lst2[i2] = lst2[i2] + lst2[i2 + 1];
                    lst2 = lst2.slice(0, i2 + 1).concat(lst2.slice(i2 + 2));
                  }
                } else if (["<sing", "<mult"].indexOf(stub) > -1) {
                  if (lst2[i2].slice(-2) !== "/>" && lst2[i2 + 1].slice(0, 1) === "<") {
                    lst2[i2] = lst2[i2] + lst2[i2 + 1];
                    lst2 = lst2.slice(0, i2 + 1).concat(lst2.slice(i2 + 2));
                  }
                }
              }
            }
          }
          return lst2;
        }
        function _decodeHtmlEntities(str2) {
          return str2.split("&amp;").join("&").split("&quot;").join('"').split("&gt;").join(">").split("&lt;").join("<").replace(/&#([0-9]{1,6});/gi, function(match, numStr) {
            var num = parseInt(numStr, 10);
            return String.fromCharCode(num);
          }).replace(/&#x([a-f0-9]{1,6});/gi, function(match, numStr) {
            var num = parseInt(numStr, 16);
            return String.fromCharCode(num);
          });
        }
        function _getAttributes(elem2) {
          var m = elem2.match(/([^\'\"=	 ]+)=(?:\"[^\"]*\"|\'[^\']*\')/g);
          if (m) {
            for (var i2 = 0, ilen2 = m.length; i2 < ilen2; i2++) {
              m[i2] = m[i2].replace(/=.*/, "");
            }
          }
          return m;
        }
        function _getAttribute(elem2, attr) {
          var rex = RegExp("^.*[	 ]+" + attr + `=("(?:[^"]*)"|'(?:[^']*)').*$`);
          var m = elem2.match(rex);
          return m ? m[1].slice(1, -1) : null;
        }
        function _getTagName(elem2) {
          var rex = RegExp("^<([^	 />]+)");
          var m = elem2.match(rex);
          return m ? m[1] : null;
        }
        function _castObjectFromOpeningTag(elem2) {
          var obj = {};
          obj.name = _getTagName(elem2);
          obj.attrs = {};
          var attributes = _getAttributes(elem2);
          if (attributes) {
            for (var i2 = 0, ilen2 = attributes.length; i2 < ilen2; i2++) {
              var attr = {
                name: attributes[i2],
                value: _getAttribute(elem2, attributes[i2])
              };
              obj.attrs[attr.name] = _decodeHtmlEntities(attr.value);
            }
          }
          obj.children = [];
          return obj;
        }
        function _extractTextFromCompositeElement(elem2) {
          var m = elem2.match(/^.*>([^<]*)<.*$/);
          return _decodeHtmlEntities(m[1]);
        }
        function _appendToChildren(obj) {
          _stack.slice(-1)[0].push(obj);
        }
        function _extendStackWithNewChildren(obj) {
          _stack.push(obj.children);
        }
        function processElement(elem2) {
          var obj;
          if (elem2.slice(1).indexOf("<") > -1) {
            var tag = elem2.slice(0, elem2.indexOf(">") + 1);
            obj = _castObjectFromOpeningTag(tag);
            obj.children = [_extractTextFromCompositeElement(elem2)];
            _appendToChildren(obj);
          } else if (elem2.slice(-2) === "/>") {
            obj = _castObjectFromOpeningTag(elem2);
            if (_getTagName(elem2) === "term") {
              obj.children.push("");
            }
            _appendToChildren(obj);
          } else if (elem2.slice(0, 2) === "</") {
            _stack.pop();
          } else {
            obj = _castObjectFromOpeningTag(elem2);
            _appendToChildren(obj);
            _extendStackWithNewChildren(obj);
          }
        }
        var lst = _listifyString(str);
        for (var i = 0, ilen = lst.length; i < ilen; i++) {
          var elem = lst[i];
          processElement(elem);
        }
        return _obj.children[0];
      };
      CSL3.XmlDOM = function(dataObj) {
        this.dataObj = dataObj;
        if ("undefined" == typeof DOMParser) {
          DOMParser = function() {
          };
          DOMParser.prototype.parseFromString = function(str2, contentType) {
            if ("undefined" != typeof ActiveXObject) {
              var xmldata = new ActiveXObject("MSXML.DomDocument");
              xmldata.async = false;
              xmldata.loadXML(str2);
              return xmldata;
            } else if ("undefined" != typeof XMLHttpRequest) {
              var xmldata = new XMLHttpRequest();
              if (!contentType) {
                contentType = "text/xml";
              }
              xmldata.open("GET", "data:" + contentType + ";charset=utf-8," + encodeURIComponent(str2), false);
              if (xmldata.overrideMimeType) {
                xmldata.overrideMimeType(contentType);
              }
              xmldata.send(null);
              return xmldata.responseXML;
            } else if ("undefined" != typeof marknote) {
              var parser = new marknote.Parser();
              return parser.parse(str2);
            }
          };
          this.hasAttributes = function(node) {
            var ret;
            if (node.attributes && node.attributes.length) {
              ret = true;
            } else {
              ret = false;
            }
            return ret;
          };
        } else {
          this.hasAttributes = function(node) {
            var ret;
            if (node.attributes && node.attributes.length) {
              ret = true;
            } else {
              ret = false;
            }
            return ret;
          };
        }
        this.importNode = function(doc, srcElement) {
          var ret;
          if ("undefined" == typeof doc.importNode) {
            ret = this._importNode(doc, srcElement, true);
          } else {
            ret = doc.importNode(srcElement, true);
          }
          return ret;
        };
        this._importNode = function(doc, node, allChildren) {
          switch (node.nodeType) {
            case 1:
              var newNode = doc.createElement(node.nodeName);
              if (node.attributes && node.attributes.length > 0)
                for (var i = 0, il = node.attributes.length; i < il; )
                  newNode.setAttribute(node.attributes[i].nodeName, node.getAttribute(node.attributes[i++].nodeName));
              if (allChildren && node.childNodes && node.childNodes.length > 0)
                for (var i = 0, il = node.childNodes.length; i < il; )
                  newNode.appendChild(this._importNode(doc, node.childNodes[i++], allChildren));
              return newNode;
              break;
            case 3:
            case 4:
            case 8:
          }
        };
        this.parser = new DOMParser();
        var str = '<docco><institution institution-parts="long" delimiter=", " substitute-use-first="1" use-last="1"><institution-part name="long"/></institution></docco>';
        var inst_doc = this.parser.parseFromString(str, "text/xml");
        var inst_node = inst_doc.getElementsByTagName("institution");
        this.institution = inst_node.item(0);
        var inst_part_node = inst_doc.getElementsByTagName("institution-part");
        this.institutionpart = inst_part_node.item(0);
        this.ns = "http://purl.org/net/xbiblio/csl";
      };
      CSL3.XmlDOM.prototype.clean = function(xml) {
        xml = xml.replace(/<\?[^?]+\?>/g, "");
        xml = xml.replace(/<![^>]+>/g, "");
        xml = xml.replace(/^\s+/, "");
        xml = xml.replace(/\s+$/, "");
        xml = xml.replace(/^\n*/, "");
        return xml;
      };
      CSL3.XmlDOM.prototype.getStyleId = function(myxml, styleName) {
        var text = "";
        var tagName = "id";
        if (styleName) {
          tagName = "title";
        }
        var node = myxml.getElementsByTagName(tagName);
        if (node && node.length) {
          node = node.item(0);
        }
        if (node) {
          text = node.textContent;
        }
        if (!text) {
          text = node.innerText;
        }
        if (!text) {
          text = node.innerHTML;
        }
        return text;
      };
      CSL3.XmlDOM.prototype.children = function(myxml) {
        var children, pos, len, ret;
        if (myxml) {
          ret = [];
          children = myxml.childNodes;
          for (pos = 0, len = children.length; pos < len; pos += 1) {
            if (children[pos].nodeName != "#text") {
              ret.push(children[pos]);
            }
          }
          return ret;
        } else {
          return [];
        }
      };
      CSL3.XmlDOM.prototype.nodename = function(myxml) {
        var ret = myxml.nodeName;
        return ret;
      };
      CSL3.XmlDOM.prototype.attributes = function(myxml) {
        var ret, attrs, attr, key, xml, pos, len;
        ret = new Object();
        if (myxml && this.hasAttributes(myxml)) {
          attrs = myxml.attributes;
          for (pos = 0, len = attrs.length; pos < len; pos += 1) {
            attr = attrs[pos];
            ret["@" + attr.name] = attr.value;
          }
        }
        return ret;
      };
      CSL3.XmlDOM.prototype.content = function(myxml) {
        var ret;
        if ("undefined" != typeof myxml.textContent) {
          ret = myxml.textContent;
        } else if ("undefined" != typeof myxml.innerText) {
          ret = myxml.innerText;
        } else {
          ret = myxml.txt;
        }
        return ret;
      };
      CSL3.XmlDOM.prototype.namespace = {
        "xml": "http://www.w3.org/XML/1998/namespace"
      };
      CSL3.XmlDOM.prototype.numberofnodes = function(myxml) {
        if (myxml) {
          return myxml.length;
        } else {
          return 0;
        }
      };
      CSL3.XmlDOM.prototype.getAttributeName = function(attr) {
        var ret = attr.name;
        return ret;
      };
      CSL3.XmlDOM.prototype.getAttributeValue = function(myxml, name, namespace) {
        var ret = "";
        if (namespace) {
          name = namespace + ":" + name;
        }
        if (myxml && this.hasAttributes(myxml) && myxml.getAttribute(name)) {
          ret = myxml.getAttribute(name);
        }
        return ret;
      };
      CSL3.XmlDOM.prototype.getNodeValue = function(myxml, name) {
        var ret = null;
        if (name) {
          var vals = myxml.getElementsByTagName(name);
          if (vals.length > 0) {
            if ("undefined" != typeof vals[0].textContent) {
              ret = vals[0].textContent;
            } else if ("undefined" != typeof vals[0].innerText) {
              ret = vals[0].innerText;
            } else {
              ret = vals[0].text;
            }
          }
        }
        if (ret === null && myxml && myxml.childNodes && (myxml.childNodes.length == 0 || myxml.childNodes.length == 1 && myxml.firstChild.nodeName == "#text")) {
          if ("undefined" != typeof myxml.textContent) {
            ret = myxml.textContent;
          } else if ("undefined" != typeof myxml.innerText) {
            ret = myxml.innerText;
          } else {
            ret = myxml.text;
          }
        }
        if (ret === null) {
          ret = myxml;
        }
        return ret;
      };
      CSL3.XmlDOM.prototype.setAttributeOnNodeIdentifiedByNameAttribute = function(myxml, nodename, partname, attrname, val) {
        var pos, len, xml, nodes, node;
        if (attrname.slice(0, 1) === "@") {
          attrname = attrname.slice(1);
        }
        nodes = myxml.getElementsByTagName(nodename);
        for (pos = 0, len = nodes.length; pos < len; pos += 1) {
          node = nodes[pos];
          if (node.getAttribute("name") != partname) {
            continue;
          }
          node.setAttribute(attrname, val);
        }
      };
      CSL3.XmlDOM.prototype.deleteNodeByNameAttribute = function(myxml, val) {
        var pos, len, node, nodes;
        nodes = myxml.childNodes;
        for (pos = 0, len = nodes.length; pos < len; pos += 1) {
          node = nodes[pos];
          if (!node || node.nodeType == node.TEXT_NODE) {
            continue;
          }
          if (this.hasAttributes(node) && node.getAttribute("name") == val) {
            myxml.removeChild(nodes[pos]);
          }
        }
      };
      CSL3.XmlDOM.prototype.deleteAttribute = function(myxml, attr) {
        myxml.removeAttribute(attr);
      };
      CSL3.XmlDOM.prototype.setAttribute = function(myxml, attr, val) {
        if (!myxml.ownerDocument) {
          myxml = myxml.firstChild;
        }
        if (["function", "unknown"].indexOf(typeof myxml.setAttribute) > -1) {
          myxml.setAttribute(attr, val);
        }
        return false;
      };
      CSL3.XmlDOM.prototype.nodeCopy = function(myxml) {
        var cloned_node = myxml.cloneNode(true);
        return cloned_node;
      };
      CSL3.XmlDOM.prototype.getNodesByName = function(myxml, name, nameattrval) {
        var ret, nodes, node, pos, len;
        ret = [];
        nodes = myxml.getElementsByTagName(name);
        for (pos = 0, len = nodes.length; pos < len; pos += 1) {
          node = nodes.item(pos);
          if (nameattrval && !(this.hasAttributes(node) && node.getAttribute("name") == nameattrval)) {
            continue;
          }
          ret.push(node);
        }
        return ret;
      };
      CSL3.XmlDOM.prototype.nodeNameIs = function(myxml, name) {
        if (name == myxml.nodeName) {
          return true;
        }
        return false;
      };
      CSL3.XmlDOM.prototype.makeXml = function(myxml) {
        var ret, topnode;
        if (!myxml) {
          myxml = "<docco><bogus/></docco>";
        }
        myxml = myxml.replace(/\s*<\?[^>]*\?>\s*\n*/g, "");
        var nodetree = this.parser.parseFromString(myxml, "application/xml");
        return nodetree.firstChild;
      };
      CSL3.XmlDOM.prototype.insertChildNodeAfter = function(parent, node, pos, datexml) {
        var myxml, xml;
        myxml = this.importNode(node.ownerDocument, datexml);
        parent.replaceChild(myxml, node);
        return parent;
      };
      CSL3.XmlDOM.prototype.insertPublisherAndPlace = function(myxml) {
        var group = myxml.getElementsByTagName("group");
        for (var i = 0, ilen = group.length; i < ilen; i += 1) {
          var node = group.item(i);
          var skippers = [];
          for (var j = 0, jlen = node.childNodes.length; j < jlen; j += 1) {
            if (node.childNodes.item(j).nodeType !== 1) {
              skippers.push(j);
            }
          }
          if (node.childNodes.length - skippers.length === 2) {
            var twovars = [];
            for (var j = 0, jlen = 2; j < jlen; j += 1) {
              if (skippers.indexOf(j) > -1) {
                continue;
              }
              var child = node.childNodes.item(j);
              var subskippers = [];
              for (var k = 0, klen = child.childNodes.length; k < klen; k += 1) {
                if (child.childNodes.item(k).nodeType !== 1) {
                  subskippers.push(k);
                }
              }
              if (child.childNodes.length - subskippers.length === 0) {
                twovars.push(child.getAttribute("variable"));
                if (child.getAttribute("suffix") || child.getAttribute("prefix")) {
                  twovars = [];
                  break;
                }
              }
            }
            if (twovars.indexOf("publisher") > -1 && twovars.indexOf("publisher-place") > -1) {
              node.setAttribute("has-publisher-and-publisher-place", true);
            }
          }
        }
      };
      CSL3.XmlDOM.prototype.isChildOfSubstitute = function(node) {
        if (node.parentNode) {
          if (node.parentNode.tagName.toLowerCase() === "substitute") {
            return true;
          } else {
            return this.isChildOfSubstitute(node.parentNode);
          }
        }
        return false;
      };
      CSL3.XmlDOM.prototype.addMissingNameNodes = function(myxml) {
        var nameslist = myxml.getElementsByTagName("names");
        for (var i = 0, ilen = nameslist.length; i < ilen; i += 1) {
          var names = nameslist.item(i);
          var namelist = names.getElementsByTagName("name");
          if ((!namelist || namelist.length === 0) && !this.isChildOfSubstitute(names)) {
            var doc = names.ownerDocument;
            var name = doc.createElement("name");
            names.appendChild(name);
          }
        }
      };
      CSL3.XmlDOM.prototype.addInstitutionNodes = function(myxml) {
        var names, thenames, institution, theinstitution, theinstitutionpart, name, thename, xml, pos, len;
        names = myxml.getElementsByTagName("names");
        for (pos = 0, len = names.length; pos < len; pos += 1) {
          thenames = names.item(pos);
          name = thenames.getElementsByTagName("name");
          if (name.length == 0) {
            continue;
          }
          institution = thenames.getElementsByTagName("institution");
          if (institution.length == 0) {
            theinstitution = this.importNode(myxml.ownerDocument, this.institution);
            theinstitutionpart = theinstitution.getElementsByTagName("institution-part").item(0);
            thename = name.item(0);
            thenames.insertBefore(theinstitution, thename.nextSibling);
            for (var j = 0, jlen = CSL3.INSTITUTION_KEYS.length; j < jlen; j += 1) {
              var attrname = CSL3.INSTITUTION_KEYS[j];
              var attrval = thename.getAttribute(attrname);
              if (attrval) {
                theinstitutionpart.setAttribute(attrname, attrval);
              }
            }
            var nameparts = thename.getElementsByTagName("name-part");
            for (var j = 0, jlen = nameparts.length; j < jlen; j += 1) {
              if ("family" === nameparts[j].getAttribute("name")) {
                for (var k = 0, klen = CSL3.INSTITUTION_KEYS.length; k < klen; k += 1) {
                  var attrname = CSL3.INSTITUTION_KEYS[k];
                  var attrval = nameparts[j].getAttribute(attrname);
                  if (attrval) {
                    theinstitutionpart.setAttribute(attrname, attrval);
                  }
                }
              }
            }
          }
        }
      };
      CSL3.XmlDOM.prototype.flagDateMacros = function(myxml) {
        var pos, len, thenode, thedate;
        var nodes = myxml.getElementsByTagName("macro");
        for (pos = 0, len = nodes.length; pos < len; pos += 1) {
          thenode = nodes.item(pos);
          thedate = thenode.getElementsByTagName("date");
          if (thedate.length) {
            thenode.setAttribute("macro-has-date", "true");
          }
        }
      };
      CSL3.setupXml = function(xmlObject) {
        var dataObj = {};
        var parser = null;
        if ("undefined" !== typeof xmlObject) {
          if ("string" === typeof xmlObject) {
            xmlObject = xmlObject.replace("^\uFEFF", "").replace(/^\s+/, "");
            if (xmlObject.slice(0, 1) === "<") {
              dataObj = CSL3.parseXml(xmlObject);
            } else {
              dataObj = JSON.parse(xmlObject);
            }
            parser = new CSL3.XmlJSON(dataObj);
          } else if ("undefined" !== typeof xmlObject.getAttribute) {
            parser = new CSL3.XmlDOM(xmlObject);
          } else if ("undefined" !== typeof xmlObject.toXMLString) {
            parser = new CSL3.XmlE4X(xmlObject);
          } else {
            parser = new CSL3.XmlJSON(xmlObject);
          }
        } else {
          CSL3.error("unable to parse XML input");
        }
        if (!parser) {
          CSL3.error("citeproc-js error: unable to parse CSL style or locale object");
        }
        return parser;
      };
      CSL3.getSortCompare = function(default_locale) {
        if (CSL3.stringCompare) {
          return CSL3.stringCompare;
        }
        var me = this;
        var strcmp;
        var strcmp_opts = {
          sensitivity: "base",
          ignorePunctuation: true,
          numeric: true
        };
        if (!default_locale) {
          default_locale = "en-US";
        }
        strcmp = function(a, b) {
          return CSL3.toLocaleLowerCase.call(me, a).localeCompare(CSL3.toLocaleLowerCase.call(me, b), default_locale, strcmp_opts);
        };
        var stripPunct = function(str) {
          return str.replace(/^[\[\]\'\"]*/g, "");
        };
        var getBracketPreSort = function() {
          if (!strcmp("[x", "x")) {
            return false;
          } else {
            return function(a, b) {
              return strcmp(stripPunct(a), stripPunct(b));
            };
          }
        };
        var bracketPreSort = getBracketPreSort();
        var sortCompare = function(a, b) {
          if (bracketPreSort) {
            return bracketPreSort(a, b);
          } else {
            return strcmp(a, b);
          }
        };
        return sortCompare;
      };
      CSL3.ambigConfigDiff = function(a, b) {
        var pos, len, ppos, llen;
        if (a.names.length !== b.names.length) {
          return 1;
        } else {
          for (pos = 0, len = a.names.length; pos < len; pos += 1) {
            if (a.names[pos] !== b.names[pos]) {
              return 1;
            } else {
              for (ppos = 0, llen = a.givens[pos]; ppos < llen; ppos += 1) {
                if (a.givens[pos][ppos] !== b.givens[pos][ppos]) {
                  return 1;
                }
              }
            }
          }
        }
        if (a.disambiguate != b.disambiguate) {
          return 1;
        }
        if (a.year_suffix !== b.year_suffix) {
          return 1;
        }
        return 0;
      };
      CSL3.cloneAmbigConfig = function(config, oldconfig) {
        var i, ilen, j, jlen, param;
        var ret = {};
        ret.names = [];
        ret.givens = [];
        ret.year_suffix = false;
        ret.disambiguate = false;
        for (i = 0, ilen = config.names.length; i < ilen; i += 1) {
          param = config.names[i];
          ret.names[i] = param;
        }
        for (i = 0, ilen = config.givens.length; i < ilen; i += 1) {
          param = [];
          for (j = 0, jlen = config.givens[i].length; j < jlen; j += 1) {
            param.push(config.givens[i][j]);
          }
          ret.givens.push(param);
        }
        if (oldconfig) {
          ret.year_suffix = oldconfig.year_suffix;
          ret.disambiguate = oldconfig.disambiguate;
        } else {
          ret.year_suffix = config.year_suffix;
          ret.disambiguate = config.disambiguate;
        }
        return ret;
      };
      CSL3.getAmbigConfig = function() {
        var config, ret;
        config = this.tmp.disambig_request;
        if (!config) {
          config = this.tmp.disambig_settings;
        }
        var ret = CSL3.cloneAmbigConfig(config);
        return ret;
      };
      CSL3.getMaxVals = function() {
        return this.tmp.names_max.mystack.slice();
      };
      CSL3.getMinVal = function() {
        return this.tmp["et-al-min"];
      };
      CSL3.tokenExec = function(token, Item, item) {
        var next, maybenext, exec, debug;
        debug = false;
        next = token.next;
        maybenext = false;
        var record = function(result) {
          if (result) {
            this.tmp.jump.replace("succeed");
            return token.succeed;
          } else {
            this.tmp.jump.replace("fail");
            return token.fail;
          }
        };
        if (token.test) {
          next = record.call(this, token.test(Item, item));
        }
        for (var i = 0, ilen = token.execs.length; i < ilen; i++) {
          exec = token.execs[i];
          maybenext = exec.call(token, this, Item, item);
          if (maybenext) {
            next = maybenext;
          }
        }
        if (debug) {
          CSL3.debug(token.name + " (" + token.tokentype + ") ---> done");
        }
        return next;
      };
      CSL3.expandMacro = function(macro_key_token, target) {
        var mkey, macro_nodes, end_of_macro, func;
        mkey = macro_key_token.postponed_macro;
        var sort_direction = macro_key_token.strings.sort_direction;
        macro_key_token = new CSL3.Token("group", CSL3.START);
        var hasDate = false;
        var macroid = false;
        macro_nodes = this.cslXml.getNodesByName(this.cslXml.dataObj, "macro", mkey);
        if (macro_nodes.length) {
          macroid = this.cslXml.getAttributeValue(macro_nodes[0], "cslid");
          hasDate = this.cslXml.getAttributeValue(macro_nodes[0], "macro-has-date");
        }
        if (hasDate) {
          mkey = mkey + "@" + this.build.current_default_locale;
          func = function(state) {
            if (state.tmp.extension) {
              state.tmp["doing-macro-with-date"] = true;
            }
          };
          macro_key_token.execs.push(func);
        }
        if (this.build.macro_stack.indexOf(mkey) > -1) {
          CSL3.error('CSL processor error: call to macro "' + mkey + '" would cause an infinite loop');
        } else {
          this.build.macro_stack.push(mkey);
        }
        macro_key_token.cslid = macroid;
        if (CSL3.MODULE_MACROS[mkey]) {
          macro_key_token.juris = mkey;
          this.opt.update_mode = CSL3.POSITION;
        }
        CSL3.Node.group.build.call(macro_key_token, this, target, true);
        if (!this.cslXml.getNodeValue(macro_nodes)) {
          CSL3.error('CSL style error: undefined macro "' + mkey + '"');
        }
        var mytarget = CSL3.getMacroTarget.call(this, mkey);
        if (mytarget) {
          CSL3.buildMacro.call(this, mytarget, macro_nodes);
          CSL3.configureMacro.call(this, mytarget);
        }
        if (!this.build.extension) {
          var func = /* @__PURE__ */ function(macro_name) {
            return function(state, Item, item) {
              var next = 0;
              while (next < state.macros[macro_name].length) {
                next = CSL3.tokenExec.call(state, state.macros[macro_name][next], Item, item);
              }
            };
          }(mkey);
          var text_node = new CSL3.Token("text", CSL3.SINGLETON);
          text_node.execs.push(func);
          target.push(text_node);
        }
        end_of_macro = new CSL3.Token("group", CSL3.END);
        end_of_macro.strings.sort_direction = sort_direction;
        if (hasDate) {
          func = function(state) {
            if (state.tmp.extension) {
              state.tmp["doing-macro-with-date"] = false;
            }
          };
          end_of_macro.execs.push(func);
        }
        if (macro_key_token.juris) {
          end_of_macro.juris = mkey;
        }
        CSL3.Node.group.build.call(end_of_macro, this, target, true);
        this.build.macro_stack.pop();
      };
      CSL3.getMacroTarget = function(mkey) {
        var mytarget = false;
        if (this.build.extension) {
          mytarget = this[this.build.root + this.build.extension].tokens;
        } else if (!this.macros[mkey]) {
          mytarget = [];
          this.macros[mkey] = mytarget;
        }
        return mytarget;
      };
      CSL3.buildMacro = function(mytarget, macro_nodes) {
        var builder = CSL3.makeBuilder(this, mytarget);
        var mynode;
        if ("undefined" === typeof macro_nodes.length) {
          mynode = macro_nodes;
        } else {
          mynode = macro_nodes[0];
        }
        builder(mynode);
      };
      CSL3.configureMacro = function(mytarget) {
        if (!this.build.extension) {
          this.configureTokenList(mytarget);
        }
      };
      CSL3.XmlToToken = function(state, tokentype, explicitTarget, var_stack) {
        var name, txt, attrfuncs, attributes, decorations, token, key, target;
        name = state.cslXml.nodename(this);
        if (state.build.skip && state.build.skip !== name) {
          return;
        }
        if (!name) {
          txt = state.cslXml.content(this);
          if (txt) {
            state.build.text = txt;
          }
          return;
        }
        if (!CSL3.Node[state.cslXml.nodename(this)]) {
          CSL3.error('Undefined node name "' + name + '".');
        }
        attrfuncs = [];
        attributes = state.cslXml.attributes(this);
        decorations = CSL3.setDecorations.call(this, state, attributes);
        token = new CSL3.Token(name, tokentype);
        if (tokentype !== CSL3.END || name === "if" || name === "else-if" || name === "layout") {
          for (var key in attributes) {
            if (attributes.hasOwnProperty(key)) {
              if (tokentype === CSL3.END && key !== "@language" && key !== "@locale") {
                continue;
              }
              if (attributes.hasOwnProperty(key)) {
                if (CSL3.Attributes[key]) {
                  try {
                    CSL3.Attributes[key].call(token, state, "" + attributes[key]);
                  } catch (e) {
                    CSL3.error(key + " attribute: " + e);
                  }
                } else {
                  CSL3.debug('warning: undefined attribute "' + key + '" in style');
                }
              }
            }
          }
          token.decorations = decorations;
          if (CSL3.DATE_VARIABLES.indexOf(attributes["@variable"]) > -1) {
            var_stack.push(token.variables);
          }
        } else if (tokentype === CSL3.END && attributes["@variable"]) {
          token.hasVariable = true;
          if (CSL3.DATE_VARIABLES.indexOf(attributes["@variable"]) > -1) {
            token.variables = var_stack.pop();
          }
        }
        if (explicitTarget) {
          target = explicitTarget;
        } else {
          target = state[state.build.area].tokens;
        }
        CSL3.Node[name].build.call(token, state, target, true);
      };
      CSL3.DateParser = function() {
        var epochPairs = [
          ["\u660E\u6CBB", 1867],
          ["\u5927\u6B63", 1911],
          ["\u662D\u548C", 1925],
          ["\u5E73\u6210", 1988]
        ];
        var epochYearByName = {};
        for (var i = 0, ilen = epochPairs.length; i < ilen; i++) {
          var key = epochPairs[i][0];
          var val = epochPairs[i][1];
          epochYearByName[key] = val;
        }
        var epochMatchStrings = [];
        var epochMap = {};
        for (var i = 0, ilen = epochPairs.length; i < ilen; i++) {
          var pair = epochPairs[i];
          var val = pair[0];
          epochMatchStrings.push(val);
          epochMap[pair[0]] = pair[1];
        }
        var epochMatchString = epochMatchStrings.join("|");
        var epochSplitter = new RegExp("(?:" + epochMatchString + ")(?:[0-9]+)");
        var epochMatcher = new RegExp("(?:" + epochMatchString + ")(?:[0-9]+)", "g");
        var kanjiMonthDay = /(\u6708|\u5E74)/g;
        var kanjiYear = /\u65E5/g;
        var kanjiRange = /\u301c/g;
        var yearLast = "(?:[?0-9]{1,2}%%NUMD%%){0,2}[?0-9]{4}(?![0-9])";
        var yearFirst = "[?0-9]{4}(?:%%NUMD%%[?0-9]{1,2}){0,2}(?![0-9])";
        var numberVal = "[?0-9]{1,3}";
        var rangeSeparator = "[%%DATED%%]";
        var fuzzyChar = "[?~]";
        var chars = "[^-/~?0-9]+";
        var rexString = "(" + yearFirst + "|" + yearLast + "|" + numberVal + "|" + rangeSeparator + "|" + fuzzyChar + "|" + chars + ")";
        var rexDash = new RegExp(rexString.replace(/%%NUMD%%/g, "-").replace(/%%DATED%%/g, "-"));
        var rexDashSlash = new RegExp(rexString.replace(/%%NUMD%%/g, "-").replace(/%%DATED%%/g, "/"));
        var rexSlashDash = new RegExp(rexString.replace(/%%NUMD%%/g, "/").replace(/%%DATED%%/g, "-"));
        var monthString = "january february march april may june july august september october november december spring summer fall winter spring summer";
        this.monthStrings = monthString.split(" ");
        this.setOrderDayMonth = function() {
          this.monthGuess = 1;
          this.dayGuess = 0;
        };
        this.setOrderMonthDay = function() {
          this.monthGuess = 0;
          this.dayGuess = 1;
        };
        this.resetDateParserMonths = function() {
          this.monthSets = [];
          for (var i2 = 0, ilen2 = this.monthStrings.length; i2 < ilen2; i2++) {
            this.monthSets.push([this.monthStrings[i2]]);
          }
          this.monthAbbrevs = [];
          for (var i2 = 0, ilen2 = this.monthSets.length; i2 < ilen2; i2++) {
            this.monthAbbrevs.push([]);
            for (var j = 0, jlen = this.monthSets[i2].length; j < jlen; j++) {
              this.monthAbbrevs[i2].push(this.monthSets[i2][0].slice(0, 3));
            }
          }
          this.monthRexes = [];
          for (var i2 = 0, ilen2 = this.monthAbbrevs.length; i2 < ilen2; i2++) {
            this.monthRexes.push(new RegExp("(?:" + this.monthAbbrevs[i2].join("|") + ")"));
          }
        };
        this.addDateParserMonths = function(lst) {
          if ("string" === typeof lst) {
            lst = lst.split(/\s+/);
          }
          if (lst.length !== 12 && lst.length !== 16) {
            CSL3.debug("month [+season] list of " + lst.length + ", expected 12 or 16. Ignoring.");
            return;
          }
          for (var i2 = 0, ilen2 = lst.length; i2 < ilen2; i2++) {
            var abbrevLength = null;
            var skip = false;
            var insert = 3;
            var extendedSets = {};
            for (var j = 0, jlen = this.monthAbbrevs.length; j < jlen; j++) {
              extendedSets[j] = {};
              if (j === i2) {
                for (var k = 0, klen = this.monthAbbrevs[i2].length; k < klen; k++) {
                  if (this.monthAbbrevs[i2][k] === lst[i2].slice(0, this.monthAbbrevs[i2][k].length)) {
                    skip = true;
                    break;
                  }
                }
              } else {
                for (var k = 0, klen = this.monthAbbrevs[j].length; k < klen; k++) {
                  abbrevLength = this.monthAbbrevs[j][k].length;
                  if (this.monthAbbrevs[j][k] === lst[i2].slice(0, abbrevLength)) {
                    while (this.monthSets[j][k].slice(0, abbrevLength) === lst[i2].slice(0, abbrevLength)) {
                      if (abbrevLength > lst[i2].length || abbrevLength > this.monthSets[j][k].length) {
                        CSL3.debug("unable to disambiguate month string in date parser: " + lst[i2]);
                        break;
                      } else {
                        abbrevLength += 1;
                      }
                    }
                    insert = abbrevLength;
                    extendedSets[j][k] = abbrevLength;
                  }
                }
              }
              for (var jKey in extendedSets) {
                for (var kKey in extendedSets[jKey]) {
                  abbrevLength = extendedSets[jKey][kKey];
                  jKey = parseInt(jKey, 10);
                  kKey = parseInt(kKey, 10);
                  this.monthAbbrevs[jKey][kKey] = this.monthSets[jKey][kKey].slice(0, abbrevLength);
                }
              }
            }
            if (!skip) {
              this.monthSets[i2].push(lst[i2]);
              this.monthAbbrevs[i2].push(lst[i2].slice(0, insert));
            }
          }
          this.monthRexes = [];
          this.monthRexStrs = [];
          for (var i2 = 0, ilen2 = this.monthAbbrevs.length; i2 < ilen2; i2++) {
            this.monthRexes.push(new RegExp("^(?:" + this.monthAbbrevs[i2].join("|") + ")"));
            this.monthRexStrs.push("^(?:" + this.monthAbbrevs[i2].join("|") + ")");
          }
          if (this.monthAbbrevs.length === 18) {
            for (var i2 = 12, ilen2 = 14; i2 < ilen2; i2++) {
              this.monthRexes[i2 + 4] = new RegExp("^(?:" + this.monthAbbrevs[i2].join("|") + ")");
              this.monthRexStrs[i2 + 4] = "^(?:" + this.monthAbbrevs[i2].join("|") + ")";
            }
          }
        };
        this.convertDateObjectToArray = function(thedate) {
          thedate["date-parts"] = [];
          thedate["date-parts"].push([]);
          var slicelen = 0;
          var part;
          for (var i2 = 0, ilen2 = 3; i2 < ilen2; i2++) {
            part = ["year", "month", "day"][i2];
            if (!thedate[part]) {
              break;
            }
            slicelen += 1;
            thedate["date-parts"][0].push(thedate[part]);
            delete thedate[part];
          }
          thedate["date-parts"].push([]);
          for (var i2 = 0, ilen2 = slicelen; i2 < ilen2; i2++) {
            part = ["year_end", "month_end", "day_end"][i2];
            if (!thedate[part]) {
              break;
            }
            thedate["date-parts"][1].push(thedate[part]);
            delete thedate[part];
          }
          if (thedate["date-parts"][0].length !== thedate["date-parts"][1].length) {
            thedate["date-parts"].pop();
          }
          return thedate;
        };
        this.convertDateObjectToString = function(thedate) {
          var ret = [];
          for (var i2 = 0, ilen2 = 3; i2 < ilen2; i2 += 1) {
            if (thedate[CSL3.DATE_PARTS_ALL[i2]]) {
              ret.push(thedate[CSL3.DATE_PARTS_ALL[i2]]);
            } else {
              break;
            }
          }
          return ret.join("-");
        };
        this._parseNumericDate = function(ret, delim, suff, txt) {
          if (!suff) {
            suff = "";
          }
          var lst = txt.split(delim);
          for (var i2 = 0, ilen2 = lst.length; i2 < ilen2; i2++) {
            if (lst[i2].length === 4) {
              ret["year" + suff] = lst[i2].replace(/^0*/, "");
              if (!i2) {
                lst = lst.slice(1);
              } else {
                lst = lst.slice(0, i2);
              }
              break;
            }
          }
          for (var i2 = 0, ilen2 = lst.length; i2 < ilen2; i2++) {
            lst[i2] = parseInt(lst[i2], 10);
          }
          if (lst.length === 1 || lst.length === 2 && !lst[1]) {
            var month = lst[0];
            if (month) {
              ret["month" + suff] = "" + lst[0];
            }
          } else if (lst.length === 2) {
            if (lst[this.monthGuess] > 12) {
              var month = lst[this.dayGuess];
              var day = lst[this.monthGuess];
              if (month) {
                ret["month" + suff] = "" + month;
                if (day) {
                  ret["day" + suff] = "" + day;
                }
              }
            } else {
              var month = lst[this.monthGuess];
              var day = lst[this.dayGuess];
              if (month) {
                ret["month" + suff] = "" + month;
                if (day) {
                  ret["day" + suff] = "" + day;
                }
              }
            }
          }
        };
        this.parseDateToObject = function(txt) {
          var orig = txt;
          var slashPos = -1;
          var dashPos = -1;
          var yearIsNegative = false;
          var lst;
          if (txt) {
            txt = txt.replace(/^(.*[0-9])T[0-9].*/, "$1");
            if (txt.slice(0, 1) === "-") {
              yearIsNegative = true;
              txt = txt.slice(1);
            }
            if (txt.match(/^[0-9]{1,3}$/)) {
              while (txt.length < 4) {
                txt = "0" + txt;
              }
            }
            txt = "" + txt;
            txt = txt.replace(/\s*[0-9]{2}:[0-9]{2}(?::[0-9]+)/, "");
            var m = txt.match(kanjiMonthDay);
            if (m) {
              txt = txt.replace(/\s+/g, "");
              txt = txt.replace(kanjiYear, "");
              txt = txt.replace(kanjiMonthDay, "-");
              txt = txt.replace(kanjiRange, "/");
              txt = txt.replace(/\-\//g, "/");
              txt = txt.replace(/-$/g, "");
              var slst = txt.split(epochSplitter);
              lst = [];
              var mm = txt.match(epochMatcher);
              if (mm) {
                var mmx = [];
                for (var i2 = 0, ilen2 = mm.length; i2 < ilen2; i2++) {
                  mmx = mmx.concat(mm[i2].match(/([^0-9]+)([0-9]+)/).slice(1));
                }
                for (var i2 = 0, ilen2 = slst.length; i2 < ilen2; i2++) {
                  lst.push(slst[i2]);
                  if (i2 !== ilen2 - 1) {
                    var mmpos = i2 * 2;
                    lst.push(mmx[mmpos]);
                    lst.push(mmx[mmpos + 1]);
                  }
                }
              } else {
                lst = slst;
              }
              for (var i2 = 1, ilen2 = lst.length; i2 < ilen2; i2 += 3) {
                lst[i2 + 1] = epochMap[lst[i2]] + parseInt(lst[i2 + 1], 10);
                lst[i2] = "";
              }
              txt = lst.join("");
              txt = txt.replace(/\s*-\s*$/, "").replace(/\s*-\s*\//, "/");
              txt = txt.replace(/\.\s*$/, "");
              txt = txt.replace(/\.(?! )/, "");
              slashPos = txt.indexOf("/");
              dashPos = txt.indexOf("-");
            }
          }
          txt = txt.replace(/([A-Za-z])\./g, "$1");
          var number = "";
          var note = "";
          var thedate = {};
          var rangeDelim;
          var dateDelim;
          if (txt.slice(0, 1) === '"' && txt.slice(-1) === '"') {
            thedate.literal = txt.slice(1, -1);
            return thedate;
          }
          if (slashPos > -1 && dashPos > -1) {
            var slashCount = txt.split("/");
            if (slashCount.length > 3) {
              rangeDelim = "-";
              txt = txt.replace(/\_/g, "-");
              dateDelim = "/";
              lst = txt.split(rexSlashDash);
            } else {
              rangeDelim = "/";
              txt = txt.replace(/\_/g, "/");
              dateDelim = "-";
              lst = txt.split(rexDashSlash);
            }
          } else {
            txt = txt.replace(/\//g, "-");
            txt = txt.replace(/\_/g, "-");
            rangeDelim = "-";
            dateDelim = "-";
            lst = txt.split(rexDash);
          }
          var ret = [];
          for (var i2 = 0, ilen2 = lst.length; i2 < ilen2; i2++) {
            var m = lst[i2].match(/^\s*([\-\/]|[^\-\/\~\?0-9]+|[\-~?0-9]+)\s*$/);
            if (m) {
              ret.push(m[1]);
            }
          }
          var delimPos = ret.indexOf(rangeDelim);
          var delims = [];
          var isRange = false;
          if (delimPos > -1) {
            delims.push([0, delimPos]);
            delims.push([delimPos + 1, ret.length]);
            isRange = true;
          } else {
            delims.push([0, ret.length]);
          }
          var suff = "";
          for (var i2 = 0, ilen2 = delims.length; i2 < ilen2; i2++) {
            var delim = delims[i2];
            var date = ret.slice(delim[0], delim[1]);
            outer:
              for (var j = 0, jlen = date.length; j < jlen; j++) {
                var element = date[j];
                if (element.indexOf(dateDelim) > -1) {
                  this._parseNumericDate(thedate, dateDelim, suff, element);
                  continue;
                }
                if (element.match(/[0-9]{4}/)) {
                  thedate["year" + suff] = element.replace(/^0*/, "");
                  continue;
                }
                if (element === "~" || element === "?" || element === "c" || element.match(/^cir/)) {
                  thedate.circa = true;
                }
                for (var k = 0, klen = this.monthRexes.length; k < klen; k++) {
                  if (element.toLocaleLowerCase().match(this.monthRexes[k])) {
                    thedate["month" + suff] = "" + (parseInt(k, 10) + 1);
                    continue outer;
                  }
                }
                if (element.match(/^[0-9]+$/)) {
                  number = element;
                }
                if (element.toLocaleLowerCase().match(/^bc/) && number) {
                  thedate["year" + suff] = "" + number * -1;
                  number = "";
                  continue;
                }
                if (element.toLocaleLowerCase().match(/^ad/) && number) {
                  thedate["year" + suff] = "" + number;
                  number = "";
                  continue;
                }
                if (element.toLocaleLowerCase().match(/(?:mic|tri|hil|eas)/) && !thedate["season" + suff]) {
                  note = element;
                  continue;
                }
              }
            if (number) {
              thedate["day" + suff] = number;
              number = "";
            }
            if (note && !thedate["season" + suff]) {
              thedate["season" + suff] = note.trim();
              note = "";
            }
            suff = "_end";
          }
          if (isRange) {
            for (var j = 0, jlen = CSL3.DATE_PARTS_ALL.length; j < jlen; j++) {
              var item = CSL3.DATE_PARTS_ALL[j];
              if (thedate[item] && !thedate[item + "_end"]) {
                thedate[item + "_end"] = thedate[item];
              } else if (!thedate[item] && thedate[item + "_end"]) {
                thedate[item] = thedate[item + "_end"];
              }
            }
          }
          if (!thedate.year || thedate.year && thedate.day && !thedate.month) {
            thedate = { "literal": orig };
          }
          var parts = ["year", "month", "day", "year_end", "month_end", "day_end"];
          for (var i2 = 0, ilen2 = parts.length; i2 < ilen2; i2++) {
            var part = parts[i2];
            if ("string" === typeof thedate[part] && thedate[part].match(/^[0-9]+$/)) {
              thedate[part] = parseInt(thedate[part], 10);
            }
          }
          if (yearIsNegative && Object.keys(thedate).indexOf("year") > -1) {
            thedate.year = thedate.year * -1;
          }
          return thedate;
        };
        this.parseDateToArray = function(txt) {
          return this.convertDateObjectToArray(this.parseDateToObject(txt));
        };
        this.parseDateToString = function(txt) {
          return this.convertDateObjectToString(this.parseDateToObject(txt));
        };
        this.parse = function(txt) {
          return this.parseDateToObject(txt);
        };
        this.setOrderMonthDay();
        this.resetDateParserMonths();
      };
      CSL3.DateParser = new CSL3.DateParser();
      CSL3.Engine = function(sys, style, lang, forceLang) {
        var attrs, langspec;
        this.processor_version = CSL3.PROCESSOR_VERSION;
        this.csl_version = "1.0";
        this.sys = sys;
        if (typeof Object.assign != "function") {
          Object.defineProperty(Object, "assign", {
            value: function assign(target) {
              "use strict";
              if (target == null) {
                throw new TypeError("Cannot convert undefined or null to object");
              }
              var to = Object(target);
              for (var index = 1; index < arguments.length; index++) {
                var nextSource = arguments[index];
                if (nextSource != null) {
                  for (var nextKey in nextSource) {
                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                      to[nextKey] = nextSource[nextKey];
                    }
                  }
                }
              }
              return to;
            },
            writable: true,
            configurable: true
          });
        }
        if (sys.variableWrapper) {
          CSL3.VARIABLE_WRAPPER_PREPUNCT_REX = new RegExp("^([" + [" "].concat(CSL3.SWAPPING_PUNCTUATION).join("") + "]*)(.*)");
        }
        if (CSL3.retrieveStyleModule) {
          this.sys.retrieveStyleModule = CSL3.retrieveStyleModule;
        }
        if (CSL3.getAbbreviation) {
          this.sys.getAbbreviation = CSL3.getAbbreviation;
        }
        if (this.sys.stringCompare) {
          CSL3.stringCompare = this.sys.stringCompare;
        }
        this.sys.AbbreviationSegments = CSL3.AbbreviationSegments;
        this.transform = new CSL3.Transform(this);
        this.setParseNames = function(val) {
          this.opt["parse-names"] = val;
        };
        this.opt = new CSL3.Engine.Opt();
        this.tmp = new CSL3.Engine.Tmp();
        this.build = new CSL3.Engine.Build();
        this.fun = new CSL3.Engine.Fun(this);
        this.configure = new CSL3.Engine.Configure();
        this.citation_sort = new CSL3.Engine.CitationSort();
        this.bibliography_sort = new CSL3.Engine.BibliographySort();
        this.citation = new CSL3.Engine.Citation(this);
        this.bibliography = new CSL3.Engine.Bibliography();
        this.intext = new CSL3.Engine.InText();
        this.output = new CSL3.Output.Queue(this);
        this.dateput = new CSL3.Output.Queue(this);
        this.cslXml = CSL3.setupXml(style);
        for (var i in CSL3.SYS_OPTIONS) {
          var option = CSL3.SYS_OPTIONS[i];
          if ("boolean" === typeof this.sys[option]) {
            this.opt.development_extensions[option] = this.sys[option];
          }
        }
        if (this.opt.development_extensions.uppercase_subtitles || this.opt.development_extensions.implicit_short_title) {
          this.opt.development_extensions.main_title_from_short_title = true;
        }
        if (this.opt.development_extensions.csl_reverse_lookup_support) {
          this.build.cslNodeId = 0;
          this.setCslNodeIds = function(myxml, nodename) {
            var children = this.cslXml.children(myxml);
            this.cslXml.setAttribute(myxml, "cslid", this.build.cslNodeId);
            this.opt.nodenames.push(nodename);
            this.build.cslNodeId += 1;
            for (var i2 = 0, ilen = this.cslXml.numberofnodes(children); i2 < ilen; i2 += 1) {
              nodename = this.cslXml.nodename(children[i2]);
              if (nodename) {
                this.setCslNodeIds(children[i2], nodename);
              }
            }
          };
          this.setCslNodeIds(this.cslXml.dataObj, "style");
        }
        this.cslXml.addMissingNameNodes(this.cslXml.dataObj);
        this.cslXml.addInstitutionNodes(this.cslXml.dataObj);
        this.cslXml.insertPublisherAndPlace(this.cslXml.dataObj);
        this.cslXml.flagDateMacros(this.cslXml.dataObj);
        attrs = this.cslXml.attributes(this.cslXml.dataObj);
        if ("undefined" === typeof attrs["@sort-separator"]) {
          this.cslXml.setAttribute(this.cslXml.dataObj, "sort-separator", ", ");
        }
        this.opt["initialize-with-hyphen"] = true;
        this.setStyleAttributes();
        this.opt.xclass = this.cslXml.getAttributeValue(this.cslXml.dataObj, "class");
        this.opt["class"] = this.opt.xclass;
        this.opt.styleID = this.cslXml.getStyleId(this.cslXml.dataObj);
        this.opt.styleName = this.cslXml.getStyleId(this.cslXml.dataObj, true);
        if (this.opt.version.slice(0, 4) === "1.1m") {
          this.opt.development_extensions.consolidate_legal_items = true;
          this.opt.development_extensions.consolidate_container_items = true;
          this.opt.development_extensions.main_title_from_short_title = true;
          this.opt.development_extensions.expect_and_symbol_form = true;
          this.opt.development_extensions.require_explicit_legal_case_title_short = true;
          this.opt.development_extensions.force_jurisdiction = true;
          this.opt.development_extensions.force_title_abbrev_fallback = true;
        }
        if (lang) {
          lang = lang.replace("_", "-");
          lang = CSL3.normalizeLocaleStr(lang);
        }
        if (this.opt["default-locale"][0]) {
          this.opt["default-locale"][0] = this.opt["default-locale"][0].replace("_", "-");
          this.opt["default-locale"][0] = CSL3.normalizeLocaleStr(this.opt["default-locale"][0]);
        }
        if (lang && forceLang) {
          this.opt["default-locale"] = [lang];
        }
        if (lang && !forceLang && this.opt["default-locale"][0]) {
          lang = this.opt["default-locale"][0];
        }
        if (this.opt["default-locale"].length === 0) {
          if (!lang) {
            lang = "en-US";
          }
          this.opt["default-locale"].push("en-US");
        }
        if (!lang) {
          lang = this.opt["default-locale"][0];
        }
        langspec = CSL3.localeResolve(lang);
        this.opt.lang = langspec.best;
        this.opt["default-locale"][0] = langspec.best;
        this.locale = {};
        if (!this.opt["default-locale-sort"]) {
          this.opt["default-locale-sort"] = this.opt["default-locale"][0];
        }
        if ("dale|".localeCompare("daleb", this.opt["default-locale-sort"]) > -1) {
          this.opt.sort_sep = "@";
        } else {
          this.opt.sort_sep = "|";
        }
        this.localeConfigure(langspec);
        function makeRegExp2(lst) {
          var lst = lst.slice();
          var ret = new RegExp("(?:(?:[?!:]*\\s+|-|^)(?:" + lst.join("|") + ")(?=[!?:]*\\s+|-|$))", "g");
          return ret;
        }
        this.locale[this.opt.lang].opts["skip-words-regexp"] = makeRegExp2(this.locale[this.opt.lang].opts["skip-words"]);
        this.output.adjust = new CSL3.Output.Queue.adjust(this.getOpt("punctuation-in-quote"));
        this.registry = new CSL3.Registry(this);
        this.macros = {};
        this.build.area = "citation";
        var area_nodes = this.cslXml.getNodesByName(this.cslXml.dataObj, this.build.area);
        this.buildTokenLists(area_nodes, this[this.build.area].tokens);
        this.build.area = "bibliography";
        var area_nodes = this.cslXml.getNodesByName(this.cslXml.dataObj, this.build.area);
        this.buildTokenLists(area_nodes, this[this.build.area].tokens);
        this.build.area = "intext";
        var area_nodes = this.cslXml.getNodesByName(this.cslXml.dataObj, this.build.area);
        this.buildTokenLists(area_nodes, this[this.build.area].tokens);
        if (this.opt.parallel.enable) {
          this.parallel = new CSL3.Parallel(this);
        }
        this.juris = {};
        this.configureTokenLists();
        this.disambiguate = new CSL3.Disambiguation(this);
        this.splice_delimiter = false;
        this.fun.dateparser = CSL3.DateParser;
        this.fun.flipflopper = new CSL3.Util.FlipFlopper(this);
        this.setCloseQuotesArray();
        this.fun.ordinalizer.init(this);
        this.fun.long_ordinalizer.init(this);
        this.fun.page_mangler = CSL3.Util.PageRangeMangler.getFunction(this, "page");
        this.fun.year_mangler = CSL3.Util.PageRangeMangler.getFunction(this, "year");
        this.setOutputFormat("html");
      };
      CSL3.Engine.prototype.setCloseQuotesArray = function() {
        var ret;
        ret = [];
        ret.push(this.getTerm("close-quote"));
        ret.push(this.getTerm("close-inner-quote"));
        ret.push('"');
        ret.push("'");
        this.opt.close_quotes_array = ret;
      };
      CSL3.makeBuilder = function(me, target) {
        var var_stack = [];
        var node_stack = [];
        function runStart(node) {
          node_stack.push(node);
          CSL3.XmlToToken.call(node, me, CSL3.START, target, var_stack);
        }
        function runEnd() {
          var node = node_stack.pop();
          CSL3.XmlToToken.call(node, me, CSL3.END, target, var_stack);
        }
        function runSingle(node) {
          CSL3.XmlToToken.call(node, me, CSL3.SINGLETON, target, var_stack);
        }
        function buildStyle(nodes, parent, node_stack2) {
          if (!node_stack2) {
            node_stack2 = [];
          }
          if (!nodes) {
            nodes = [];
          }
          if ("undefined" === typeof nodes.length) {
            nodes = [nodes];
          }
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (me.cslXml.nodename(node) === null) {
              continue;
            }
            if (parent && me.cslXml.nodename(node) === "date") {
              CSL3.Util.fixDateNode.call(me, parent, i, node);
              node = me.cslXml.children(parent)[i];
            }
            if (me.cslXml.numberofnodes(me.cslXml.children(node))) {
              runStart(node);
              buildStyle(me.cslXml.children(node), node, node_stack2);
              runEnd();
            } else {
              runSingle(node);
            }
          }
        }
        return buildStyle;
      };
      CSL3.Engine.prototype.buildTokenLists = function(area_nodes, target) {
        if (!this.cslXml.getNodeValue(area_nodes)) {
          return;
        }
        var builder = CSL3.makeBuilder(this, target);
        var mynode;
        if ("undefined" === typeof area_nodes.length) {
          mynode = area_nodes;
        } else {
          mynode = area_nodes[0];
        }
        builder(mynode);
      };
      CSL3.Engine.prototype.setStyleAttributes = function() {
        var dummy, attributes, attrname;
        var dummy = {};
        dummy.name = this.cslXml.nodename(this.cslXml.dataObj);
        attributes = this.cslXml.attributes(this.cslXml.dataObj);
        for (attrname in attributes) {
          if (attributes.hasOwnProperty(attrname)) {
            CSL3.Attributes[attrname].call(dummy, this, attributes[attrname]);
          }
        }
      };
      CSL3.Engine.prototype.getTerm = function(term, form, plural, gender, mode, forceDefaultLocale) {
        if (term && term.match(/[A-Z]/) && term === term.toUpperCase()) {
          CSL3.debug("Warning: term key is in uppercase form: " + term);
          term = term.toLowerCase();
        }
        var lang;
        if (forceDefaultLocale) {
          lang = this.opt["default-locale"][0];
        } else {
          lang = this.opt.lang;
        }
        var ret = CSL3.Engine.getField(CSL3.LOOSE, this.locale[lang].terms, term, form, plural, gender);
        if (!ret && term === "range-delimiter") {
          ret = "\u2013";
        }
        if (typeof ret === "undefined") {
          if (mode === CSL3.STRICT) {
            CSL3.error('Error in getTerm: term "' + term + '" does not exist.');
          } else if (mode === CSL3.TOLERANT) {
            ret = "";
          }
        }
        if (ret) {
          this.tmp.cite_renders_content = true;
        }
        return ret;
      };
      CSL3.Engine.prototype.getDate = function(form, forceDefaultLocale) {
        var lang;
        if (forceDefaultLocale) {
          lang = this.opt["default-locale"];
        } else {
          lang = this.opt.lang;
        }
        if (this.locale[lang].dates[form]) {
          return this.locale[lang].dates[form];
        } else {
          return false;
        }
      };
      CSL3.Engine.prototype.getOpt = function(arg) {
        if ("undefined" !== typeof this.locale[this.opt.lang].opts[arg]) {
          return this.locale[this.opt.lang].opts[arg];
        } else {
          return false;
        }
      };
      CSL3.Engine.prototype.getVariable = function(Item, varname, form, plural) {
        return CSL3.Engine.getField(CSL3.LOOSE, Item, varname, form, plural);
      };
      CSL3.Engine.prototype.getDateNum = function(ItemField, partname) {
        if ("undefined" === typeof ItemField) {
          return 0;
        } else {
          return ItemField[partname];
        }
      };
      CSL3.Engine.getField = function(mode, hash, term, form, plural, gender) {
        var ret, forms, f, pos, len, hashterm;
        ret = "";
        if ("undefined" === typeof hash[term]) {
          if (mode === CSL3.STRICT) {
            CSL3.error('Error in getField: term "' + term + '" does not exist.');
          } else {
            return void 0;
          }
        }
        if (gender && hash[term][gender]) {
          hashterm = hash[term][gender];
        } else {
          hashterm = hash[term];
        }
        forms = [];
        if (form === "symbol") {
          forms = ["symbol", "short"];
        } else if (form === "verb-short") {
          forms = ["verb-short", "verb"];
        } else if (form !== "long") {
          forms = [form];
        }
        forms = forms.concat(["long"]);
        len = forms.length;
        for (pos = 0; pos < len; pos += 1) {
          f = forms[pos];
          if ("string" === typeof hashterm || "number" === typeof hashterm) {
            ret = hashterm;
          } else if ("undefined" !== typeof hashterm[f]) {
            if ("string" === typeof hashterm[f] || "number" === typeof hashterm[f]) {
              ret = hashterm[f];
            } else {
              if ("number" === typeof plural) {
                ret = hashterm[f][plural];
              } else {
                ret = hashterm[f][0];
              }
            }
            break;
          }
        }
        return ret;
      };
      CSL3.Engine.prototype.configureTokenLists = function() {
        var area, pos, len;
        len = CSL3.AREAS.length;
        for (pos = 0; pos < len; pos += 1) {
          area = CSL3.AREAS[pos];
          var tokens = this[area].tokens;
          this.configureTokenList(tokens);
        }
        this.version = CSL3.version;
        return this.state;
      };
      CSL3.Engine.prototype.configureTokenList = function(tokens) {
        var dateparts_master, token, dateparts, part, ppos, pppos, llen, lllen;
        dateparts_master = ["year", "month", "day"];
        llen = tokens.length - 1;
        for (ppos = llen; ppos > -1; ppos += -1) {
          token = tokens[ppos];
          if ("date" === token.name && CSL3.END === token.tokentype) {
            dateparts = [];
          }
          if ("date-part" === token.name && token.strings.name) {
            lllen = dateparts_master.length;
            for (pppos = 0; pppos < lllen; pppos += 1) {
              part = dateparts_master[pppos];
              if (part === token.strings.name) {
                dateparts.push(token.strings.name);
              }
            }
          }
          if ("date" === token.name && CSL3.START === token.tokentype) {
            dateparts.reverse();
            token.dateparts = dateparts;
          }
          token.next = ppos + 1;
          if (token.name && CSL3.Node[token.name].configure) {
            CSL3.Node[token.name].configure.call(token, this, ppos);
          }
        }
      };
      CSL3.Engine.prototype.refetchItems = function(ids) {
        var ret = [];
        for (var i = 0, ilen = ids.length; i < ilen; i += 1) {
          ret.push(this.refetchItem("" + ids[i]));
        }
        return ret;
      };
      CSL3.ITERATION = 0;
      CSL3.Engine.prototype.retrieveItem = function(id) {
        var Item, m, i;
        if (!this.tmp.loadedItemIDs[id]) {
          this.tmp.loadedItemIDs[id] = true;
        } else {
          return this.registry.refhash[id];
        }
        if (this.opt.development_extensions.normalize_lang_keys_to_lowercase && "boolean" === typeof this.opt.development_extensions.normalize_lang_keys_to_lowercase) {
          for (var i = 0, ilen = this.opt["default-locale"].length; i < ilen; i += 1) {
            this.opt["default-locale"][i] = this.opt["default-locale"][i].toLowerCase();
          }
          for (var i = 0, ilen = this.opt["locale-translit"].length; i < ilen; i += 1) {
            this.opt["locale-translit"][i] = this.opt["locale-translit"][i].toLowerCase();
          }
          for (var i = 0, ilen = this.opt["locale-translat"].length; i < ilen; i += 1) {
            this.opt["locale-translat"][i] = this.opt["locale-translat"][i].toLowerCase();
          }
          this.opt.development_extensions.normalize_lang_keys_to_lowercase = 100;
        }
        CSL3.ITERATION += 1;
        Item = JSON.parse(JSON.stringify(this.sys.retrieveItem("" + id)));
        if (this.opt.development_extensions.normalize_lang_keys_to_lowercase) {
          if (Item.multi) {
            if (Item.multi._keys) {
              for (var field in Item.multi._keys) {
                for (var key in Item.multi._keys[field]) {
                  if (key !== key.toLowerCase()) {
                    Item.multi._keys[field][key.toLowerCase()] = Item.multi._keys[field][key];
                    delete Item.multi._keys[field][key];
                  }
                }
              }
            }
            if (Item.multi.main) {
              for (var field in Item.multi.main) {
                Item.multi.main[field] = Item.multi.main[field].toLowerCase();
              }
            }
          }
          for (var i = 0, ilen = CSL3.NAME_VARIABLES.length; i > ilen; i += 1) {
            var ctype = CSL3.NAME_VARIABLES[i];
            if (Item[ctype] && Item[ctype].multi) {
              for (var j = 0, jlen = Item[ctype].length; j < jlen; j += 1) {
                var creator = Item[ctype][j];
                if (creator.multi) {
                  if (creator.multi._key) {
                    for (var key in creator.multi._key) {
                      if (key !== key.toLowerCase()) {
                        creator.multi._key[key.toLowerCase()] = creator.multi._key[key];
                        delete creator.multi._key[key];
                      }
                    }
                  }
                  if (creator.multi.main) {
                    creator.multi.main = creator.multi.main.toLowerCase();
                  }
                }
              }
            }
          }
        }
        if (Item.language && Item.language.match(/[><]/)) {
          var m = Item.language.match(/(.*?)([<>])(.*)/);
          if (m[2] === "<") {
            Item["language-name"] = m[1];
            Item["language-name-original"] = m[3];
          } else {
            Item["language-name"] = m[3];
            Item["language-name-original"] = m[1];
          }
          if (this.opt.multi_layout) {
            if (Item["language-name-original"]) {
              Item.language = Item["language-name-original"];
            }
          } else {
            if (Item["language-name"]) {
              Item.language = Item["language-name"];
            }
          }
        }
        if (Item.page) {
          Item["page-first"] = Item.page;
          var num = "" + Item.page;
          var m = num.split(/\s*(?:&|, |-|\u2013)\s*/);
          if (m[0].slice(-1) !== "\\") {
            Item["page-first"] = m[0];
          }
        }
        if (this.opt.development_extensions.field_hack && Item.note) {
          CSL3.parseNoteFieldHacks(Item, false, this.opt.development_extensions.allow_field_hack_date_override);
        }
        for (var key in Item) {
          if (CSL3.DATE_VARIABLES.indexOf(key.replace(/^alt-/, "")) > -1) {
            var dateobj = Item[key];
            if (dateobj) {
              if (this.opt.development_extensions.raw_date_parsing) {
                if (dateobj.raw && (!dateobj["date-parts"] || dateobj["date-parts"].length === 0)) {
                  dateobj = this.fun.dateparser.parseDateToObject(dateobj.raw);
                }
              }
              Item[key] = this.dateParseArray(dateobj);
            }
          }
        }
        if (this.opt.development_extensions.consolidate_legal_items) {
          if (Item.type && ["bill", "gazette", "legislation", "regulation", "treaty"].indexOf(Item.type) > -1) {
            var varname;
            var elements = ["type", "title", "jurisdiction", "genre", "volume", "container-title"];
            var legislation_id = [];
            for (var i = 0, ilen = elements.length; i < ilen; i += 1) {
              varname = elements[i];
              if (Item[varname]) {
                legislation_id.push(Item[varname]);
              }
            }
            elements = ["original-date", "issued"];
            for (var i = 0, ilen = elements.length; i < ilen; i += 1) {
              varname = elements[i];
              if (Item[varname] && Item[varname].year) {
                var value = Item[varname].year;
                legislation_id.push(value);
                break;
              }
            }
            Item.legislation_id = legislation_id.join("::");
          }
        }
        if (this.bibliography.opt.track_container_items) {
          if (this.bibliography.opt.track_container_items.indexOf(Item.type) > -1) {
            var varname;
            var elements = ["type", "container-title", "publisher", "edition"];
            var container_id = [];
            for (var i = 0, ilen = elements.length; i < ilen; i += 1) {
              varname = elements[i];
              if (Item[varname]) {
                container_id.push(Item[varname]);
              }
            }
            Item.container_id = container_id.join("::");
          }
        }
        if (this.opt.development_extensions.force_jurisdiction) {
          if ("string" === typeof Item.authority) {
            Item.authority = [
              {
                literal: Item.authority,
                multi: {
                  _key: {}
                }
              }
            ];
            if (Item.multi && Item.multi._keys && Item.multi._keys.authority) {
              Item.authority[0].multi._key = {};
              for (var key in Item.multi._keys.authority) {
                Item.authority[0].multi._key[key] = {
                  literal: Item.multi._keys.authority[key]
                };
              }
            }
          }
        }
        if (!Item["title-short"]) {
          Item["title-short"] = Item.shortTitle;
        }
        if (this.opt.development_extensions.main_title_from_short_title) {
          var narrowSpaceLocale = this.opt["default-locale"][0].slice(0, 2).toLowerCase() === "fr";
          CSL3.extractTitleAndSubtitle.call(this, Item, narrowSpaceLocale);
        }
        var isLegalType = ["bill", "legal_case", "legislation", "gazette", "regulation"].indexOf(Item.type) > -1;
        if (this.opt.development_extensions.force_jurisdiction && isLegalType) {
          if (!Item.jurisdiction) {
            Item.jurisdiction = "us";
          }
        }
        var normalizedKey;
        if (!isLegalType && Item.title && this.sys.getAbbreviation) {
          var noHints = false;
          if (!Item.jurisdiction) {
            noHints = true;
          }
          if (this.sys.normalizeAbbrevsKey) {
            normalizedKey = this.sys.normalizeAbbrevsKey("title", Item.title);
          } else {
            normalizedKey = Item.title;
          }
          var jurisdiction = this.transform.loadAbbreviation(Item.jurisdiction, "title", normalizedKey, Item.language);
          if (this.transform.abbrevs[jurisdiction].title) {
            if (this.transform.abbrevs[jurisdiction].title[normalizedKey]) {
              Item["title-short"] = this.transform.abbrevs[jurisdiction].title[normalizedKey];
            }
          }
        }
        if (!Item["container-title-short"]) {
          Item["container-title-short"] = Item.journalAbbreviation;
        }
        if (Item["container-title"] && this.sys.getAbbreviation) {
          if (this.sys.normalizeAbbrevsKey) {
            normalizedKey = this.sys.normalizeAbbrevsKey(Item["container-title"]);
          } else {
            normalizedKey = Item["container-title"];
          }
          var jurisdiction = this.transform.loadAbbreviation(Item.jurisdiction, "container-title", normalizedKey, Item.language);
          if (this.transform.abbrevs[jurisdiction]["container-title"]) {
            if (this.transform.abbrevs[jurisdiction]["container-title"][normalizedKey]) {
              Item["container-title-short"] = this.transform.abbrevs[jurisdiction]["container-title"][normalizedKey];
            }
          }
        }
        if (Item.jurisdiction) {
          Item.country = Item.jurisdiction.split(":")[0];
        }
        if (this.registry.refhash[id]) {
          if (JSON.stringify(this.registry.refhash[id]) != JSON.stringify(Item)) {
            for (var key in this.registry.refhash[id]) {
              delete this.registry.refhash[id][key];
            }
            this.tmp.taintedItemIDs[Item.id] = true;
            Object.assign(this.registry.refhash[id], Item);
          }
        } else {
          this.registry.refhash[id] = Item;
        }
        return this.registry.refhash[id];
      };
      CSL3.Engine.prototype.refetchItem = function(id) {
        return this.registry.refhash[id];
      };
      CSL3.Engine.prototype.setOpt = function(token, name, value) {
        if (token.name === "style" || token.name === "cslstyle") {
          this.opt.inheritedAttributes[name] = value;
          this.citation.opt.inheritedAttributes[name] = value;
          this.bibliography.opt.inheritedAttributes[name] = value;
        } else if (["citation", "bibliography"].indexOf(token.name) > -1) {
          this[token.name].opt.inheritedAttributes[name] = value;
        } else {
          token.strings[name] = value;
        }
      };
      CSL3.Engine.prototype.inheritOpt = function(token, attrname, parentname, defaultValue) {
        if ("undefined" !== typeof token.strings[attrname]) {
          return token.strings[attrname];
        } else {
          var parentValue = this[this.tmp.root].opt.inheritedAttributes[parentname ? parentname : attrname];
          if ("undefined" !== typeof parentValue) {
            return parentValue;
          } else {
            return defaultValue;
          }
        }
      };
      CSL3.Engine.prototype.remapSectionVariable = function(inputList) {
        for (var i = 0, ilen = inputList.length; i < ilen; i += 1) {
          var Item = inputList[i][0];
          var item = inputList[i][1];
          if (["bill", "gazette", "legislation", "regulation", "treaty"].indexOf(Item.type) > -1) {
            if (item.locator) {
              item.locator = item.locator.trim();
              var m = item.locator.match(CSL3.STATUTE_SUBDIV_PLAIN_REGEX_FRONT);
              if (!m) {
                if (item.label) {
                  item.locator = CSL3.STATUTE_SUBDIV_STRINGS_REVERSE[item.label] + " " + item.locator;
                } else {
                  item.locator = "p. " + item.locator;
                }
              }
            }
            var sectionMasterLabel = null;
            if (Item.section) {
              Item.section = Item.section.trim();
              var m = Item.section.match(CSL3.STATUTE_SUBDIV_PLAIN_REGEX_FRONT);
              if (!m) {
                Item.section = "sec. " + Item.section;
                sectionMasterLabel = "sec.";
              } else {
                sectionMasterLabel = m[0].trim();
              }
            }
            if (Item.section) {
              if (!item.locator) {
                item.locator = Item.section;
              } else {
                var m = item.locator.match(/^([^ ]*)\s*(.*)/);
                var space = " ";
                if (m) {
                  if (m[1] === "p." && sectionMasterLabel !== "p.") {
                    item.locator = m[2];
                  }
                  if (["[", "(", ".", ",", ";", ":", "?"].indexOf(item.locator.slice(0, 1)) > -1) {
                    space = "";
                  }
                } else {
                  space = "";
                }
                item.locator = Item.section + space + item.locator;
              }
            }
            item.label = "";
          }
        }
      };
      CSL3.Engine.prototype.setNumberLabels = function(Item) {
        if (Item.number && ["bill", "gazette", "legislation", "regulation", "treaty"].indexOf(Item.type) > -1 && this.opt.development_extensions.consolidate_legal_items && !this.tmp.shadow_numbers["number"]) {
          this.tmp.shadow_numbers["number"] = {};
          this.tmp.shadow_numbers["number"].values = [];
          this.tmp.shadow_numbers["number"].plural = 0;
          this.tmp.shadow_numbers["number"].numeric = false;
          this.tmp.shadow_numbers["number"].label = false;
          var value = "" + Item.number;
          value = value.split("\\").join("");
          var firstword = value.split(/\s+/)[0];
          var firstlabel = CSL3.STATUTE_SUBDIV_STRINGS[firstword];
          if (firstlabel) {
            var splt = value.split(CSL3.STATUTE_SUBDIV_PLAIN_REGEX);
            if (splt.length > 1) {
              var lst = [];
              for (var j = 1, jlen = splt.length; j < jlen; j += 1) {
                lst.push(splt[j].replace(/\s*$/, "").replace(/^\s*/, ""));
              }
              value = lst.join(" ");
            } else {
              value = splt[0];
            }
            this.tmp.shadow_numbers["number"].label = firstlabel;
            this.tmp.shadow_numbers["number"].values.push(["Blob", value, false]);
            this.tmp.shadow_numbers["number"].numeric = false;
          } else {
            this.tmp.shadow_numbers["number"].values.push(["Blob", value, false]);
            this.tmp.shadow_numbers["number"].numeric = true;
          }
        }
      };
      CSL3.substituteOne = function(template) {
        return function(state, list) {
          if (!list) {
            return "";
          } else {
            return template.replace("%%STRING%%", list);
          }
        };
      };
      CSL3.substituteTwo = function(template) {
        return function(param) {
          var template2 = template.replace("%%PARAM%%", param);
          return function(state, list) {
            if (!list) {
              return "";
            } else {
              return template2.replace("%%STRING%%", list);
            }
          };
        };
      };
      CSL3.Mode = function(mode) {
        var decorations, params, param, func, val, args;
        decorations = {};
        params = CSL3.Output.Formats[mode];
        for (param in params) {
          if (true) {
            if ("@" !== param.slice(0, 1)) {
              decorations[param] = params[param];
              continue;
            }
            func = false;
            val = params[param];
            args = param.split("/");
            if (typeof val === "string" && val.indexOf("%%STRING%%") > -1) {
              if (val.indexOf("%%PARAM%%") > -1) {
                func = CSL3.substituteTwo(val);
              } else {
                func = CSL3.substituteOne(val);
              }
            } else if (typeof val === "boolean" && !val) {
              func = CSL3.Output.Formatters.passthrough;
            } else if (typeof val === "function") {
              func = val;
            } else {
              CSL3.error("Bad " + mode + " config entry for " + param + ": " + val);
            }
            if (args.length === 1) {
              decorations[args[0]] = func;
            } else if (args.length === 2) {
              if (!decorations[args[0]]) {
                decorations[args[0]] = {};
              }
              decorations[args[0]][args[1]] = func;
            }
          }
        }
        return decorations;
      };
      CSL3.setDecorations = function(state, attributes) {
        var ret, key, pos;
        ret = [];
        for (pos in CSL3.FORMAT_KEY_SEQUENCE) {
          if (true) {
            var key = CSL3.FORMAT_KEY_SEQUENCE[pos];
            if (attributes[key]) {
              ret.push([key, attributes[key]]);
              delete attributes[key];
            }
          }
        }
        return ret;
      };
      CSL3.Doppeler = function(rexStr, stringMangler) {
        var matchRex = new RegExp("(" + rexStr + ")", "g");
        var splitRex = new RegExp(rexStr, "g");
        this.split = function(str) {
          if (stringMangler) {
            str = stringMangler(str);
          }
          var match = str.match(matchRex);
          if (!match) {
            return {
              tags: [],
              strings: [str]
            };
          }
          var split = str.split(splitRex);
          for (var i = match.length - 1; i > -1; i--) {
            if (typeof match[i] === "number") {
              match[i] = "";
            }
            var tag = match[i];
            if (tag === "'" && split[i + 1].length > 0) {
              split[i + 1] = match[i] + split[i + 1];
              match[i] = "";
            }
          }
          return {
            tags: match,
            strings: split,
            origStrings: split.slice()
          };
        };
        this.join = function(obj) {
          var lst = obj.strings.slice(-1);
          for (var i = obj.tags.length - 1; i > -1; i--) {
            lst.push(obj.tags[i]);
            lst.push(obj.strings[i]);
          }
          lst.reverse();
          return lst.join("");
        };
      };
      CSL3.Engine.prototype.normalDecorIsOrphan = function(blob, params) {
        if (params[1] === "normal") {
          var use_param = false;
          var all_the_decor;
          if (this.tmp.area === "citation") {
            all_the_decor = [this.citation.opt.layout_decorations].concat(blob.alldecor);
          } else {
            all_the_decor = blob.alldecor;
          }
          for (var k = all_the_decor.length - 1; k > -1; k += -1) {
            for (var n = all_the_decor[k].length - 1; n > -1; n += -1) {
              if (all_the_decor[k][n][0] === params[0]) {
                if (all_the_decor[k][n][1] !== "normal") {
                  use_param = true;
                }
              }
            }
          }
          if (!use_param) {
            return true;
          }
        }
        return false;
      };
      CSL3.Engine.prototype.getCitationLabel = function(Item) {
        var label = "";
        var params = this.getTrigraphParams();
        var config = params[0];
        var myname = this.getTerm("reference", "short", 0);
        if ("undefined" === typeof myname) {
          myname = "reference";
        }
        myname = myname.replace(".", "");
        myname = myname.slice(0, 1).toUpperCase() + myname.slice(1);
        for (var i = 0, ilen = CSL3.NAME_VARIABLES.length; i < ilen; i += 1) {
          var n = CSL3.NAME_VARIABLES[i];
          if (Item[n]) {
            var names = Item[n];
            if (names.length > params.length) {
              config = params[params.length - 1];
            } else {
              config = params[names.length - 1];
            }
            for (var j = 0, jlen = names.length; j < jlen; j += 1) {
              if (j === config.authors.length) {
                break;
              }
              var res = this.nameOutput.getName(names[j], "locale-translit", true);
              var name = res.name;
              if (name && name.family) {
                myname = name.family;
                myname = myname.replace(/^([ \'\u2019a-z]+\s+)/, "");
              } else if (name && name.literal) {
                myname = name.literal;
              }
              var m = myname.toLowerCase().match(/^(a\s+|the\s+|an\s+)/);
              if (m) {
                myname = myname.slice(m[1].length);
              }
              myname = myname.replace(CSL3.ROMANESQUE_NOT_REGEXP, "");
              if (!myname) {
                break;
              }
              myname = myname.slice(0, config.authors[j]);
              if (myname.length > 1) {
                myname = myname.slice(0, 1).toUpperCase() + myname.slice(1).toLowerCase();
              } else if (myname.length === 1) {
                myname = myname.toUpperCase();
              }
              label += myname;
            }
            break;
          }
        }
        if (!label) {
          if (Item.title) {
            var skipWords = this.locale[this.opt.lang].opts["skip-words"];
            var lst = Item.title.split(/\s+/);
            for (var i = lst.length - 1; i > -1; i--) {
              if (skipWords.indexOf(lst[i]) > -1) {
                lst = lst.slice(0, i).concat(lst.slice(i + 1));
              }
            }
            var str = lst.join("");
            str = str.slice(0, params[0].authors[0]);
            if (str.length > 1) {
              str = str.slice(0, 1).toUpperCase() + str.slice(1).toLowerCase();
            } else if (str.length === 1) {
              str = str.toUpperCase();
            }
            label = str;
          }
        }
        var year = "0000";
        if (Item.issued) {
          if (Item.issued.year) {
            year = "" + Item.issued.year;
          }
        }
        year = year.slice(config.year * -1);
        label = label + year;
        return label;
      };
      CSL3.Engine.prototype.getTrigraphParams = function() {
        var params = [];
        var ilst = this.opt.trigraph.split(":");
        if (!this.opt.trigraph || this.opt.trigraph.slice(0, 1) !== "A") {
          CSL3.error("Bad trigraph definition: " + this.opt.trigraph);
        }
        for (var i = 0, ilen = ilst.length; i < ilen; i += 1) {
          var str = ilst[i];
          var config = { authors: [], year: 0 };
          for (var j = 0, jlen = str.length; j < jlen; j += 1) {
            switch (str.slice(j, j + 1)) {
              case "A":
                config.authors.push(1);
                break;
              case "a":
                config.authors[config.authors.length - 1] += 1;
                break;
              case "0":
                config.year += 1;
                break;
              default:
                CSL3.error("Invalid character in trigraph definition: " + this.opt.trigraph);
            }
          }
          params.push(config);
        }
        return params;
      };
      CSL3.Engine.prototype.setOutputFormat = function(mode) {
        this.opt.mode = mode;
        this.fun.decorate = CSL3.Mode(mode);
        if (!this.output[mode]) {
          this.output[mode] = {};
          this.output[mode].tmp = {};
        }
      };
      CSL3.Engine.prototype.getSortFunc = function() {
        return function(a, b) {
          a = a.split("-");
          b = b.split("-");
          if (a.length < b.length) {
            return 1;
          } else if (a.length > b.length) {
            return -1;
          } else {
            a = a.slice(-1)[0];
            b = b.slice(-1)[0];
            if (a.length < b.length) {
              return 1;
            } else if (a.length > b.length) {
              return -1;
            } else {
              return 0;
            }
          }
        };
      };
      CSL3.Engine.prototype.setLangTagsForCslSort = function(tags) {
        var i, ilen;
        if (tags) {
          this.opt["locale-sort"] = [];
          for (i = 0, ilen = tags.length; i < ilen; i += 1) {
            this.opt["locale-sort"].push(tags[i]);
          }
        }
        this.opt["locale-sort"].sort(this.getSortFunc());
      };
      CSL3.Engine.prototype.setLangTagsForCslTransliteration = function(tags) {
        var i, ilen;
        this.opt["locale-translit"] = [];
        if (tags) {
          for (i = 0, ilen = tags.length; i < ilen; i += 1) {
            this.opt["locale-translit"].push(tags[i]);
          }
        }
        this.opt["locale-translit"].sort(this.getSortFunc());
      };
      CSL3.Engine.prototype.setLangTagsForCslTranslation = function(tags) {
        var i, ilen;
        this.opt["locale-translat"] = [];
        if (tags) {
          for (i = 0, ilen = tags.length; i < ilen; i += 1) {
            this.opt["locale-translat"].push(tags[i]);
          }
        }
        this.opt["locale-translat"].sort(this.getSortFunc());
      };
      CSL3.Engine.prototype.setLangPrefsForCites = function(obj, conv) {
        var opt = this.opt["cite-lang-prefs"];
        if (!conv) {
          conv = function(key) {
            return key.toLowerCase();
          };
        }
        var segments = ["Persons", "Institutions", "Titles", "Journals", "Publishers", "Places"];
        for (var i = 0, ilen = segments.length; i < ilen; i += 1) {
          var clientSegment = conv(segments[i]);
          var citeprocSegment = segments[i].toLowerCase();
          if (!obj[clientSegment]) {
            continue;
          }
          var supplements = [];
          while (obj[clientSegment].length > 1) {
            supplements.push(obj[clientSegment].pop());
          }
          var sortval = { orig: 1, translit: 2, translat: 3 };
          if (supplements.length === 2 && sortval[supplements[0]] < sortval[supplements[1]]) {
            supplements.reverse();
          }
          while (supplements.length) {
            obj[clientSegment].push(supplements.pop());
          }
          var lst = opt[citeprocSegment];
          while (lst.length) {
            lst.pop();
          }
          for (var j = 0, jlen = obj[clientSegment].length; j < jlen; j += 1) {
            lst.push(obj[clientSegment][j]);
          }
        }
      };
      CSL3.Engine.prototype.setLangPrefsForCiteAffixes = function(affixList) {
        if (affixList && affixList.length === 48) {
          var affixes = this.opt.citeAffixes;
          var count = 0;
          var settings = ["persons", "institutions", "titles", "journals", "publishers", "places"];
          var forms = ["translit", "orig", "translit", "translat"];
          var value;
          for (var i = 0, ilen = settings.length; i < ilen; i += 1) {
            for (var j = 0, jlen = forms.length; j < jlen; j += 1) {
              value = "";
              if (count % 8 === 4) {
                if (!affixes[settings[i]]["locale-" + forms[j]].prefix && !affixes[settings[i]]["locale-" + forms[j]].suffix) {
                  value = affixList[count] ? affixList[count] : "";
                  affixes[settings[i]]["locale-" + forms[j]].prefix = value;
                  value = affixList[count] ? affixList[count + 1] : "";
                  affixes[settings[i]]["locale-" + forms[j]].suffix = value;
                }
              } else {
                value = affixList[count] ? affixList[count] : "";
                affixes[settings[i]]["locale-" + forms[j]].prefix = value;
                value = affixList[count] ? affixList[count + 1] : "";
                affixes[settings[i]]["locale-" + forms[j]].suffix = value;
              }
              count += 2;
            }
          }
          this.opt.citeAffixes = affixes;
        }
      };
      CSL3.Engine.prototype.setAutoVietnameseNamesOption = function(arg) {
        if (arg) {
          this.opt["auto-vietnamese-names"] = true;
        } else {
          this.opt["auto-vietnamese-names"] = false;
        }
      };
      CSL3.Engine.prototype.setAbbreviations = function(arg) {
        if (this.sys.setAbbreviations) {
          this.sys.setAbbreviations(arg);
        }
      };
      CSL3.Engine.prototype.setSuppressTrailingPunctuation = function(arg) {
        this.citation.opt.suppressTrailingPunctuation = !!arg;
      };
      CSL3.Output = {};
      CSL3.Output.Queue = function(state) {
        this.levelname = ["top"];
        this.state = state;
        this.queue = [];
        this.empty = new CSL3.Token("empty");
        var tokenstore = {};
        tokenstore.empty = this.empty;
        this.formats = new CSL3.Stack(tokenstore);
        this.current = new CSL3.Stack(this.queue);
      };
      CSL3.Output.Queue.prototype.pop = function() {
        var drip = this.current.value();
        if (drip.length) {
          return drip.pop();
        } else {
          return drip.blobs.pop();
        }
      };
      CSL3.Output.Queue.prototype.getToken = function(name) {
        var ret = this.formats.value()[name];
        return ret;
      };
      CSL3.Output.Queue.prototype.mergeTokenStrings = function(base, modifier) {
        var base_token, modifier_token, ret, key;
        base_token = this.formats.value()[base];
        modifier_token = this.formats.value()[modifier];
        ret = base_token;
        if (modifier_token) {
          if (!base_token) {
            base_token = new CSL3.Token(base, CSL3.SINGLETON);
            base_token.decorations = [];
          }
          ret = new CSL3.Token(base, CSL3.SINGLETON);
          var key = "";
          for (var key in base_token.strings) {
            if (base_token.strings.hasOwnProperty(key)) {
              ret.strings[key] = base_token.strings[key];
            }
          }
          for (var key in modifier_token.strings) {
            if (modifier_token.strings.hasOwnProperty(key)) {
              ret.strings[key] = modifier_token.strings[key];
            }
          }
          ret.decorations = base_token.decorations.concat(modifier_token.decorations);
        }
        return ret;
      };
      CSL3.Output.Queue.prototype.addToken = function(name, modifier, token) {
        var newtok, attr;
        newtok = new CSL3.Token("output");
        if ("string" === typeof token) {
          token = this.formats.value()[token];
        }
        if (token && token.strings) {
          for (attr in token.strings) {
            if (token.strings.hasOwnProperty(attr)) {
              newtok.strings[attr] = token.strings[attr];
            }
          }
          newtok.decorations = token.decorations;
        }
        if ("string" === typeof modifier) {
          newtok.strings.delimiter = modifier;
        }
        this.formats.value()[name] = newtok;
      };
      CSL3.Output.Queue.prototype.pushFormats = function(tokenstore) {
        if (!tokenstore) {
          tokenstore = {};
        }
        tokenstore.empty = this.empty;
        this.formats.push(tokenstore);
      };
      CSL3.Output.Queue.prototype.popFormats = function() {
        this.formats.pop();
      };
      CSL3.Output.Queue.prototype.startTag = function(name, token) {
        var tokenstore = {};
        if (this.state.tmp["doing-macro-with-date"] && this.state.tmp.extension) {
          token = this.empty;
          name = "empty";
        }
        tokenstore[name] = token;
        this.pushFormats(tokenstore);
        this.openLevel(name);
      };
      CSL3.Output.Queue.prototype.endTag = function(name) {
        this.closeLevel(name);
        this.popFormats();
      };
      CSL3.Output.Queue.prototype.openLevel = function(token) {
        var blob, curr;
        if ("object" === typeof token) {
          blob = new CSL3.Blob(void 0, token);
        } else if ("undefined" === typeof token) {
          blob = new CSL3.Blob(void 0, this.formats.value().empty, "empty");
        } else {
          if (!this.formats.value() || !this.formats.value()[token]) {
            CSL3.error('CSL processor error: call to nonexistent format token "' + token + '"');
          }
          blob = new CSL3.Blob(void 0, this.formats.value()[token], token);
        }
        curr = this.current.value();
        if (!this.state.tmp.just_looking && this.checkNestedBrace) {
          blob.strings.prefix = this.checkNestedBrace.update(blob.strings.prefix);
        }
        curr.push(blob);
        this.current.push(blob);
      };
      CSL3.Output.Queue.prototype.closeLevel = function(name) {
        if (name && name !== this.current.value().levelname) {
          CSL3.error("Level mismatch error:  wanted " + name + " but found " + this.current.value().levelname);
        }
        var blob = this.current.pop();
        if (!this.state.tmp.just_looking && this.checkNestedBrace) {
          blob.strings.suffix = this.checkNestedBrace.update(blob.strings.suffix);
        }
      };
      CSL3.Output.Queue.prototype.append = function(str, tokname, notSerious, ignorePredecessor, noStripPeriods) {
        var token, blob, curr;
        var useblob = true;
        if (notSerious) {
          ignorePredecessor = true;
        }
        if (this.state.tmp["doing-macro-with-date"] && !notSerious) {
          if (tokname !== "macro-with-date") {
            return false;
          }
          if (tokname === "macro-with-date") {
            tokname = "empty";
          }
        }
        if ("undefined" === typeof str) {
          return false;
        }
        if ("number" === typeof str) {
          str = "" + str;
        }
        if (!notSerious && this.state.tmp.element_trace && this.state.tmp.element_trace.value() === "suppress-me") {
          return false;
        }
        blob = false;
        if (!tokname) {
          token = this.formats.value().empty;
        } else if (tokname === "literal") {
          token = true;
          useblob = false;
        } else if ("string" === typeof tokname) {
          token = this.formats.value()[tokname];
        } else {
          token = tokname;
        }
        if (!token) {
          CSL3.error("CSL processor error: unknown format token name: " + tokname);
        }
        if (token.strings && "undefined" === typeof token.strings.delimiter) {
          token.strings.delimiter = "";
        }
        if ("string" === typeof str && str.length) {
          str = str.replace(/ ([:;?!\u00bb])/g, "\u202F$1").replace(/\u00ab /g, "\xAB\u202F");
          this.last_char_rendered = str.slice(-1);
          str = str.replace(/\s+'/g, " '");
          if (!notSerious) {
            str = str.replace(/^'/g, " '");
          }
          if (!ignorePredecessor) {
            this.state.tmp.term_predecessor = true;
            this.state.tmp.in_cite_predecessor = true;
          } else if (notSerious) {
            this.state.tmp.term_predecessor_name = true;
          }
        }
        blob = new CSL3.Blob(str, token);
        curr = this.current.value();
        if ("undefined" === typeof curr && this.current.mystack.length === 0) {
          this.current.mystack.push([]);
          curr = this.current.value();
        }
        if ("string" === typeof blob.blobs) {
          if (!ignorePredecessor) {
            this.state.tmp.term_predecessor = true;
            this.state.tmp.in_cite_predecessor = true;
          } else if (notSerious) {
            this.state.tmp.term_predecessor_name = true;
          }
        }
        if ("string" === typeof str) {
          if ("string" === typeof blob.blobs) {
            if (blob.blobs.slice(0, 1) !== " ") {
              var blobPrefix = "";
              var blobBlobs = blob.blobs;
              while (CSL3.TERMINAL_PUNCTUATION.indexOf(blobBlobs.slice(0, 1)) > -1) {
                blobPrefix = blobPrefix + blobBlobs.slice(0, 1);
                blobBlobs = blobBlobs.slice(1);
              }
              if (blobBlobs && blobPrefix) {
                blob.strings.prefix = blob.strings.prefix + blobPrefix;
                blob.blobs = blobBlobs;
              }
            }
          }
          if (blob.strings["text-case"]) {
            blob.blobs = CSL3.Output.Formatters[blob.strings["text-case"]](this.state, str);
          }
          if (this.state.tmp.strip_periods && !noStripPeriods) {
            blob.blobs = blob.blobs.replace(/\.([^a-z]|$)/g, "$1");
          }
          for (var i = blob.decorations.length - 1; i > -1; i += -1) {
            if (blob.decorations[i][0] === "@quotes" && blob.decorations[i][1] !== "false") {
              blob.punctuation_in_quote = this.state.getOpt("punctuation-in-quote");
            }
            if (!blob.blobs.match(CSL3.ROMANESQUE_REGEXP)) {
              if (blob.decorations[i][0] === "@font-style") {
                blob.decorations = blob.decorations.slice(0, i).concat(blob.decorations.slice(i + 1));
              }
            }
          }
          curr.push(blob);
          this.state.fun.flipflopper.processTags(blob);
        } else if (useblob) {
          curr.push(blob);
        } else {
          curr.push(str);
        }
        return true;
      };
      CSL3.Output.Queue.prototype.string = function(state, myblobs, blob) {
        var i, ilen, j, jlen, b;
        var txt_esc = CSL3.getSafeEscape(this.state);
        var blobs = myblobs.slice();
        var ret = [];
        if (blobs.length === 0) {
          return ret;
        }
        var blob_delimiter = "";
        if (blob) {
          blob_delimiter = blob.strings.delimiter;
        } else {
          state.tmp.count_offset_characters = false;
          state.tmp.offset_characters = 0;
        }
        if (blob && blob.new_locale) {
          blob.old_locale = state.opt.lang;
          state.opt.lang = blob.new_locale;
        }
        var blobjr, use_suffix, use_prefix, params;
        for (var i = 0, ilen = blobs.length; i < ilen; i += 1) {
          blobjr = blobs[i];
          if (blobjr.strings.first_blob) {
            state.tmp.count_offset_characters = blobjr.strings.first_blob;
          }
          if ("string" === typeof blobjr.blobs) {
            if ("number" === typeof blobjr.num) {
              ret.push(blobjr);
            } else if (blobjr.blobs) {
              if (blobjr.particle) {
                blobjr.blobs = blobjr.particle + blobjr.blobs;
                blobjr.particle = "";
              }
              b = txt_esc(blobjr.blobs);
              var blen = b.length;
              if (!state.tmp.suppress_decorations) {
                for (j = 0, jlen = blobjr.decorations.length; j < jlen; j += 1) {
                  params = blobjr.decorations[j];
                  if (params[0] === "@showid") {
                    continue;
                  }
                  if (state.normalDecorIsOrphan(blobjr, params)) {
                    continue;
                  }
                  b = state.fun.decorate[params[0]][params[1]].call(blobjr, state, b, params[2]);
                }
              }
              if (b && b.length) {
                b = txt_esc(blobjr.strings.prefix) + b + txt_esc(blobjr.strings.suffix);
                if (state.opt.development_extensions.csl_reverse_lookup_support && !state.tmp.suppress_decorations) {
                  for (j = 0, jlen = blobjr.decorations.length; j < jlen; j += 1) {
                    params = blobjr.decorations[j];
                    if (params[0] === "@showid") {
                      b = state.fun.decorate[params[0]][params[1]].call(blobjr, state, b, params[2]);
                    }
                  }
                }
                ret.push(b);
                if (state.tmp.count_offset_characters) {
                  state.tmp.offset_characters += blen + blobjr.strings.suffix.length + blobjr.strings.prefix.length;
                }
              }
            }
          } else if (blobjr.blobs.length) {
            var addtoret = state.output.string(state, blobjr.blobs, blobjr);
            if (blob) {
              if ("string" !== addtoret && addtoret.length > 1 && blobjr.strings.delimiter) {
                var numberSeen = false;
                for (var j = 0, jlen = addtoret.length; j < jlen; j++) {
                  if ("string" !== typeof addtoret[j]) {
                    numberSeen = true;
                  } else if (numberSeen) {
                    addtoret[j] = blobjr.strings.delimiter + addtoret[j];
                  }
                }
              }
            }
            ret = ret.concat(addtoret);
          }
          if (blobjr.strings.first_blob && state.registry.registry[blobjr.strings.first_blob]) {
            state.registry.registry[blobjr.strings.first_blob].offset = state.tmp.offset_characters;
            state.tmp.count_offset_characters = false;
          }
        }
        for (i = 0, ilen = ret.length - 1; i < ilen; i += 1) {
          if ("number" === typeof ret[i].num && "number" === typeof ret[i + 1].num && !ret[i + 1].UGLY_DELIMITER_SUPPRESS_HACK) {
            ret[i].strings.suffix = ret[i].strings.suffix + (blob_delimiter ? blob_delimiter : "");
            ret[i + 1].successor_prefix = "";
            ret[i + 1].UGLY_DELIMITER_SUPPRESS_HACK = true;
          }
        }
        var span_split = 0;
        for (var i = 0, ilen = ret.length; i < ilen; i += 1) {
          if ("string" === typeof ret[i]) {
            span_split = parseInt(i, 10) + 1;
            if (i < ret.length - 1 && "object" === typeof ret[i + 1]) {
              if (blob_delimiter && !ret[i + 1].UGLY_DELIMITER_SUPPRESS_HACK) {
                ret[i] += txt_esc(blob_delimiter);
              }
              ret[i + 1].UGLY_DELIMITER_SUPPRESS_HACK = true;
            }
          }
        }
        if (blob && (blob.decorations.length || blob.strings.suffix)) {
          span_split = ret.length;
        } else if (blob && blob.strings.prefix) {
          for (var i = 0, ilen = ret.length; i < ilen; i++) {
            if ("undefined" !== typeof ret[i].num) {
              span_split = i;
              if (i === 0) {
                ret[i].strings.prefix = blob.strings.prefix + ret[i].strings.prefix;
              }
              break;
            }
          }
        }
        var blobs_start = state.output.renderBlobs(ret.slice(0, span_split), blob_delimiter, false, blob);
        if (blobs_start && blob && (blob.decorations.length || blob.strings.suffix || blob.strings.prefix)) {
          if (!state.tmp.suppress_decorations) {
            for (var i = 0, ilen = blob.decorations.length; i < ilen; i += 1) {
              params = blob.decorations[i];
              if (["@cite", "@bibliography", "@display", "@showid"].indexOf(params[0]) > -1) {
                continue;
              }
              if (state.normalDecorIsOrphan(blobjr, params)) {
                continue;
              }
              if (!params[0]) continue;
              if ("string" === typeof blobs_start) {
                blobs_start = state.fun.decorate[params[0]][params[1]].call(blob, state, blobs_start, params[2]);
              }
            }
          }
          b = blobs_start;
          use_suffix = blob.strings.suffix;
          if (b && b.length) {
            use_prefix = blob.strings.prefix;
            b = txt_esc(use_prefix) + b + txt_esc(use_suffix);
            if (state.tmp.count_offset_characters) {
              state.tmp.offset_characters += use_prefix.length + use_suffix.length;
            }
          }
          blobs_start = b;
          if (!state.tmp.suppress_decorations) {
            for (var i = 0, ilen = blob.decorations.length; i < ilen; i += 1) {
              params = blob.decorations[i];
              if (["@cite", "@bibliography", "@display", "@showid"].indexOf(params[0]) === -1) {
                continue;
              }
              if ("string" === typeof blobs_start) {
                blobs_start = state.fun.decorate[params[0]][params[1]].call(blob, state, blobs_start, params[2]);
              }
            }
          }
        }
        var blobs_end = ret.slice(span_split, ret.length);
        if (!blobs_end.length && blobs_start) {
          ret = [blobs_start];
        } else if (blobs_end.length && !blobs_start) {
          ret = blobs_end;
        } else if (blobs_start && blobs_end.length) {
          ret = [blobs_start].concat(blobs_end);
        }
        if ("undefined" === typeof blob) {
          this.queue = [];
          this.current.mystack = [];
          this.current.mystack.push(this.queue);
          if (state.tmp.suppress_decorations) {
            ret = state.output.renderBlobs(ret, void 0, false);
          }
        } else if ("boolean" === typeof blob) {
          ret = state.output.renderBlobs(ret, void 0, true);
        }
        if (blob && blob.new_locale) {
          state.opt.lang = blob.old_locale;
        }
        return ret;
      };
      CSL3.Output.Queue.prototype.clearlevel = function() {
        var blob, pos, len;
        blob = this.current.value();
        len = blob.blobs.length;
        for (pos = 0; pos < len; pos += 1) {
          blob.blobs.pop();
        }
      };
      CSL3.Output.Queue.prototype.renderBlobs = function(blobs, delim, in_cite, parent) {
        var state, ret, ret_last_char, use_delim, blob, pos, len, ppos, llen, str, params, txt_esc;
        txt_esc = CSL3.getSafeEscape(this.state);
        if (!delim) {
          delim = "";
        }
        state = this.state;
        ret = "";
        ret_last_char = [];
        use_delim = "";
        len = blobs.length;
        if (this.state.tmp.area === "citation" && !this.state.tmp.just_looking && len === 1 && typeof blobs[0] === "object" && parent) {
          blobs[0].strings.prefix = parent.strings.prefix + blobs[0].strings.prefix;
          blobs[0].strings.suffix = blobs[0].strings.suffix + parent.strings.suffix;
          blobs[0].decorations = blobs[0].decorations.concat(parent.decorations);
          blobs[0].params = parent.params;
          return blobs[0];
        }
        var start = true;
        for (pos = 0; pos < len; pos += 1) {
          if (blobs[pos].checkNext) {
            blobs[pos].checkNext(blobs[pos + 1], start);
            start = false;
          } else if (blobs[pos + 1] && blobs[pos + 1].splice_prefix) {
            start = false;
          } else {
            start = true;
          }
        }
        var doit = true;
        for (pos = blobs.length - 1; pos > 0; pos += -1) {
          if (blobs[pos].checkLast) {
            if (doit && blobs[pos].checkLast(blobs[pos - 1])) {
              doit = false;
            }
          } else {
            doit = true;
          }
        }
        len = blobs.length;
        for (pos = 0; pos < len; pos += 1) {
          blob = blobs[pos];
          if (ret) {
            use_delim = delim;
          }
          if ("string" === typeof blob) {
            ret += txt_esc(use_delim);
            ret += blob;
            if (state.tmp.count_offset_characters) {
              state.tmp.offset_characters += use_delim.length;
            }
          } else if (in_cite) {
            if (ret) {
              ret = [ret, blob];
            } else {
              ret = [blob];
            }
          } else if (blob.status !== CSL3.SUPPRESS) {
            if (blob.particle) {
              str = blob.particle + blob.num;
            } else {
              str = blob.formatter.format(blob.num, blob.gender);
            }
            var strlen = str.replace(/<[^>]*>/g, "").length;
            this.append(str, "empty", true);
            var str_blob = this.pop();
            var count_offset_characters = state.tmp.count_offset_characters;
            str = this.string(state, [str_blob], false);
            state.tmp.count_offset_characters = count_offset_characters;
            if (blob.strings["text-case"]) {
              str = CSL3.Output.Formatters[blob.strings["text-case"]](this.state, str);
            }
            if (str && this.state.tmp.strip_periods) {
              str = str.replace(/\.([^a-z]|$)/g, "$1");
            }
            if (!state.tmp.suppress_decorations) {
              llen = blob.decorations.length;
              for (ppos = 0; ppos < llen; ppos += 1) {
                params = blob.decorations[ppos];
                if (state.normalDecorIsOrphan(blob, params)) {
                  continue;
                }
                str = state.fun.decorate[params[0]][params[1]].call(blob, state, str, params[2]);
              }
            }
            str = txt_esc(blob.strings.prefix) + str + txt_esc(blob.strings.suffix);
            var addme = "";
            if (blob.status === CSL3.END) {
              addme = txt_esc(blob.range_prefix);
            } else if (blob.status === CSL3.SUCCESSOR) {
              addme = txt_esc(blob.successor_prefix);
            } else if (blob.status === CSL3.START) {
              if (pos > 0 && !blob.suppress_splice_prefix) {
                addme = txt_esc(blob.splice_prefix);
              } else {
                addme = "";
              }
            } else if (blob.status === CSL3.SEEN) {
              addme = txt_esc(blob.splice_prefix);
            }
            ret += addme;
            ret += str;
            if (state.tmp.count_offset_characters) {
              state.tmp.offset_characters += addme.length + blob.strings.prefix.length + strlen + blob.strings.suffix.length;
            }
          }
        }
        return ret;
      };
      CSL3.Output.Queue.purgeEmptyBlobs = function(parent) {
        if ("object" !== typeof parent || "object" !== typeof parent.blobs || !parent.blobs.length) {
          return;
        }
        for (var i = parent.blobs.length - 1; i > -1; i--) {
          CSL3.Output.Queue.purgeEmptyBlobs(parent.blobs[i]);
          var child = parent.blobs[i];
          if (!child || !child.blobs || !child.blobs.length) {
            var buf = [];
            while (parent.blobs.length - 1 > i) {
              buf.push(parent.blobs.pop());
            }
            parent.blobs.pop();
            while (buf.length) {
              parent.blobs.push(buf.pop());
            }
          }
        }
      };
      CSL3.Output.Queue.adjust = function(punctInQuote) {
        var NO_SWAP_IN = {
          ";": true,
          ":": true
        };
        var NO_SWAP_OUT = {
          ".": true,
          "!": true,
          "?": true
        };
        var LtoR_MAP = {
          "!": {
            ".": "!",
            "?": "!?",
            ":": "!",
            ",": "!,",
            ";": "!;"
          },
          "?": {
            "!": "?!",
            ".": "?",
            ":": "?",
            ",": "?,",
            ";": "?;"
          },
          ".": {
            "!": ".!",
            "?": ".?",
            ":": ".:",
            ",": ".,",
            ";": ".;"
          },
          ":": {
            "!": "!",
            "?": "?",
            ".": ":",
            ",": ":,",
            ";": ":;"
          },
          ",": {
            "!": ",!",
            "?": ",?",
            ":": ",:",
            ".": ",.",
            ";": ",;"
          },
          ";": {
            "!": "!",
            "?": "?",
            ":": ";",
            ",": ";,",
            ".": ";"
          }
        };
        var SWAP_IN = {};
        var SWAP_OUT = {};
        var PUNCT = {};
        var PUNCT_OR_SPACE = {};
        for (var key in LtoR_MAP) {
          PUNCT[key] = true;
          PUNCT_OR_SPACE[key] = true;
          if (!NO_SWAP_IN[key]) {
            SWAP_IN[key] = true;
          }
          if (!NO_SWAP_OUT[key]) {
            SWAP_OUT[key] = true;
          }
        }
        PUNCT_OR_SPACE[" "] = true;
        PUNCT_OR_SPACE["\xA0"] = true;
        var RtoL_MAP = {};
        for (var key in LtoR_MAP) {
          for (var subkey in LtoR_MAP[key]) {
            if (!RtoL_MAP[subkey]) {
              RtoL_MAP[subkey] = {};
            }
            RtoL_MAP[subkey][key] = LtoR_MAP[key][subkey];
          }
        }
        function blobIsNumber(blob) {
          return "number" === typeof blob.num || blob.blobs && blob.blobs.length === 1 && "number" === typeof blob.blobs[0].num;
        }
        function blobEndsInNumber(blob) {
          if ("number" === typeof blob.num) {
            return true;
          }
          if (!blob.blobs || "object" !== typeof blob.blobs) {
            return false;
          }
          if (blobEndsInNumber(blob.blobs[blob.blobs.length - 1])) {
            return true;
          }
        }
        function blobHasDecorations(blob, includeQuotes) {
          var ret = false;
          var decorlist = ["@font-style", "@font-variant", "@font-weight", "@text-decoration", "@vertical-align"];
          if (includeQuotes) {
            decorlist.push("@quotes");
          }
          if (blob.decorations) {
            for (var i = 0, ilen = blob.decorations.length; i < ilen; i++) {
              if (decorlist.indexOf(blob.decorations[i][0]) > -1) {
                ret = true;
                break;
              }
            }
          }
          return ret;
        }
        function blobHasDescendantQuotes(blob) {
          if (blob.decorations) {
            for (var i = 0, ilen = blob.decorations.length; i < ilen; i++) {
              if (blob.decorations[i][0] === "@quotes" && blob.decorations[i][1] !== "false") {
                return true;
              }
            }
          }
          if ("object" !== typeof blob.blobs) {
            return false;
          }
          return blobHasDescendantQuotes(blob.blobs[blob.blobs.length - 1]);
        }
        function blobHasDescendantMergingPunctuation(parentChar, blob) {
          var childChar = blob.strings.suffix.slice(-1);
          if (!childChar && "string" === typeof blob.blobs) {
            childChar = blob.blobs.slice(-1);
          }
          var mergedChars = RtoL_MAP[parentChar][childChar];
          if (mergedChars && mergedChars.length === 1) {
            return true;
          }
          if ("object" !== typeof blob.blobs) {
            return false;
          }
          if (blobHasDescendantMergingPunctuation(parentChar, blob.blobs[blob.blobs.length - 1])) {
            return true;
          }
          return false;
        }
        function matchLastChar(blob, chr) {
          if (!PUNCT[chr]) {
            return false;
          }
          if ("string" === typeof blob.blobs) {
            if (blob.blobs.slice(-1) === chr) {
              return true;
            } else {
              return false;
            }
          } else {
            var child = blob.blobs[blob.blobs.length - 1];
            if (child) {
              var childChar = child.strings.suffix.slice(-1);
              if (!childChar) {
                return matchLastChar(child, chr);
              } else if (child.strings.suffix.slice(-1) == chr) {
                return true;
              } else {
                return false;
              }
            } else {
              return false;
            }
          }
        }
        function mergeChars(First, first, Second, second, merge_right) {
          var FirstStrings = "blobs" === first ? First : First.strings;
          var SecondStrings = "blobs" === second ? Second : Second.strings;
          var firstChar = FirstStrings[first].slice(-1);
          var secondChar = SecondStrings[second].slice(0, 1);
          function cullRight() {
            SecondStrings[second] = SecondStrings[second].slice(1);
          }
          function cullLeft() {
            FirstStrings[first] = FirstStrings[first].slice(0, -1);
          }
          function addRight(chr) {
            SecondStrings[second] = chr + SecondStrings[second];
          }
          function addLeft(chr) {
            FirstStrings[first] += chr;
          }
          var cull = merge_right ? cullLeft : cullRight;
          function matchOnRight() {
            return RtoL_MAP[secondChar];
          }
          function matchOnLeft() {
            return LtoR_MAP[firstChar];
          }
          var match = merge_right ? matchOnLeft : matchOnRight;
          function mergeToRight() {
            var chr = LtoR_MAP[firstChar][secondChar];
            if ("string" === typeof chr) {
              cullLeft();
              cullRight();
              addRight(chr);
            } else {
              addRight(firstChar);
              cullLeft();
            }
          }
          function mergeToLeft() {
            var chr = RtoL_MAP[secondChar][firstChar];
            if ("string" === typeof chr) {
              cullLeft();
              cullRight();
              addLeft(chr);
            } else {
              addLeft(secondChar);
              cullRight();
            }
          }
          var merge = merge_right ? mergeToRight : mergeToLeft;
          var isDuplicate = firstChar === secondChar;
          if (isDuplicate) {
            cull();
          } else {
            if (match()) {
              merge();
            }
          }
        }
        function upward(parent) {
          if (parent.blobs && "string" == typeof parent.blobs) {
            if (PUNCT[parent.strings.suffix.slice(0, 1)] && parent.strings.suffix.slice(0, 1) === parent.blobs.slice(-1)) {
              parent.strings.suffix = parent.strings.suffix.slice(1);
            }
            return;
          } else if ("object" !== typeof parent || "object" !== typeof parent.blobs || !parent.blobs.length) {
            return;
          }
          var parentDecorations = blobHasDecorations(parent, true);
          for (var i = parent.blobs.length - 1; i > -1; i--) {
            this.upward(parent.blobs[i]);
            var parentStrings = parent.strings;
            var childStrings = parent.blobs[i].strings;
            if (i === 0) {
              if (" " === parentStrings.prefix.slice(-1) && " " === childStrings.prefix.slice(0, 1)) {
                childStrings.prefix = childStrings.prefix.slice(1);
              }
              var childChar = childStrings.prefix.slice(0, 1);
              if (!parentDecorations && PUNCT_OR_SPACE[childChar] && !parentStrings.prefix) {
                parentStrings.prefix += childChar;
                childStrings.prefix = childStrings.prefix.slice(1);
              }
            }
            if (i === parent.blobs.length - 1) {
              var childChar = childStrings.suffix.slice(-1);
              if (!parentDecorations && [" "].indexOf(childChar) > -1) {
                if (parentStrings.suffix.slice(0, 1) !== childChar) {
                  parentStrings.suffix = childChar + parentStrings.suffix;
                }
                childStrings.suffix = childStrings.suffix.slice(0, -1);
              }
            }
            if (parentStrings.delimiter && i > 0) {
              if (PUNCT_OR_SPACE[parentStrings.delimiter.slice(-1)] && parentStrings.delimiter.slice(-1) === childStrings.prefix.slice(0, 1)) {
                childStrings.prefix = childStrings.prefix.slice(1);
              }
            }
          }
        }
        function leftward(parent) {
          if ("object" !== typeof parent || "object" !== typeof parent.blobs || !parent.blobs.length) {
            return;
          }
          for (var i = parent.blobs.length - 1; i > -1; i--) {
            this.leftward(parent.blobs[i]);
            if (i < parent.blobs.length - 1 && !parent.strings.delimiter) {
              var child = parent.blobs[i];
              var childChar = child.strings.suffix.slice(-1);
              var sibling = parent.blobs[i + 1];
              var siblingChar = sibling.strings.prefix.slice(0, 1);
              var hasDecorations = blobHasDecorations(child) || blobHasDecorations(sibling);
              var hasNumber = "number" === typeof childChar || "number" === typeof siblingChar;
              if (!hasDecorations && !hasNumber && PUNCT[siblingChar] && !hasNumber) {
                var suffixAndPrefixMatch = siblingChar === child.strings.suffix.slice(-1);
                var suffixAndFieldMatch = !child.strings.suffix && "string" === typeof child.blobs && child.blobs.slice(-1) === siblingChar;
                if (!suffixAndPrefixMatch && !suffixAndFieldMatch) {
                  mergeChars(child, "suffix", sibling, "prefix");
                } else {
                  sibling.strings.prefix = sibling.strings.prefix.slice(1);
                }
              }
            }
          }
        }
        function downward(parent) {
          if (parent.blobs && "string" == typeof parent.blobs) {
            if (PUNCT[parent.strings.suffix.slice(0, 1)] && parent.strings.suffix.slice(0, 1) === parent.blobs.slice(-1)) {
              parent.strings.suffix = parent.strings.suffix.slice(1);
            }
            return;
          } else if ("object" !== typeof parent || "object" !== typeof parent.blobs || !parent.blobs.length) {
            return;
          }
          var parentStrings = parent.strings;
          var someChildrenAreNumbers = false;
          for (var i = 0, ilen = parent.blobs.length; i < ilen; i++) {
            if (blobIsNumber(parent.blobs[i])) {
              someChildrenAreNumbers = true;
              break;
            }
          }
          if (true) {
            if (parentStrings.delimiter && PUNCT[parentStrings.delimiter.slice(0, 1)]) {
              var delimChar = parentStrings.delimiter.slice(0, 1);
              for (var i = parent.blobs.length - 2; i > -1; i--) {
                var childStrings = parent.blobs[i].strings;
                if (childStrings.suffix.slice(-1) !== delimChar) {
                  childStrings.suffix += delimChar;
                }
              }
              parentStrings.delimiter = parentStrings.delimiter.slice(1);
            }
          }
          for (var i = parent.blobs.length - 1; i > -1; i--) {
            var child = parent.blobs[i];
            var childStrings = parent.blobs[i].strings;
            var childDecorations = blobHasDecorations(child, true);
            var childIsNumber = blobIsNumber(child);
            if (i === parent.blobs.length - 1) {
              if (true) {
                var parentChar = parentStrings.suffix.slice(0, 1);
                var allowMigration = false;
                if (PUNCT[parentChar]) {
                  allowMigration = blobHasDescendantMergingPunctuation(parentChar, child);
                  if (!allowMigration && punctInQuote) {
                    allowMigration = blobHasDescendantQuotes(child);
                  }
                }
                if (allowMigration) {
                  if (PUNCT[parentChar]) {
                    if (!blobEndsInNumber(child)) {
                      if ("string" === typeof child.blobs) {
                        mergeChars(child, "blobs", parent, "suffix");
                      } else {
                        mergeChars(child, "suffix", parent, "suffix");
                      }
                      if (parentStrings.suffix.slice(0, 1) === ".") {
                        childStrings.suffix += parentStrings.suffix.slice(0, 1);
                        parentStrings.suffix = parentStrings.suffix.slice(1);
                      }
                    }
                  }
                }
                if (childStrings.suffix.slice(-1) === "\xA0" && parentStrings.suffix.slice(0, 1) === " ") {
                  parentStrings.suffix = parentStrings.suffix.slice(1);
                }
                if (PUNCT_OR_SPACE[childStrings.suffix.slice(0, 1)]) {
                  if ("string" === typeof child.blobs && child.blobs.slice(-1) === childStrings.suffix.slice(0, 1)) {
                    childStrings.suffix = childStrings.suffix.slice(1);
                  }
                  if (childStrings.suffix.slice(-1) === parentStrings.suffix.slice(0, 1)) {
                    parentStrings.suffix = parentStrings.suffix.slice(0, -1);
                  }
                }
              }
              if (matchLastChar(parent, parent.strings.suffix.slice(0, 1))) {
                parent.strings.suffix = parent.strings.suffix.slice(1);
              }
            } else if (parentStrings.delimiter) {
              if (PUNCT_OR_SPACE[parentStrings.delimiter.slice(0, 1)] && parentStrings.delimiter.slice(0, 1) === childStrings.suffix.slice(-1)) {
                parent.blobs[i].strings.suffix = parent.blobs[i].strings.suffix.slice(0, -1);
              }
            } else {
              var siblingStrings = parent.blobs[i + 1].strings;
              if (!blobIsNumber(child) && !childDecorations && PUNCT_OR_SPACE[childStrings.suffix.slice(-1)] && childStrings.suffix.slice(-1) === siblingStrings.prefix.slice(0, 1)) {
                siblingStrings.prefix = siblingStrings.prefix.slice(1);
              }
            }
            if (!childIsNumber && !childDecorations && PUNCT[childStrings.suffix.slice(0, 1)] && "string" === typeof child.blobs) {
              mergeChars(child, "blobs", child, "suffix");
            }
            this.downward(parent.blobs[i]);
          }
        }
        function swapToTheLeft(child) {
          var childChar = child.strings.suffix.slice(0, 1);
          if ("string" === typeof child.blobs) {
            while (SWAP_IN[childChar]) {
              mergeChars(child, "blobs", child, "suffix");
              childChar = child.strings.suffix.slice(0, 1);
            }
          } else {
            while (SWAP_IN[childChar]) {
              mergeChars(child.blobs[child.blobs.length - 1], "suffix", child, "suffix");
              childChar = child.strings.suffix.slice(0, 1);
            }
          }
        }
        function swapToTheRight(child) {
          if ("string" === typeof child.blobs) {
            var childChar = child.blobs.slice(-1);
            while (SWAP_OUT[childChar]) {
              mergeChars(child, "blobs", child, "suffix", true);
              childChar = child.blobs.slice(-1);
            }
          } else {
            var childChar = child.blobs[child.blobs.length - 1].strings.suffix.slice(-1);
            while (SWAP_OUT[childChar]) {
              mergeChars(child.blobs[child.blobs.length - 1], "suffix", child, "suffix", true);
              childChar = child.blobs[child.blobs.length - 1].strings.suffix.slice(-1);
            }
          }
        }
        function fix(parent) {
          if ("object" !== typeof parent || "object" !== typeof parent.blobs || !parent.blobs.length) {
            return;
          }
          var lastChar;
          for (var i = 0, ilen = parent.blobs.length; i < ilen; i++) {
            var child = parent.blobs[i];
            var quoteSwap = false;
            for (var j = 0, jlen = child.decorations.length; j < jlen; j++) {
              var decoration = child.decorations[j];
              if (decoration[0] === "@quotes" && decoration[1] !== "false") {
                quoteSwap = true;
              }
            }
            if (quoteSwap) {
              if (punctInQuote) {
                swapToTheLeft(child);
              } else {
                swapToTheRight(child);
              }
            }
            lastChar = this.fix(parent.blobs[i]);
            if (child.blobs && "string" === typeof child.blobs) {
              lastChar = child.blobs.slice(-1);
            }
          }
          return lastChar;
        }
        this.upward = upward;
        this.leftward = leftward;
        this.downward = downward;
        this.fix = fix;
      };
      CSL3.Engine.Opt = function() {
        this.parallel = {
          enable: false
        }, this.has_disambiguate = false;
        this.mode = "html";
        this.dates = {};
        this.jurisdictions_seen = {};
        this.suppressedJurisdictions = {};
        this.inheritedAttributes = {};
        this["locale-sort"] = [];
        this["locale-translit"] = [];
        this["locale-translat"] = [];
        this.citeAffixes = {
          persons: {
            "locale-orig": {
              prefix: "",
              suffix: ""
            },
            "locale-translit": {
              prefix: "",
              suffix: ""
            },
            "locale-translat": {
              prefix: "",
              suffix: ""
            }
          },
          institutions: {
            "locale-orig": {
              prefix: "",
              suffix: ""
            },
            "locale-translit": {
              prefix: "",
              suffix: ""
            },
            "locale-translat": {
              prefix: "",
              suffix: ""
            }
          },
          titles: {
            "locale-orig": {
              prefix: "",
              suffix: ""
            },
            "locale-translit": {
              prefix: "",
              suffix: ""
            },
            "locale-translat": {
              prefix: "",
              suffix: ""
            }
          },
          journals: {
            "locale-orig": {
              prefix: "",
              suffix: ""
            },
            "locale-translit": {
              prefix: "",
              suffix: ""
            },
            "locale-translat": {
              prefix: "",
              suffix: ""
            }
          },
          publishers: {
            "locale-orig": {
              prefix: "",
              suffix: ""
            },
            "locale-translit": {
              prefix: "",
              suffix: ""
            },
            "locale-translat": {
              prefix: "",
              suffix: ""
            }
          },
          places: {
            "locale-orig": {
              prefix: "",
              suffix: ""
            },
            "locale-translit": {
              prefix: "",
              suffix: ""
            },
            "locale-translat": {
              prefix: "",
              suffix: ""
            }
          }
        };
        this["default-locale"] = [];
        this.update_mode = CSL3.NONE;
        this.bib_mode = CSL3.NONE;
        this.sort_citations = false;
        this["et-al-min"] = 0;
        this["et-al-use-first"] = 1;
        this["et-al-use-last"] = false;
        this["et-al-subsequent-min"] = false;
        this["et-al-subsequent-use-first"] = false;
        this["demote-non-dropping-particle"] = "display-and-sort";
        this["parse-names"] = true;
        this.citation_number_slug = false;
        this.trigraph = "Aaaa00:AaAa00:AaAA00:AAAA00";
        this.nodenames = [];
        this.gender = {};
        this["cite-lang-prefs"] = {
          persons: ["orig"],
          institutions: ["orig"],
          titles: ["orig"],
          journals: ["orig"],
          publishers: ["orig"],
          places: ["orig"],
          number: ["orig"]
        };
        this.has_layout_locale = false;
        this.disable_duplicate_year_suppression = [];
        this.use_context_condition = false;
        this.jurisdiction_fallbacks = {};
        this.development_extensions = {};
        this.development_extensions.field_hack = true;
        this.development_extensions.allow_field_hack_date_override = true;
        this.development_extensions.locator_date_and_revision = true;
        this.development_extensions.locator_label_parse = true;
        this.development_extensions.raw_date_parsing = true;
        this.development_extensions.clean_up_csl_flaws = true;
        this.development_extensions.consolidate_legal_items = false;
        this.development_extensions.csl_reverse_lookup_support = false;
        this.development_extensions.wrap_url_and_doi = false;
        this.development_extensions.thin_non_breaking_space_html_hack = false;
        this.development_extensions.apply_citation_wrapper = false;
        this.development_extensions.main_title_from_short_title = false;
        this.development_extensions.uppercase_subtitles = false;
        this.development_extensions.normalize_lang_keys_to_lowercase = false;
        this.development_extensions.strict_text_case_locales = false;
        this.development_extensions.expect_and_symbol_form = false;
        this.development_extensions.require_explicit_legal_case_title_short = false;
        this.development_extensions.spoof_institutional_affiliations = false;
        this.development_extensions.force_jurisdiction = false;
        this.development_extensions.parse_names = true;
        this.development_extensions.hanging_indent_legacy_number = false;
        this.development_extensions.throw_on_empty = false;
        this.development_extensions.strict_inputs = true;
        this.development_extensions.prioritize_disambiguate_condition = false;
        this.development_extensions.force_short_title_casing_alignment = true;
        this.development_extensions.implicit_short_title = false;
        this.development_extensions.force_title_abbrev_fallback = false;
        this.development_extensions.split_container_title = false;
        this.development_extensions.legacy_institution_name_ordering = false;
        this.development_extensions.etal_min_etal_usefirst_hack = false;
      };
      CSL3.Engine.Tmp = function() {
        this.names_max = new CSL3.Stack();
        this.names_base = new CSL3.Stack();
        this.givens_base = new CSL3.Stack();
        this.value = [];
        this.namepart_decorations = {};
        this.namepart_type = false;
        this.area = "citation";
        this.root = "citation";
        this.extension = "";
        this.can_substitute = new CSL3.Stack(0, CSL3.LITERAL);
        this.element_rendered_ok = false;
        this.element_trace = new CSL3.Stack("style");
        this.nameset_counter = 0;
        this.group_context = new CSL3.Stack({
          term_intended: false,
          variable_attempt: false,
          variable_success: false,
          output_tip: void 0,
          label_form: void 0,
          parallel_first: void 0,
          parallel_last: void 0,
          parallel_delimiter_override: void 0,
          condition: false,
          force_suppress: false,
          done_vars: []
        });
        this.term_predecessor = false;
        this.in_cite_predecessor = false;
        this.jump = new CSL3.Stack(0, CSL3.LITERAL);
        this.decorations = new CSL3.Stack();
        this.tokenstore_stack = new CSL3.Stack();
        this.last_suffix_used = "";
        this.last_names_used = [];
        this.last_years_used = [];
        this.years_used = [];
        this.names_used = [];
        this.taintedItemIDs = {};
        this.taintedCitationIDs = {};
        this.initialize_with = new CSL3.Stack();
        this.disambig_request = false;
        this["name-as-sort-order"] = false;
        this.suppress_decorations = false;
        this.disambig_settings = new CSL3.AmbigConfig();
        this.bib_sort_keys = [];
        this.prefix = new CSL3.Stack("", CSL3.LITERAL);
        this.suffix = new CSL3.Stack("", CSL3.LITERAL);
        this.delimiter = new CSL3.Stack("", CSL3.LITERAL);
        this.cite_locales = [];
        this.cite_affixes = {
          citation: false,
          bibliography: false,
          citation_sort: false,
          bibliography_sort: false
        };
        this.strip_periods = 0;
        this.shadow_numbers = {};
        this.authority_stop_last = 0;
        this.loadedItemIDs = {};
        this.condition_counter = 0;
        this.condition_lang_val_arr = [];
        this.condition_lang_counter_arr = [];
      };
      CSL3.Engine.Fun = function(state) {
        this.match = new CSL3.Util.Match();
        this.suffixator = new CSL3.Util.Suffixator(CSL3.SUFFIX_CHARS);
        this.romanizer = new CSL3.Util.Romanizer();
        this.ordinalizer = new CSL3.Util.Ordinalizer(state);
        this.long_ordinalizer = new CSL3.Util.LongOrdinalizer();
      };
      CSL3.Engine.Build = function() {
        this["alternate-term"] = false;
        this.in_bibliography = false;
        this.in_style = false;
        this.skip = false;
        this.postponed_macro = false;
        this.layout_flag = false;
        this.name = false;
        this.names_variables = [[]];
        this.name_label = [{}];
        this.form = false;
        this.term = false;
        this.macro = {};
        this.macro_stack = [];
        this.text = false;
        this.lang = false;
        this.area = "citation";
        this.root = "citation";
        this.extension = "";
        this.substitute_level = new CSL3.Stack(0, CSL3.LITERAL);
        this.names_level = 0;
        this.render_nesting_level = 0;
        this.render_seen = false;
        this.bibliography_key_pos = 0;
      };
      CSL3.Engine.Configure = function() {
        this.tests = [];
        this.fail = [];
        this.succeed = [];
      };
      CSL3.Engine.Citation = function(state) {
        this.opt = {
          inheritedAttributes: {}
        };
        this.tokens = [];
        this.srt = new CSL3.Registry.Comparifier(state, "citation_sort");
        this.opt.collapse = [];
        this.opt["disambiguate-add-names"] = false;
        this.opt["disambiguate-add-givenname"] = false;
        this.opt["disambiguate-add-year-suffix"] = false;
        this.opt["givenname-disambiguation-rule"] = "by-cite";
        this.opt["near-note-distance"] = 5;
        this.opt.topdecor = [];
        this.opt.layout_decorations = [];
        this.opt.layout_prefix = "";
        this.opt.layout_suffix = "";
        this.opt.layout_delimiter = "";
        this.opt.sort_locales = [];
        this.opt.max_number_of_names = 0;
        this.root = "citation";
      };
      CSL3.Engine.Bibliography = function() {
        this.opt = {
          inheritedAttributes: {}
        };
        this.tokens = [];
        this.opt.collapse = [];
        this.opt.topdecor = [];
        this.opt.layout_decorations = [];
        this.opt.layout_prefix = "";
        this.opt.layout_suffix = "";
        this.opt.layout_delimiter = "";
        this.opt["line-spacing"] = 1;
        this.opt["entry-spacing"] = 1;
        this.opt.sort_locales = [];
        this.opt.max_number_of_names = 0;
        this.root = "bibliography";
      };
      CSL3.Engine.BibliographySort = function() {
        this.tokens = [];
        this.opt = {};
        this.opt.sort_directions = [];
        this.opt.topdecor = [];
        this.opt.citation_number_sort_direction = CSL3.ASCENDING;
        this.opt.citation_number_secondary = false;
        this.tmp = {};
        this.keys = [];
        this.root = "bibliography";
      };
      CSL3.Engine.CitationSort = function() {
        this.tokens = [];
        this.opt = {};
        this.opt.sort_directions = [];
        this.keys = [];
        this.opt.topdecor = [];
        this.root = "citation";
      };
      CSL3.Engine.InText = function() {
        this.opt = {
          inheritedAttributes: {}
        };
        this.tokens = [];
        this.opt.collapse = [];
        this.opt["disambiguate-add-names"] = false;
        this.opt["disambiguate-add-givenname"] = false;
        this.opt["disambiguate-add-year-suffix"] = false;
        this.opt["givenname-disambiguation-rule"] = "by-cite";
        this.opt["near-note-distance"] = 5;
        this.opt.topdecor = [];
        this.opt.layout_decorations = [];
        this.opt.layout_prefix = "";
        this.opt.layout_suffix = "";
        this.opt.layout_delimiter = "";
        this.opt.sort_locales = [];
        this.opt.max_number_of_names = 0;
        this.root = "intext";
      };
      CSL3.Engine.prototype.previewCitationCluster = function(citation, citationsPre, citationsPost, newMode) {
        var oldMode = this.opt.mode;
        this.setOutputFormat(newMode);
        if (citation.citationID) {
          delete citation.citationID;
        }
        var ret = this.processCitationCluster(citation, citationsPre, citationsPost, CSL3.PREVIEW);
        this.setOutputFormat(oldMode);
        return ret[1];
      };
      CSL3.Engine.prototype.appendCitationCluster = function(citation) {
        var citationsPre = [];
        var len = this.registry.citationreg.citationByIndex.length;
        for (var pos = 0; pos < len; pos += 1) {
          var c = this.registry.citationreg.citationByIndex[pos];
          citationsPre.push(["" + c.citationID, c.properties.noteIndex]);
        }
        return this.processCitationCluster(citation, citationsPre, [])[1];
      };
      CSL3.Engine.prototype.processCitationCluster = function(citation, citationsPre, citationsPost, flag) {
        var c, preCitation, postCitation, i, ilen, j, jlen, k, klen, n, nlen, key, Item, item, noteCitations, textCitations, m, citationsInNote;
        this.debug = false;
        this.tmp.loadedItemIDs = {};
        this.tmp.citation_errors = [];
        this.registry.return_data = { "bibchange": false };
        this.setCitationId(citation);
        var oldCitationList;
        var oldItemList;
        var oldAmbigs;
        if (flag === CSL3.PREVIEW) {
          if (this.debug) {
            CSL3.debug("****** start state save *********");
          }
          oldCitationList = this.registry.citationreg.citationByIndex.slice();
          oldItemList = this.registry.reflist.slice();
          var newCitationList = citationsPre.concat(citationsPost);
          var newItemIds = {};
          var newItemIdsList = [];
          for (var i = 0, ilen = newCitationList.length; i < ilen; i += 1) {
            c = this.registry.citationreg.citationById[newCitationList[i][0]];
            for (j = 0, jlen = c.citationItems.length; j < jlen; j += 1) {
              newItemIds[c.citationItems[j].id] = true;
              newItemIdsList.push("" + c.citationItems[j].id);
            }
          }
          for (j = 0, jlen = citation.citationItems.length; j < jlen; j += 1) {
            newItemIds[citation.citationItems[j].id] = true;
            newItemIdsList.push("" + citation.citationItems[j].id);
          }
          oldAmbigs = {};
          for (var i = 0, ilen = oldItemList.length; i < ilen; i += 1) {
            if (!newItemIds[oldItemList[i].id]) {
              var oldAkey = this.registry.registry[oldItemList[i].id].ambig;
              var ids = this.registry.ambigcites[oldAkey];
              if (ids) {
                for (j = 0, jlen = ids.length; j < jlen; j += 1) {
                  oldAmbigs[ids[j]] = CSL3.cloneAmbigConfig(this.registry.registry[ids[j]].disambig);
                }
              }
            }
          }
          if (this.debug) {
            CSL3.debug("****** end state save *********");
          }
        }
        this.tmp.taintedCitationIDs = {};
        var sortedItems = [];
        var rerunAkeys = {};
        for (var i = 0, ilen = citation.citationItems.length; i < ilen; i += 1) {
          item = {};
          for (var key in citation.citationItems[i]) {
            item[key] = citation.citationItems[i][key];
          }
          Item = this.retrieveItem("" + item.id);
          if (Item.id) {
            this.transform.loadAbbreviation("default", "hereinafter", Item.id, Item.language);
          }
          item = CSL3.parseLocator.call(this, item);
          if (this.opt.development_extensions.consolidate_legal_items) {
            this.remapSectionVariable([[Item, item]]);
          }
          if (this.opt.development_extensions.locator_label_parse) {
            if (item.locator && ["bill", "gazette", "legislation", "regulation", "treaty"].indexOf(Item.type) === -1 && (!item.label || item.label === "page")) {
              var m = CSL3.LOCATOR_LABELS_REGEXP.exec(item.locator);
              if (m) {
                var tryLabel = CSL3.LOCATOR_LABELS_MAP[m[2]];
                if (this.getTerm(tryLabel)) {
                  item.label = tryLabel;
                  item.locator = m[3];
                }
              }
            }
          }
          var newitem = [Item, item];
          sortedItems.push(newitem);
          citation.citationItems[i].item = Item;
        }
        citation.sortedItems = sortedItems;
        var citationByIndex = [];
        var citationById = {};
        var lastNotePos;
        for (i = 0, ilen = citationsPre.length; i < ilen; i += 1) {
          preCitation = citationsPre[i];
          if (this.opt.development_extensions.strict_inputs) {
            if (citationById[preCitation[0]]) {
              CSL3.error("Previously referenced citationID " + preCitation[0] + " encountered in citationsPre");
            }
            if (preCitation[1]) {
              if (lastNotePos > preCitation[1]) {
                CSL3.debug("Note index sequence is not sane at citationsPre[" + i + "]");
              }
              lastNotePos = preCitation[1];
            }
          }
          this.registry.citationreg.citationById[preCitation[0]].properties.noteIndex = preCitation[1];
          citationByIndex.push(this.registry.citationreg.citationById[preCitation[0]]);
          citationById[preCitation[0]] = this.registry.citationreg.citationById[preCitation[0]];
        }
        if (!citation.properties) {
          citation.properties = {
            noteIndex: 0
          };
        }
        if (this.opt.development_extensions.strict_inputs) {
          if (citationById[citation.citationID]) {
            CSL3.error("Citation with previously referenced citationID " + citation.citationID);
          }
          if (citation.properties.noteIndex) {
            if (lastNotePos > citation.properties.noteIndex) {
              CSL3.debug("Note index sequence is not sane for citation " + citation.citationID);
            }
            lastNotePos = citation.properties.noteIndex;
          }
        }
        citationByIndex.push(citation);
        citationById[citation.citationID] = citation;
        for (i = 0, ilen = citationsPost.length; i < ilen; i += 1) {
          postCitation = citationsPost[i];
          if (this.opt.development_extensions.strict_inputs) {
            if (citationById[postCitation[0]]) {
              CSL3.error("Previously referenced citationID " + postCitation[0] + " encountered in citationsPost");
            }
            if (postCitation[1]) {
              if (lastNotePos > postCitation[1]) {
                CSL3.debug("Note index sequence is not sane at postCitation[" + i + "]");
              }
              lastNotePos = postCitation[1];
            }
          }
          this.registry.citationreg.citationById[postCitation[0]].properties.noteIndex = postCitation[1];
          citationByIndex.push(this.registry.citationreg.citationById[postCitation[0]]);
          citationById[postCitation[0]] = this.registry.citationreg.citationById[postCitation[0]];
        }
        this.registry.citationreg.citationByIndex = citationByIndex;
        this.registry.citationreg.citationById = citationById;
        this.registry.citationreg.citationsByItemId = {};
        if (this.opt.update_mode === CSL3.POSITION) {
          textCitations = [];
          noteCitations = [];
          citationsInNote = {};
        }
        var update_items = [];
        for (var i = 0, ilen = citationByIndex.length; i < ilen; i += 1) {
          citationByIndex[i].properties.index = i;
          for (j = 0, jlen = citationByIndex[i].sortedItems.length; j < jlen; j += 1) {
            item = citationByIndex[i].sortedItems[j];
            if (!this.registry.citationreg.citationsByItemId[item[1].id]) {
              this.registry.citationreg.citationsByItemId[item[1].id] = [];
              update_items.push("" + item[1].id);
            }
            if (this.registry.citationreg.citationsByItemId[item[1].id].indexOf(citationByIndex[i]) === -1) {
              this.registry.citationreg.citationsByItemId[item[1].id].push(citationByIndex[i]);
            }
          }
          if (this.opt.update_mode === CSL3.POSITION) {
            if (citationByIndex[i].properties.noteIndex) {
              noteCitations.push(citationByIndex[i]);
            } else {
              citationByIndex[i].properties.noteIndex = 0;
              textCitations.push(citationByIndex[i]);
            }
          }
        }
        if (flag !== CSL3.ASSUME_ALL_ITEMS_REGISTERED) {
          if (this.debug) {
            CSL3.debug("****** start update items *********");
          }
          this.updateItems(update_items, null, null, true);
          if (this.debug) {
            CSL3.debug("****** endo update items *********");
          }
        }
        if (!this.opt.citation_number_sort && sortedItems && sortedItems.length > 1 && this.citation_sort.tokens.length > 0) {
          for (var i = 0, ilen = sortedItems.length; i < ilen; i += 1) {
            sortedItems[i][1].sortkeys = CSL3.getSortKeys.call(this, sortedItems[i][0], "citation_sort");
          }
          if (this.opt.grouped_sort && !citation.properties.unsorted) {
            for (var i = 0, ilen = sortedItems.length; i < ilen; i += 1) {
              var sortkeys = sortedItems[i][1].sortkeys;
              this.tmp.authorstring_request = true;
              var mydisambig = this.registry.registry[sortedItems[i][0].id].disambig;
              this.tmp.authorstring_request = true;
              CSL3.getAmbiguousCite.call(this, sortedItems[i][0], mydisambig);
              var authorstring = this.registry.authorstrings[sortedItems[i][0].id];
              this.tmp.authorstring_request = false;
              sortedItems[i][1].sortkeys = [authorstring].concat(sortkeys);
            }
            sortedItems.sort(this.citation.srt.compareCompositeKeys);
            var lastauthor = false;
            var thiskey = false;
            var thisauthor = false;
            for (var i = 0, ilen = sortedItems.length; i < ilen; i += 1) {
              if (sortedItems[i][1].sortkeys[0] !== lastauthor) {
                thisauthor = sortedItems[i][1].sortkeys[0];
                thiskey = sortedItems[i][1].sortkeys[1];
              }
              sortedItems[i][1].sortkeys[0] = "" + thiskey + i;
              lastauthor = thisauthor;
            }
          }
          if (!citation.properties.unsorted) {
            sortedItems.sort(this.citation.srt.compareCompositeKeys);
          }
        }
        if (this.opt.parallel.enable) {
          this.parallel.StartCitation(citation.sortedItems);
        }
        var citations;
        if (this.opt.update_mode === CSL3.POSITION) {
          for (var i = 0; i < 2; i += 1) {
            var first_ref = {};
            var last_ref = {};
            var first_container_ref = {};
            citations = [textCitations, noteCitations][i];
            for (j = 0, jlen = citations.length; j < jlen; j += 1) {
              var onecitation = citations[j];
              if (!citations[j].properties.noteIndex) {
                citations[j].properties.noteIndex = 0;
              }
              citations[j].properties.noteIndex = parseInt(citations[j].properties.noteIndex, 10);
              if (j > 0 && onecitation.properties.noteIndex && citations[j - 1].properties.noteIndex > onecitation.properties.noteIndex) {
                citationsInNote = {};
                first_ref = {};
                last_ref = {};
                first_container_ref = {};
              }
              for (k = 0, klen = onecitation.sortedItems.length; k < klen; k += 1) {
                if (onecitation.sortedItems[k][1].parallel && onecitation.sortedItems[k][1].parallel !== "first") {
                  continue;
                }
                if (!citationsInNote[onecitation.properties.noteIndex]) {
                  citationsInNote[onecitation.properties.noteIndex] = 1;
                } else {
                  citationsInNote[onecitation.properties.noteIndex] += 1;
                }
              }
              for (k = 0, klen = citations[j].sortedItems.length; k < klen; k += 1) {
                item = citations[j].sortedItems[k];
                var item_id = item[0].id;
                var first_id = item[0].legislation_id ? item[0].legislation_id : item[0].id;
                var last_id = item[0].legislation_id ? item[0].legislation_id : item[0].container_id ? item[0].container_id : item[0].id;
                var myxloc = item[1]["locator-extra"];
                var mylocator = item[1].locator;
                var mylabel = item[1].label;
                var incitationid;
                var incitationxloc;
                if (k > 0) {
                  if (onecitation.sortedItems[k - 1][0].legislation_id) {
                    incitationid = onecitation.sortedItems[k - 1][0].legislation_id;
                  } else {
                    incitationid = onecitation.sortedItems[k - 1][1].id;
                    incitationxloc = onecitation.sortedItems[k - 1][1]["locator-extra"];
                    for (var l = k - 2; l > -1; l--) {
                      if (onecitation.sortedItems[l][1].parallel === "first") {
                        incitationid = onecitation.sortedItems[l][1].id;
                        incitationxloc = onecitation.sortedItems[l][1]["locator-extra"];
                      }
                    }
                  }
                }
                if (flag === CSL3.PREVIEW) {
                  if (onecitation.citationID != citation.citationID) {
                    if ("undefined" === typeof first_ref[item[1].id]) {
                      first_ref[first_id] = onecitation.properties.noteIndex;
                      last_ref[last_id] = onecitation.properties.noteIndex;
                    } else {
                      last_ref[last_id] = onecitation.properties.noteIndex;
                    }
                    continue;
                  }
                }
                var oldvalue = {};
                oldvalue.position = item[1].position;
                oldvalue["first-reference-note-number"] = item[1]["first-reference-note-number"];
                oldvalue["first-container-reference-note-number"] = item[1]["first-container-reference-note-number"];
                oldvalue["near-note"] = item[1]["near-note"];
                item[1]["first-reference-note-number"] = 0;
                item[1]["first-container-reference-note-number"] = 0;
                item[1]["near-note"] = false;
                if (this.registry.citationreg.citationsByItemId[item_id]) {
                  if (this.opt.xclass === "note" && this.opt.has_disambiguate) {
                    var oldCount = this.registry.registry[item[0].id]["citation-count"];
                    var newCount = this.registry.citationreg.citationsByItemId[item_id].length;
                    this.registry.registry[item[0].id]["citation-count"] = this.registry.citationreg.citationsByItemId[item_id].length;
                    if ("number" === typeof oldCount) {
                      var oldCountCheck = oldCount < 2;
                      var newCountCheck = newCount < 2;
                      if (oldCountCheck !== newCountCheck) {
                        for (var l = 0, llen = this.registry.citationreg.citationsByItemId[item_id].length; l < llen; l++) {
                          rerunAkeys[this.registry.registry[item[0].id].ambig] = true;
                          this.tmp.taintedCitationIDs[this.registry.citationreg.citationsByItemId[item_id][l].citationID] = true;
                        }
                      }
                    } else {
                      for (var l = 0, llen = this.registry.citationreg.citationsByItemId[item_id].length; l < llen; l++) {
                        rerunAkeys[this.registry.registry[item[0].id].ambig] = true;
                        this.tmp.taintedCitationIDs[this.registry.citationreg.citationsByItemId[item_id][l].citationID] = true;
                      }
                    }
                  }
                }
                var oldlastid;
                var oldlastxloc;
                if ("undefined" === typeof last_ref[last_id] && onecitation.properties.mode !== "author-only") {
                  first_ref[first_id] = onecitation.properties.noteIndex;
                  last_ref[last_id] = onecitation.properties.noteIndex;
                  first_container_ref[last_id] = onecitation.properties.noteIndex;
                  item[1].position = CSL3.POSITION_FIRST;
                } else {
                  var ibidme = false;
                  var suprame = false;
                  var prevCitation = null;
                  if (j > 0) {
                    var prevCitation = citations[j - 1];
                  }
                  var thisCitation = citations[j];
                  if (j > 0) {
                    var old_last_id_offset = 1;
                    if (prevCitation.properties.mode === "author-only" && j > 1) {
                      old_last_id_offset = 2;
                    }
                    var adjusted_offset = j - old_last_id_offset;
                    if (citations[adjusted_offset].sortedItems.length) {
                      oldlastid = citations[adjusted_offset].sortedItems.slice(-1)[0][1].id;
                      oldlastxloc = citations[j - old_last_id_offset].sortedItems.slice(-1)[0][1]["locator-extra"];
                    }
                    if (prevCitation.sortedItems.length) {
                      if (prevCitation.sortedItems[0].slice(-1)[0].legislation_id) {
                        oldlastid = prevCitation.sortedItems[0].slice(-1)[0].legislation_id;
                      }
                    }
                  }
                  if (j > 0 && k === 0 && prevCitation.properties.noteIndex !== thisCitation.properties.noteIndex) {
                    var useme = false;
                    var oldid = prevCitation.sortedItems[0][0].id;
                    if (prevCitation.sortedItems[0][0].legislation_id) {
                      oldid = prevCitation.sortedItems[0][0].legislation_id;
                    }
                    if (oldid == first_id && prevCitation.properties.noteIndex >= thisCitation.properties.noteIndex - 1) {
                      var prevxloc = prevCitation.sortedItems[0][1]["locator-extra"];
                      var thisxloc = thisCitation.sortedItems[0][1]["locator-extra"];
                      if ((citationsInNote[prevCitation.properties.noteIndex] === 1 || prevCitation.properties.noteIndex === 0) && prevxloc === thisxloc) {
                        useme = true;
                      }
                    }
                    if (useme) {
                      ibidme = true;
                    } else {
                      suprame = true;
                    }
                  } else if (k > 0 && incitationid == first_id && incitationxloc == myxloc) {
                    ibidme = true;
                  } else if (k === 0 && j > 0 && prevCitation.properties.noteIndex == thisCitation.properties.noteIndex && prevCitation.sortedItems.length && oldlastid == first_id && oldlastxloc == myxloc) {
                    ibidme = true;
                  } else {
                    suprame = true;
                  }
                  var prev, prev_locator, prev_label, curr_locator, curr_label;
                  if (ibidme) {
                    if (k > 0) {
                      prev = onecitation.sortedItems[k - 1][1];
                    } else {
                      prev = citations[j - 1].sortedItems[0][1];
                    }
                    if (prev.locator) {
                      if (prev.label) {
                        prev_label = prev.label;
                      } else {
                        prev_label = "";
                      }
                      prev_locator = "" + prev.locator + prev_label;
                    } else {
                      prev_locator = prev.locator;
                    }
                    if (mylocator) {
                      if (mylabel) {
                        curr_label = mylabel;
                      } else {
                        curr_label = "";
                      }
                      curr_locator = "" + mylocator + curr_label;
                    } else {
                      curr_locator = mylocator;
                    }
                  }
                  if (ibidme && prev_locator && !curr_locator) {
                    ibidme = false;
                    suprame = true;
                  }
                  if (ibidme) {
                    if (!prev_locator && curr_locator) {
                      item[1].position = CSL3.POSITION_IBID_WITH_LOCATOR;
                    } else if (!prev_locator && !curr_locator) {
                      item[1].position = CSL3.POSITION_IBID;
                    } else if (prev_locator && curr_locator === prev_locator) {
                      item[1].position = CSL3.POSITION_IBID;
                    } else if (prev_locator && curr_locator && curr_locator !== prev_locator) {
                      item[1].position = CSL3.POSITION_IBID_WITH_LOCATOR;
                    } else {
                      ibidme = false;
                      suprame = true;
                    }
                  }
                  if (suprame) {
                    item[1].position = CSL3.POSITION_CONTAINER_SUBSEQUENT;
                    if ("undefined" === typeof first_ref[first_id]) {
                      first_ref[first_id] = onecitation.properties.noteIndex;
                    } else {
                      item[1].position = CSL3.POSITION_SUBSEQUENT;
                    }
                  }
                  if (suprame || ibidme) {
                    if (onecitation.properties.mode === "author-only") {
                      item[1].position = CSL3.POSITION_FIRST;
                    }
                    if (first_container_ref[last_id] != onecitation.properties.noteIndex) {
                      item[1]["first-container-reference-note-number"] = first_container_ref[last_id];
                      if (this.registry.registry[item[0].id]) {
                        this.registry.registry[item[0].id]["first-container-reference-note-number"] = first_container_ref[last_id];
                      }
                    }
                    if (first_ref[first_id] != onecitation.properties.noteIndex) {
                      item[1]["first-reference-note-number"] = first_ref[first_id];
                      if (this.registry.registry[item[0].id]) {
                        this.registry.registry[item[0].id]["first-reference-note-number"] = first_ref[first_id];
                      }
                    }
                  }
                }
                if (onecitation.properties.noteIndex) {
                  var note_distance = parseInt(onecitation.properties.noteIndex, 10) - parseInt(last_ref[last_id], 10);
                  if (item[1].position !== CSL3.POSITION_FIRST && note_distance <= this.citation.opt["near-note-distance"]) {
                    item[1]["near-note"] = true;
                  }
                  last_ref[last_id] = onecitation.properties.noteIndex;
                } else if (item[1].position !== CSL3.POSITION_FIRST) {
                  item[1]["near-note"] = true;
                }
                if (onecitation.citationID != citation.citationID) {
                  for (n = 0, nlen = CSL3.POSITION_TEST_VARS.length; n < nlen; n += 1) {
                    var param = CSL3.POSITION_TEST_VARS[n];
                    if (item[1][param] !== oldvalue[param]) {
                      if (this.registry.registry[item[0].id]) {
                        if (param === "first-reference-note-number") {
                          rerunAkeys[this.registry.registry[item[0].id].ambig] = true;
                          this.tmp.taintedItemIDs[item[0].id] = true;
                        }
                      }
                      this.tmp.taintedCitationIDs[onecitation.citationID] = true;
                    }
                  }
                }
                if (this.sys.variableWrapper) {
                  item[1].index = onecitation.properties.index;
                  item[1].noteIndex = onecitation.properties.noteIndex;
                }
              }
            }
          }
        }
        if (this.opt.citation_number_sort && sortedItems && sortedItems.length > 1 && this.citation_sort.tokens.length > 0) {
          if (!citation.properties.unsorted) {
            for (var i = 0, ilen = sortedItems.length; i < ilen; i += 1) {
              sortedItems[i][1].sortkeys = CSL3.getSortKeys.call(this, sortedItems[i][0], "citation_sort");
            }
            sortedItems.sort(this.citation.srt.compareCompositeKeys);
          }
        }
        for (var key in this.tmp.taintedItemIDs) {
          if (this.tmp.taintedItemIDs.hasOwnProperty(key)) {
            citations = this.registry.citationreg.citationsByItemId[key];
            if (citations) {
              for (var i = 0, ilen = citations.length; i < ilen; i += 1) {
                this.tmp.taintedCitationIDs[citations[i].citationID] = true;
              }
            }
          }
        }
        var ret = [];
        if (flag === CSL3.PREVIEW) {
          if (this.debug) {
            CSL3.debug("****** start run processor *********");
          }
          try {
            ret = this.process_CitationCluster.call(this, citation.sortedItems, citation);
          } catch (e) {
            CSL3.error("Error running CSL processor for preview: " + e);
          }
          if (this.debug) {
            CSL3.debug("****** end run processor *********");
            CSL3.debug("****** start state restore *********");
          }
          this.registry.citationreg.citationByIndex = oldCitationList;
          this.registry.citationreg.citationById = {};
          for (var i = 0, ilen = oldCitationList.length; i < ilen; i += 1) {
            this.registry.citationreg.citationById[oldCitationList[i].citationID] = oldCitationList[i];
          }
          if (this.debug) {
            CSL3.debug("****** start final update *********");
          }
          var oldItemIds = [];
          for (var i = 0, ilen = oldItemList.length; i < ilen; i += 1) {
            oldItemIds.push("" + oldItemList[i].id);
          }
          this.updateItems(oldItemIds, null, null, true);
          if (this.debug) {
            CSL3.debug("****** end final update *********");
          }
          for (var key in oldAmbigs) {
            if (oldAmbigs.hasOwnProperty(key)) {
              this.registry.registry[key].disambig = oldAmbigs[key];
            }
          }
          if (this.debug) {
            CSL3.debug("****** end state restore *********");
          }
        } else {
          for (var rerunAkey in rerunAkeys) {
            this.disambiguate.run(rerunAkey, citation);
          }
          var obj;
          for (var key in this.tmp.taintedCitationIDs) {
            if (key == citation.citationID) {
              continue;
            }
            var mycitation = this.registry.citationreg.citationById[key];
            if (!mycitation.properties.unsorted) {
              for (var i = 0, ilen = mycitation.sortedItems.length; i < ilen; i += 1) {
                mycitation.sortedItems[i][1].sortkeys = CSL3.getSortKeys.call(this, mycitation.sortedItems[i][0], "citation_sort");
              }
              mycitation.sortedItems.sort(this.citation.srt.compareCompositeKeys);
            }
            this.tmp.citation_pos = mycitation.properties.index;
            this.tmp.citation_note_index = mycitation.properties.noteIndex;
            this.tmp.citation_id = "" + mycitation.citationID;
            obj = [];
            obj.push(mycitation.properties.index);
            obj.push(this.process_CitationCluster.call(this, mycitation.sortedItems, mycitation));
            obj.push(mycitation.citationID);
            ret.push(obj);
          }
          this.tmp.taintedItemIDs = {};
          this.tmp.taintedCitationIDs = {};
          this.tmp.citation_pos = citation.properties.index;
          this.tmp.citation_note_index = citation.properties.noteIndex;
          this.tmp.citation_id = "" + citation.citationID;
          obj = [];
          obj.push(citationsPre.length);
          obj.push(this.process_CitationCluster.call(this, sortedItems, citation));
          obj.push(citation.citationID);
          ret.push(obj);
          ret.sort(function(a, b) {
            if (a[0] > b[0]) {
              return 1;
            } else if (a[0] < b[0]) {
              return -1;
            } else {
              return 0;
            }
          });
        }
        this.registry.return_data.citation_errors = this.tmp.citation_errors.slice();
        return [this.registry.return_data, ret];
      };
      CSL3.Engine.prototype.process_CitationCluster = function(sortedItems, citation) {
        var str = "";
        if (citation && citation.properties && citation.properties.mode === "composite") {
          citation.properties.mode = "author-only";
          var firstChunk = CSL3.getCitationCluster.call(this, sortedItems, citation);
          citation.properties.mode = "suppress-author";
          var secondChunk = "";
          if (citation.properties.infix) {
            this.output.append(citation.properties.infix);
            secondChunk = this.output.string(this, this.output.queue);
            if ("object" === typeof secondChunk) {
              secondChunk = secondChunk.join("");
            }
          }
          var thirdChunk = CSL3.getCitationCluster.call(this, sortedItems, citation);
          citation.properties.mode = "composite";
          if (firstChunk && secondChunk && CSL3.SWAPPING_PUNCTUATION.concat(["\u2019", "'"]).indexOf(secondChunk[0]) > -1) {
            firstChunk += secondChunk;
            secondChunk = false;
          }
          str = [firstChunk, secondChunk, thirdChunk].filter(function(obj) {
            return obj;
          }).join(" ");
        } else {
          str = CSL3.getCitationCluster.call(this, sortedItems, citation);
        }
        return str;
      };
      CSL3.Engine.prototype.makeCitationCluster = function(rawList) {
        var inputList, newitem, str, pos, len, item, Item;
        inputList = [];
        len = rawList.length;
        for (pos = 0; pos < len; pos += 1) {
          item = {};
          for (var key in rawList[pos]) {
            item[key] = rawList[pos][key];
          }
          Item = this.retrieveItem("" + item.id);
          if (this.opt.development_extensions.locator_label_parse) {
            if (item.locator && ["bill", "gazette", "legislation", "regulation", "treaty"].indexOf(Item.type) === -1 && (!item.label || item.label === "page")) {
              var m = CSL3.LOCATOR_LABELS_REGEXP.exec(item.locator);
              if (m) {
                var tryLabel = CSL3.LOCATOR_LABELS_MAP[m[2]];
                if (this.getTerm(tryLabel)) {
                  item.label = tryLabel;
                  item.locator = m[3];
                }
              }
            }
          }
          if (item.locator) {
            item.locator = ("" + item.locator).replace(/\s+$/, "");
          }
          newitem = [Item, item];
          inputList.push(newitem);
        }
        if (this.opt.development_extensions.consolidate_legal_items) {
          this.remapSectionVariable(inputList);
        }
        if (inputList && inputList.length > 1 && this.citation_sort.tokens.length > 0) {
          len = inputList.length;
          for (pos = 0; pos < len; pos += 1) {
            inputList[pos][1].sortkeys = CSL3.getSortKeys.call(this, inputList[pos][0], "citation_sort");
          }
          inputList.sort(this.citation.srt.compareCompositeKeys);
        }
        this.tmp.citation_errors = [];
        var str = CSL3.getCitationCluster.call(this, inputList);
        return str;
      };
      CSL3.getAmbiguousCite = function(Item, disambig, visualForm, item) {
        var ret;
        var flags = this.tmp.group_context.tip;
        var oldTermSiblingLayer = {
          term_intended: flags.term_intended,
          variable_attempt: flags.variable_attempt,
          variable_success: flags.variable_success,
          output_tip: flags.output_tip,
          label_form: flags.label_form,
          non_parallel: flags.non_parallel,
          parallel_last: flags.parallel_last,
          parallel_first: flags.parallel_first,
          parallel_last_override: flags.parallel_last_override,
          parallel_delimiter_override: flags.parallel_delimiter_override,
          parallel_delimiter_override_on_suppress: flags.parallel_delimiter_override_on_suppress,
          condition: flags.condition,
          force_suppress: flags.force_suppress,
          done_vars: flags.done_vars.slice()
        };
        if (disambig) {
          this.tmp.disambig_request = disambig;
        } else {
          this.tmp.disambig_request = false;
        }
        var itemSupp = {
          position: CSL3.POSITION_SUBSEQUENT,
          "near-note": true
        };
        if (item) {
          itemSupp.locator = item.locator;
          itemSupp.label = item.label;
        }
        if (this.registry.registry[Item.id] && this.registry.citationreg.citationsByItemId && this.registry.citationreg.citationsByItemId[Item.id] && this.registry.citationreg.citationsByItemId[Item.id].length && visualForm) {
          if (this.citation.opt["givenname-disambiguation-rule"] === "by-cite") {
            itemSupp["first-reference-note-number"] = this.registry.registry[Item.id]["first-reference-note-number"];
          }
        }
        this.tmp.area = "citation";
        this.tmp.root = "citation";
        var origSuppressDecorations = this.tmp.suppress_decorations;
        this.tmp.suppress_decorations = true;
        this.tmp.just_looking = true;
        CSL3.getCite.call(this, Item, itemSupp, null, false);
        for (var i = 0, ilen = this.output.queue.length; i < ilen; i += 1) {
          CSL3.Output.Queue.purgeEmptyBlobs(this.output.queue[i]);
        }
        if (this.opt.development_extensions.clean_up_csl_flaws) {
          for (var j = 0, jlen = this.output.queue.length; j < jlen; j += 1) {
            this.output.adjust.upward(this.output.queue[j]);
            this.output.adjust.leftward(this.output.queue[j]);
            this.output.adjust.downward(this.output.queue[j]);
            this.output.adjust.fix(this.output.queue[j]);
          }
        }
        var ret = this.output.string(this, this.output.queue);
        this.tmp.just_looking = false;
        this.tmp.suppress_decorations = origSuppressDecorations;
        this.tmp.group_context.replace(oldTermSiblingLayer);
        return ret;
      };
      CSL3.getSpliceDelimiter = function(last_locator, last_collapsed, pos) {
        if (void 0 !== this.citation.opt["after-collapse-delimiter"]) {
          if (last_locator) {
            this.tmp.splice_delimiter = this.citation.opt["after-collapse-delimiter"];
          } else if (last_collapsed && !this.tmp.have_collapsed) {
            this.tmp.splice_delimiter = this.citation.opt["after-collapse-delimiter"];
          } else if (!last_collapsed && !this.tmp.have_collapsed && this.citation.opt.collapse !== "year-suffix") {
            this.tmp.splice_delimiter = this.citation.opt["after-collapse-delimiter"];
          } else {
            this.tmp.splice_delimiter = this.citation.opt.layout_delimiter;
          }
        } else if (this.tmp.use_cite_group_delimiter) {
          this.tmp.splice_delimiter = this.citation.opt.cite_group_delimiter;
        } else {
          if (this.tmp.have_collapsed && this.opt.xclass === "in-text" && this.opt.update_mode !== CSL3.NUMERIC) {
            this.tmp.splice_delimiter = ", ";
          } else if (this.tmp.cite_locales[pos - 1]) {
            var alt_affixes = this.tmp.cite_affixes[this.tmp.area][this.tmp.cite_locales[pos - 1]];
            if (alt_affixes && alt_affixes.delimiter) {
              this.tmp.splice_delimiter = alt_affixes.delimiter;
            }
          } else if (!this.tmp.splice_delimiter) {
            this.tmp.splice_delimiter = "";
          }
        }
        return this.tmp.splice_delimiter;
      };
      CSL3.getCitationCluster = function(inputList, citation) {
        var result, objects, myparams, len, pos, item, last_collapsed, params, empties, composite, compie, myblobs, Item, llen, ppos, obj, preceding_item, txt_esc, error_object, citationID, authorOnly, suppressAuthor;
        var citation_prefix = "";
        this.output.checkNestedBrace = new CSL3.checkNestedBrace(this);
        if (citation) {
          citationID = citation.citationID;
          authorOnly = citation.properties.mode === "author-only" ? !!citation.properties.mode : false;
          if (this.opt.xclass !== "note") {
            suppressAuthor = citation.properties.mode === "suppress-author" ? !!citation.properties.mode : false;
          }
          if (citation.properties.prefix) {
            citation_prefix = CSL3.checkPrefixSpaceAppend(this, citation.properties.prefix);
          }
        }
        inputList = inputList ? inputList : [];
        this.tmp.last_primary_names_string = false;
        txt_esc = CSL3.getSafeEscape(this);
        this.tmp.area = "citation";
        this.tmp.root = "citation";
        result = "";
        objects = [];
        this.tmp.last_suffix_used = "";
        this.tmp.last_names_used = [];
        this.tmp.last_years_used = [];
        this.tmp.backref_index = [];
        this.tmp.cite_locales = [];
        if (!this.tmp.just_looking) {
          this.tmp.abbrev_trimmer = {
            QUASHES: {}
          };
        }
        var use_layout_prefix = this.output.checkNestedBrace.update(this.citation.opt.layout_prefix + citation_prefix);
        var suppressTrailingPunctuation = false;
        if (this.citation.opt.suppressTrailingPunctuation) {
          suppressTrailingPunctuation = true;
        }
        if (citationID) {
          if (this.registry.citationreg.citationById[citationID].properties["suppress-trailing-punctuation"]) {
            suppressTrailingPunctuation = true;
          }
        }
        if (this.opt.xclass === "note") {
          var parasets = [];
          var lastTitle = false;
          var lastPosition = false;
          var lastID = false;
          var lst = [];
          for (var i = 0, ilen = inputList.length; i < ilen; i += 1) {
            var type = inputList[i][0].type;
            var title = inputList[i][0].title;
            var position = inputList[i][1].position;
            var id = inputList[i][0].id;
            if (title && type === "legal_case" && id !== lastID && position) {
              if (title !== lastTitle || parasets.length === 0) {
                lst = [];
                parasets.push(lst);
              }
              lst.push(inputList[i][1]);
            }
            lastTitle = title;
            lastPosition = position;
            lastID = id;
          }
          for (i = 0, ilen = parasets.length; i < ilen; i += 1) {
            lst = parasets[i];
            if (lst.length < 2) {
              continue;
            }
            var locatorInLastPosition = lst.slice(-1)[0].locator;
            if (locatorInLastPosition) {
              for (var j = 0, jlen = lst.length - 1; j < jlen; j += 1) {
                if (lst[j].locator) {
                  locatorInLastPosition = false;
                }
              }
            }
            if (locatorInLastPosition) {
              lst[0].locator = locatorInLastPosition;
              delete lst.slice(-1)[0].locator;
              lst[0].label = lst.slice(-1)[0].label;
              if (lst.slice(-1)[0].label) {
                delete lst.slice(-1)[0].label;
              }
            }
          }
        }
        myparams = [];
        len = inputList.length;
        if (inputList[0] && inputList[0][1]) {
          if (authorOnly) {
            delete inputList[0][1]["suppress-author"];
            inputList[0][1]["author-only"] = true;
          } else if (suppressAuthor) {
            delete inputList[0][1]["author-only"];
            inputList[0][1]["suppress-author"] = true;
          }
        }
        if (this.opt.parallel.enable) {
          this.parallel.StartCitation(inputList);
        }
        for (pos = 0; pos < len; pos += 1) {
          this.tmp.cite_index = pos;
          Item = inputList[pos][0];
          item = inputList[pos][1];
          item = CSL3.parseLocator.call(this, item);
          last_collapsed = this.tmp.have_collapsed;
          var last_locator = false;
          if (pos > 0 && inputList[pos - 1][1]) {
            last_locator = !!inputList[pos - 1][1].locator;
          }
          params = {};
          this.tmp.shadow_numbers = {};
          if (!this.tmp.just_looking && this.opt.hasPlaceholderTerm) {
            var output = this.output;
            this.output = new CSL3.Output.Queue(this);
            this.output.adjust = new CSL3.Output.Queue.adjust();
            CSL3.getAmbiguousCite.call(this, Item, null, false, item);
            this.output = output;
          }
          this.tmp.in_cite_predecessor = false;
          if (pos > 0) {
            CSL3.getCite.call(this, Item, item, "" + inputList[pos - 1][0].id, true);
          } else {
            this.tmp.term_predecessor = false;
            CSL3.getCite.call(this, Item, item, null, true);
          }
          if (!this.tmp.cite_renders_content) {
            error_object = {
              citationID: "" + this.tmp.citation_id,
              index: this.tmp.citation_pos,
              noteIndex: this.tmp.citation_note_index,
              itemID: "" + Item.id,
              citationItems_pos: pos,
              error_code: CSL3.ERROR_NO_RENDERED_FORM
            };
            this.tmp.citation_errors.push(error_object);
          }
          params.splice_delimiter = CSL3.getSpliceDelimiter.call(this, last_locator, last_collapsed, pos);
          if (item && item["author-only"]) {
            this.tmp.suppress_decorations = true;
          }
          if (pos > 0) {
            preceding_item = inputList[pos - 1][1];
            var precedingEndsInPeriodOrComma = preceding_item.suffix && [";", ".", ","].indexOf(preceding_item.suffix.slice(-1)) > -1;
            var currentStartsWithPeriodOrComma = !preceding_item.suffix && item.prefix && [";", ".", ","].indexOf(item.prefix.slice(0, 1)) > -1;
            if (precedingEndsInPeriodOrComma || currentStartsWithPeriodOrComma) {
              var spaceidx = params.splice_delimiter.indexOf(" ");
              if (spaceidx > -1 && !currentStartsWithPeriodOrComma) {
                params.splice_delimiter = params.splice_delimiter.slice(spaceidx);
              } else {
                params.splice_delimiter = "";
              }
            }
          }
          params.suppress_decorations = this.tmp.suppress_decorations;
          params.have_collapsed = this.tmp.have_collapsed;
          myparams.push(params);
          if (item["author-only"]) {
            break;
          }
        }
        empties = 0;
        myblobs = this.output.queue.slice();
        var citation_suffix = "";
        if (citation) {
          citation_suffix = CSL3.checkSuffixSpacePrepend(this, citation.properties.suffix);
        }
        var suffix = this.citation.opt.layout_suffix;
        var last_locale = this.tmp.cite_locales[this.tmp.cite_locales.length - 1];
        if (last_locale && this.tmp.cite_affixes[this.tmp.area][last_locale] && this.tmp.cite_affixes[this.tmp.area][last_locale].suffix) {
          suffix = this.tmp.cite_affixes[this.tmp.area][last_locale].suffix;
        }
        if (CSL3.TERMINAL_PUNCTUATION.slice(0, -1).indexOf(suffix.slice(0, 1)) > -1) {
          suffix = suffix.slice(0, 1);
        }
        suffix = this.output.checkNestedBrace.update(citation_suffix + suffix);
        for (var i = 0, ilen = this.output.queue.length; i < ilen; i += 1) {
          CSL3.Output.Queue.purgeEmptyBlobs(this.output.queue[i]);
        }
        if (!this.tmp.suppress_decorations && this.output.queue.length) {
          if (!(this.opt.development_extensions.apply_citation_wrapper && this.sys.wrapCitationEntry && !this.tmp.just_looking && this.tmp.area === "citation")) {
            if (!suppressTrailingPunctuation) {
              this.output.queue[this.output.queue.length - 1].strings.suffix = suffix;
            }
            this.output.queue[0].strings.prefix = use_layout_prefix;
          }
        }
        if (this.opt.development_extensions.clean_up_csl_flaws) {
          for (var j = 0, jlen = this.output.queue.length; j < jlen; j += 1) {
            this.output.adjust.upward(this.output.queue[j]);
            this.output.adjust.leftward(this.output.queue[j]);
            this.output.adjust.downward(this.output.queue[j]);
            this.tmp.last_chr = this.output.adjust.fix(this.output.queue[j]);
          }
        }
        for (pos = 0, len = myblobs.length; pos < len; pos += 1) {
          var buffer = [];
          this.output.queue = [myblobs[pos]];
          this.tmp.suppress_decorations = myparams[pos].suppress_decorations;
          this.tmp.splice_delimiter = myparams[pos].splice_delimiter;
          if (myblobs[pos].parallel_delimiter) {
            this.tmp.splice_delimiter = myblobs[pos].parallel_delimiter;
          }
          this.tmp.have_collapsed = myparams[pos].have_collapsed;
          composite = this.output.string(this, this.output.queue);
          this.tmp.suppress_decorations = false;
          if ("string" === typeof composite) {
            this.tmp.suppress_decorations = false;
            if (!composite) {
              if (this.opt.development_extensions.throw_on_empty) {
                CSL3.error("Citation would render no content");
              } else {
                composite = "[NO_PRINTED_FORM]";
              }
            }
            return composite;
          }
          if ("object" === typeof composite && composite.length === 0 && !item["suppress-author"]) {
            if (pos === 0) {
              var errStr = "[CSL STYLE ERROR: reference with no printed form.]";
              var preStr = pos === 0 ? txt_esc(this.citation.opt.layout_prefix) : "";
              var sufStr = pos === myblobs.length - 1 ? txt_esc(this.citation.opt.layout_suffix) : "";
              composite.push(preStr + errStr + sufStr);
            } else if (pos === myblobs.length - 1) {
              var tmpobj = objects[objects.length - 1];
              if (typeof tmpobj === "string") {
                objects[objects.length - 1] += txt_esc(this.citation.opt.layout_suffix);
              } else if (typeof tmpobj === "object") {
                tmpobj.strings.suffix += txt_esc(this.citation.opt.layout_suffix);
              }
            }
          }
          if (buffer.length && "string" === typeof composite[0]) {
            composite.reverse();
            var tmpstr = composite.pop();
            if (tmpstr && tmpstr.slice(0, 1) === ",") {
              buffer.push(tmpstr);
            } else if ("string" == typeof buffer.slice(-1)[0] && buffer.slice(-1)[0].slice(-1) === ",") {
              buffer.push(" " + tmpstr);
            } else if (tmpstr) {
              buffer.push(txt_esc(this.tmp.splice_delimiter) + tmpstr);
            }
          } else {
            composite.reverse();
            compie = composite.pop();
            if ("undefined" !== typeof compie) {
              if (buffer.length && "string" === typeof buffer[buffer.length - 1]) {
                buffer[buffer.length - 1] += compie.successor_prefix;
              }
              buffer.push(compie);
            }
          }
          llen = composite.length;
          for (ppos = 0; ppos < llen; ppos += 1) {
            obj = composite[ppos];
            if ("string" === typeof obj) {
              buffer.push(txt_esc(this.tmp.splice_delimiter) + obj);
              continue;
            }
            compie = composite.pop();
            if ("undefined" !== typeof compie) {
              buffer.push(compie);
            }
          }
          if (buffer.length === 0 && !inputList[pos][1]["suppress-author"]) {
            empties += 1;
          }
          if (buffer.length > 1 && typeof buffer[0] !== "string") {
            buffer = [this.output.renderBlobs(buffer)];
          }
          if (buffer.length) {
            if ("string" === typeof buffer[0]) {
              if (pos > 0) {
                buffer[0] = txt_esc(this.tmp.splice_delimiter) + buffer[0];
              }
            } else {
              if (pos > 0) {
                buffer[0].splice_prefix = this.tmp.splice_delimiter;
              } else {
                buffer[0].splice_prefix = "";
              }
            }
          }
          objects = objects.concat(buffer);
        }
        result += this.output.renderBlobs(objects);
        if (result) {
          if (!this.tmp.suppress_decorations) {
            len = this.citation.opt.layout_decorations.length;
            for (pos = 0; pos < len; pos += 1) {
              params = this.citation.opt.layout_decorations[pos];
              if (params[1] === "normal") {
                continue;
              }
              if (!item || !item["author-only"]) {
                result = this.fun.decorate[params[0]][params[1]](this, result);
              }
            }
          }
        }
        this.tmp.suppress_decorations = false;
        if (!result) {
          if (this.opt.development_extensions.throw_on_empty) {
            CSL3.error("Citation would render no content");
          } else {
            result = "[NO_PRINTED_FORM]";
          }
        }
        return result;
      };
      CSL3.getCite = function(Item, item, prevItemID, blockShadowNumberReset) {
        var next, error_object;
        var areaOrig = this.tmp.area;
        if (item && item["author-only"] && this.intext && this.intext.tokens.length > 0) {
          this.tmp.area = "intext";
        }
        this.tmp.cite_renders_content = false;
        this.tmp.probably_rendered_something = false;
        this.tmp.prevItemID = prevItemID;
        CSL3.citeStart.call(this, Item, item, blockShadowNumberReset);
        next = 0;
        this.tmp.name_node = {};
        this.nameOutput = new CSL3.NameOutput(this, Item, item);
        while (next < this[this.tmp.area].tokens.length) {
          next = CSL3.tokenExec.call(this, this[this.tmp.area].tokens[next], Item, item);
        }
        CSL3.citeEnd.call(this, Item, item);
        if (!this.tmp.cite_renders_content && !this.tmp.just_looking) {
          if (this.tmp.area === "bibliography") {
            error_object = {
              index: this.tmp.bibliography_pos,
              itemID: "" + Item.id,
              error_code: CSL3.ERROR_NO_RENDERED_FORM
            };
            this.tmp.bibliography_errors.push(error_object);
          }
        }
        this.tmp.area = areaOrig;
        return "" + Item.id;
      };
      CSL3.citeStart = function(Item, item, blockShadowNumberReset) {
        this.tmp.lang_array = [];
        if (Item.language) {
          var m = Item.language.match(/^([a-zA-Z]+).*/);
          if (m) {
            this.tmp.lang_array.push(m[1].toLowerCase());
          }
        }
        this.tmp.lang_array.push(this.opt.lang);
        if (!blockShadowNumberReset) {
          this.tmp.shadow_numbers = {};
        }
        this.tmp.disambiguate_count = 0;
        this.tmp.disambiguate_maxMax = 0;
        this.tmp.same_author_as_previous_cite = false;
        if (!this.tmp.suppress_decorations) {
          this.tmp.subsequent_author_substitute_ok = true;
        } else {
          this.tmp.subsequent_author_substitute_ok = false;
        }
        this.tmp.lastchr = "";
        if (this.tmp.area === "citation" && this.citation.opt.collapse && this.citation.opt.collapse.length) {
          this.tmp.have_collapsed = true;
        } else {
          this.tmp.have_collapsed = false;
        }
        this.tmp.render_seen = false;
        if (this.tmp.disambig_request && !this.tmp.disambig_override) {
          this.tmp.disambig_settings = this.tmp.disambig_request;
        } else if (this.registry.registry[Item.id] && !this.tmp.disambig_override) {
          this.tmp.disambig_request = this.registry.registry[Item.id].disambig;
          this.tmp.disambig_settings = this.registry.registry[Item.id].disambig;
        } else {
          this.tmp.disambig_settings = new CSL3.AmbigConfig();
        }
        if (this.tmp.area !== "citation") {
          if (!this.registry.registry[Item.id]) {
            this.tmp.disambig_restore = new CSL3.AmbigConfig();
          } else {
            this.tmp.disambig_restore = CSL3.cloneAmbigConfig(this.registry.registry[Item.id].disambig);
            if (this.tmp.area === "bibliography" && this.tmp.disambig_settings && this.tmp.disambig_override) {
              if (this.opt["disambiguate-add-names"]) {
                this.tmp.disambig_settings.names = this.registry.registry[Item.id].disambig.names.slice();
                if (this.tmp.disambig_request) {
                  this.tmp.disambig_request.names = this.registry.registry[Item.id].disambig.names.slice();
                }
              }
              if (this.opt["disambiguate-add-givenname"]) {
                this.tmp.disambig_request = this.tmp.disambig_settings;
                this.tmp.disambig_settings.givens = this.registry.registry[Item.id].disambig.givens.slice();
                this.tmp.disambig_request.givens = this.registry.registry[Item.id].disambig.givens.slice();
                for (var i = 0, ilen = this.tmp.disambig_settings.givens.length; i < ilen; i += 1) {
                  this.tmp.disambig_settings.givens[i] = this.registry.registry[Item.id].disambig.givens[i].slice();
                }
                for (var i = 0, ilen = this.tmp.disambig_request.givens.length; i < ilen; i += 1) {
                  this.tmp.disambig_request.givens[i] = this.registry.registry[Item.id].disambig.givens[i].slice();
                }
              }
            }
          }
        }
        this.tmp.names_used = [];
        this.tmp.nameset_counter = 0;
        this.tmp.years_used = [];
        this.tmp.names_max.clear();
        if (!this.tmp.just_looking) {
          if (!item || item.parallel === "first" || !item.parallel) {
            this.tmp.abbrev_trimmer = {
              QUASHES: {}
            };
          }
        }
        this.tmp.splice_delimiter = this[this.tmp.area].opt.layout_delimiter;
        this.bibliography_sort.keys = [];
        this.citation_sort.keys = [];
        this.tmp.has_done_year_suffix = false;
        this.tmp.last_cite_locale = false;
        if (!this.tmp.just_looking && item && !item.position && this.registry.registry[Item.id]) {
          this.tmp.disambig_restore = CSL3.cloneAmbigConfig(this.registry.registry[Item.id].disambig);
        }
        this.tmp.first_name_string = false;
        this.tmp.authority_stop_last = 0;
      };
      CSL3.citeEnd = function(Item, item) {
        if (this.tmp.disambig_restore && this.registry.registry[Item.id]) {
          this.registry.registry[Item.id].disambig.names = this.tmp.disambig_restore.names.slice();
          this.registry.registry[Item.id].disambig.givens = this.tmp.disambig_restore.givens.slice();
          for (var i = 0, ilen = this.registry.registry[Item.id].disambig.givens.length; i < ilen; i += 1) {
            this.registry.registry[Item.id].disambig.givens[i] = this.tmp.disambig_restore.givens[i].slice();
          }
        }
        this.tmp.disambig_restore = false;
        if (item && item.suffix) {
          this.tmp.last_suffix_used = item.suffix;
        } else {
          this.tmp.last_suffix_used = "";
        }
        this.tmp.last_years_used = this.tmp.years_used.slice();
        this.tmp.last_names_used = this.tmp.names_used.slice();
        this.tmp.cut_var = false;
        this.tmp.disambig_request = false;
        this.tmp.cite_locales.push(this.tmp.last_cite_locale);
        if (this.tmp.issued_date && this.tmp.renders_collection_number) {
          var buf = [];
          for (var i = this.tmp.issued_date.list.length - 1; i > this.tmp.issued_date.pos; i += -1) {
            buf.push(this.tmp.issued_date.list.pop());
          }
          this.tmp.issued_date.list.pop();
          for (i = buf.length - 1; i > -1; i += -1) {
            this.tmp.issued_date.list.push(buf.pop());
          }
        }
        this.tmp.issued_date = false;
        this.tmp.renders_collection_number = false;
      };
      CSL3.Engine.prototype.makeBibliography = function(bibsection) {
        var debug, ret, params, maxoffset, item, len, pos, tok, tokk, tokkk, entry_ids, entry_strings;
        debug = false;
        if (!bibsection && (this.bibliography.opt.exclude_types || this.bibliography.opt.exclude_with_fields)) {
          bibsection = {
            exclude: []
          };
          if (this.bibliography.opt.exclude_types) {
            for (var i in this.bibliography.opt.exclude_types) {
              var val = this.bibliography.opt.exclude_types[i];
              bibsection.exclude.push({
                field: "type",
                value: val
              });
            }
          }
          if (this.bibliography.opt.exclude_with_fields) {
            for (var i in this.bibliography.opt.exclude_with_fields) {
              var field = this.bibliography.opt.exclude_with_fields[i];
              bibsection.exclude.push({
                field,
                value: true
              });
            }
          }
        }
        if (!this.bibliography.tokens.length) {
          return false;
        }
        if ("string" === typeof bibsection) {
          this.opt.citation_number_slug = bibsection;
          bibsection = false;
        }
        if (debug) {
          len = this.bibliography.tokens.length;
          for (pos = 0; pos < len; pos += 1) {
            tok = this.bibliography.tokens[pos];
            CSL3.debug("bibtok: " + tok.name);
          }
          CSL3.debug("---");
          len = this.citation.tokens.length;
          for (pos = 0; pos < len; pos += 1) {
            tokk = this.citation.tokens[pos];
            CSL3.debug("cittok: " + tok.name);
          }
          CSL3.debug("---");
          len = this.bibliography_sort.tokens.length;
          for (pos = 0; pos < len; pos += 1) {
            tokkk = this.bibliography_sort.tokens[pos];
            CSL3.debug("bibsorttok: " + tok.name);
          }
        }
        ret = CSL3.getBibliographyEntries.call(this, bibsection);
        entry_ids = ret[0];
        entry_strings = ret[1];
        var done = ret[2];
        params = {
          "maxoffset": 0,
          "entryspacing": this.bibliography.opt["entry-spacing"],
          "linespacing": this.bibliography.opt["line-spacing"],
          "second-field-align": false,
          "entry_ids": entry_ids,
          "bibliography_errors": this.tmp.bibliography_errors.slice(),
          "done": done
        };
        if (this.bibliography.opt["second-field-align"]) {
          params["second-field-align"] = this.bibliography.opt["second-field-align"];
        }
        maxoffset = 0;
        len = this.registry.reflist.length;
        for (pos = 0; pos < len; pos += 1) {
          item = this.registry.reflist[pos];
          if (item.offset > params.maxoffset) {
            params.maxoffset = item.offset;
          }
        }
        if (this.bibliography.opt.hangingindent) {
          params.hangingindent = this.bibliography.opt.hangingindent;
        }
        params.bibstart = this.fun.decorate.bibstart;
        params.bibend = this.fun.decorate.bibend;
        this.opt.citation_number_slug = false;
        return [params, entry_strings];
      };
      CSL3.getBibliographyEntries = function(bibsection) {
        var ret, input, include, anymatch, allmatch, bib_entry, res, item, spec, lllen, pppos, topblobs, entry_item_ids, debug, i, ilen, siblings, skips, sortedItems, eyetem, entry_item_data, j, jlen;
        ret = [];
        entry_item_data = [];
        this.tmp.area = "bibliography";
        this.tmp.root = "bibliography";
        this.tmp.last_rendered_name = false;
        this.tmp.bibliography_errors = [];
        this.tmp.bibliography_pos = 0;
        if (bibsection && bibsection.page_start && bibsection.page_length) {
          input = this.registry.getSortedIds();
        } else {
          input = this.refetchItems(this.registry.getSortedIds());
        }
        this.tmp.disambig_override = true;
        function eval_string(a, b) {
          if (a === b) {
            return true;
          }
          return false;
        }
        function eval_list(a, lst) {
          lllen = lst.length;
          for (pppos = 0; pppos < lllen; pppos += 1) {
            if (eval_string(a, lst[pppos])) {
              return true;
            }
          }
          return false;
        }
        function eval_spec(a, b) {
          if ("boolean" === typeof a || !a) {
            if (a) {
              return !!b;
            } else {
              return !b;
            }
          } else {
            if ("string" === typeof b) {
              return eval_string(a, b);
            } else if (!b) {
              return false;
            } else {
              return eval_list(a, b);
            }
          }
        }
        skips = {};
        var page_item_count;
        if (bibsection && bibsection.page_start && bibsection.page_length) {
          page_item_count = 0;
          if (bibsection.page_start !== true) {
            for (i = 0, ilen = input.length; i < ilen; i += 1) {
              skips[input[i]] = true;
              if (bibsection.page_start == input[i]) {
                break;
              }
            }
          }
        }
        var processed_item_ids = [];
        var consolidatedIDs = {};
        this.tmp.container_item_count = {};
        input = input.filter((o) => {
          var ret2 = o;
          if (o.legislation_id) {
            if (consolidatedIDs[o.legislation_id]) {
              ret2 = false;
            } else {
              consolidatedIDs[o.legislation_id] = true;
            }
          } else if (o.container_id) {
            if (!this.tmp.container_item_count[o.container_id]) {
              this.tmp.container_item_count[o.container_id] = 0;
            }
            this.tmp.container_item_count[o.container_id]++;
            if (this.bibliography.opt.consolidate_containers.indexOf(o.type) > -1) {
              if (consolidatedIDs[o.container_id]) {
                ret2 = false;
              } else {
                consolidatedIDs[o.container_id] = true;
              }
            }
          }
          return ret2;
        });
        this.tmp.container_item_pos = {};
        for (i = 0, ilen = input.length; i < ilen; i += 1) {
          if (bibsection && bibsection.page_start && bibsection.page_length) {
            if (skips[input[i]]) {
              continue;
            }
            item = this.refetchItem(input[i]);
            if (page_item_count === bibsection.page_length) {
              break;
            }
          } else {
            item = input[i];
            if (skips[item.id]) {
              continue;
            }
          }
          if (bibsection) {
            include = true;
            if (bibsection.include) {
              include = false;
              for (j = 0, jlen = bibsection.include.length; j < jlen; j += 1) {
                spec = bibsection.include[j];
                if (eval_spec(spec.value, item[spec.field])) {
                  include = true;
                  break;
                }
              }
            } else if (bibsection.exclude) {
              anymatch = false;
              for (j = 0, jlen = bibsection.exclude.length; j < jlen; j += 1) {
                spec = bibsection.exclude[j];
                if (eval_spec(spec.value, item[spec.field])) {
                  anymatch = true;
                  break;
                }
              }
              if (anymatch) {
                include = false;
              }
            } else if (bibsection.select) {
              include = false;
              allmatch = true;
              for (j = 0, jlen = bibsection.select.length; j < jlen; j += 1) {
                spec = bibsection.select[j];
                if (!eval_spec(spec.value, item[spec.field])) {
                  allmatch = false;
                }
              }
              if (allmatch) {
                include = true;
              }
            }
            if (bibsection.quash) {
              allmatch = true;
              for (j = 0, jlen = bibsection.quash.length; j < jlen; j += 1) {
                spec = bibsection.quash[j];
                if (!eval_spec(spec.value, item[spec.field])) {
                  allmatch = false;
                }
              }
              if (allmatch) {
                include = false;
              }
            }
            if (!include) {
              continue;
            }
          }
          if (debug) {
            CSL3.debug("BIB: " + item.id);
          }
          if (item.container_id) {
            if (!this.tmp.container_item_pos[item.container_id]) {
              this.tmp.container_item_pos[item.container_id] = 0;
            }
            this.tmp.container_item_pos[item.container_id]++;
          }
          bib_entry = new CSL3.Token("group", CSL3.START);
          bib_entry.decorations = [["@bibliography", "entry"]].concat(this.bibliography.opt.layout_decorations);
          this.output.startTag("bib_entry", bib_entry);
          if (item.system_id && this.sys.embedBibliographyEntry) {
            this.output.current.value().item_id = item.system_id;
          } else {
            this.output.current.value().system_id = item.id;
          }
          entry_item_ids = [];
          if (this.registry.registry[item.id].master && !(bibsection && bibsection.page_start && bibsection.page_length)) {
            sortedItems = [[item, { id: item.id }]];
            siblings = this.registry.registry[item.id].siblings;
            for (var j = 0, jlen = siblings.length; j < jlen; j++) {
              sortedItems.push([this.refetchItem(siblings[j]), { id: siblings[j] }]);
            }
            this.parallel.StartCitation(sortedItems);
            if (this.registry.registry[item.id].parallel_delimiter_override) {
              this.output.queue[0].strings.delimiter = this.registry.registry[item.id].parallel_delimiter_override;
            } else {
              this.output.queue[0].strings.delimiter = ", ";
            }
            this.tmp.term_predecessor = false;
            this.tmp.cite_index = 0;
            for (j = 0, jlen = sortedItems.length; j < jlen; j += 1) {
              if (j < sortedItems.length - 1) {
                this.tmp.parallel_and_not_last = true;
              } else {
                delete this.tmp.parallel_and_not_last;
              }
              entry_item_ids.push("" + CSL3.getCite.call(this, sortedItems[j][0], sortedItems[j][1]));
              this.tmp.cite_index++;
              skips[sortedItems[j][0].id] = true;
            }
          } else if (!this.registry.registry[item.id].siblings) {
            this.tmp.term_predecessor = false;
            this.tmp.cite_index = 0;
            entry_item_ids.push("" + CSL3.getCite.call(this, item));
            if (bibsection && bibsection.page_start && bibsection.page_length) {
              page_item_count += 1;
            }
          }
          entry_item_data.push("");
          this.tmp.bibliography_pos += 1;
          processed_item_ids.push(entry_item_ids);
          this.output.endTag("bib_entry");
          if (this.output.queue[0].blobs.length && this.output.queue[0].blobs[0].blobs.length) {
            if (!this.output.queue[0].blobs[0].blobs[0].strings) {
              topblobs = this.output.queue[0].blobs;
            } else {
              topblobs = this.output.queue[0].blobs[0].blobs;
            }
            topblobs[0].strings.prefix = this.bibliography.opt.layout_prefix + topblobs[0].strings.prefix;
          }
          for (j = 0, jlen = this.output.queue.length; j < jlen; j += 1) {
            CSL3.Output.Queue.purgeEmptyBlobs(this.output.queue[j]);
          }
          for (j = 0, jlen = this.output.queue.length; j < jlen; j += 1) {
            this.output.adjust.upward(this.output.queue[j]);
            this.output.adjust.leftward(this.output.queue[j]);
            this.output.adjust.downward(this.output.queue[j], true);
            this.output.adjust.fix(this.output.queue[j]);
          }
          res = this.output.string(this, this.output.queue)[0];
          if (!res && this.opt.update_mode === CSL3.NUMERIC) {
            var err = ret.length + 1 + ". [CSL STYLE ERROR: reference with no printed form.]";
            res = CSL3.Output.Formats[this.opt.mode]["@bibliography/entry"](this, err);
          }
          if (res) {
            ret.push(res);
          }
        }
        var done = false;
        if (bibsection && bibsection.page_start && bibsection.page_length) {
          var last_expected_id = input.slice(-1)[0];
          var last_seen_id = processed_item_ids.slice(-1)[0];
          if (!last_expected_id || !last_seen_id || last_expected_id == last_seen_id) {
            done = true;
          }
        }
        this.tmp.disambig_override = false;
        return [processed_item_ids, ret, done];
      };
      CSL3.Engine.prototype.setCitationId = function(citation, force) {
        var ret, id, direction;
        ret = false;
        if (!citation.citationID || force) {
          id = Math.floor(Math.random() * 1e14);
          while (true) {
            direction = 0;
            if (!this.registry.citationreg.citationById[id]) {
              citation.citationID = "a" + id.toString(32);
              break;
            } else if (!direction && id < 5e13) {
              direction = 1;
            } else {
              direction = -1;
            }
            if (direction === 1) {
              id += 1;
            } else {
              id += -1;
            }
          }
          ret = "" + id;
        }
        this.registry.citationreg.citationById[citation.citationID] = citation;
        return ret;
      };
      CSL3.Engine.prototype.rebuildProcessorState = function(citations, mode, uncitedItemIDs) {
        if (!citations) {
          citations = [];
        }
        if (!mode) {
          mode = "html";
        }
        var doneIDs = {};
        var itemIDs = [];
        for (var i = 0, ilen = citations.length; i < ilen; i += 1) {
          for (var j = 0, jlen = citations[i].citationItems.length; j < jlen; j += 1) {
            var itemID = "" + citations[i].citationItems[j].id;
            if (!doneIDs[itemID]) {
              itemIDs.push(itemID);
            }
            doneIDs[itemID] = true;
          }
        }
        this.updateItems(itemIDs);
        var pre = [];
        var post = [];
        var ret = [];
        var oldMode = this.opt.mode;
        this.setOutputFormat(mode);
        for (var i = 0, ilen = citations.length; i < ilen; i += 1) {
          var res = this.processCitationCluster(citations[i], pre, post, CSL3.ASSUME_ALL_ITEMS_REGISTERED);
          pre.push([citations[i].citationID, citations[i].properties.noteIndex]);
          for (var j = 0, jlen = res[1].length; j < jlen; j += 1) {
            var index = res[1][j][0];
            ret[index] = [
              pre[index][0],
              pre[index][1],
              res[1][j][1]
            ];
          }
        }
        this.updateUncitedItems(uncitedItemIDs);
        this.setOutputFormat(oldMode);
        return ret;
      };
      CSL3.Engine.prototype.restoreProcessorState = function(citations) {
        var i, ilen, j, jlen, item, Item, newitem, citationList, itemList, sortedItems;
        citationList = [];
        itemList = [];
        if (!citations) {
          citations = [];
        }
        var indexNumbers = [];
        var citationIds = {};
        for (i = 0, ilen = citations.length; i < ilen; i += 1) {
          if (citationIds[citations[i].citationID]) {
            this.setCitationId(citations[i], true);
          }
          citationIds[citations[i].citationID] = true;
          indexNumbers.push(citations[i].properties.index);
        }
        var oldCitations = citations.slice();
        oldCitations.sort(
          function(a, b) {
            if (a.properties.index < b.properties.index) {
              return -1;
            } else if (a.properties.index > b.properties.index) {
              return 1;
            } else {
              return 0;
            }
          }
        );
        for (i = 0, ilen = oldCitations.length; i < ilen; i += 1) {
          oldCitations[i].properties.index = i;
        }
        for (i = 0, ilen = oldCitations.length; i < ilen; i += 1) {
          sortedItems = [];
          for (j = 0, jlen = oldCitations[i].citationItems.length; j < jlen; j += 1) {
            item = oldCitations[i].citationItems[j];
            if ("undefined" === typeof item.sortkeys) {
              item.sortkeys = [];
            }
            Item = this.retrieveItem("" + item.id);
            newitem = [Item, item];
            sortedItems.push(newitem);
            oldCitations[i].citationItems[j].item = Item;
            itemList.push("" + item.id);
          }
          if (!oldCitations[i].properties.unsorted) {
            sortedItems.sort(this.citation.srt.compareCompositeKeys);
          }
          oldCitations[i].sortedItems = sortedItems;
          this.registry.citationreg.citationById[oldCitations[i].citationID] = oldCitations[i];
        }
        this.updateItems(itemList);
        for (i = 0, ilen = citations.length; i < ilen; i += 1) {
          citationList.push(["" + citations[i].citationID, citations[i].properties.noteIndex]);
        }
        var ret = [];
        if (citations && citations.length) {
          ret = this.processCitationCluster(citations[0], [], citationList.slice(1));
        } else {
          this.registry = new CSL3.Registry(this);
          this.tmp = new CSL3.Engine.Tmp();
          this.disambiguate = new CSL3.Disambiguation(this);
        }
        return ret;
      };
      CSL3.Engine.prototype.updateItems = function(idList, nosort, rerun_ambigs, implicitUpdate) {
        var debug = false;
        var oldArea = this.tmp.area;
        var oldRoot = this.tmp.root;
        var oldExtension = this.tmp.extension;
        if (this.bibliography_sort.tokens.length === 0) {
          nosort = true;
        }
        this.tmp.area = "citation";
        this.tmp.root = "citation";
        this.tmp.extension = "";
        if (!implicitUpdate) {
          this.tmp.loadedItemIDs = {};
        }
        if (debug) {
          CSL3.debug("--> init <--");
        }
        this.registry.init(idList);
        if (rerun_ambigs) {
          for (var ambig in this.registry.ambigcites) {
            this.registry.ambigsTouched[ambig] = true;
          }
        }
        this.registry.dodeletes(this.registry.myhash);
        this.registry.doinserts(this.registry.mylist);
        this.registry.dorefreshes();
        this.registry.rebuildlist(nosort);
        this.registry.setsortkeys();
        this.registry.setdisambigs();
        this.registry.sorttokens(nosort);
        this.registry.renumber();
        this.tmp.extension = oldExtension;
        this.tmp.area = oldArea;
        this.tmp.root = oldRoot;
        return this.registry.getSortedIds();
      };
      CSL3.Engine.prototype.updateUncitedItems = function(idList, nosort) {
        var idHash;
        var oldArea = this.tmp.area;
        var oldRoot = this.tmp.root;
        var oldExtension = this.tmp.extension;
        if (this.bibliography_sort.tokens.length === 0) {
          nosort = true;
        }
        this.tmp.area = "citation";
        this.tmp.root = "citation";
        this.tmp.extension = "";
        this.tmp.loadedItemIDs = {};
        if (!idList) {
          idList = [];
        }
        if ("object" == typeof idList) {
          if ("undefined" == typeof idList.length) {
            idHash = idList;
            idList = [];
            for (var key in idHash) {
              idList.push(key);
            }
          } else if ("number" == typeof idList.length) {
            idHash = {};
            for (var i = 0, ilen = idList.length; i < ilen; i += 1) {
              idHash[idList[i]] = true;
            }
          }
        }
        this.registry.init(idList, true);
        this.registry.dopurge(idHash);
        this.registry.doinserts(this.registry.mylist);
        this.registry.dorefreshes();
        this.registry.rebuildlist(nosort);
        this.registry.setsortkeys();
        this.registry.setdisambigs();
        this.registry.sorttokens(nosort);
        this.registry.renumber();
        this.tmp.extension = oldExtension;
        this.tmp.area = oldArea;
        this.tmp.root = oldRoot;
        return this.registry.getSortedIds();
      };
      CSL3.localeResolve = function(langstr, defaultLocale) {
        var ret, langlst;
        if (!defaultLocale) {
          defaultLocale = "en-US";
        }
        if (!langstr) {
          langstr = defaultLocale;
        }
        ret = {};
        langlst = langstr.split(/[\-_]/);
        ret.base = CSL3.LANG_BASES[langlst[0]];
        if ("undefined" === typeof ret.base) {
          return { base: defaultLocale, best: langstr, bare: langlst[0] };
        }
        if (langlst.length === 1) {
          ret.generic = true;
        }
        if (langlst.length === 1 || langlst[1] === "x") {
          ret.best = ret.base.replace("_", "-");
        } else {
          ret.best = langlst.slice(0, 2).join("-");
        }
        ret.base = ret.base.replace("_", "-");
        ret.bare = langlst[0];
        return ret;
      };
      CSL3.Engine.prototype.localeConfigure = function(langspec, beShy) {
        var localexml;
        if (beShy && this.locale[langspec.best]) {
          return;
        }
        if (langspec.best === "en-US") {
          localexml = CSL3.setupXml(this.sys.retrieveLocale("en-US"));
          this.localeSet(localexml, "en-US", langspec.best);
        } else if (langspec.best !== "en-US") {
          if (langspec.base !== langspec.best) {
            localexml = CSL3.setupXml(this.sys.retrieveLocale(langspec.base));
            this.localeSet(localexml, langspec.base, langspec.best);
          }
          localexml = CSL3.setupXml(this.sys.retrieveLocale(langspec.best));
          this.localeSet(localexml, langspec.best, langspec.best);
        }
        this.localeSet(this.cslXml, "", langspec.best);
        this.localeSet(this.cslXml, langspec.bare, langspec.best);
        if (langspec.base !== langspec.best) {
          this.localeSet(this.cslXml, langspec.base, langspec.best);
        }
        this.localeSet(this.cslXml, langspec.best, langspec.best);
        if ("undefined" === typeof this.locale[langspec.best].terms["page-range-delimiter"]) {
          if (["fr", "pt"].indexOf(langspec.best.slice(0, 2).toLowerCase()) > -1) {
            this.locale[langspec.best].terms["page-range-delimiter"] = "-";
          } else {
            this.locale[langspec.best].terms["page-range-delimiter"] = "\u2013";
          }
        }
        if ("undefined" === typeof this.locale[langspec.best].terms["year-range-delimiter"]) {
          this.locale[langspec.best].terms["year-range-delimiter"] = "\u2013";
        }
        if ("undefined" === typeof this.locale[langspec.best].terms["citation-range-delimiter"]) {
          this.locale[langspec.best].terms["citation-range-delimiter"] = "\u2013";
        }
        if (this.opt.development_extensions.normalize_lang_keys_to_lowercase) {
          var localeLists = ["default-locale", "locale-sort", "locale-translit", "locale-translat"];
          for (var i = 0, ilen = localeLists.length; i < ilen; i += 1) {
            for (var j = 0, jlen = this.opt[localeLists[i]].length; j < jlen; j += 1) {
              this.opt[localeLists[i]][j] = this.opt[localeLists[i]][j].toLowerCase();
            }
          }
          this.opt.lang = this.opt.lang.toLowerCase();
        }
      };
      CSL3.Engine.prototype.localeSet = function(myxml, lang_in, lang_out) {
        var blob, locale, nodes, attributes, pos, term, form, termname, styleopts, date, attrname, len, genderform, target, i, ilen;
        lang_in = lang_in.replace("_", "-");
        lang_out = lang_out.replace("_", "-");
        if (this.opt.development_extensions.normalize_lang_keys_to_lowercase) {
          lang_in = lang_in.toLowerCase();
          lang_out = lang_out.toLowerCase();
        }
        if (!this.locale[lang_out]) {
          this.locale[lang_out] = {};
          this.locale[lang_out].terms = {};
          this.locale[lang_out].opts = {};
          this.locale[lang_out].opts["skip-words"] = CSL3.SKIP_WORDS;
          if (!this.locale[lang_out].opts["leading-noise-words"]) {
            this.locale[lang_out].opts["leading-noise-words"] = [];
          }
          this.locale[lang_out].dates = {};
          this.locale[lang_out].ord = { "1.0.1": false, keys: {} };
          this.locale[lang_out]["noun-genders"] = {};
        }
        locale = myxml.makeXml();
        if (myxml.nodeNameIs(myxml.dataObj, "locale")) {
          locale = myxml.dataObj;
        } else {
          nodes = myxml.getNodesByName(myxml.dataObj, "locale");
          var foundLocale = false;
          for (pos = 0, len = myxml.numberofnodes(nodes); pos < len; pos += 1) {
            blob = nodes[pos];
            if (!foundLocale && myxml.getAttributeValue(blob, "lang", "xml") === lang_in) {
              locale = blob;
              foundLocale = true;
            } else {
              var lang = myxml.getAttributeValue(blob, "lang", "xml");
              var style_options = myxml.getNodesByName(blob, "style-options");
              if (lang && style_options && style_options.length) {
                var jurispref = myxml.getAttributeValue(style_options[0], "jurisdiction-preference");
                if (jurispref) {
                  if (!this.locale[lang]) {
                    this.locale[lang] = {
                      opts: {}
                    };
                  }
                  this.locale[lang].opts["jurisdiction-preference"] = jurispref.split(/\s+/);
                }
              }
            }
          }
        }
        nodes = myxml.getNodesByName(locale, "type");
        for (i = 0, ilen = myxml.numberofnodes(nodes); i < ilen; i += 1) {
          var typenode = nodes[i];
          var type = myxml.getAttributeValue(typenode, "name");
          var gender = myxml.getAttributeValue(typenode, "gender");
          this.opt.gender[type] = gender;
        }
        var hasCslOrdinals101 = myxml.getNodesByName(locale, "term", "ordinal").length;
        if (hasCslOrdinals101) {
          for (var key in this.locale[lang_out].ord.keys) {
            delete this.locale[lang_out].terms[key];
          }
          this.locale[lang_out].ord = { "1.0.1": false, keys: {} };
        }
        nodes = myxml.getNodesByName(locale, "term");
        var ordinals101 = { "last-digit": {}, "last-two-digits": {}, "whole-number": {} };
        var ordinals101_toggle = false;
        var genderized_terms = {};
        for (pos = 0, len = myxml.numberofnodes(nodes); pos < len; pos += 1) {
          term = nodes[pos];
          termname = myxml.getAttributeValue(term, "name");
          if (termname === "sub verbo") {
            termname = "sub-verbo";
          }
          if (termname.slice(0, 7) === "ordinal") {
            if (termname === "ordinal") {
              ordinals101_toggle = true;
            } else {
              var match = myxml.getAttributeValue(term, "match");
              var termstub = termname.slice(8);
              var genderform = myxml.getAttributeValue(term, "gender-form");
              if (!genderform) {
                genderform = "neuter";
              }
              if (!match) {
                match = "last-two-digits";
                if (termstub.slice(0, 1) === "0") {
                  match = "last-digit";
                }
              }
              if (termstub.slice(0, 1) === "0") {
                termstub = termstub.slice(1);
              }
              if (!ordinals101[match][termstub]) {
                ordinals101[match][termstub] = {};
              }
              ordinals101[match][termstub][genderform] = termname;
            }
            this.locale[lang_out].ord.keys[termname] = true;
          }
          if ("undefined" === typeof this.locale[lang_out].terms[termname]) {
            this.locale[lang_out].terms[termname] = {};
          }
          form = "long";
          genderform = false;
          if (myxml.getAttributeValue(term, "form")) {
            form = myxml.getAttributeValue(term, "form");
          }
          if (myxml.getAttributeValue(term, "gender-form")) {
            genderform = myxml.getAttributeValue(term, "gender-form");
          }
          if (myxml.getAttributeValue(term, "gender")) {
            this.locale[lang_out]["noun-genders"][termname] = myxml.getAttributeValue(term, "gender");
          }
          if (genderform) {
            this.locale[lang_out].terms[termname][genderform] = {};
            this.locale[lang_out].terms[termname][genderform][form] = [];
            target = this.locale[lang_out].terms[termname][genderform];
            genderized_terms[termname] = true;
          } else {
            this.locale[lang_out].terms[termname][form] = [];
            target = this.locale[lang_out].terms[termname];
          }
          if (myxml.numberofnodes(myxml.getNodesByName(term, "multiple"))) {
            target[form][0] = myxml.getNodeValue(term, "single");
            if (target[form][0].indexOf("%s") > -1) {
              this.opt.hasPlaceholderTerm = true;
            }
            target[form][1] = myxml.getNodeValue(term, "multiple");
            if (target[form][1].indexOf("%s") > -1) {
              this.opt.hasPlaceholderTerm = true;
            }
          } else {
            target[form] = myxml.getNodeValue(term);
            if (target[form].indexOf("%s") > -1) {
              this.opt.hasPlaceholderTerm = true;
            }
          }
        }
        if (!this.locale[lang_out].terms.supplement) {
          this.locale[lang_out].terms.supplement = {};
        }
        if (!this.locale[lang_out].terms.supplement["long"]) {
          this.locale[lang_out].terms.supplement["long"] = ["supplement", "supplements"];
        }
        if (ordinals101_toggle) {
          for (var ikey in genderized_terms) {
            var gender_segments = {};
            var form_segments = 0;
            for (var jkey in this.locale[lang_out].terms[ikey]) {
              if (["masculine", "feminine"].indexOf(jkey) > -1) {
                gender_segments[jkey] = this.locale[lang_out].terms[ikey][jkey];
              } else {
                form_segments += 1;
              }
            }
            if (!form_segments) {
              if (gender_segments.feminine) {
                for (var jkey in gender_segments.feminine) {
                  this.locale[lang_out].terms[ikey][jkey] = gender_segments.feminine[jkey];
                }
              } else if (gender_segments.masculine) {
                for (var jkey in gender_segments.masculine) {
                  this.locale[lang_out].terms[ikey][jkey] = gender_segments.masculine[jkey];
                }
              }
            }
          }
          this.locale[lang_out].ord["1.0.1"] = ordinals101;
        }
        for (termname in this.locale[lang_out].terms) {
          for (i = 0, ilen = 2; i < ilen; i += 1) {
            genderform = CSL3.GENDERS[i];
            if (this.locale[lang_out].terms[termname][genderform]) {
              for (form in this.locale[lang_out].terms[termname]) {
                if (!this.locale[lang_out].terms[termname][genderform][form]) {
                  this.locale[lang_out].terms[termname][genderform][form] = this.locale[lang_out].terms[termname][form];
                }
              }
            }
          }
        }
        nodes = myxml.getNodesByName(locale, "style-options");
        for (pos = 0, len = myxml.numberofnodes(nodes); pos < len; pos += 1) {
          if (true) {
            styleopts = nodes[pos];
            attributes = myxml.attributes(styleopts);
            for (attrname in attributes) {
              if (attributes.hasOwnProperty(attrname)) {
                if (attrname === "@punctuation-in-quote" || attrname === "@limit-day-ordinals-to-day-1") {
                  if (attributes[attrname] === "true") {
                    this.locale[lang_out].opts[attrname.slice(1)] = true;
                  } else {
                    this.locale[lang_out].opts[attrname.slice(1)] = false;
                  }
                } else if (attrname === "@jurisdiction-preference") {
                  var jurisdiction_preference = attributes[attrname].split(/\s+/);
                  this.locale[lang_out].opts[attrname.slice(1)] = jurisdiction_preference;
                } else if (attrname === "@skip-words") {
                  var skip_words = attributes[attrname].split(/\s*,\s*/);
                  this.locale[lang_out].opts[attrname.slice(1)] = skip_words;
                } else if (attrname === "@leading-noise-words") {
                  var val = attributes[attrname].split(/\s*,\s*/);
                  this.locale[lang_out].opts["leading-noise-words"] = val;
                } else if (attrname === "@name-as-sort-order") {
                  this.locale[lang_out].opts["name-as-sort-order"] = {};
                  var lst = attributes[attrname].split(/\s+/);
                  for (var i = 0, ilen = lst.length; i < ilen; i += 1) {
                    this.locale[lang_out].opts["name-as-sort-order"][lst[i]] = true;
                  }
                } else if (attrname === "@name-as-reverse-order") {
                  this.locale[lang_out].opts["name-as-reverse-order"] = {};
                  var lst = attributes[attrname].split(/\s+/);
                  for (var i = 0, ilen = lst.length; i < ilen; i += 1) {
                    this.locale[lang_out].opts["name-as-reverse-order"][lst[i]] = true;
                  }
                } else if (attrname === "@name-never-short") {
                  this.locale[lang_out].opts["name-never-short"] = {};
                  var lst = attributes[attrname].split(/\s+/);
                  for (var i = 0, ilen = lst.length; i < ilen; i += 1) {
                    this.locale[lang_out].opts["name-never-short"][lst[i]] = true;
                  }
                }
              }
            }
          }
        }
        nodes = myxml.getNodesByName(locale, "date");
        for (pos = 0, len = myxml.numberofnodes(nodes); pos < len; pos += 1) {
          if (true) {
            var date = nodes[pos];
            this.locale[lang_out].dates[myxml.getAttributeValue(date, "form")] = date;
          }
        }
        CSL3.SET_COURT_CLASSES(this, lang_out, myxml, locale);
      };
      CSL3.getLocaleNames = function(myxml, preferredLocale) {
        var stylexml = CSL3.setupXml(myxml);
        function extendLocaleList(localeList, locale) {
          var forms = ["base", "best"];
          if (locale) {
            var normalizedLocale = CSL3.localeResolve(locale);
            for (var i2 = 0, ilen2 = forms.length; i2 < ilen2; i2++) {
              if (normalizedLocale[forms[i2]] && localeList.indexOf(normalizedLocale[forms[i2]]) === -1) {
                localeList.push(normalizedLocale[forms[i2]]);
              }
            }
          }
        }
        var localeIDs = ["en-US"];
        function sniffLocaleOnOneNodeName(nodeName) {
          var nodes = stylexml.getNodesByName(stylexml.dataObj, nodeName);
          for (var i2 = 0, ilen2 = nodes.length; i2 < ilen2; i2++) {
            var nodeLocales = stylexml.getAttributeValue(nodes[i2], "locale");
            if (nodeLocales) {
              nodeLocales = nodeLocales.split(/ +/);
              for (var j = 0, jlen = nodeLocales.length; j < jlen; j++) {
                this.extendLocaleList(localeIDs, nodeLocales[j]);
              }
            }
          }
        }
        extendLocaleList(localeIDs, preferredLocale);
        var styleNode = stylexml.getNodesByName(stylexml.dataObj, "style")[0];
        var defaultLocale = stylexml.getAttributeValue(styleNode, "default-locale");
        extendLocaleList(localeIDs, defaultLocale);
        var nodeNames = ["layout", "if", "else-if", "condition"];
        for (var i = 0, ilen = nodeNames.length; i < ilen; i++) {
          sniffLocaleOnOneNodeName(stylexml, localeIDs, nodeNames[i]);
        }
        return localeIDs;
      };
      CSL3.Node = {};
      CSL3.Node.bibliography = {
        build: function(state, target) {
          if (this.tokentype === CSL3.START) {
            state.build.area = "bibliography";
            state.build.root = "bibliography";
            state.build.extension = "";
            var func = function(state2) {
              state2.tmp.area = "bibliography";
              state2.tmp.root = "bibliography";
              state2.tmp.extension = "";
            };
            this.execs.push(func);
          }
          target.push(this);
        }
      };
      CSL3.Node.choose = {
        build: function(state, target) {
          var func;
          if (this.tokentype === CSL3.START) {
            func = function(state2) {
              state2.tmp.jump.push(void 0, CSL3.LITERAL);
            };
          }
          if (this.tokentype === CSL3.END) {
            func = function(state2) {
              state2.tmp.jump.pop();
            };
          }
          this.execs.push(func);
          target.push(this);
        },
        configure: function(state, pos) {
          if (this.tokentype === CSL3.END) {
            state.configure.fail.push(pos);
            state.configure.succeed.push(pos);
          } else {
            state.configure.fail.pop();
            state.configure.succeed.pop();
          }
        }
      };
      CSL3.Node.citation = {
        build: function(state, target) {
          if (this.tokentype === CSL3.START) {
            state.build.area = "citation";
            state.build.root = "citation";
            state.build.extension = "";
            var func = function(state2) {
              state2.tmp.area = "citation";
              state2.tmp.root = "citation";
              state2.tmp.extension = "";
            };
            this.execs.push(func);
          }
          if (this.tokentype === CSL3.END) {
            state.opt.grouped_sort = state.opt.xclass === "in-text" && (state.citation.opt.collapse && state.citation.opt.collapse.length) || state.citation.opt.cite_group_delimiter && state.citation.opt.cite_group_delimiter.length && state.opt.update_mode !== CSL3.POSITION && state.opt.update_mode !== CSL3.NUMERIC;
            if (state.opt.grouped_sort && state.citation_sort.opt.sort_directions.length) {
              var firstkey = state.citation_sort.opt.sort_directions[0].slice();
              state.citation_sort.opt.sort_directions = [firstkey].concat(state.citation_sort.opt.sort_directions);
            }
            state.citation.srt = new CSL3.Registry.Comparifier(state, "citation_sort");
          }
          target.push(this);
        }
      };
      CSL3.Node["#comment"] = {
        // This is a comment in the CSL file.
        build: function() {
        }
      };
      CSL3.Node.date = {
        build: function(state, target) {
          var func, date_obj, len, pos, part, dpx, parts, mypos, start, end;
          if (this.tokentype === CSL3.START || this.tokentype === CSL3.SINGLETON) {
            state.dateput.string(state, state.dateput.queue);
            state.tmp.date_token = CSL3.Util.cloneToken(this);
            state.tmp.date_token.strings.prefix = "";
            state.tmp.date_token.strings.suffix = "";
            state.dateput.openLevel(this);
            state.build.date_parts = [];
            state.build.date_variables = this.variables;
            if (!state.build.extension) {
              CSL3.Util.substituteStart.call(this, state, target);
            }
            if (state.build.extension) {
              func = CSL3.dateMacroAsSortKey;
            } else {
              func = function(state2, Item, item) {
                var dp;
                state2.tmp.element_rendered_ok = false;
                state2.tmp.donesies = [];
                state2.tmp.dateparts = [];
                dp = [];
                if (this.variables.length && !(state2.tmp.just_looking && this.variables[0] === "accessed")) {
                  date_obj = Item[this.variables[0]];
                  if ("undefined" === typeof date_obj) {
                    date_obj = { "date-parts": [[0]] };
                    if (state2.opt.development_extensions.locator_date_and_revision) {
                      if (item && this.variables[0] === "locator-date" && item["locator-date"]) {
                        date_obj = item["locator-date"];
                      }
                    }
                  }
                  state2.tmp.date_object = date_obj;
                  len = this.dateparts.length;
                  for (pos = 0; pos < len; pos += 1) {
                    part = this.dateparts[pos];
                    if ("undefined" !== typeof state2.tmp.date_object[part + "_end"]) {
                      dp.push(part);
                    } else if (part === "month" && "undefined" !== typeof state2.tmp.date_object.season_end) {
                      dp.push(part);
                    }
                  }
                  dpx = [];
                  parts = ["year", "month", "day"];
                  len = parts.length;
                  for (pos = 0; pos < len; pos += 1) {
                    if (dp.indexOf(parts[pos]) > -1) {
                      dpx.push(parts[pos]);
                    }
                  }
                  dp = dpx.slice();
                  mypos = 2;
                  len = dp.length;
                  for (pos = 0; pos < len; pos += 1) {
                    part = dp[pos];
                    start = state2.tmp.date_object[part];
                    end = state2.tmp.date_object[part + "_end"];
                    if (start !== end) {
                      mypos = pos;
                      break;
                    }
                  }
                  state2.tmp.date_collapse_at = dp.slice(mypos);
                } else {
                  state2.tmp.date_object = false;
                }
              };
            }
            this.execs.push(func);
            func = function(state2, Item) {
              if (!Item[this.variables[0]]) {
                return;
              }
              state2.output.startTag("date", this);
              if (this.variables[0] === "issued" && (Item.type === "legal_case" || Item.type === "legislation") && state2.opt.disable_duplicate_year_suppression.indexOf(Item.country) === -1 && !state2.tmp.extension && "" + Item["collection-number"] === "" + state2.tmp.date_object.year && this.dateparts.length === 1 && this.dateparts[0] === "year") {
                for (var key in state2.tmp.date_object) {
                  if (state2.tmp.date_object.hasOwnProperty(key)) {
                    if (key.slice(0, 4) === "year") {
                      state2.tmp.issued_date = {};
                      var lst = state2.output.current.mystack.slice(-2)[0].blobs;
                      state2.tmp.issued_date.list = lst;
                      state2.tmp.issued_date.pos = lst.length - 1;
                    }
                  }
                }
              }
            };
            this.execs.push(func);
          }
          if (!state.build.extension && (this.tokentype === CSL3.END || this.tokentype === CSL3.SINGLETON)) {
            func = function(state2, Item) {
              if (!Item[this.variables[0]]) {
                return;
              }
              state2.output.endTag();
            };
            this.execs.push(func);
          }
          target.push(this);
          if (this.tokentype === CSL3.END || this.tokentype === CSL3.SINGLETON) {
            if (!state.build.extension) {
              CSL3.Util.substituteEnd.call(this, state, target);
            }
          }
        }
      };
      CSL3.Node["date-part"] = {
        build: function(state, target) {
          var func, pos, len, first_date, value, value_end, real, have_collapsed, invoked, precondition, known_year, bc, ad, bc_end, ad_end, ready, curr, dcurr, number, num, formatter, item, blob;
          if (!this.strings.form) {
            this.strings.form = "long";
          }
          state.build.date_parts.push(this.strings.name);
          var date_variable = state.build.date_variables[0];
          function formatAndStrip(myform, gender, val) {
            if (!val) {
              return val;
            }
            val = "" + CSL3.Util.Dates[this.strings.name][myform](state, val, gender, this.default_locale);
            if ("month" === this.strings.name) {
              if (state.tmp.strip_periods) {
                val = val.replace(/\./g, "");
              } else {
                for (var i = 0, ilen = this.decorations.length; i < ilen; i += 1) {
                  if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
                    val = val.replace(/\./g, "");
                    break;
                  }
                }
              }
            }
            return val;
          }
          func = function(state2, Item) {
            if (!state2.tmp.date_object) {
              return;
            } else {
              state2.tmp.probably_rendered_something = true;
            }
            var last_string_output = "";
            first_date = true;
            value = "";
            value_end = "";
            state2.tmp.donesies.push(this.strings.name);
            if (state2.tmp.date_object.literal && "year" === this.strings.name) {
              last_string_output = state2.tmp.date_object.literal;
              state2.output.append(state2.tmp.date_object.literal, this);
            }
            if (state2.tmp.date_object) {
              value = state2.tmp.date_object[this.strings.name];
              value_end = state2.tmp.date_object[this.strings.name + "_end"];
            }
            if ("year" === this.strings.name && value === 0 && !state2.tmp.suppress_decorations) {
              value = false;
            }
            real = !state2.tmp.suppress_decorations;
            have_collapsed = state2.tmp.have_collapsed;
            invoked = state2[state2.tmp.area].opt.collapse === "year-suffix" || state2[state2.tmp.area].opt.collapse === "year-suffix-ranged";
            precondition = state2.opt["disambiguate-add-year-suffix"];
            if (real && precondition && invoked) {
              state2.tmp.years_used.push(value);
              known_year = state2.tmp.last_years_used.length >= state2.tmp.years_used.length;
              if (known_year && have_collapsed) {
                if (state2.tmp.last_years_used[state2.tmp.years_used.length - 1] === value) {
                  value = false;
                }
              }
            }
            if ("undefined" !== typeof value) {
              bc = false;
              ad = false;
              bc_end = false;
              ad_end = false;
              if ("year" === this.strings.name) {
                if (parseInt(value, 10) < 500 && parseInt(value, 10) > 0) {
                  ad = state2.getTerm("ad");
                }
                if (parseInt(value, 10) < 0) {
                  bc = state2.getTerm("bc");
                  value = parseInt(value, 10) * -1;
                }
                if (value_end) {
                  if (parseInt(value_end, 10) < 500 && parseInt(value_end, 10) > 0) {
                    ad_end = state2.getTerm("ad");
                  }
                  if (parseInt(value_end, 10) < 0) {
                    bc_end = state2.getTerm("bc");
                    value_end = parseInt(value_end, 10) * -1;
                  }
                }
              }
              var monthnameid = "" + state2.tmp.date_object.month;
              while (monthnameid.length < 2) {
                monthnameid = "0" + monthnameid;
              }
              monthnameid = "month-" + monthnameid;
              var gender = state2.locale[state2.opt.lang]["noun-genders"][monthnameid];
              if (this.strings.form) {
                var myform = this.strings.form;
                var myform_end = this.strings.form;
                if (this.strings.name === "day") {
                  if (myform === "ordinal" && state2.locale[state2.opt.lang].opts["limit-day-ordinals-to-day-1"]) {
                    if (value != 1) {
                      myform = "numeric";
                    }
                    if (value_end != 1) {
                      myform_end = "numeric";
                    }
                  }
                }
                value = formatAndStrip.call(this, myform, gender, value);
                value_end = formatAndStrip.call(this, myform_end, gender, value_end);
              }
              state2.output.openLevel("empty");
              if (state2.tmp.date_collapse_at.length) {
                ready = true;
                len = state2.tmp.date_collapse_at.length;
                for (pos = 0; pos < len; pos += 1) {
                  item = state2.tmp.date_collapse_at[pos];
                  if (state2.tmp.donesies.indexOf(item) === -1) {
                    ready = false;
                    break;
                  }
                }
                if (ready) {
                  if ("" + value_end !== "0") {
                    if (state2.dateput.queue.length === 0) {
                      first_date = true;
                    }
                    if (state2.opt["year-range-format"] && state2.opt["year-range-format"] !== "expanded" && !state2.tmp.date_object.day && !state2.tmp.date_object.month && !state2.tmp.date_object.season && this.strings.name === "year" && value && value_end) {
                      value_end = state2.fun.year_mangler(value + "-" + value_end, true);
                      var range_delimiter = state2.getTerm("year-range-delimiter");
                      value_end = value_end.slice(value_end.indexOf(range_delimiter) + 1);
                    }
                    last_string_output = value_end;
                    state2.dateput.append(value_end, this);
                    if (first_date) {
                      blob = state2.dateput.current.value().blobs[0];
                      if (blob) {
                        blob.strings.prefix = "";
                      }
                    }
                  }
                  last_string_output = value;
                  state2.output.append(value, this);
                  curr = state2.output.current.value();
                  blob = curr.blobs[curr.blobs.length - 1];
                  if (blob) {
                    blob.strings.suffix = "";
                  }
                  if (this.strings["range-delimiter"]) {
                    state2.output.append(this.strings["range-delimiter"]);
                  } else {
                    state2.output.append(state2.getTerm("year-range-delimiter"), "empty");
                  }
                  state2.dateput.closeLevel();
                  dcurr = state2.dateput.current.value();
                  curr.blobs = curr.blobs.concat(dcurr);
                  state2.dateput.string(state2, state2.dateput.queue);
                  state2.dateput.openLevel(state2.tmp.date_token);
                  state2.tmp.date_collapse_at = [];
                } else {
                  last_string_output = value;
                  state2.output.append(value, this);
                  if (state2.tmp.date_collapse_at.indexOf(this.strings.name) > -1) {
                    if ("" + value_end !== "0") {
                      if (state2.dateput.queue.length === 0) {
                        first_date = true;
                      }
                      state2.dateput.openLevel("empty");
                      last_string_output = value_end;
                      state2.dateput.append(value_end, this);
                      if (first_date) {
                        blob = state2.dateput.current.value().blobs[0];
                        if (blob) {
                          blob.strings.prefix = "";
                        }
                      }
                      if (bc) {
                        last_string_output = bc;
                        state2.dateput.append(bc);
                      }
                      if (ad) {
                        last_string_output = ad;
                        state2.dateput.append(ad);
                      }
                      state2.dateput.closeLevel();
                    }
                  }
                }
              } else {
                last_string_output = value;
                state2.output.append(value, this);
              }
              if (bc) {
                last_string_output = bc;
                state2.output.append(bc);
              }
              if (ad) {
                last_string_output = ad;
                state2.output.append(ad);
              }
              state2.output.closeLevel();
            } else if ("month" === this.strings.name) {
              if (state2.tmp.date_object.season) {
                value = "" + state2.tmp.date_object.season;
                if (value && value.match(/^[1-4]$/)) {
                  state2.tmp.group_context.tip.variable_success = true;
                  last_string_output = "winter";
                  state2.output.append(state2.getTerm("season-0" + value), this);
                } else if (value) {
                  last_string_output = value;
                  state2.output.append(value, this);
                }
              }
            }
            state2.tmp.value = [];
            if (Item[date_variable] && (value || state2.tmp.have_collapsed) && !state2.opt.has_year_suffix && "year" === this.strings.name && !state2.tmp.just_looking) {
              if (state2.registry.registry[Item.id] && state2.registry.registry[Item.id].disambig.year_suffix !== false && !state2.tmp.has_done_year_suffix) {
                state2.tmp.has_done_year_suffix = true;
                last_string_output = "x";
                num = parseInt(state2.registry.registry[Item.id].disambig.year_suffix, 10);
                number = new CSL3.NumericBlob(state2, false, num, this, Item.id);
                this.successor_prefix = state2[state2.build.area].opt.layout_delimiter;
                this.splice_prefix = state2[state2.build.area].opt.layout_delimiter;
                formatter = new CSL3.Util.Suffixator(CSL3.SUFFIX_CHARS);
                number.setFormatter(formatter);
                if (state2[state2.tmp.area].opt.collapse === "year-suffix-ranged") {
                  number.range_prefix = state2.getTerm("citation-range-delimiter");
                }
                if (state2[state2.tmp.area].opt.cite_group_delimiter) {
                  number.successor_prefix = state2[state2.tmp.area].opt.cite_group_delimiter;
                } else if (state2[state2.tmp.area].opt["year-suffix-delimiter"]) {
                  number.successor_prefix = state2[state2.tmp.area].opt["year-suffix-delimiter"];
                } else {
                  number.successor_prefix = state2[state2.tmp.area].opt.layout_delimiter;
                }
                number.UGLY_DELIMITER_SUPPRESS_HACK = true;
                state2.output.append(number, "literal");
              }
            }
            if (last_string_output && !state2.tmp.group_context.tip.condition) {
              state2.tmp.just_did_number = last_string_output.match(/[0-9]$/);
              if (state2.output.current.tip.strings.suffix) {
                state2.tmp.just_did_number = false;
              }
            }
          };
          this.execs.push(func);
          target.push(this);
        }
      };
      CSL3.Node["else-if"] = {
        //
        // these function are the same as those in if, might just clone
        build: function(state, target) {
          CSL3.Conditions.TopNode.call(this, state, target);
          target.push(this);
        },
        configure: function(state, pos) {
          CSL3.Conditions.Configure.call(this, state, pos);
        }
      };
      CSL3.Node["else"] = {
        build: function(state, target) {
          target.push(this);
        },
        configure: function(state, pos) {
          if (this.tokentype === CSL3.START) {
            state.configure.fail[state.configure.fail.length - 1] = pos;
          }
        }
      };
      CSL3.Node["et-al"] = {
        build: function(state, target) {
          if (state.build.area === "citation" || state.build.area === "bibliography") {
            var func = function(state2) {
              state2.tmp.etal_node = this;
              if ("string" === typeof this.strings.term) {
                state2.tmp.etal_term = this.strings.term;
              }
            };
            this.execs.push(func);
          }
          target.push(this);
        }
      };
      CSL3.Node.group = {
        build: function(state, target, realGroup) {
          var func, execs;
          this.realGroup = realGroup;
          if (this.tokentype === CSL3.START) {
            CSL3.Util.substituteStart.call(this, state, target);
            if (state.build.substitute_level.value()) {
              state.build.substitute_level.replace(state.build.substitute_level.value() + 1);
            }
            if (!this.juris) {
              target.push(this);
            }
            func = function(state2) {
              state2.output.startTag("group", this);
              if (this.strings.label_form_override) {
                if (!state2.tmp.group_context.tip.label_form) {
                  state2.tmp.group_context.tip.label_form = this.strings.label_form_override;
                }
              }
              if (this.strings.label_capitalize_if_first_override) {
                if (!state2.tmp.group_context.tip.label_capitalize_if_first) {
                  state2.tmp.group_context.tip.label_capitalize_if_first = this.strings.label_capitalize_if_first_override;
                }
              }
              if (this.realGroup) {
                if (state2.tmp.group_context.tip.condition) {
                  CSL3.UPDATE_GROUP_CONTEXT_CONDITION(state2, this.strings.prefix, null, this);
                }
                var condition = false;
                var force_suppress = false;
                if (state2.tmp.group_context.mystack.length) {
                  state2.output.current.value().parent = state2.tmp.group_context.tip.output_tip;
                }
                var label_form = state2.tmp.group_context.tip.label_form;
                if (!label_form) {
                  label_form = this.strings.label_form_override;
                }
                var label_capitalize_if_first = state2.tmp.group_context.tip.label_capitalize_if_first;
                if (!label_capitalize_if_first) {
                  label_capitalize_if_first = this.strings.label_capitalize_if_first;
                }
                if (state2.tmp.group_context.tip.condition) {
                  condition = state2.tmp.group_context.tip.condition;
                  force_suppress = state2.tmp.group_context.tip.force_suppress;
                } else if (this.strings.reject) {
                  condition = {
                    test: this.strings.reject,
                    not: true
                  };
                } else if (this.strings.require) {
                  condition = {
                    test: this.strings.require,
                    not: false
                  };
                }
                var context = {
                  old_term_predecessor: state2.tmp.term_predecessor,
                  term_intended: false,
                  variable_attempt: false,
                  variable_success: false,
                  variable_success_parent: state2.tmp.group_context.tip.variable_success,
                  output_tip: state2.output.current.tip,
                  label_form,
                  label_static: state2.tmp.group_context.tip.label_static,
                  label_capitalize_if_first,
                  parallel_delimiter_override: this.strings.set_parallel_delimiter_override,
                  parallel_delimiter_override_on_suppress: this.strings.set_parallel_delimiter_override_on_suppress,
                  condition,
                  force_suppress,
                  done_vars: state2.tmp.group_context.tip.done_vars.slice()
                };
                if (this.non_parallel) {
                  var non_parallel = state2.tmp.group_context.tip.non_parallel;
                  if (!non_parallel) {
                    non_parallel = {};
                  }
                  Object.assign(non_parallel, this.non_parallel);
                  context.non_parallel = non_parallel;
                }
                if (this.parallel_first) {
                  var parallel_first = state2.tmp.group_context.tip.parallel_first;
                  if (!parallel_first) {
                    parallel_first = {};
                  }
                  Object.assign(parallel_first, this.parallel_first);
                  context.parallel_first = parallel_first;
                }
                if (this.parallel_last) {
                  var parallel_last = state2.tmp.group_context.tip.parallel_last;
                  if (!parallel_last) {
                    parallel_last = {};
                  }
                  Object.assign(parallel_last, this.parallel_last);
                  context.parallel_last = parallel_last;
                }
                if (state2.tmp.abbrev_trimmer && state2.tmp.abbrev_trimmer.LAST_TO_FIRST && context.parallel_last) {
                  if (!context.parallel_first) {
                    context.parallel_first = {};
                  }
                  for (var varname in state2.tmp.abbrev_trimmer.LAST_TO_FIRST) {
                    if (context.parallel_last[varname]) {
                      context.parallel_first[varname] = true;
                      delete context.parallel_last[varname];
                    }
                  }
                }
                state2.tmp.group_context.push(context);
                if (state2.tmp.abbrev_trimmer && this.parallel_last_to_first) {
                  if (!state2.tmp.abbrev_trimmer.LAST_TO_FIRST) {
                    state2.tmp.abbrev_trimmer.LAST_TO_FIRST = {};
                  }
                  for (var varname in this.parallel_last_to_first) {
                    state2.tmp.abbrev_trimmer.LAST_TO_FIRST[varname] = true;
                  }
                }
              }
            };
            execs = [];
            execs.push(func);
            this.execs = execs.concat(this.execs);
            if (this.strings["has-publisher-and-publisher-place"]) {
              state.build["publisher-special"] = true;
              if (this.strings["subgroup-delimiter"]) {
                func = function(state2, Item) {
                  if (Item.publisher && Item["publisher-place"]) {
                    var publisher_lst = Item.publisher.split(/;\s*/);
                    var publisher_place_lst = Item["publisher-place"].split(/;\s*/);
                    if (publisher_lst.length > 1 && publisher_lst.length === publisher_place_lst.length) {
                      state2.publisherOutput = new CSL3.PublisherOutput(state2, this);
                      state2.publisherOutput["publisher-list"] = publisher_lst;
                      state2.publisherOutput["publisher-place-list"] = publisher_place_lst;
                    }
                  }
                };
                this.execs.push(func);
              }
            }
            if (this.juris) {
              var choose_start = new CSL3.Token("choose", CSL3.START);
              CSL3.Node.choose.build.call(choose_start, state, target);
              var if_start = new CSL3.Token("if", CSL3.START);
              func = /* @__PURE__ */ function(macroName) {
                return function(Item, item) {
                  return CSL3.INIT_JURISDICTION_MACROS(state, Item, item, macroName);
                };
              }(this.juris);
              if_start.tests ? {} : if_start.tests = [];
              if_start.tests.push(func);
              if_start.test = state.fun.match.any(if_start, state, if_start.tests);
              target.push(if_start);
              var text_node = new CSL3.Token("text", CSL3.SINGLETON);
              func = function(state2, Item, item) {
                var itemItem = Item;
                if (item && item["best-jurisdiction"] && this.juris === "juris-locator") {
                  itemItem = item;
                }
                var next = 0;
                if (state2.juris[itemItem["best-jurisdiction"]][this.juris]) {
                  while (next < state2.juris[itemItem["best-jurisdiction"]][this.juris].length) {
                    next = CSL3.tokenExec.call(state2, state2.juris[itemItem["best-jurisdiction"]][this.juris][next], Item, item);
                  }
                }
              };
              text_node.juris = this.juris;
              text_node.execs.push(func);
              target.push(text_node);
              var if_end = new CSL3.Token("if", CSL3.END);
              CSL3.Node["if"].build.call(if_end, state, target);
              var else_start = new CSL3.Token("else", CSL3.START);
              CSL3.Node["else"].build.call(else_start, state, target);
            }
          }
          if (this.tokentype === CSL3.END) {
            if (state.build["publisher-special"]) {
              state.build["publisher-special"] = false;
              func = function(state2) {
                if (state2.publisherOutput) {
                  state2.publisherOutput.render();
                  state2.publisherOutput = false;
                }
              };
              this.execs.push(func);
            }
            func = function(state2, Item, item) {
              if (!state2.tmp.group_context.tip.condition) {
                if (state2.output.current.tip.strings.suffix) {
                  state2.tmp.just_did_number = false;
                }
              }
              state2.output.endTag();
              if (this.realGroup) {
                var flags = state2.tmp.group_context.pop();
                if (flags.parallel_delimiter_override) {
                  state2.tmp.group_context.tip.parallel_delimiter_override = flags.parallel_delimiter_override;
                  if (!state2.tmp.just_looking && state2.registry.registry[Item.id].master) {
                    state2.registry.registry[Item.id].parallel_delimiter_override = flags.parallel_delimiter_override;
                  }
                }
                if (flags.parallel_delimiter_override_on_suppress) {
                  state2.tmp.group_context.tip.parallel_delimiter_override_on_suppress = flags.parallel_delimiter_override_on_suppress;
                }
                if (state2.tmp.area === "bibliography_sort") {
                  var citationNumberIdx = flags.done_vars.indexOf("citation-number");
                  if (this.strings.sort_direction && citationNumberIdx > -1 && state2.tmp.group_context.length() == 1) {
                    if (this.strings.sort_direction === CSL3.DESCENDING) {
                      state2.bibliography_sort.opt.citation_number_sort_direction = CSL3.DESCENDING;
                    } else {
                      state2.bibliography_sort.opt.citation_number_sort_direction = CSL3.ASCENDING;
                    }
                    flags.done_vars = flags.done_vars.slice(0, citationNumberIdx).concat(flags.done_vars.slice(citationNumberIdx + 1));
                  }
                }
                if (flags.condition) {
                  flags.force_suppress = CSL3.EVALUATE_GROUP_CONDITION(state2, flags);
                }
                if (state2.tmp.group_context.tip.condition) {
                  state2.tmp.group_context.tip.force_suppress = flags.force_suppress;
                }
                if (!flags.force_suppress && (flags.variable_success || flags.term_intended && !flags.variable_attempt)) {
                  if (!this.isJurisLocatorLabel) {
                    state2.tmp.group_context.tip.variable_success = true;
                  }
                  var blobs = state2.output.current.value().blobs;
                  var pos = state2.output.current.value().blobs.length - 1;
                  if (!state2.tmp.just_looking && (flags.non_parallel || flags.parallel_last || flags.parallel_first || flags.parallel_delimiter_override || flags.parallel_delimiter_override_on_suppress)) {
                    var hasRepeat = state2.parallel.checkRepeats(flags);
                    if (hasRepeat) {
                      if (blobs) {
                        blobs.pop();
                      }
                    }
                    if (state2.tmp.cite_index > 0 && (hasRepeat || !flags.parallel_first && !flags.parallel_last && !flags.non_parallel)) {
                      var info = state2.tmp.suppress_repeats[state2.tmp.cite_index - 1];
                      if (hasRepeat && flags.parallel_delimiter_override_on_suppress && (info.SIBLING || info.ORPHAN)) {
                        state2.output.queue.slice(-1)[0].parallel_delimiter = flags.parallel_delimiter_override_on_suppress;
                      } else if (flags.parallel_delimiter_override && info.SIBLING) {
                        state2.output.queue.slice(-1)[0].parallel_delimiter = flags.parallel_delimiter_override;
                      }
                    }
                  }
                } else {
                  state2.tmp.term_predecessor = flags.old_term_predecessor;
                  state2.tmp.group_context.tip.variable_attempt = flags.variable_attempt;
                  if (flags.force_suppress && !state2.tmp.group_context.tip.condition) {
                    state2.tmp.group_context.tip.variable_attempt = true;
                    state2.tmp.group_context.tip.variable_success = flags.variable_success_parent;
                  }
                  if (flags.force_suppress) {
                    for (var i = 0, ilen = flags.done_vars.length; i < ilen; i++) {
                      var doneVar = flags.done_vars[i];
                      for (var j = 0, jlen = state2.tmp.done_vars.length; j < jlen; j++) {
                        if (state2.tmp.done_vars[j] === doneVar) {
                          state2.tmp.done_vars = state2.tmp.done_vars.slice(0, j).concat(state2.tmp.done_vars.slice(j + 1));
                        }
                      }
                    }
                  }
                  if (state2.output.current.value().blobs) {
                    state2.output.current.value().blobs.pop();
                  }
                }
              }
            };
            this.execs.push(func);
            if (this.juris) {
              var else_end = new CSL3.Token("else", CSL3.END);
              CSL3.Node["else"].build.call(else_end, state, target);
              var choose_end = new CSL3.Token("choose", CSL3.END);
              CSL3.Node.choose.build.call(choose_end, state, target);
            }
          }
          if (this.tokentype === CSL3.END) {
            if (!this.juris) {
              target.push(this);
            }
            if (state.build.substitute_level.value()) {
              state.build.substitute_level.replace(state.build.substitute_level.value() - 1);
            }
            CSL3.Util.substituteEnd.call(this, state, target);
          }
        }
      };
      CSL3.Node["if"] = {
        build: function(state, target) {
          CSL3.Conditions.TopNode.call(this, state, target);
          target.push(this);
        },
        configure: function(state, pos) {
          CSL3.Conditions.Configure.call(this, state, pos);
        }
      };
      CSL3.Node["conditions"] = {
        build: function(state) {
          if (this.tokentype === CSL3.START) {
            state.tmp.conditions.addMatch(this.match);
          }
          if (this.tokentype === CSL3.END) {
            state.tmp.conditions.matchCombine();
          }
        }
      };
      CSL3.Node["condition"] = {
        build: function(state) {
          if (this.tokentype === CSL3.SINGLETON) {
            var test = state.fun.match[this.match](this, state, this.tests);
            state.tmp.conditions.addTest(test);
          }
        }
      };
      CSL3.Conditions = {};
      CSL3.Conditions.TopNode = function(state) {
        var func;
        if (this.tokentype === CSL3.START || this.tokentype === CSL3.SINGLETON) {
          if (this.locale) {
            state.opt.lang = this.locale;
          }
          if (!this.tests || !this.tests.length) {
            state.tmp.conditions = new CSL3.Conditions.Engine(state, this);
          } else {
            this.test = state.fun.match[this.match](this, state, this.tests);
          }
          if (state.build.substitute_level.value() === 0) {
            func = function(state2) {
              state2.tmp.condition_counter++;
            };
            this.execs.push(func);
          }
        }
        if (this.tokentype === CSL3.END || this.tokentype === CSL3.SINGLETON) {
          if (state.build.substitute_level.value() === 0) {
            func = function(state2) {
              state2.tmp.condition_counter--;
              if (state2.tmp.condition_lang_counter_arr.length > 0) {
                var counter = state2.tmp.condition_lang_counter_arr.slice(-1)[0];
                if (counter === state2.tmp.condition_counter) {
                  state2.opt.lang = state2.tmp.condition_lang_val_arr.pop();
                  state2.tmp.condition_lang_counter_arr.pop();
                }
              }
              if (this.locale_default) {
                state2.output.current.value().old_locale = this.locale_default;
                state2.output.closeLevel("empty");
                state2.opt.lang = this.locale_default;
              }
            };
            this.execs.push(func);
          }
          func = function(state2) {
            var next = this[state2.tmp.jump.value()];
            return next;
          };
          this.execs.push(func);
          if (this.locale_default) {
            state.opt.lang = this.locale_default;
          }
        }
      };
      CSL3.Conditions.Configure = function(state, pos) {
        if (this.tokentype === CSL3.START) {
          this.fail = state.configure.fail.slice(-1)[0];
          this.succeed = this.next;
          state.configure.fail[state.configure.fail.length - 1] = pos;
        } else if (this.tokentype === CSL3.SINGLETON) {
          this.fail = this.next;
          this.succeed = state.configure.succeed.slice(-1)[0];
          state.configure.fail[state.configure.fail.length - 1] = pos;
        } else {
          this.succeed = state.configure.succeed.slice(-1)[0];
          this.fail = this.next;
        }
      };
      CSL3.Conditions.Engine = function(state, token) {
        this.token = token;
        this.state = state;
      };
      CSL3.Conditions.Engine.prototype.addTest = function(test) {
        this.token.tests ? {} : this.token.tests = [];
        this.token.tests.push(test);
      };
      CSL3.Conditions.Engine.prototype.addMatch = function(match) {
        this.token.match = match;
      };
      CSL3.Conditions.Engine.prototype.matchCombine = function() {
        this.token.test = this.state.fun.match[this.token.match](this.token, this.state, this.token.tests);
      };
      CSL3.Node.info = {
        build: function(state) {
          if (this.tokentype === CSL3.START) {
            state.build.skip = "info";
          } else {
            state.build.skip = false;
          }
        }
      };
      CSL3.Node.institution = {
        build: function(state, target) {
          if ([CSL3.SINGLETON, CSL3.START].indexOf(this.tokentype) > -1) {
            var func = function(state2) {
              if ("string" === typeof this.strings.delimiter) {
                state2.tmp.institution_delimiter = this.strings.delimiter;
              } else {
                state2.tmp.institution_delimiter = state2.tmp.name_delimiter;
              }
              if ("text" === state2.inheritOpt(this, "and")) {
                this.and_term = state2.getTerm("and", "long", 0);
              } else if ("symbol" === state2.inheritOpt(this, "and")) {
                if (state2.opt.development_extensions.expect_and_symbol_form) {
                  this.and_term = state2.getTerm("and", "symbol", 0);
                } else {
                  this.and_term = "&";
                }
              } else if ("none" === state2.inheritOpt(this, "and")) {
                this.and_term = state2.tmp.institution_delimiter;
              }
              if ("undefined" === typeof this.and_term && state2.tmp.and_term) {
                this.and_term = state2.tmp.and_term;
              }
              if (CSL3.STARTSWITH_ROMANESQUE_REGEXP.test(this.and_term)) {
                this.and_prefix_single = " ";
                this.and_prefix_multiple = ", ";
                if ("string" === typeof state2.tmp.institution_delimiter) {
                  this.and_prefix_multiple = state2.tmp.institution_delimiter;
                }
                this.and_suffix = " ";
              } else {
                this.and_prefix_single = "";
                this.and_prefix_multiple = "";
                this.and_suffix = "";
              }
              if (state2.inheritOpt(this, "delimiter-precedes-last") === "always") {
                this.and_prefix_single = state2.tmp.institution_delimiter;
              } else if (state2.inheritOpt(this, "delimiter-precedes-last") === "never") {
                if (this.and_prefix_multiple) {
                  this.and_prefix_multiple = " ";
                }
              }
              this.and = {};
              if ("undefined" !== typeof this.and_term) {
                state2.output.append(this.and_term, "empty", true);
                this.and.single = state2.output.pop();
                this.and.single.strings.prefix = this.and_prefix_single;
                this.and.single.strings.suffix = this.and_suffix;
                state2.output.append(this.and_term, "empty", true);
                this.and.multiple = state2.output.pop();
                this.and.multiple.strings.prefix = this.and_prefix_multiple;
                this.and.multiple.strings.suffix = this.and_suffix;
              } else if ("undefined" !== this.strings.delimiter) {
                this.and.single = new CSL3.Blob(state2.tmp.institution_delimiter);
                this.and.single.strings.prefix = "";
                this.and.single.strings.suffix = "";
                this.and.multiple = new CSL3.Blob(state2.tmp.institution_delimiter);
                this.and.multiple.strings.prefix = "";
                this.and.multiple.strings.suffix = "";
              }
              state2.nameOutput.institution = this;
            };
            this.execs.push(func);
          }
          target.push(this);
        },
        configure: function(state) {
          if ([CSL3.SINGLETON, CSL3.START].indexOf(this.tokentype) > -1) {
            state.build.has_institution = true;
          }
        }
      };
      CSL3.Node["institution-part"] = {
        build: function(state, target) {
          var func;
          if ("long" === this.strings.name) {
            if (this.strings["if-short"]) {
              func = function(state2) {
                state2.nameOutput.institutionpart["long-with-short"] = this;
              };
            } else {
              func = function(state2) {
                state2.nameOutput.institutionpart["long"] = this;
              };
            }
          } else if ("short" === this.strings.name) {
            func = function(state2) {
              state2.nameOutput.institutionpart["short"] = this;
            };
          }
          this.execs.push(func);
          target.push(this);
        }
      };
      CSL3.Node.key = {
        build: function(state, target) {
          target = state[state.build.root + "_sort"].tokens;
          var func;
          var debug = false;
          var start_key = new CSL3.Token("key", CSL3.START);
          state.tmp.root = state.build.root;
          start_key.strings["et-al-min"] = state.inheritOpt(this, "et-al-min");
          start_key.strings["et-al-use-first"] = state.inheritOpt(this, "et-al-use-first");
          start_key.strings["et-al-use-last"] = state.inheritOpt(this, "et-al-use-last");
          func = function(state2) {
            state2.tmp.done_vars = [];
          };
          start_key.execs.push(func);
          func = function(state2) {
            state2.output.openLevel("empty");
          };
          start_key.execs.push(func);
          var sort_direction = [];
          if (this.strings.sort_direction === CSL3.DESCENDING) {
            sort_direction.push(1);
            sort_direction.push(-1);
          } else {
            sort_direction.push(-1);
            sort_direction.push(1);
          }
          state[state.build.area].opt.sort_directions.push(sort_direction);
          if (CSL3.DATE_VARIABLES.indexOf(this.variables[0]) > -1) {
            state.build.date_key = true;
          }
          func = function(state2) {
            state2.tmp.sort_key_flag = true;
            if (state2.inheritOpt(this, "et-al-min")) {
              state2.tmp["et-al-min"] = state2.inheritOpt(this, "et-al-min");
            }
            if (state2.inheritOpt(this, "et-al-use-first")) {
              state2.tmp["et-al-use-first"] = state2.inheritOpt(this, "et-al-use-first");
            }
            if ("boolean" === typeof state2.inheritOpt(this, "et-al-use-last")) {
              state2.tmp["et-al-use-last"] = state2.inheritOpt(this, "et-al-use-last");
            }
          };
          start_key.execs.push(func);
          target.push(start_key);
          if (this.variables.length) {
            var variable = this.variables[0];
            if (CSL3.NAME_VARIABLES.indexOf(variable) > -1) {
              var names_start_token = new CSL3.Token("names", CSL3.START);
              names_start_token.tokentype = CSL3.START;
              names_start_token.variables = this.variables;
              CSL3.Node.names.build.call(names_start_token, state, target);
              var name_token = new CSL3.Token("name", CSL3.SINGLETON);
              name_token.tokentype = CSL3.SINGLETON;
              name_token.strings["name-as-sort-order"] = "all";
              name_token.strings["sort-separator"] = " ";
              name_token.strings["et-al-use-last"] = state.inheritOpt(this, "et-al-use-last");
              name_token.strings["et-al-min"] = state.inheritOpt(this, "et-al-min");
              name_token.strings["et-al-use-first"] = state.inheritOpt(this, "et-al-use-first");
              CSL3.Node.name.build.call(name_token, state, target);
              var institution_token = new CSL3.Token("institution", CSL3.SINGLETON);
              institution_token.tokentype = CSL3.SINGLETON;
              CSL3.Node.institution.build.call(institution_token, state, target);
              var names_end_token = new CSL3.Token("names", CSL3.END);
              names_end_token.tokentype = CSL3.END;
              CSL3.Node.names.build.call(names_end_token, state, target);
            } else {
              var single_text = new CSL3.Token("text", CSL3.SINGLETON);
              single_text.strings.sort_direction = this.strings.sort_direction;
              single_text.dateparts = this.dateparts;
              if (CSL3.NUMERIC_VARIABLES.indexOf(variable) > -1) {
                if (variable === "citation-number") {
                  func = function(state2, Item) {
                    if (state2.tmp.area === "bibliography_sort") {
                      if (this.strings.sort_direction === CSL3.DESCENDING) {
                        state2.bibliography_sort.opt.citation_number_sort_direction = CSL3.DESCENDING;
                      } else {
                        state2.bibliography_sort.opt.citation_number_sort_direction = CSL3.ASCENDING;
                      }
                    }
                    if (state2.tmp.area === "citation_sort" && state2.bibliography_sort.tmp.citation_number_map) {
                      var num = state2.bibliography_sort.tmp.citation_number_map[state2.registry.registry[Item.id].seq];
                    } else {
                      var num = state2.registry.registry[Item.id].seq;
                    }
                    if (num) {
                      num = CSL3.Util.padding("" + num);
                    }
                    state2.output.append(num, this);
                  };
                } else {
                  func = function(state2, Item) {
                    var num = false;
                    num = Item[variable];
                    if (num) {
                      num = CSL3.Util.padding(num);
                    }
                    state2.output.append(num, this);
                  };
                }
              } else if (variable === "citation-label") {
                func = function(state2, Item) {
                  var trigraph = state2.getCitationLabel(Item);
                  state2.output.append(trigraph, this);
                };
              } else if (CSL3.DATE_VARIABLES.indexOf(variable) > -1) {
                func = CSL3.dateAsSortKey;
                single_text.variables = this.variables;
              } else if ("title" === variable) {
                var abbrevfam = "title";
                var abbrfall = false;
                var altvar = false;
                var transfall = true;
                func = state.transform.getOutputFunction(this.variables, abbrevfam, abbrfall, altvar, transfall);
              } else if ("court-class" === variable) {
                func = function(state2, Item, item) {
                  CSL3.INIT_JURISDICTION_MACROS(state2, Item, item, "juris-main");
                  var cls = CSL3.GET_COURT_CLASS(state2, Item, true);
                  state2.output.append(cls, "empty");
                };
              } else {
                func = function(state2, Item) {
                  var varval = Item[variable];
                  state2.output.append(varval, "empty");
                };
              }
              single_text.execs.push(func);
              target.push(single_text);
            }
          } else {
            var token = new CSL3.Token("text", CSL3.SINGLETON);
            token.strings.sort_direction = this.strings.sort_direction;
            token.postponed_macro = this.postponed_macro;
            CSL3.expandMacro.call(state, token, target);
          }
          var end_key = new CSL3.Token("key", CSL3.END);
          func = function(state2) {
            var keystring = state2.output.string(state2, state2.output.queue);
            if (state2.sys.normalizeUnicode) {
              keystring = state2.sys.normalizeUnicode(keystring);
            }
            keystring = keystring ? keystring.split(" ").join(state2.opt.sort_sep) + state2.opt.sort_sep : "";
            if (debug) {
              CSL3.debug("keystring: " + keystring + " " + typeof keystring);
            }
            if ("" === keystring) {
              keystring = void 0;
            }
            if ("string" !== typeof keystring) {
              keystring = void 0;
            }
            state2[state2[state2.tmp.area].root + "_sort"].keys.push(keystring);
            state2.tmp.value = [];
          };
          end_key.execs.push(func);
          if (state.build.date_key) {
            if (state.build.area === "citation" && state.build.extension === "_sort") {
              state[state.build.area].opt.sort_directions.push([-1, 1]);
              func = function(state2, Item) {
                var year_suffix = state2.registry.registry[Item.id].disambig.year_suffix;
                if (!year_suffix) {
                  year_suffix = 0;
                }
                var key = CSL3.Util.padding("" + year_suffix);
                state2[state2.tmp.area].keys.push(key);
              };
              end_key.execs.push(func);
            }
            state.build.date_key = false;
          }
          func = function(state2) {
            state2.tmp["et-al-min"] = void 0;
            state2.tmp["et-al-use-first"] = void 0;
            state2.tmp["et-al-use-last"] = void 0;
            state2.tmp.sort_key_flag = false;
          };
          end_key.execs.push(func);
          target.push(end_key);
        }
      };
      CSL3.Node.label = {
        build: function(state, target) {
          if (this.strings.term) {
            var func = function(state2, Item, item) {
              var termtxt = CSL3.evaluateLabel(this, state2, Item, item);
              if (item && this.strings.term === "locator") {
                item.section_form_override = this.strings.form;
              }
              if (termtxt) {
                state2.tmp.group_context.tip.term_intended = true;
              }
              CSL3.UPDATE_GROUP_CONTEXT_CONDITION(state2, termtxt, null, this);
              if (termtxt.indexOf("%s") === -1) {
                if (this.strings.capitalize_if_first) {
                  if (!state2.tmp.term_predecessor && !(state2.opt["class"] === "in-text" && state2.tmp.area === "citation")) {
                    termtxt = CSL3.Output.Formatters["capitalize-first"](state2, termtxt);
                  }
                }
                state2.output.append(termtxt, this);
              }
            };
            this.execs.push(func);
          } else {
            if (!this.strings.form) {
              this.strings.form = "long";
            }
            var namevars = state.build.names_variables[state.build.names_variables.length - 1];
            var namelabels = state.build.name_label[state.build.name_label.length - 1];
            for (var i = 0, ilen = namevars.length; i < ilen; i += 1) {
              if (!namelabels[namevars[i]]) {
                namelabels[namevars[i]] = {};
              }
            }
            if (!state.build.name_flag) {
              for (var i = 0, ilen = namevars.length; i < ilen; i += 1) {
                namelabels[namevars[i]].before = this;
              }
            } else {
              for (var i = 0, ilen = namevars.length; i < ilen; i += 1) {
                namelabels[namevars[i]].after = this;
              }
            }
          }
          target.push(this);
        }
      };
      CSL3.Node.layout = {
        build: function(state, target) {
          var func, prefix_token, suffix_token, tok;
          function setSuffix() {
            if (state.build.area === "bibliography") {
              suffix_token = new CSL3.Token("text", CSL3.SINGLETON);
              func = function(state2) {
                if (!state2.tmp.parallel_and_not_last) {
                  var suffix;
                  if (state2.tmp.cite_affixes[state2.tmp.area][state2.tmp.last_cite_locale]) {
                    suffix = state2.tmp.cite_affixes[state2.tmp.area][state2.tmp.last_cite_locale].suffix;
                  } else {
                    suffix = state2.bibliography.opt.layout_suffix;
                  }
                  var topblob = state2.output.current.value();
                  if (state2.opt.using_display) {
                    topblob.blobs[topblob.blobs.length - 1].strings.suffix = suffix;
                  } else {
                    topblob.strings.suffix = suffix;
                  }
                }
                if (state2.bibliography.opt["second-field-align"]) {
                  state2.output.endTag("bib_other");
                }
              };
              suffix_token.execs.push(func);
              target.push(suffix_token);
            }
          }
          if (this.tokentype === CSL3.START) {
            if (this.locale_raw) {
              state.build.current_default_locale = this.locale_raw;
            } else {
              state.build.current_default_locale = state.opt["default-locale"];
            }
            func = function(state2, Item, item) {
              if (state2.opt.development_extensions.apply_citation_wrapper && state2.sys.wrapCitationEntry && !state2.tmp.just_looking && Item.system_id && state2.tmp.area === "citation") {
                var cite_entry = new CSL3.Token("group", CSL3.START);
                cite_entry.decorations = [["@cite", "entry"]];
                state2.output.startTag("cite_entry", cite_entry);
                state2.output.current.value().item_id = Item.system_id;
                if (item) {
                  state2.output.current.value().locator_txt = item.locator_txt;
                  state2.output.current.value().suffix_txt = item.suffix_txt;
                }
              }
            };
            this.execs.push(func);
          }
          if (this.tokentype === CSL3.START && !state.tmp.cite_affixes[state.build.area]) {
            func = function(state2, Item, item) {
              state2.tmp.done_vars = [];
              if (item && item["author-only"]) {
                state2.tmp.done_vars.push("locator");
              }
              if (state2.opt.suppressedJurisdictions[Item["country"]] && Item["country"] && ["treaty", "patent"].indexOf(Item.type) === -1) {
                state2.tmp.done_vars.push("country");
              }
              if (!state2.tmp.just_looking && state2.registry.registry[Item.id] && state2.registry.registry[Item.id].parallel) {
                state2.tmp.done_vars.push("first-reference-note-number");
              }
              if (!state2.tmp.just_looking && state2.tmp.abbrev_trimmer && Item.jurisdiction) {
                for (var field in state2.tmp.abbrev_trimmer.QUASHES[Item.jurisdiction]) {
                  state2.tmp.done_vars.push(field);
                }
              }
              state2.tmp.rendered_name = false;
            };
            this.execs.push(func);
            func = function(state2) {
              state2.tmp.sort_key_flag = false;
            };
            this.execs.push(func);
            func = function(state2) {
              state2.tmp.nameset_counter = 0;
            };
            this.execs.push(func);
            func = function(state2, Item) {
              var tok2 = new CSL3.Token();
              state2.output.openLevel(tok2);
            };
            this.execs.push(func);
            target.push(this);
            if (state.build.area === "citation") {
              prefix_token = new CSL3.Token("text", CSL3.SINGLETON);
              func = function(state2, Item, item) {
                if (item && item.prefix) {
                  var prefix = CSL3.checkPrefixSpaceAppend(state2, item.prefix);
                  if (!state2.tmp.just_looking) {
                    prefix = state2.output.checkNestedBrace.update(prefix);
                  }
                  var ignorePredecessor = CSL3.checkIgnorePredecessor(state2, prefix);
                  state2.output.append(prefix, this, false, ignorePredecessor);
                }
              };
              prefix_token.execs.push(func);
              target.push(prefix_token);
            }
          }
          var my_tok;
          if (this.locale_raw) {
            my_tok = new CSL3.Token("dummy", CSL3.START);
            my_tok.locale = this.locale_raw;
            my_tok.strings.delimiter = this.strings.delimiter;
            my_tok.strings.suffix = this.strings.suffix;
            if (!state.tmp.cite_affixes[state.build.area]) {
              state.tmp.cite_affixes[state.build.area] = {};
            }
          }
          if (this.tokentype === CSL3.START) {
            state.build.layout_flag = true;
            if (!this.locale_raw) {
              state[state.tmp.area].opt.topdecor = [this.decorations];
              state[state.tmp.area + "_sort"].opt.topdecor = [this.decorations];
              state[state.build.area].opt.layout_prefix = this.strings.prefix;
              state[state.build.area].opt.layout_suffix = this.strings.suffix;
              state[state.build.area].opt.layout_delimiter = this.strings.delimiter;
              state[state.build.area].opt.layout_decorations = this.decorations;
              if (state.tmp.cite_affixes[state.build.area]) {
                tok = new CSL3.Token("else", CSL3.START);
                CSL3.Node["else"].build.call(tok, state, target);
              }
            }
            if (this.locale_raw) {
              if (!state.build.layout_locale_flag) {
                var choose_tok = new CSL3.Token("choose", CSL3.START);
                CSL3.Node.choose.build.call(choose_tok, state, target);
                my_tok.name = "if";
                CSL3.Attributes["@locale-internal"].call(my_tok, state, this.locale_raw);
                CSL3.Node["if"].build.call(my_tok, state, target);
              } else {
                my_tok.name = "else-if";
                CSL3.Attributes["@locale-internal"].call(my_tok, state, this.locale_raw);
                CSL3.Node["else-if"].build.call(my_tok, state, target);
              }
              state.tmp.cite_affixes[state.build.area][my_tok.locale] = {};
              state.tmp.cite_affixes[state.build.area][my_tok.locale].delimiter = this.strings.delimiter;
              state.tmp.cite_affixes[state.build.area][my_tok.locale].suffix = this.strings.suffix;
            }
          }
          if (this.tokentype === CSL3.END) {
            if (this.locale_raw) {
              setSuffix();
              if (!state.build.layout_locale_flag) {
                my_tok.name = "if";
                my_tok.tokentype = CSL3.END;
                CSL3.Attributes["@locale-internal"].call(my_tok, state, this.locale_raw);
                CSL3.Node["if"].build.call(my_tok, state, target);
                state.build.layout_locale_flag = true;
              } else {
                my_tok.name = "else-if";
                my_tok.tokentype = CSL3.END;
                CSL3.Attributes["@locale-internal"].call(my_tok, state, this.locale_raw);
                CSL3.Node["else-if"].build.call(my_tok, state, target);
              }
            }
            if (!this.locale_raw) {
              setSuffix();
              if (state.tmp.cite_affixes[state.build.area]) {
                if (state.build.layout_locale_flag) {
                  tok = new CSL3.Token("else", CSL3.END);
                  CSL3.Node["else"].build.call(tok, state, target);
                  tok = new CSL3.Token("choose", CSL3.END);
                  CSL3.Node.choose.build.call(tok, state, target);
                }
              }
              state.build_layout_locale_flag = true;
              if (state.build.area === "citation") {
                suffix_token = new CSL3.Token("text", CSL3.SINGLETON);
                func = function(state2, Item, item) {
                  var sp;
                  if (item && item.suffix) {
                    var suffix = CSL3.checkSuffixSpacePrepend(state2, item.suffix);
                    if (!state2.tmp.just_looking) {
                      suffix = state2.output.checkNestedBrace.update(suffix);
                    }
                    state2.output.append(suffix, this);
                  }
                };
                suffix_token.execs.push(func);
                target.push(suffix_token);
              }
              func = function(state2) {
                state2.output.closeLevel();
              };
              this.execs.push(func);
              func = function(state2, Item) {
                if (state2.opt.development_extensions.apply_citation_wrapper && state2.sys.wrapCitationEntry && !state2.tmp.just_looking && Item.system_id && state2.tmp.area === "citation") {
                  state2.output.endTag();
                }
              };
              this.execs.push(func);
              target.push(this);
              state.build.layout_flag = false;
              state.build.layout_locale_flag = false;
            }
          }
        }
      };
      CSL3.Node.macro = {
        build: function() {
        }
      };
      CSL3.Node.alternative = {
        build: function(state, target) {
          if (this.tokentype === CSL3.START) {
            var choose_tok = new CSL3.Token("choose", CSL3.START);
            CSL3.Node["choose"].build.call(choose_tok, state, target);
            var if_tok = new CSL3.Token("if", CSL3.START);
            CSL3.Attributes["@alternative-node-internal"].call(if_tok, state);
            CSL3.Node["if"].build.call(if_tok, state, target);
            var func = function(state2, Item) {
              state2.tmp.oldItem = Item;
              state2.tmp.oldLang = state2.opt.lang;
              state2.tmp.abort_alternative = true;
              if (Item["language-name"] && Item["language-name-original"]) {
                var newItem = JSON.parse(JSON.stringify(Item));
                newItem.language = newItem["language-name"];
                var langspec = CSL3.localeResolve(newItem.language, state2.opt["default-locale"][0]);
                if (state2.opt.multi_layout) {
                  for (var i in state2.opt.multi_layout) {
                    var locale_list = state2.opt.multi_layout[i];
                    var gotlang = false;
                    for (var j in locale_list) {
                      var tryspec = locale_list[j];
                      if (langspec.best === tryspec.best || langspec.base === tryspec.base || langspec.bare === tryspec.bare) {
                        gotlang = locale_list[0].best;
                        break;
                      }
                    }
                    if (!gotlang) {
                      gotlang = state2.opt["default-locale"][0];
                    }
                    state2.opt.lang = gotlang;
                  }
                }
                for (var key in newItem) {
                  if (["id", "type", "language", "multi"].indexOf(key) === -1 && key.slice(0, 4) !== "alt-") {
                    if (newItem.multi && newItem.multi._keys[key]) {
                      var deleteme = true;
                      for (var lang in newItem.multi._keys[key]) {
                        if (langspec.bare === lang.replace(/^([a-zA-Z]+).*/, "$1")) {
                          deleteme = false;
                          break;
                        }
                      }
                      if (deleteme) {
                        delete newItem[key];
                      }
                    } else {
                      delete newItem[key];
                    }
                  }
                }
                for (var key in newItem) {
                  if (key.slice(0, 4) === "alt-") {
                    newItem[key.slice(4)] = newItem[key];
                    state2.tmp.abort_alternative = false;
                  } else {
                    if (newItem.multi && newItem.multi._keys) {
                      if (!newItem["alt-" + key] && newItem.multi._keys[key]) {
                        if (newItem.multi._keys[key][langspec.best]) {
                          newItem[key] = newItem.multi._keys[key][langspec.best];
                          state2.tmp.abort_alternative = false;
                        } else if (newItem.multi._keys[key][langspec.base]) {
                          newItem[key] = newItem.multi._keys[key][langspec.base];
                          state2.tmp.abort_alternative = false;
                        } else if (newItem.multi._keys[key][langspec.bare]) {
                          newItem[key] = newItem.multi._keys[key][langspec.bare];
                          state2.tmp.abort_alternative = false;
                        }
                      }
                    }
                  }
                }
              }
              state2.output.openLevel(this);
              state2.registry.refhash[Item.id] = newItem;
              state2.nameOutput = new CSL3.NameOutput(state2, newItem);
            };
            this.execs.push(func);
            target.push(this);
            var choose_tok = new CSL3.Token("choose", CSL3.START);
            CSL3.Node["choose"].build.call(choose_tok, state, target);
            var if_tok = new CSL3.Token("if", CSL3.START);
            CSL3.Attributes["@alternative-node-internal"].call(if_tok, state);
            var func = function(state2) {
              state2.tmp.abort_alternative = true;
            };
            if_tok.execs.push(func);
            CSL3.Node["if"].build.call(if_tok, state, target);
          } else if (this.tokentype === CSL3.END) {
            var if_tok = new CSL3.Token("if", CSL3.END);
            CSL3.Node["if"].build.call(if_tok, state, target);
            var choose_tok = new CSL3.Token("choose", CSL3.END);
            CSL3.Node["choose"].build.call(choose_tok, state, target);
            var func = function(state2, Item) {
              state2.output.closeLevel();
              state2.registry.refhash[Item.id] = state2.tmp.oldItem;
              state2.opt.lang = state2.tmp.oldLang;
              state2.nameOutput = new CSL3.NameOutput(state2, state2.tmp.oldItem);
              state2.tmp.abort_alternative = false;
            };
            this.execs.push(func);
            target.push(this);
            var if_tok = new CSL3.Token("if", CSL3.END);
            CSL3.Node["if"].build.call(if_tok, state, target);
            var choose_tok = new CSL3.Token("choose", CSL3.END);
            CSL3.Node["choose"].build.call(choose_tok, state, target);
          }
        }
      };
      CSL3.Node["alternative-text"] = {
        build: function(state, target) {
          if (this.tokentype === CSL3.SINGLETON) {
            var func = function(state2, Item) {
              var Item = state2.refetchItem(Item.id);
              CSL3.getCite.call(state2, Item);
            };
            this.execs.push(func);
          }
          target.push(this);
        }
      };
      CSL3.NameOutput = function(state, Item, item) {
        this.debug = false;
        this.state = state;
        if (this.debug) {
          this.state.sys.print("(1)");
        }
        this.Item = Item;
        this.item = item;
        this.nameset_base = 0;
        this.etal_spec = {};
        this._first_creator_variable = false;
        this._please_chop = false;
      };
      CSL3.NameOutput.prototype.init = function(names) {
        this.requireMatch = names.requireMatch;
        if (this.state.tmp.term_predecessor) {
          this.state.tmp.subsequent_author_substitute_ok = false;
        }
        if (this.nameset_offset) {
          this.nameset_base = this.nameset_base + this.nameset_offset;
        }
        this.nameset_offset = 0;
        this.names = names;
        this.variables = names.variables;
        this.state.tmp.value = [];
        this.state.tmp.rendered_name = [];
        this.state.tmp.label_blob = false;
        this.state.tmp.etal_node = false;
        this.state.tmp.etal_term = false;
        for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
          if (this.Item[this.variables[i]] && this.Item[this.variables[i]].length) {
            this.state.tmp.value = this.state.tmp.value.concat(this.Item[this.variables[i]]);
          }
        }
        this["et-al"] = void 0;
        this["with"] = void 0;
        this.name = void 0;
        this.institutionpart = {};
        this.state.tmp.group_context.tip.variable_attempt = true;
        this.labelVariable = this.variables[0];
        if (!this.state.tmp.value.length) {
          return;
        }
        var checkCommonTerm = this.checkCommonAuthor(this.requireMatch);
        if (checkCommonTerm) {
          this.state.tmp.can_substitute.pop();
          this.state.tmp.can_substitute.push(true);
          for (var i in this.variables) {
            var idx = this.state.tmp.done_vars.indexOf(this.variables[i]);
            if (idx > -1) {
              this.state.tmp.done_vars = this.state.tmp.done_vars.slice(0, idx).concat(this.state.tmp.done_vars.slice(i + 1));
            }
          }
          this.state.tmp.common_term_match_fail = true;
          this.variables = [];
        }
      };
      CSL3.NameOutput.prototype.reinit = function(names, labelVariable) {
        this.requireMatch = names.requireMatch;
        this.labelVariable = labelVariable;
        if (this.state.tmp.can_substitute.value()) {
          this.nameset_offset = 0;
          this.variables = names.variables;
          var oldval = this.state.tmp.value.slice();
          this.state.tmp.value = [];
          for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
            if (this.Item[this.variables[i]] && this.Item[this.variables[i]].length) {
              this.state.tmp.value = this.state.tmp.value.concat(this.Item[this.variables[i]]);
            }
          }
          if (this.state.tmp.value.length) {
            this.state.tmp.can_substitute.replace(false, CSL3.LITERAL);
          }
          this.state.tmp.value = oldval;
        }
        var checkCommonTerm = this.checkCommonAuthor(this.requireMatch);
        if (checkCommonTerm) {
          this.state.tmp.can_substitute.pop();
          this.state.tmp.can_substitute.push(true);
          for (var i in this.variables) {
            var idx = this.state.tmp.done_vars.indexOf(this.variables[i]);
            if (idx > -1) {
              this.state.tmp.done_vars = this.state.tmp.done_vars.slice(0, idx).concat(this.state.tmp.done_vars.slice(i + 1));
            }
          }
          this.variables = [];
        }
      };
      CSL3.NameOutput.prototype.outputNames = function() {
        var i, ilen;
        var variables = this.variables;
        if (this.institution.and) {
          if (!this.institution.and.single.blobs || !this.institution.and.single.blobs.length) {
            this.institution.and.single.blobs = this.name.and.single.blobs;
          }
          if (!this.institution.and.multiple.blobs || !this.institution.and.multiple.blobs.length) {
            this.institution.and.multiple.blobs = this.name.and.multiple.blobs;
          }
        }
        this.variable_offset = {};
        if (this.family) {
          this.family_decor = CSL3.Util.cloneToken(this.family);
          this.family_decor.strings.prefix = "";
          this.family_decor.strings.suffix = "";
          for (i = 0, ilen = this.family.execs.length; i < ilen; i += 1) {
            this.family.execs[i].call(this.family_decor, this.state, this.Item);
          }
        } else {
          this.family_decor = false;
        }
        if (this.given) {
          this.given_decor = CSL3.Util.cloneToken(this.given);
          this.given_decor.strings.prefix = "";
          this.given_decor.strings.suffix = "";
          for (i = 0, ilen = this.given.execs.length; i < ilen; i += 1) {
            this.given.execs[i].call(this.given_decor, this.state, this.Item);
          }
        } else {
          this.given_decor = false;
        }
        if (this.debug) {
          this.state.sys.print("(2)");
        }
        this.getEtAlConfig();
        if (this.debug) {
          this.state.sys.print("(3)");
        }
        this.divideAndTransliterateNames();
        if (this.debug) {
          this.state.sys.print("(4)");
        }
        this.truncatePersonalNameLists();
        if (this.debug) {
          this.state.sys.print("(5)");
        }
        if (this.debug) {
          this.state.sys.print("(6)");
        }
        this.disambigNames();
        this.constrainNames();
        if (this.debug) {
          this.state.sys.print("(7)");
        }
        if (this.name.strings.form === "count") {
          if (this.state.tmp.extension || this.names_count != 0) {
            this.state.output.append(this.names_count, "empty");
            this.state.tmp.group_context.tip.variable_success = true;
          }
          return;
        }
        if (this.debug) {
          this.state.sys.print("(8)");
        }
        this.setEtAlParameters();
        if (this.debug) {
          this.state.sys.print("(9)");
        }
        this.setCommonTerm(this.requireMatch);
        if (this.debug) {
          this.state.sys.print("(10)");
        }
        this.renderAllNames();
        if (this.debug) {
          this.state.sys.print("(11)");
        }
        var blob_list = [];
        for (i = 0, ilen = variables.length; i < ilen; i += 1) {
          var v = variables[i];
          var institution_sets = [];
          var institutions = false;
          var varblob = null;
          if (!this.state.opt.development_extensions.spoof_institutional_affiliations) {
            varblob = this._join([this.freeters[v]], "");
          } else {
            if (this.debug) {
              this.state.sys.print("(11a)");
            }
            for (var j = 0, jlen = this.institutions[v].length; j < jlen; j += 1) {
              institution_sets.push(this.joinPersonsAndInstitutions([this.persons[v][j], this.institutions[v][j]]));
            }
            if (this.debug) {
              this.state.sys.print("(11b)");
            }
            if (this.institutions[v].length) {
              var pos = this.nameset_base + this.variable_offset[v];
              if (this.freeters[v].length) {
                pos += 1;
              }
              institutions = this.joinInstitutionSets(institution_sets, pos);
            }
            if (this.debug) {
              this.state.sys.print("(11c)");
            }
            var varblob = this.joinFreetersAndInstitutionSets([this.freeters[v], institutions]);
            if (this.debug) {
              this.state.sys.print("(11d)");
            }
          }
          if (varblob) {
            if (!this.state.tmp.extension) {
              varblob = this._applyLabels(varblob, v);
            }
            blob_list.push(varblob);
          }
          if (this.debug) {
            this.state.sys.print("(11e)");
          }
          if (this.common_term) {
            break;
          }
        }
        if (this.debug) {
          this.state.sys.print("(12)");
        }
        this.state.output.openLevel("empty");
        this.state.output.current.value().strings.delimiter = this.state.inheritOpt(this.names, "delimiter", "names-delimiter");
        if (this.debug) {
          this.state.sys.print("(13)");
        }
        for (i = 0, ilen = blob_list.length; i < ilen; i += 1) {
          this.state.output.append(blob_list[i], "literal", true);
        }
        if (!this.state.tmp.just_looking && blob_list.length > 0) {
          this.state.tmp.probably_rendered_something = true;
        }
        if (this.debug) {
          this.state.sys.print("(14)");
        }
        this.state.output.closeLevel("empty");
        if (this.debug) {
          this.state.sys.print("(15)");
        }
        var blob = this.state.output.pop();
        this.state.tmp.name_node.top = blob;
        if (this.debug) {
          this.state.sys.print("(16)");
        }
        var namesToken = CSL3.Util.cloneToken(this.names);
        if (this.state.tmp.group_context.tip.condition) {
          CSL3.UPDATE_GROUP_CONTEXT_CONDITION(this.state, this.names.strings.prefix, null, this.names);
        }
        this.state.output.append(blob, namesToken);
        if (this.state.tmp.term_predecessor_name) {
          this.state.tmp.term_predecessor = true;
        }
        if (this.debug) {
          this.state.sys.print("(17)");
        }
        if (this.debug) {
          this.state.sys.print("(18)");
        }
        if (variables[0] !== "authority") {
          var name_node_string = [];
          var nameobjs = this.Item[variables[0]];
          if (nameobjs) {
            for (var i = 0, ilen = nameobjs.length; i < ilen; i += 1) {
              var substring = CSL3.Util.Names.getRawName(nameobjs[i]);
              if (substring) {
                name_node_string.push(substring);
              }
            }
          }
          name_node_string = name_node_string.join(", ");
          if (name_node_string) {
            this.state.tmp.name_node.string = name_node_string;
          }
        }
        if (this.state.tmp.name_node.string && !this.state.tmp.first_name_string) {
          this.state.tmp.first_name_string = this.state.tmp.name_node.string;
        }
        if ("classic" === this.Item.type) {
          if (this.state.tmp.first_name_string) {
            var author_title = [];
            author_title.push(this.state.tmp.first_name_string);
            if (this.Item.title) {
              author_title.push(this.Item.title);
            }
            author_title = author_title.join(", ");
            if (author_title && this.state.sys.getAbbreviation) {
              if (this.state.sys.normalizeAbbrevsKey) {
                author_title = this.state.sys.normalizeAbbrevsKey("classic", author_title);
              }
              this.state.transform.loadAbbreviation("default", "classic", author_title, this.Item.language);
              if (this.state.transform.abbrevs["default"].classic[author_title]) {
                this.state.tmp.done_vars.push("title");
                this.state.output.append(this.state.transform.abbrevs["default"].classic[author_title], "empty", true);
                blob = this.state.output.pop();
                this.state.tmp.name_node.top.blobs.pop();
                this.state.tmp.name_node.top.blobs.push(blob);
              }
            }
          }
        }
        this._collapseAuthor();
        this.variables = [];
        this.state.tmp.authority_stop_last = 0;
        if (this.debug) {
          this.state.sys.print("(19)");
        }
      };
      CSL3.NameOutput.prototype._applyLabels = function(blob, v) {
        var txt;
        if (!this.label || !this.label[this.labelVariable]) {
          return blob;
        }
        var plural = 0;
        var num = this.freeters_count[v] + this.institutions_count[v];
        if (num > 1) {
          plural = 1;
        } else {
          for (var i = 0, ilen = this.persons[v].length; i < ilen; i += 1) {
            num += this.persons_count[v][i];
          }
          if (num > 1) {
            plural = 1;
          }
        }
        if (this.label[this.labelVariable].before) {
          if ("number" === typeof this.label[this.labelVariable].before.strings.plural) {
            plural = this.label[this.labelVariable].before.strings.plural;
          }
          txt = this._buildLabel(v, plural, "before", this.labelVariable);
          this.state.output.openLevel("empty");
          this.state.output.append(txt, this.label[this.labelVariable].before, true);
          this.state.output.append(blob, "literal", true);
          this.state.output.closeLevel("empty");
          blob = this.state.output.pop();
        } else if (this.label[this.labelVariable].after) {
          if ("number" === typeof this.label[this.labelVariable].after.strings.plural) {
            plural = this.label[this.labelVariable].after.strings.plural;
          }
          txt = this._buildLabel(v, plural, "after", this.labelVariable);
          this.state.output.openLevel("empty");
          this.state.output.append(blob, "literal", true);
          this.state.output.append(txt, this.label[this.labelVariable].after, true);
          this.state.tmp.label_blob = this.state.output.pop();
          this.state.output.append(this.state.tmp.label_blob, "literal", true);
          this.state.output.closeLevel("empty");
          blob = this.state.output.pop();
        }
        return blob;
      };
      CSL3.NameOutput.prototype._buildLabel = function(term, plural, position, v) {
        if (this.common_term) {
          term = this.common_term;
        }
        var ret = false;
        var node = this.label[v][position];
        if (node) {
          ret = CSL3.castLabel(this.state, node, term, plural, CSL3.TOLERANT);
        }
        return ret;
      };
      CSL3.NameOutput.prototype._collapseAuthor = function() {
        var myqueue, mystr, oldchars;
        if (this.state.tmp.name_node.top.blobs.length === 0) {
          return;
        }
        if (this.nameset_base === 0 && this.Item[this.variables[0]] && !this._first_creator_variable) {
          this._first_creator_variable = this.variables[0];
        }
        if (this.state[this.state.tmp.area].opt.collapse && this.state[this.state.tmp.area].opt.collapse.length || this.state[this.state.tmp.area].opt.cite_group_delimiter && this.state[this.state.tmp.area].opt.cite_group_delimiter.length) {
          if (this.state.tmp.authorstring_request) {
            mystr = "";
            myqueue = this.state.tmp.name_node.top.blobs.slice(-1)[0].blobs;
            oldchars = this.state.tmp.offset_characters;
            if (myqueue) {
              mystr = this.state.output.string(this.state, myqueue, false);
            }
            this.state.tmp.offset_characters = oldchars;
            this.state.registry.authorstrings[this.Item.id] = mystr;
          } else if (!this.state.tmp.just_looking && !this.state.tmp.suppress_decorations && (this.state[this.state.tmp.area].opt.collapse && this.state[this.state.tmp.area].opt.collapse.length || this.state[this.state.tmp.area].opt.cite_group_delimiter && this.state[this.state.tmp.area].opt.cite_group_delimiter)) {
            mystr = "";
            myqueue = this.state.tmp.name_node.top.blobs.slice(-1)[0].blobs;
            oldchars = this.state.tmp.offset_characters;
            if (myqueue) {
              mystr = this.state.output.string(this.state, myqueue, false);
            }
            if (mystr === this.state.tmp.last_primary_names_string) {
              if (this.item["suppress-author"] || this.state[this.state.tmp.area].opt.collapse && this.state[this.state.tmp.area].opt.collapse.length) {
                this.state.tmp.name_node.top.blobs.pop();
                this.state.tmp.name_node.children = [];
                this.state.tmp.offset_characters = oldchars;
              }
              if (this.state[this.state.tmp.area].opt.cite_group_delimiter && this.state[this.state.tmp.area].opt.cite_group_delimiter) {
                this.state.tmp.use_cite_group_delimiter = true;
              }
            } else {
              this.state.tmp.last_primary_names_string = mystr;
              if (this.variables.indexOf(this._first_creator_variable) > -1 && this.item && this.item["suppress-author"] && this.Item.type !== "legal_case") {
                this.state.tmp.name_node.top.blobs.pop();
                this.state.tmp.name_node.children = [];
                this.state.tmp.offset_characters = oldchars;
                this.state.tmp.term_predecessor = false;
              }
              this.state.tmp.have_collapsed = false;
              if (this.state[this.state.tmp.area].opt.cite_group_delimiter && this.state[this.state.tmp.area].opt.cite_group_delimiter) {
                this.state.tmp.use_cite_group_delimiter = false;
              }
            }
          }
        }
      };
      CSL3.NameOutput.prototype.isPerson = function(value) {
        if (value.literal || !value.given && value.family && value.isInstitution) {
          return false;
        } else {
          return true;
        }
      };
      CSL3.NameOutput.prototype.truncatePersonalNameLists = function() {
        var v, i, ilen, j, jlen, chopvar, values;
        this.freeters_count = {};
        this.persons_count = {};
        this.institutions_count = {};
        for (v in this.freeters) {
          if (this.freeters.hasOwnProperty(v)) {
            this.freeters_count[v] = this.freeters[v].length;
            this.freeters[v] = this._truncateNameList(this.freeters, v);
          }
        }
        for (v in this.persons) {
          if (this.persons.hasOwnProperty(v)) {
            this.institutions_count[v] = this.institutions[v].length;
            this._truncateNameList(this.institutions, v);
            this.persons[v] = this.persons[v].slice(0, this.institutions[v].length);
            this.persons_count[v] = [];
            for (j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
              this.persons_count[v][j] = this.persons[v][j].length;
              this.persons[v][j] = this._truncateNameList(this.persons, v, j);
            }
          }
        }
        if (this.state.opt.development_extensions.etal_min_etal_usefirst_hack && this.etal_min === 1 && this.etal_use_first === 1 && !(this.state.tmp.extension || this.state.tmp.just_looking)) {
          chopvar = v;
        } else {
          chopvar = false;
        }
        if (chopvar || this._please_chop) {
          for (i = 0, ilen = this.variables.length; i < ilen; i += 1) {
            v = this.variables[i];
            if (this.freeters[v].length) {
              if (this._please_chop === v) {
                this.freeters[v] = this.freeters[v].slice(1);
                this.freeters_count[v] += -1;
                this._please_chop = false;
              } else if (chopvar && !this._please_chop) {
                this.freeters[v] = this.freeters[v].slice(0, 1);
                this.freeters_count[v] = 1;
                this.institutions[v] = [];
                this.persons[v] = [];
                this._please_chop = chopvar;
              }
            }
            for (var j = 0, jlen = this.persons[v].length; j < jlen; j++) {
              if (this.persons[v][j].length) {
                if (this._please_chop === v) {
                  this.persons[v][j] = this.persons[v][j].slice(1);
                  this.persons_count[v][j] += -1;
                  this._please_chop = false;
                  break;
                } else if (chopvar && !this._please_chop) {
                  this.freeters[v] = this.persons[v][j].slice(0, 1);
                  this.freeters_count[v] = 1;
                  this.institutions[v] = [];
                  this.persons[v] = [];
                  values = [];
                  this._please_chop = chopvar;
                  break;
                }
              }
            }
            if (this.institutions[v].length) {
              if (this._please_chop === v) {
                this.institutions[v] = this.institutions[v].slice(1);
                this.institutions_count[v] += -1;
                this._please_chop = false;
              } else if (chopvar && !this._please_chop) {
                this.institutions[v] = this.institutions[v].slice(0, 1);
                this.institutions_count[v] = 1;
                values = [];
                this._please_chop = chopvar;
              }
            }
          }
        }
        for (i = 0, ilen = this.variables.length; i < ilen; i += 1) {
          if (this.institutions[v].length) {
            this.nameset_offset += 1;
          }
          for (var j = 0, jlen = this.persons[v].length; j < jlen; j++) {
            if (this.persons[v][j].length) {
              this.nameset_offset += 1;
            }
          }
        }
      };
      CSL3.NameOutput.prototype._truncateNameList = function(container, variable, index) {
        var lst;
        if ("undefined" === typeof index) {
          lst = container[variable];
        } else {
          lst = container[variable][index];
        }
        if (this.state[this.state[this.state.tmp.area].root].opt.max_number_of_names && lst.length > 50 && lst.length > this.state[this.state[this.state.tmp.area].root].opt.max_number_of_names + 2) {
          var limit = this.state[this.state[this.state.tmp.area].root].opt.max_number_of_names;
          lst = lst.slice(0, limit + 1).concat(lst.slice(-1));
        }
        return lst;
      };
      CSL3.NameOutput.prototype.divideAndTransliterateNames = function() {
        var i, ilen, j, jlen;
        var Item = this.Item;
        var variables = this.variables;
        this.varnames = variables.slice();
        this.freeters = {};
        this.persons = {};
        this.institutions = {};
        for (i = 0, ilen = variables.length; i < ilen; i += 1) {
          var v = variables[i];
          this.variable_offset[v] = this.nameset_offset;
          var values = this._normalizeVariableValue(Item, v);
          if (this.name.strings["suppress-min"] && values.length >= this.name.strings["suppress-min"]) {
            values = [];
          }
          if (this.name.strings["suppress-max"] && values.length <= this.name.strings["suppress-max"]) {
            values = [];
          }
          this._getFreeters(v, values);
          this._getPersonsAndInstitutions(v, values);
          if (this.state.opt.development_extensions.spoof_institutional_affiliations) {
            if (this.name.strings["suppress-min"] === 0) {
              this.freeters[v] = [];
              for (j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
                this.persons[v][j] = [];
              }
            } else if (this.institution.strings["suppress-min"] === 0) {
              this.institutions[v] = [];
              this.freeters[v] = this.freeters[v].concat(this.persons[v]);
              for (j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
                for (var k = 0, klen = this.persons[v][j].length; k < klen; k += 1) {
                  this.freeters[v].push(this.persons[v][j][k]);
                }
              }
              this.persons[v] = [];
            }
          }
        }
      };
      CSL3.NameOutput.prototype._normalizeVariableValue = function(Item, variable) {
        var names;
        if ("string" === typeof Item[variable] || "number" === typeof Item[variable]) {
          CSL3.debug('name variable "' + variable + '" is string or number, not array. Attempting to fix.');
          names = [{ literal: Item[variable] + "" }];
        } else if (!Item[variable]) {
          names = [];
        } else if ("number" !== typeof Item[variable].length) {
          CSL3.debug('name variable "' + variable + '" is object, not array. Attempting to fix.');
          Item[variable] = [Item[variable]];
          names = Item[variable].slice();
        } else {
          names = Item[variable].slice();
        }
        return names;
      };
      CSL3.NameOutput.prototype._getFreeters = function(v, values) {
        this.freeters[v] = [];
        if (this.state.opt.development_extensions.spoof_institutional_affiliations) {
          for (var i = values.length - 1; i > -1; i--) {
            if (this.isPerson(values[i])) {
              var value = this._checkNickname(values.pop());
              if (value) {
                this.freeters[v].push(value);
              }
            } else {
              break;
            }
          }
        } else {
          for (var i = values.length - 1; i > -1; i--) {
            var value = values.pop();
            if (this.isPerson(value)) {
              var value = this._checkNickname(value);
            }
            this.freeters[v].push(value);
          }
        }
        this.freeters[v].reverse();
        if (this.freeters[v].length) {
          this.nameset_offset += 1;
        }
      };
      CSL3.NameOutput.prototype._getPersonsAndInstitutions = function(v, values) {
        this.persons[v] = [];
        this.institutions[v] = [];
        if (!this.state.opt.development_extensions.spoof_institutional_affiliations) {
          return;
        }
        var persons = [];
        var has_affiliates = false;
        var first = true;
        for (var i = values.length - 1; i > -1; i += -1) {
          if (this.isPerson(values[i])) {
            var value = this._checkNickname(values[i]);
            if (value) {
              persons.push(value);
            }
          } else {
            has_affiliates = true;
            this.institutions[v].push(values[i]);
            if (!first) {
              persons.reverse();
              this.persons[v].push(persons);
              persons = [];
            }
            first = false;
          }
        }
        if (has_affiliates) {
          persons.reverse();
          this.persons[v].push(persons);
          this.persons[v].reverse();
          this.institutions[v].reverse();
        }
      };
      CSL3.NameOutput.prototype._clearValues = function(values) {
        for (var i = values.length - 1; i > -1; i += -1) {
          values.pop();
        }
      };
      CSL3.NameOutput.prototype._checkNickname = function(name) {
        if (["interview", "personal_communication"].indexOf(this.Item.type) > -1) {
          var author = "";
          author = CSL3.Util.Names.getRawName(name);
          if (author && this.state.sys.getAbbreviation && !(this.item && this.item["suppress-author"])) {
            var normalizedKey = author;
            if (this.state.sys.normalizeAbbrevsKey) {
              normalizedKey = this.state.sys.normalizeAbbrevsKey("author", author);
            }
            this.state.transform.loadAbbreviation("default", "nickname", normalizedKey, this.Item.language);
            var myLocalName = this.state.transform.abbrevs["default"].nickname[normalizedKey];
            if (myLocalName) {
              if (myLocalName === "!here>>>") {
                name = false;
              } else {
                name = { family: myLocalName, given: "" };
              }
            }
          }
        }
        return name;
      };
      CSL3.NameOutput.prototype._purgeEmptyBlobs = function(blobs) {
        for (var i = blobs.length - 1; i > -1; i += -1) {
          if (!blobs[i] || blobs[i].length === 0 || !blobs[i].blobs.length) {
            blobs = blobs.slice(0, i).concat(blobs.slice(i + 1));
          }
        }
        return blobs;
      };
      CSL3.NameOutput.prototype.joinPersons = function(blobs, pos, j, tokenname) {
        var ret;
        blobs = this._purgeEmptyBlobs(blobs);
        if (!tokenname) {
          tokenname = "name";
        }
        if ("undefined" === typeof j) {
          if (this.etal_spec[pos].freeters === 1) {
            ret = this._joinEtAl(blobs);
          } else if (this.etal_spec[pos].freeters === 2) {
            ret = this._joinEllipsis(blobs);
          } else if (!this.state.tmp.sort_key_flag) {
            ret = this._joinAnd(blobs);
          } else {
            ret = this._join(blobs, this.state.inheritOpt(this.name, "delimiter", "name-delimiter", ", "));
          }
        } else {
          if (this.etal_spec[pos].persons[j] === 1) {
            ret = this._joinEtAl(blobs);
          } else if (this.etal_spec[pos].persons[j] === 2) {
            ret = this._joinEllipsis(blobs);
          } else if (!this.state.tmp.sort_key_flag) {
            ret = this._joinAnd(blobs);
          } else {
            ret = this._join(blobs, this.state.inheritOpt(this.name, "delimiter", "name-delimiter", ", "));
          }
        }
        return ret;
      };
      CSL3.NameOutput.prototype.joinInstitutionSets = function(blobs, pos) {
        var ret;
        blobs = this._purgeEmptyBlobs(blobs);
        if (this.etal_spec[pos].institutions === 1) {
          ret = this._joinEtAl(blobs, "institution");
        } else if (this.etal_spec[pos].institutions === 2) {
          ret = this._joinEllipsis(blobs, "institution");
        } else {
          ret = this._joinAnd(blobs);
        }
        return ret;
      };
      CSL3.NameOutput.prototype.joinPersonsAndInstitutions = function(blobs) {
        blobs = this._purgeEmptyBlobs(blobs);
        var ret = this._join(blobs, this.state.tmp.name_delimiter);
        ret.isInstitution = true;
        return ret;
      };
      CSL3.NameOutput.prototype.joinFreetersAndInstitutionSets = function(blobs) {
        blobs = this._purgeEmptyBlobs(blobs);
        var ret = this._join(blobs, "[never here]", this["with"].single, this["with"].multiple);
        return ret;
      };
      CSL3.NameOutput.prototype._getAfterInvertedName = function(blobs, delimiter, finalJoin) {
        if (finalJoin && blobs.length > 1) {
          if (this.state.inheritOpt(this.name, "delimiter-precedes-last") === "after-inverted-name") {
            var prevBlob = blobs[blobs.length - 2];
            if (prevBlob.blobs.length > 0 && prevBlob.blobs[0].isInverted) {
              finalJoin.strings.prefix = delimiter;
            }
          }
        }
        return finalJoin;
      };
      CSL3.NameOutput.prototype._getAndJoin = function(blobs, delimiter) {
        var finalJoin = false;
        if (blobs.length > 1) {
          var singleOrMultiple = "single";
          if (blobs.length > 2) {
            singleOrMultiple = "multiple";
          }
          if (blobs[blobs.length - 1].isInstitution) {
            finalJoin = this.institution.and[singleOrMultiple];
          } else {
            finalJoin = this.name.and[singleOrMultiple];
          }
          finalJoin = JSON.parse(JSON.stringify(finalJoin));
          finalJoin = this._getAfterInvertedName(blobs, delimiter, finalJoin);
        }
        return finalJoin;
      };
      CSL3.NameOutput.prototype._joinEtAl = function(blobs) {
        var delimiter = this.state.inheritOpt(this.name, "delimiter", "name-delimiter", ", ");
        var blob = this._join(blobs, delimiter);
        this.state.output.openLevel(this._getToken("name"));
        this.state.output.current.value().strings.delimiter = "";
        this.state.output.append(blob, "literal", true);
        if (blobs.length > 1) {
          this.state.output.append(this["et-al"].multiple, "literal", true);
        } else if (blobs.length === 1) {
          this.state.output.append(this["et-al"].single, "literal", true);
        }
        this.state.output.closeLevel();
        return this.state.output.pop();
      };
      CSL3.NameOutput.prototype._joinEllipsis = function(blobs) {
        var delimiter = this.state.inheritOpt(this.name, "delimiter", "name-delimiter", ", ");
        var finalJoin = false;
        if (blobs.length > 1) {
          var singleOrMultiple = "single";
          if (blobs.length > 2) {
            singleOrMultiple = "multiple";
          }
          finalJoin = JSON.parse(JSON.stringify(this.name.ellipsis[singleOrMultiple]));
          finalJoin = this._getAfterInvertedName(blobs, delimiter, finalJoin);
        }
        return this._join(blobs, delimiter, finalJoin);
      };
      CSL3.NameOutput.prototype._joinAnd = function(blobs) {
        var delimiter = this.state.inheritOpt(this.name, "delimiter", "name-delimiter", ", ");
        var finalJoin = this._getAndJoin(blobs, delimiter);
        return this._join(blobs, delimiter, finalJoin);
      };
      CSL3.NameOutput.prototype._join = function(blobs, delimiter, finalJoin) {
        var i, ilen;
        if (!blobs) {
          return false;
        }
        blobs = this._purgeEmptyBlobs(blobs);
        if (!blobs.length) {
          return false;
        }
        if (blobs.length > 1) {
          if (blobs.length === 2) {
            if (!finalJoin) {
              blobs[0].strings.suffix += delimiter;
            } else {
              blobs = [blobs[0], finalJoin, blobs[1]];
            }
          } else {
            var offset;
            if (finalJoin) {
              offset = 1;
            } else {
              offset = 0;
            }
            var blob = blobs.pop();
            for (var i = 0, ilen = blobs.length - offset; i < ilen; i++) {
              blobs[i].strings.suffix += delimiter;
            }
            blobs.push(finalJoin);
            blobs.push(blob);
          }
        }
        this.state.output.openLevel();
        for (i = 0, ilen = blobs.length; i < ilen; i += 1) {
          this.state.output.append(blobs[i], false, true);
        }
        this.state.output.closeLevel();
        return this.state.output.pop();
      };
      CSL3.NameOutput.prototype._getToken = function(tokenname) {
        var token = this[tokenname];
        if (tokenname === "institution") {
          var newtoken = new CSL3.Token();
          return newtoken;
        }
        return token;
      };
      CSL3.NameOutput.prototype.checkCommonAuthor = function(requireMatch) {
        if (!requireMatch) {
          return false;
        }
        var common_term = false;
        if (this.variables.length === 2) {
          var variables = this.variables;
          var varnames = variables.slice();
          varnames.sort();
          common_term = varnames.join("");
        }
        if (!common_term) {
          return false;
        }
        var has_term = false;
        if (this.state.locale[this.state.opt.lang].terms[common_term]) {
          has_term = true;
        }
        if (!has_term) {
          this.state.tmp.done_vars.push(this.variables[0]);
          this.state.tmp.done_vars.push(this.variables[1]);
          return false;
        }
        var firstSet = this.Item[this.variables[0]];
        var secondSet = this.Item[this.variables[1]];
        var perfectMatch = this._compareNamesets(firstSet, secondSet);
        if (perfectMatch === true) {
          this.state.tmp.done_vars.push(this.variables[0]);
          this.state.tmp.done_vars.push(this.variables[1]);
        }
        return !perfectMatch;
      };
      CSL3.NameOutput.prototype.setCommonTerm = function() {
        var variables = this.variables;
        var varnames = variables.slice();
        varnames.sort();
        this.common_term = varnames.join("");
        if (!this.common_term) {
          return;
        }
        var has_term = false;
        if (this.label && this.label[this.variables[0]]) {
          if (this.label[this.variables[0]].before) {
            has_term = this.state.getTerm(this.common_term, this.label[this.variables[0]].before.strings.form, 0);
          } else if (this.label[this.variables[0]].after) {
            has_term = this.state.getTerm(this.common_term, this.label[this.variables[0]].after.strings.form, 0);
          }
        }
        if (!this.state.locale[this.state.opt.lang].terms[this.common_term] || !has_term || this.variables.length < 2) {
          this.common_term = false;
          return;
        }
        var freeters_offset = 0;
        for (var i = 0, ilen = this.variables.length - 1; i < ilen; i += 1) {
          var v = this.variables[i];
          var vv = this.variables[i + 1];
          if (this.freeters[v].length || this.freeters[vv].length) {
            if (this.etal_spec[v].freeters !== this.etal_spec[vv].freeters || !this._compareNamesets(this.freeters[v], this.freeters[vv])) {
              this.common_term = false;
              return;
            }
            freeters_offset += 1;
          }
          if (this.persons[v].length !== this.persons[vv].length) {
            this.common_term = false;
            return;
          }
          for (var j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
            if (this.etal_spec[v].persons[j] !== this.etal_spec[vv].persons[j] || !this._compareNamesets(this.persons[v][j], this.persons[vv][j])) {
              this.common_term = false;
              return;
            }
          }
        }
      };
      CSL3.NameOutput.prototype._compareNamesets = function(base_nameset, nameset) {
        if (!base_nameset || !nameset || base_nameset.length !== nameset.length) {
          return false;
        }
        for (var i = 0, ilen = nameset.length; i < ilen; i += 1) {
          for (var j = 0, jlen = CSL3.NAME_PARTS.length; j < jlen; j += 1) {
            var part = CSL3.NAME_PARTS[j];
            if (!base_nameset[i] || base_nameset[i][part] != nameset[i][part]) {
              return false;
            }
          }
        }
        return true;
      };
      CSL3.NameOutput.prototype.constrainNames = function() {
        this.names_count = 0;
        var pos;
        for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
          var v = this.variables[i];
          pos = this.nameset_base + i;
          if (this.freeters[v].length) {
            this.state.tmp.names_max.push(this.freeters[v].length, "literal");
            this._imposeNameConstraints(this.freeters, this.freeters_count, v, pos);
            this.names_count += this.freeters[v].length;
          }
          if (this.institutions[v].length) {
            this.state.tmp.names_max.push(this.institutions[v].length, "literal");
            this._imposeNameConstraints(this.institutions, this.institutions_count, v, pos);
            this.persons[v] = this.persons[v].slice(0, this.institutions[v].length);
            this.names_count += this.institutions[v].length;
          }
          for (var j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
            if (this.persons[v][j].length) {
              this.state.tmp.names_max.push(this.persons[v][j].length, "literal");
              this._imposeNameConstraints(this.persons[v], this.persons_count[v], j, pos);
              this.names_count += this.persons[v][j].length;
            }
          }
        }
      };
      CSL3.NameOutput.prototype._imposeNameConstraints = function(lst, count, key, pos) {
        var display_names = lst[key];
        var discretionary_names_length = this.state.tmp["et-al-min"];
        if (this.state.tmp.suppress_decorations) {
          if (this.state.tmp.disambig_request && this.state.tmp.disambig_request.names[pos]) {
            discretionary_names_length = this.state.tmp.disambig_request.names[pos];
          } else if (count[key] >= this.etal_min) {
            discretionary_names_length = this.etal_use_first;
          }
        } else {
          if (this.state.tmp.disambig_request && this.state.tmp.disambig_request.names[pos] > this.etal_use_first) {
            if (count[key] < this.etal_min) {
              discretionary_names_length = count[key];
            } else {
              discretionary_names_length = this.state.tmp.disambig_request.names[pos];
            }
          } else if (count[key] >= this.etal_min) {
            discretionary_names_length = this.etal_use_first;
          }
          if (this.etal_use_last && discretionary_names_length > this.etal_min - 2) {
            discretionary_names_length = this.etal_min - 2;
          }
        }
        var sane = this.etal_min >= this.etal_use_first;
        var overlength = count[key] > discretionary_names_length;
        if (discretionary_names_length > count[key]) {
          discretionary_names_length = display_names.length;
        }
        if (sane && overlength) {
          if (this.etal_use_last) {
            lst[key] = display_names.slice(0, discretionary_names_length).concat(display_names.slice(-1));
          } else {
            lst[key] = display_names.slice(0, discretionary_names_length);
          }
        }
        this.state.tmp.disambig_settings.names[pos] = lst[key].length;
        this.state.disambiguate.padBase(this.state.tmp.disambig_settings);
      };
      CSL3.NameOutput.prototype.disambigNames = function() {
        var pos;
        for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
          var v = this.variables[i];
          pos = this.nameset_base + i;
          if (this.freeters[v].length) {
            this._runDisambigNames(this.freeters[v], pos);
          }
          if (this.institutions[v].length) {
            if ("undefined" === typeof this.state.tmp.disambig_settings.givens[pos]) {
              this.state.tmp.disambig_settings.givens[pos] = [];
            }
            for (var j = 0, jlen = this.institutions[v].length; j < jlen; j += 1) {
              if ("undefined" === typeof this.state.tmp.disambig_settings.givens[pos][j]) {
                this.state.tmp.disambig_settings.givens[pos].push(2);
              }
            }
          }
          for (var j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
            if (this.persons[v][j].length) {
              this._runDisambigNames(this.persons[v][j], pos);
            }
          }
        }
      };
      CSL3.NameOutput.prototype._runDisambigNames = function(lst, pos) {
        var chk, myform, myinitials, param, i, ilen, paramx;
        for (i = 0, ilen = lst.length; i < ilen; i += 1) {
          if (!lst[i].given && !lst[i].family) {
            continue;
          }
          myinitials = this.state.inheritOpt(this.name, "initialize-with");
          this.state.registry.namereg.addname("" + this.Item.id, lst[i], i);
          chk = this.state.tmp.disambig_settings.givens[pos];
          if ("undefined" === typeof chk) {
            for (var j = 0, jlen = pos + 1; j < jlen; j += 1) {
              if (!this.state.tmp.disambig_settings.givens[j]) {
                this.state.tmp.disambig_settings.givens[j] = [];
              }
            }
          }
          chk = this.state.tmp.disambig_settings.givens[pos][i];
          if ("undefined" === typeof chk) {
            myform = this.state.inheritOpt(this.name, "form", "name-form", "long");
            param = this.state.registry.namereg.evalname("" + this.Item.id, lst[i], i, 0, myform, myinitials);
            this.state.tmp.disambig_settings.givens[pos].push(param);
          }
          myform = this.state.inheritOpt(this.name, "form", "name-form", "long");
          paramx = this.state.registry.namereg.evalname("" + this.Item.id, lst[i], i, 0, myform, myinitials);
          if (this.state.tmp.disambig_request) {
            var val = this.state.tmp.disambig_settings.givens[pos][i];
            if (val === 1 && this.state.citation.opt["givenname-disambiguation-rule"] === "by-cite" && ("undefined" === typeof this.state.inheritOpt(this.name, "initialize-with") || "undefined" === typeof lst[i].given)) {
              val = 2;
            }
            param = val;
            if (this.state.opt["disambiguate-add-givenname"] && lst[i].given) {
              param = this.state.registry.namereg.evalname("" + this.Item.id, lst[i], i, param, this.state.inheritOpt(this.name, "form", "name-form", "long"), this.state.inheritOpt(this.name, "initialize-with"));
            }
          } else {
            param = paramx;
          }
          if (!this.state.tmp.just_looking && this.item && this.item.position === CSL3.POSITION_FIRST) {
            if (paramx > param) {
              param = paramx;
            }
          }
          if (!this.state.tmp.sort_key_flag) {
            this.state.tmp.disambig_settings.givens[pos][i] = param;
            if ("string" === typeof myinitials && ("undefined" === typeof this.name.strings["initialize"] || true === this.name.strings["initialize"])) {
              this.state.tmp.disambig_settings.use_initials = true;
            }
          }
        }
      };
      CSL3.NameOutput.prototype.getEtAlConfig = function() {
        var item = this.item;
        this["et-al"] = {};
        this.state.output.append(this.etal_term, this.etal_style, true);
        this["et-al"].single = this.state.output.pop();
        this["et-al"].single.strings.suffix = this.etal_suffix;
        this["et-al"].single.strings.prefix = this.etal_prefix_single;
        this.state.output.append(this.etal_term, this.etal_style, true);
        this["et-al"].multiple = this.state.output.pop();
        this["et-al"].multiple.strings.suffix = this.etal_suffix;
        this["et-al"].multiple.strings.prefix = this.etal_prefix_multiple;
        if ("undefined" === typeof item) {
          item = {};
        }
        if (item.position) {
          if (this.state.inheritOpt(this.name, "et-al-subsequent-min")) {
            this.etal_min = this.state.inheritOpt(this.name, "et-al-subsequent-min");
          } else {
            this.etal_min = this.state.inheritOpt(this.name, "et-al-min");
          }
          if (this.state.inheritOpt(this.name, "et-al-subsequent-use-first")) {
            this.etal_use_first = this.state.inheritOpt(this.name, "et-al-subsequent-use-first");
          } else {
            this.etal_use_first = this.state.inheritOpt(this.name, "et-al-use-first");
          }
        } else {
          if (this.state.tmp["et-al-min"]) {
            this.etal_min = this.state.tmp["et-al-min"];
          } else {
            this.etal_min = this.state.inheritOpt(this.name, "et-al-min");
          }
          if (this.state.tmp["et-al-use-first"]) {
            this.etal_use_first = this.state.tmp["et-al-use-first"];
          } else {
            this.etal_use_first = this.state.inheritOpt(this.name, "et-al-use-first");
          }
          if ("boolean" === typeof this.state.tmp["et-al-use-last"]) {
            this.etal_use_last = this.state.tmp["et-al-use-last"];
          } else {
            this.etal_use_last = this.state.inheritOpt(this.name, "et-al-use-last");
          }
        }
        if (!this.state.tmp["et-al-min"]) {
          this.state.tmp["et-al-min"] = this.etal_min;
        }
      };
      CSL3.NameOutput.prototype.setEtAlParameters = function() {
        var i, ilen, j, jlen;
        for (i = 0, ilen = this.variables.length; i < ilen; i += 1) {
          var v = this.variables[i];
          if ("undefined" === typeof this.etal_spec[v]) {
            this.etal_spec[v] = { freeters: 0, institutions: 0, persons: [] };
          }
          this.etal_spec[this.nameset_base + i] = this.etal_spec[v];
          if (this.freeters[v].length) {
            this._setEtAlParameter("freeters", v);
          }
          for (j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
            if ("undefined" === typeof this.etal_spec[v][j]) {
              this.etal_spec[v].persons[j] = 0;
            }
            this._setEtAlParameter("persons", v, j);
          }
          if (this.institutions[v].length) {
            this._setEtAlParameter("institutions", v);
          }
        }
      };
      CSL3.NameOutput.prototype._setEtAlParameter = function(type, v, j) {
        var lst, count;
        if (type === "persons") {
          lst = this.persons[v][j];
          count = this.persons_count[v][j];
        } else {
          lst = this[type][v];
          count = this[type + "_count"][v];
        }
        if (lst.length < count && !this.state.tmp.sort_key_flag) {
          if (this.etal_use_last) {
            if (type === "persons") {
              this.etal_spec[v].persons[j] = 2;
            } else {
              this.etal_spec[v][type] = 2;
            }
          } else {
            if (type === "persons") {
              this.etal_spec[v].persons[j] = 1;
            } else {
              this.etal_spec[v][type] = 1;
            }
          }
        } else {
          if (type === "persons") {
            this.etal_spec[v].persons[j] = 0;
          } else {
            this.etal_spec[v][type] = 0;
          }
        }
      };
      CSL3.NameOutput.prototype.renderAllNames = function() {
        var pos;
        for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
          var v = this.variables[i];
          if (this.freeters[v].length || this.institutions[v].length) {
            if (!this.state.tmp.group_context.tip.condition) {
              this.state.tmp.just_did_number = false;
            }
          }
          pos = this.nameset_base + i;
          if (this.freeters[v].length) {
            this.freeters[v] = this._renderNames(v, this.freeters[v], pos);
          }
          for (var j = 0, jlen = this.institutions[v].length; j < jlen; j += 1) {
            this.persons[v][j] = this._renderNames(v, this.persons[v][j], pos, j);
          }
        }
        this.renderInstitutionNames();
      };
      CSL3.NameOutput.prototype.renderInstitutionNames = function() {
        for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
          var v = this.variables[i];
          for (var j = 0, jlen = this.institutions[v].length; j < jlen; j += 1) {
            var institution;
            var name = this.institutions[v][j];
            var j, jlen, localesets;
            if (this.state.tmp.extension) {
              localesets = ["sort"];
            } else if (name.isInstitution || name.literal) {
              localesets = this.state.opt["cite-lang-prefs"].institutions;
            } else {
              localesets = this.state.opt["cite-lang-prefs"].persons;
            }
            var slot = { primary: "locale-orig", secondary: false, tertiary: false };
            if (localesets) {
              var slotnames = ["primary", "secondary", "tertiary"];
              for (var k = 0, klen = slotnames.length; k < klen; k += 1) {
                if (localesets.length - 1 < k) {
                  break;
                }
                if (localesets[k]) {
                  slot[slotnames[k]] = "locale-" + localesets[k];
                }
              }
            } else {
              slot.primary = "locale-translat";
            }
            if (this.state.tmp.area !== "bibliography" && !(this.state.tmp.area === "citation" && this.state.opt.xclass === "note" && this.item && !this.item.position)) {
              slot.secondary = false;
              slot.tertiary = false;
            }
            this.setRenderedName(name);
            var institution = this._renderInstitutionName(v, name, slot, j);
            this.institutions[v][j] = institution;
          }
        }
      };
      CSL3.NameOutput.prototype._renderInstitutionName = function(v, name, slot, j) {
        var secondary, tertiary, long_style, short_style, institution, institution_short, institution_long;
        var res = this.getName(name, slot.primary, true);
        var primary = res.name;
        var usedOrig = res.usedOrig;
        if (primary) {
          primary = this.fixupInstitution(primary, v, j);
        }
        secondary = false;
        if (slot.secondary) {
          res = this.getName(name, slot.secondary, false, usedOrig);
          var secondary = res.name;
          usedOrig = res.usedOrig;
          if (secondary) {
            secondary = this.fixupInstitution(secondary, v, j);
          }
        }
        tertiary = false;
        if (slot.tertiary) {
          res = this.getName(name, slot.tertiary, false, usedOrig);
          tertiary = res.name;
          if (tertiary) {
            tertiary = this.fixupInstitution(tertiary, v, j);
          }
        }
        var n = {
          l: {
            pri: false,
            sec: false,
            ter: false
          },
          s: {
            pri: false,
            sec: false,
            ter: false
          }
        };
        if (primary) {
          n.l.pri = primary["long"];
          n.s.pri = primary["short"].length ? primary["short"] : primary["long"];
        }
        if (secondary) {
          n.l.sec = secondary["long"];
          n.s.sec = secondary["short"].length ? secondary["short"] : secondary["long"];
        }
        if (tertiary) {
          n.l.ter = tertiary["long"];
          n.s.ter = tertiary["short"].length ? tertiary["short"] : tertiary["long"];
        }
        switch (this.institution.strings["institution-parts"]) {
          case "short":
            if (primary["short"].length) {
              short_style = this._getShortStyle();
              institution = [this._composeOneInstitutionPart([n.s.pri, n.s.sec, n.s.ter], slot, short_style, v)];
            } else {
              long_style = this._getLongStyle(primary, v, j);
              institution = [this._composeOneInstitutionPart([n.l.pri, n.l.sec, n.l.ter], slot, long_style, v)];
            }
            break;
          case "short-long":
            long_style = this._getLongStyle(primary, v, j);
            short_style = this._getShortStyle();
            institution_short = this._renderOneInstitutionPart(primary["short"], short_style);
            institution_long = this._composeOneInstitutionPart([n.l.pri, n.l.sec, n.l.ter], slot, long_style, v);
            institution = [institution_short, institution_long];
            break;
          case "long-short":
            long_style = this._getLongStyle(primary, v, j);
            short_style = this._getShortStyle();
            institution_short = this._renderOneInstitutionPart(primary["short"], short_style);
            institution_long = this._composeOneInstitutionPart([n.l.pri, n.l.sec, n.l.ter], slot, long_style, v);
            institution = [institution_long, institution_short];
            break;
          default:
            long_style = this._getLongStyle(primary, v, j);
            institution = [this._composeOneInstitutionPart([n.l.pri, n.l.sec, n.l.ter], slot, long_style, v)];
            break;
        }
        var blob = this._join(institution, " ");
        if (blob) {
          blob.isInstitution = true;
        }
        this.state.tmp.name_node.children.push(blob);
        return blob;
      };
      CSL3.NameOutput.prototype._composeOneInstitutionPart = function(names, slot, style) {
        var primary = false, secondary = false, tertiary = false, primary_tok, secondary_tok, tertiary_tok;
        if (names[0]) {
          primary_tok = CSL3.Util.cloneToken(style);
          if (this.state.opt.citeAffixes[slot.primary]) {
            if ("<i>" === this.state.opt.citeAffixes.institutions[slot.primary].prefix) {
              var hasItalic = false;
              for (var i = 0, ilen = primary_tok.decorations.length; i < ilen; i += 1) {
                if (style.decorations[i][0] === "@font-style" && primary_tok.decorations[i][1] === "italic") {
                  hasItalic = true;
                }
              }
              if (!hasItalic) {
                primary_tok.decorations.push(["@font-style", "italic"]);
              }
            }
          }
          primary = this._renderOneInstitutionPart(names[0], primary_tok);
        }
        if (names[1]) {
          secondary = this._renderOneInstitutionPart(names[1], style);
        }
        if (names[2]) {
          tertiary = this._renderOneInstitutionPart(names[2], style);
        }
        var institutionblob;
        if (secondary || tertiary) {
          this.state.output.openLevel("empty");
          this.state.output.append(primary);
          secondary_tok = CSL3.Util.cloneToken(style);
          if (slot.secondary) {
            secondary_tok.strings.prefix = this.state.opt.citeAffixes.institutions[slot.secondary].prefix;
            secondary_tok.strings.suffix = this.state.opt.citeAffixes.institutions[slot.secondary].suffix;
            if (!secondary_tok.strings.prefix) {
              secondary_tok.strings.prefix = " ";
            }
          }
          var secondary_outer = new CSL3.Token();
          secondary_outer.decorations.push(["@font-style", "normal"]);
          secondary_outer.decorations.push(["@font-weight", "normal"]);
          this.state.output.openLevel(secondary_outer);
          this.state.output.append(secondary, secondary_tok);
          this.state.output.closeLevel();
          tertiary_tok = CSL3.Util.cloneToken(style);
          if (slot.tertiary) {
            tertiary_tok.strings.prefix = this.state.opt.citeAffixes.institutions[slot.tertiary].prefix;
            tertiary_tok.strings.suffix = this.state.opt.citeAffixes.institutions[slot.tertiary].suffix;
            if (!tertiary_tok.strings.prefix) {
              tertiary_tok.strings.prefix = " ";
            }
          }
          var tertiary_outer = new CSL3.Token();
          tertiary_outer.decorations.push(["@font-style", "normal"]);
          tertiary_outer.decorations.push(["@font-weight", "normal"]);
          this.state.output.openLevel(tertiary_outer);
          this.state.output.append(tertiary, tertiary_tok);
          this.state.output.closeLevel();
          this.state.output.closeLevel();
          institutionblob = this.state.output.pop();
        } else {
          institutionblob = primary;
        }
        return institutionblob;
      };
      CSL3.NameOutput.prototype._renderOneInstitutionPart = function(blobs, style) {
        for (var i = 0, ilen = blobs.length; i < ilen; i += 1) {
          if (blobs[i]) {
            var str = blobs[i];
            if (this.state.tmp.strip_periods) {
              str = str.replace(/\./g, "");
            } else {
              for (var j = 0, jlen = style.decorations.length; j < jlen; j += 1) {
                if ("@strip-periods" === style.decorations[j][0] && "true" === style.decorations[j][1]) {
                  str = str.replace(/\./g, "");
                  break;
                }
              }
            }
            this.state.tmp.group_context.tip.variable_success = true;
            this.state.tmp.can_substitute.replace(false, CSL3.LITERAL);
            if (str === "!here>>>") {
              blobs[i] = false;
            } else {
              this.state.output.append(str, style, true);
              blobs[i] = this.state.output.pop();
            }
          }
        }
        if ("undefined" === typeof this.institution.strings["part-separator"]) {
          this.institution.strings["part-separator"] = this.state.tmp.name_delimiter;
        }
        return this._join(blobs, this.institution.strings["part-separator"]);
      };
      CSL3.NameOutput.prototype._renderNames = function(v, values, pos, j) {
        var ret = false;
        if (values.length) {
          var names = [];
          for (var i = 0, ilen = values.length; i < ilen; i += 1) {
            var name = values[i];
            var ret, localesets;
            if (this.state.tmp.extension) {
              localesets = ["sort"];
            } else if (name.isInstitution || name.literal) {
              localesets = this.state.opt["cite-lang-prefs"].institutions;
            } else {
              localesets = this.state.opt["cite-lang-prefs"].persons;
            }
            var slot = { primary: "locale-orig", secondary: false, tertiary: false };
            if (localesets) {
              var slotnames = ["primary", "secondary", "tertiary"];
              for (var k = 0, klen = slotnames.length; k < klen; k += 1) {
                if (localesets.length - 1 < k) {
                  break;
                }
                slot[slotnames[k]] = "locale-" + localesets[k];
              }
            } else {
              slot.primary = "locale-translat";
            }
            if (this.state.tmp.sort_key_flag || this.state.tmp.area !== "bibliography" && !(this.state.tmp.area === "citation" && this.state.opt.xclass === "note" && this.item && !this.item.position)) {
              slot.secondary = false;
              slot.tertiary = false;
            }
            this.setRenderedName(name);
            if (!name.literal && !name.isInstitution) {
              var nameBlob = this._renderPersonalName(v, name, slot, pos, i, j);
              var nameToken = CSL3.Util.cloneToken(this.name);
              this.state.output.append(nameBlob, nameToken, true);
              names.push(this.state.output.pop());
            } else {
              names.push(this._renderInstitutionName(v, name, slot, j));
            }
          }
          ret = this.joinPersons(names, pos, j);
        }
        return ret;
      };
      CSL3.NameOutput.prototype._renderPersonalName = function(v, name, slot, pos, i, j) {
        var res = this.getName(name, slot.primary, true);
        var primary = this._renderOnePersonalName(res.name, pos, i, j);
        var secondary = false;
        if (slot.secondary) {
          res = this.getName(name, slot.secondary, false, res.usedOrig);
          if (res.name) {
            secondary = this._renderOnePersonalName(res.name, pos, i, j);
          }
        }
        var tertiary = false;
        if (slot.tertiary) {
          res = this.getName(name, slot.tertiary, false, res.usedOrig);
          if (res.name) {
            tertiary = this._renderOnePersonalName(res.name, pos, i, j);
          }
        }
        var personblob;
        if (secondary || tertiary) {
          this.state.output.openLevel("empty");
          this.state.output.append(primary);
          var secondary_tok = new CSL3.Token();
          if (slot.secondary) {
            secondary_tok.strings.prefix = this.state.opt.citeAffixes.persons[slot.secondary].prefix;
            secondary_tok.strings.suffix = this.state.opt.citeAffixes.persons[slot.secondary].suffix;
            if (!secondary_tok.strings.prefix) {
              secondary_tok.strings.prefix = " ";
            }
          }
          this.state.output.append(secondary, secondary_tok);
          var tertiary_tok = new CSL3.Token();
          if (slot.tertiary) {
            tertiary_tok.strings.prefix = this.state.opt.citeAffixes.persons[slot.tertiary].prefix;
            tertiary_tok.strings.suffix = this.state.opt.citeAffixes.persons[slot.tertiary].suffix;
            if (!tertiary_tok.strings.prefix) {
              tertiary_tok.strings.prefix = " ";
            }
          }
          this.state.output.append(tertiary, tertiary_tok);
          this.state.output.closeLevel();
          personblob = this.state.output.pop();
        } else {
          personblob = primary;
        }
        return personblob;
      };
      CSL3.NameOutput.prototype._isRomanesque = function(name) {
        var ret = 2;
        if (!name.family.replace(/\"/g, "").match(CSL3.ROMANESQUE_REGEXP)) {
          ret = 0;
        }
        if (!ret && name.given && name.given.match(CSL3.STARTSWITH_ROMANESQUE_REGEXP)) {
          ret = 1;
        }
        var top_locale;
        if (ret == 2) {
          if (name.multi && name.multi.main) {
            top_locale = name.multi.main.slice(0, 2);
          } else if (this.Item.language) {
            top_locale = this.Item.language.slice(0, 2);
          }
          if (["ja", "zh"].indexOf(top_locale) > -1) {
            ret = 1;
          }
        }
        return ret;
      };
      CSL3.NameOutput.prototype._renderOnePersonalName = function(value, pos, i, j) {
        var name = value;
        var dropping_particle = this._droppingParticle(name, pos, j);
        var family = this._familyName(name);
        var non_dropping_particle = this._nonDroppingParticle(name);
        var givenInfo = this._givenName(name, pos, i);
        var given = givenInfo.blob;
        var suffix = this._nameSuffix(name);
        if (given === false) {
          dropping_particle = false;
          suffix = false;
        }
        var sort_sep = this.state.inheritOpt(this.name, "sort-separator");
        if (!sort_sep) {
          sort_sep = "";
        }
        var suffix_sep;
        if (name["comma-suffix"]) {
          suffix_sep = ", ";
        } else {
          suffix_sep = " ";
        }
        var romanesque = this._isRomanesque(name);
        function hasJoiningPunctuation(blob2) {
          if (!blob2) {
            return false;
          } else if ("string" === typeof blob2.blobs) {
            if (["\u2019", "'", "-", " "].indexOf(blob2.blobs.slice(-1)) > -1) {
              return true;
            } else {
              return false;
            }
          } else {
            return hasJoiningPunctuation(blob2.blobs[blob2.blobs.length - 1]);
          }
        }
        var has_hyphenated_non_dropping_particle = hasJoiningPunctuation(non_dropping_particle);
        var nbspace;
        if (["fr", "ru", "cs"].indexOf(this.state.opt["default-locale"][0].slice(0, 2)) > -1) {
          nbspace = "\xA0";
        } else {
          nbspace = " ";
        }
        var blob, merged, first, second;
        if (romanesque === 0) {
          blob = this._join([non_dropping_particle, family, given], "");
        } else if (romanesque === 1 || name["static-ordering"]) {
          merged = this._join([non_dropping_particle, family], nbspace);
          blob = this._join([merged, given], " ");
        } else if (name["reverse-ordering"]) {
          merged = this._join([non_dropping_particle, family], nbspace);
          blob = this._join([given, merged], " ");
        } else if (this.state.tmp.sort_key_flag) {
          if (this.state.opt["demote-non-dropping-particle"] === "never") {
            merged = this._join([non_dropping_particle, family], nbspace);
            merged = this._join([merged, dropping_particle], " ");
            merged = this._join([merged, given], this.state.opt.sort_sep);
            blob = this._join([merged, suffix], " ");
          } else {
            second = this._join([given, dropping_particle, non_dropping_particle], " ");
            merged = this._join([family, second], this.state.opt.sort_sep);
            blob = this._join([merged, suffix], " ");
          }
        } else if (this.state.inheritOpt(this.name, "name-as-sort-order") === "all" || this.state.inheritOpt(this.name, "name-as-sort-order") === "first" && i === 0 && (j === 0 || "undefined" === typeof j)) {
          if (["Lord", "Lady"].indexOf(name.given) > -1) {
            sort_sep = ", ";
          }
          if (["always", "display-and-sort"].indexOf(this.state.opt["demote-non-dropping-particle"]) > -1) {
            second = this._join([given, dropping_particle], name["comma-dropping-particle"] + " ");
            second = this._join([second, non_dropping_particle], " ");
            if (second && this.given) {
              second.strings.prefix = this.given.strings.prefix;
              second.strings.suffix = this.given.strings.suffix;
            }
            if (family && this.family) {
              family.strings.prefix = this.family.strings.prefix;
              family.strings.suffix = this.family.strings.suffix;
            }
            merged = this._join([family, second], sort_sep);
            blob = this._join([merged, suffix], sort_sep);
          } else {
            if (has_hyphenated_non_dropping_particle) {
              first = this._join([non_dropping_particle, family], "");
            } else {
              first = this._join([non_dropping_particle, family], nbspace);
            }
            if (first && this.family) {
              first.strings.prefix = this.family.strings.prefix;
              first.strings.suffix = this.family.strings.suffix;
            }
            second = this._join([given, dropping_particle], name["comma-dropping-particle"] + " ");
            if (second && this.given) {
              second.strings.prefix = this.given.strings.prefix;
              second.strings.suffix = this.given.strings.suffix;
            }
            merged = this._join([first, second], sort_sep);
            blob = this._join([merged, suffix], sort_sep);
          }
          blob.isInverted = true;
        } else {
          if (name["dropping-particle"] && name.family && !name["non-dropping-particle"]) {
            var dp = name["dropping-particle"];
            var apostrophes = ["'", "\u02BC", "\u2019", "-"];
            if (apostrophes.indexOf(dp.slice(-1)) > -1 && dp.slice(0, -1) !== "de") {
              family = this._join([dropping_particle, family], "");
              dropping_particle = false;
            }
          }
          if (has_hyphenated_non_dropping_particle) {
            second = this._join([non_dropping_particle, family], "");
            second = this._join([dropping_particle, second], nbspace);
          } else {
            second = this._join([dropping_particle, non_dropping_particle, family], nbspace);
          }
          second = this._join([second, suffix], suffix_sep);
          if (second && this.family) {
            second.strings.prefix = this.family.strings.prefix;
            second.strings.suffix = this.family.strings.suffix;
          }
          if (given && this.given) {
            given.strings.prefix = this.given.strings.prefix;
            given.strings.suffix = this.given.strings.suffix;
          }
          if (second.strings.prefix) {
            name["comma-dropping-particle"] = "";
          }
          var space;
          if (this.state.inheritOpt(this.name, "initialize-with") && this.state.inheritOpt(this.name, "initialize-with").match(/[\u00a0\ufeff]/) && givenInfo.initializationLevel === 1) {
            space = nbspace;
          } else {
            space = " ";
          }
          blob = this._join([given, second], name["comma-dropping-particle"] + space);
        }
        this.state.tmp.group_context.tip.variable_success = true;
        this.state.tmp.can_substitute.replace(false, CSL3.LITERAL);
        this.state.tmp.term_predecessor = true;
        this.state.tmp.name_node.children.push(blob);
        return blob;
      };
      CSL3.NameOutput.prototype._normalizeNameInput = function(value) {
        var name = {
          literal: value.literal,
          family: value.family,
          isInstitution: value.isInstitution,
          given: value.given,
          suffix: value.suffix,
          "comma-suffix": value["comma-suffix"],
          "non-dropping-particle": value["non-dropping-particle"],
          "dropping-particle": value["dropping-particle"],
          "static-ordering": value["static-ordering"],
          "static-particles": value["static-particles"],
          "reverse-ordering": value["reverse-ordering"],
          "full-form-always": value["full-form-always"],
          "parse-names": value["parse-names"],
          "comma-dropping-particle": "",
          block_initialize: value.block_initialize,
          multi: value.multi
        };
        this._parseName(name);
        return name;
      };
      CSL3.NameOutput.prototype._stripPeriods = function(tokname, str) {
        var decor_tok = this[tokname + "_decor"];
        if (str) {
          if (this.state.tmp.strip_periods) {
            str = str.replace(/\./g, "");
          } else if (decor_tok) {
            for (var i = 0, ilen = decor_tok.decorations.length; i < ilen; i += 1) {
              if ("@strip-periods" === decor_tok.decorations[i][0] && "true" === decor_tok.decorations[i][1]) {
                str = str.replace(/\./g, "");
                break;
              }
            }
          }
        }
        return str;
      };
      CSL3.NameOutput.prototype._nonDroppingParticle = function(name) {
        var ndp = name["non-dropping-particle"];
        if (ndp && this.state.tmp.sort_key_flag) {
          ndp = ndp.replace(/[\'\u2019]/, "");
        }
        var str = this._stripPeriods("family", ndp);
        if (this.state.output.append(str, this.family_decor, true)) {
          return this.state.output.pop();
        }
        return false;
      };
      CSL3.NameOutput.prototype._droppingParticle = function(name, pos, j) {
        var dp = name["dropping-particle"];
        if (dp && this.state.tmp.sort_key_flag) {
          dp = dp.replace(/[\'\u2019]/, "");
        }
        var str = this._stripPeriods("given", dp);
        if (name["dropping-particle"] && name["dropping-particle"].match(/^et.?al[^a-z]$/)) {
          if (this.state.inheritOpt(this.name, "et-al-use-last")) {
            if ("undefined" === typeof j) {
              this.etal_spec[pos].freeters = 2;
            } else {
              this.etal_spec[pos].persons = 2;
            }
          } else {
            if ("undefined" === typeof j) {
              this.etal_spec[pos].freeters = 1;
            } else {
              this.etal_spec[pos].persons = 1;
            }
          }
          name["comma-dropping-particle"] = "";
        } else if (this.state.output.append(str, this.given_decor, true)) {
          return this.state.output.pop();
        }
        return false;
      };
      CSL3.NameOutput.prototype._familyName = function(name) {
        var str = this._stripPeriods("family", name.family);
        if (this.state.output.append(str, this.family_decor, true)) {
          return this.state.output.pop();
        }
        return false;
      };
      CSL3.NameOutput.prototype._givenName = function(name, pos, i) {
        var ret;
        var formIsShort = this.state.inheritOpt(this.name, "form", "name-form", "long") !== "long";
        var initializeIsTurnedOn = this.state.inheritOpt(this.name, "initialize") !== false;
        var hasInitializeWith = "string" === typeof this.state.inheritOpt(this.name, "initialize-with") && !name.block_initialize;
        var defaultLevel;
        var useLevel;
        if (name["full-form-always"]) {
          useLevel = 2;
        } else {
          if (formIsShort) {
            defaultLevel = 0;
          } else if (hasInitializeWith) {
            defaultLevel = 1;
          } else {
            defaultLevel = 2;
          }
          var requestedLevel = this.state.tmp.disambig_settings.givens[pos][i];
          if (requestedLevel > defaultLevel) {
            useLevel = requestedLevel;
          } else {
            useLevel = defaultLevel;
          }
        }
        var gdropt = this.state.citation.opt["givenname-disambiguation-rule"];
        if (gdropt && gdropt.slice(-14) === "-with-initials") {
          hasInitializeWith = true;
        }
        if (name.family && useLevel === 1) {
          if (hasInitializeWith) {
            var initialize_with = this.state.inheritOpt(this.name, "initialize-with", false, "");
            name.given = CSL3.Util.Names.initializeWith(this.state, name.given, initialize_with, !initializeIsTurnedOn);
          } else {
            name.given = CSL3.Util.Names.unInitialize(this.state, name.given);
          }
        } else if (useLevel === 0) {
          return {
            blob: false
          };
        } else if (useLevel === 2) {
          name.given = CSL3.Util.Names.unInitialize(this.state, name.given);
        }
        var str = this._stripPeriods("given", name.given);
        var rendered = this.state.output.append(str, this.given_decor, true);
        if (rendered) {
          ret = this.state.output.pop();
          return {
            blob: ret,
            initializationLevel: useLevel
          };
        }
        return {
          blob: false
        };
      };
      CSL3.NameOutput.prototype._nameSuffix = function(name) {
        var str = name.suffix, ret;
        if (str && "string" === typeof this.state.inheritOpt(this.name, "initialize-with")) {
          str = CSL3.Util.Names.initializeWith(this.state, str, this.state.inheritOpt(this.name, "initialize-with"), true);
        }
        str = this._stripPeriods("family", str);
        var toSuffix = "";
        if (str && str.slice(-1) === ".") {
          str = str.slice(0, -1);
          toSuffix = ".";
        }
        var rendered = this.state.output.append(str, "empty", true);
        if (rendered) {
          ret = this.state.output.pop();
          ret.strings.suffix = toSuffix + ret.strings.suffix;
          return ret;
        }
        return false;
      };
      CSL3.NameOutput.prototype._getLongStyle = function(name) {
        var long_style;
        if (name["short"].length) {
          if (this.institutionpart["long-with-short"]) {
            long_style = this.institutionpart["long-with-short"];
          } else {
            long_style = this.institutionpart["long"];
          }
        } else {
          long_style = this.institutionpart["long"];
        }
        if (!long_style) {
          long_style = new CSL3.Token();
        }
        return long_style;
      };
      CSL3.NameOutput.prototype._getShortStyle = function() {
        var short_style;
        if (this.institutionpart["short"]) {
          short_style = this.institutionpart["short"];
        } else {
          short_style = new CSL3.Token();
        }
        return short_style;
      };
      CSL3.NameOutput.prototype._parseName = function(name) {
        if (!name["parse-names"] && "undefined" !== typeof name["parse-names"]) {
          return name;
        }
        if (name.family && !name.given && name.isInstitution) {
          name.literal = name.family;
          name.family = void 0;
          name.isInstitution = void 0;
        }
        var noparse;
        if (name.family && (name.family.slice(0, 1) === '"' && name.family.slice(-1) === '"') || !name["parse-names"] && "undefined" !== typeof name["parse-names"]) {
          name.family = name.family.slice(1, -1);
          noparse = true;
          name["parse-names"] = 0;
        } else {
          noparse = false;
        }
        if (this.state.opt.development_extensions.parse_names) {
          if (!name["non-dropping-particle"] && name.family && !noparse && name.given) {
            if (!name["static-particles"]) {
              CSL3.parseParticles(name, true);
            }
          }
        }
      };
      CSL3.NameOutput.prototype.getName = function(name, slotLocaleset, fallback, stopOrig) {
        if (stopOrig && slotLocaleset === "locale-orig") {
          return { name: false, usedOrig: stopOrig };
        }
        if (!name.family) {
          name.family = "";
        }
        if (!name.given) {
          name.given = "";
        }
        var name_params = {};
        name_params["static-ordering"] = this.getStaticOrder(name);
        var foundTag = true;
        var langTag;
        if (slotLocaleset !== "locale-orig") {
          foundTag = false;
          if (name.multi) {
            var langTags = this.state.opt[slotLocaleset];
            for (var i = 0, ilen = langTags.length; i < ilen; i += 1) {
              langTag = langTags[i];
              if (name.multi._key[langTag]) {
                foundTag = true;
                var isInstitution = name.isInstitution;
                name = name.multi._key[langTag];
                name.isInstitution = isInstitution;
                name_params = this.getNameParams(langTag);
                name_params.transliterated = true;
                break;
              }
            }
          }
        }
        if (!foundTag) {
          langTag = false;
          if (name.multi && name.multi.main) {
            langTag = name.multi.main;
          } else if (this.Item.language) {
            langTag = this.Item.language;
          }
          if (langTag) {
            name_params = this.getNameParams(langTag);
          }
        }
        if (!fallback && !foundTag) {
          return { name: false, usedOrig: stopOrig };
        }
        if (!name.family) {
          name.family = "";
        }
        if (!name.given) {
          name.given = "";
        }
        if (name.literal) {
          delete name.family;
          delete name.given;
        }
        name = {
          family: name.family,
          given: name.given,
          "non-dropping-particle": name["non-dropping-particle"],
          "dropping-particle": name["dropping-particle"],
          suffix: name.suffix,
          "static-ordering": name_params["static-ordering"],
          "static-particles": name["static-particles"],
          "reverse-ordering": name_params["reverse-ordering"],
          "full-form-always": name_params["full-form-always"],
          "parse-names": name["parse-names"],
          "comma-suffix": name["comma-suffix"],
          "comma-dropping-particle": name["comma-dropping-particle"],
          transliterated: name_params.transliterated,
          block_initialize: name_params["block-initialize"],
          literal: name.literal,
          isInstitution: name.isInstitution,
          multi: name.multi
        };
        if (!name.literal && (!name.given && name.family && name.isInstitution)) {
          name.literal = name.family;
        }
        if (name.literal) {
          delete name.family;
          delete name.given;
        }
        name = this._normalizeNameInput(name);
        var usedOrig;
        if (stopOrig) {
          usedOrig = stopOrig;
        } else {
          usedOrig = !foundTag;
        }
        return { name, usedOrig };
      };
      CSL3.NameOutput.prototype.getNameParams = function(langTag) {
        var ret = {};
        var langspec = CSL3.localeResolve(this.Item.language, this.state.opt["default-locale"][0]);
        var try_locale = this.state.locale[langspec.best] ? langspec.best : this.state.opt["default-locale"][0];
        var name_as_sort_order = this.state.locale[try_locale].opts["name-as-sort-order"];
        var name_as_reverse_order = this.state.locale[try_locale].opts["name-as-reverse-order"];
        var name_never_short = this.state.locale[try_locale].opts["name-never-short"];
        var field_lang_bare = langTag.split("-")[0];
        if (name_as_sort_order && name_as_sort_order[field_lang_bare]) {
          ret["static-ordering"] = true;
          ret["reverse-ordering"] = false;
        }
        if (name_as_reverse_order && name_as_reverse_order[field_lang_bare]) {
          ret["reverse-ordering"] = true;
          ret["static-ordering"] = false;
        }
        if (name_never_short && name_never_short[field_lang_bare]) {
          ret["full-form-always"] = true;
        }
        if (ret["static-ordering"]) {
          ret["block-initialize"] = true;
        }
        return ret;
      };
      CSL3.NameOutput.prototype.setRenderedName = function(name) {
        if (this.state.tmp.area === "bibliography") {
          var strname = "";
          for (var j = 0, jlen = CSL3.NAME_PARTS.length; j < jlen; j += 1) {
            if (name[CSL3.NAME_PARTS[j]]) {
              strname += name[CSL3.NAME_PARTS[j]];
            }
          }
          this.state.tmp.rendered_name.push(strname);
        }
      };
      CSL3.NameOutput.prototype.fixupInstitution = function(name, varname, listpos) {
        if (!name.literal && name.family) {
          name.literal = name.family;
          delete name.family;
        }
        var longNameStr = name.literal;
        var shortNameStr = longNameStr;
        var ret = {
          "long": longNameStr.split(/\s*\|\s*/),
          "short": shortNameStr.split(/\s*\|\s*/)
        };
        if (this.state.sys.getAbbreviation) {
          if (this.institution.strings.form === "short") {
            let jurisdiction = this.Item.jurisdiction;
            jurisdiction = this.state.transform.loadAbbreviation(jurisdiction, "institution-entire", longNameStr, this.Item.language);
            if (this.state.transform.abbrevs[jurisdiction]["institution-entire"][longNameStr]) {
              longNameStr = this.state.transform.abbrevs[jurisdiction]["institution-entire"][longNameStr];
            } else {
              jurisdiction = this.Item.jurisdiction;
              jurisdiction = this.state.transform.loadAbbreviation(jurisdiction, "institution-part", longNameStr, this.Item.language);
              if (this.state.transform.abbrevs[jurisdiction]["institution-part"][longNameStr]) {
                longNameStr = this.state.transform.abbrevs[jurisdiction]["institution-part"][longNameStr];
              }
            }
            longNameStr = this._quashChecks(jurisdiction, longNameStr);
          }
          if (["short", "short-long", "long-short"].indexOf(this.institution.strings["institution-parts"]) > -1) {
            let jurisdiction = this.Item.jurisdiction;
            jurisdiction = this.state.transform.loadAbbreviation(jurisdiction, "institution-part", shortNameStr, this.Item.language);
            if (this.state.transform.abbrevs[jurisdiction]["institution-part"][shortNameStr]) {
              shortNameStr = this.state.transform.abbrevs[jurisdiction]["institution-part"][shortNameStr];
            }
            shortNameStr = this._quashChecks(jurisdiction, shortNameStr);
            if (["short-long", "long-short"].indexOf(this.institution.strings["institution-parts"]) > -1) {
              if (shortNameStr === longNameStr) {
                shortNameStr = "";
              }
            }
          }
          ret["long"] = longNameStr.split(/\s*\|\s*/);
          ret["short"] = shortNameStr.split(/\s*\|\s*/);
          if (["short", "short-long", "long-short"].indexOf(this.institution.strings["institution-parts"]) > -1) {
            for (var j = ret["short"].length - 1; j > -1; j--) {
              let jurisdiction = this.Item.jurisdiction;
              var abbrevKey = ret["short"][j];
              jurisdiction = this.state.transform.loadAbbreviation(jurisdiction, "institution-part", abbrevKey, this.Item.language);
              if (this.state.transform.abbrevs[jurisdiction]["institution-part"][abbrevKey]) {
                ret["short"][j] = this.state.transform.abbrevs[jurisdiction]["institution-part"][abbrevKey];
              }
              if (ret["short"][j].indexOf("|") > -1) {
                let retShort = ret["short"];
                let splitShort = retShort[j].split(/\s*\|\s*/);
                ret["short"] = retShort.slice(0, j).concat(splitShort).concat(retShort.slice(j + 1));
              }
            }
          }
          if (this.state.opt.development_extensions.legacy_institution_name_ordering) {
            ret["short"].reverse();
          }
          ret["short"] = this._trimInstitution(ret["short"]);
          if (this.institution.strings["reverse-order"]) {
            ret["short"].reverse();
          }
          if (!this.state.tmp.just_looking) {
            if (this.Item.jurisdiction) {
              let jurisdiction = this.Item.jurisdiction;
              var trimmer = this.state.tmp.abbrev_trimmer;
              if (trimmer && trimmer[jurisdiction] && trimmer[jurisdiction][varname]) {
                for (var i = 0, ilen = ret["short"].length; i < ilen; i++) {
                  var frag = ret["short"][i];
                  ret["short"][i] = frag.replace(trimmer[jurisdiction][varname], "").trim();
                }
              }
            }
          }
        }
        if (this.state.opt.development_extensions.legacy_institution_name_ordering) {
          ret["long"].reverse();
        }
        ret["long"] = this._trimInstitution(ret["long"]);
        if (this.institution.strings["reverse-order"]) {
          ret["long"].reverse();
        }
        return ret;
      };
      CSL3.NameOutput.prototype.getStaticOrder = function(name, refresh) {
        var static_ordering_val = false;
        if (!refresh && name["static-ordering"]) {
          static_ordering_val = true;
        } else if (this._isRomanesque(name) === 0) {
          static_ordering_val = true;
        } else if ((!name.multi || !name.multi.main) && this.Item.language && ["vi", "hu"].indexOf(this.Item.language) > -1) {
          static_ordering_val = true;
        } else if (name.multi && name.multi.main && ["vi", "hu"].indexOf(name.multi.main.slice(0, 2)) > -1) {
          static_ordering_val = true;
        } else {
          if (this.state.opt["auto-vietnamese-names"] && (CSL3.VIETNAMESE_NAMES.exec(name.family + " " + name.given) && CSL3.VIETNAMESE_SPECIALS.exec(name.family + name.given))) {
            static_ordering_val = true;
          }
        }
        return static_ordering_val;
      };
      CSL3.NameOutput.prototype._quashChecks = function(jurisdiction, str) {
        var str = this.state.transform.quashCheck(jurisdiction, str);
        var lst = str.split(/>>[0-9]{4}>>/);
        var m = str.match(/>>([0-9]{4})>>/);
        str = lst.pop();
        var date = this.Item["original-date"] ? this.Item["original-date"] : this.Item["issued"];
        if (date) {
          date = parseInt(date.year, 10);
          date = isNaN(date) ? false : date;
        }
        if (date) {
          if (lst.length > 0) {
            for (var k = m.length - 1; k > 0; k--) {
              if (date >= parseInt(m[k], 10)) {
                break;
              }
              str = lst.pop();
            }
          }
          str = str.replace(/\s*\|\s*/g, "|");
        }
        return str;
      };
      CSL3.NameOutput.prototype._trimInstitution = function(subunits) {
        var use_first = false;
        var stop_last = false;
        var use_last = false;
        var stop_first = false;
        var s = subunits.slice();
        if (this.institution) {
          if ("undefined" !== typeof this.institution.strings["use-first"]) {
            use_first = this.institution.strings["use-first"];
          }
          if ("undefined" !== typeof this.institution.strings["use-last"]) {
            use_last = this.institution.strings["use-last"];
          }
          if ("undefined" !== typeof this.institution.strings["stop-first"]) {
            stop_first = this.institution.strings["stop-first"];
          }
          if ("undefined" !== typeof this.institution.strings["stop-last"]) {
            stop_last = this.institution.strings["stop-last"];
          }
          if (use_first) {
            if (stop_last) {
              s = s.slice(0, stop_last * -1);
            }
            s = s.slice(0, use_first);
          }
          if (use_last) {
            var ss = subunits.slice();
            if (use_first) {
              stop_first = use_first;
            } else {
              s = [];
            }
            if (stop_first) {
              ss = ss.slice(stop_first);
            }
            ss = ss.slice(use_last * -1);
            s = s.concat(ss);
          }
          subunits = s;
        }
        return subunits;
      };
      CSL3.PublisherOutput = function(state, group_tok) {
        this.state = state;
        this.group_tok = group_tok;
        this.varlist = [];
      };
      CSL3.PublisherOutput.prototype.render = function() {
        this.clearVars();
        this.composeAndBlob();
        this.composeElements();
        this.composePublishers();
        this.joinPublishers();
      };
      CSL3.PublisherOutput.prototype.composeAndBlob = function() {
        this.and_blob = {};
        var and_term = false;
        if (this.group_tok.strings.and === "text") {
          and_term = this.state.getTerm("and");
        } else if (this.group_tok.strings.and === "symbol") {
          and_term = "&";
        }
        var tok = new CSL3.Token();
        tok.strings.suffix = " ";
        tok.strings.prefix = " ";
        this.state.output.append(and_term, tok, true);
        var no_delim = this.state.output.pop();
        tok.strings.prefix = this.group_tok.strings["subgroup-delimiter"];
        this.state.output.append(and_term, tok, true);
        var with_delim = this.state.output.pop();
        this.and_blob.single = false;
        this.and_blob.multiple = false;
        if (and_term) {
          if (this.group_tok.strings["subgroup-delimiter-precedes-last"] === "always") {
            this.and_blob.single = with_delim;
          } else if (this.group_tok.strings["subgroup-delimiter-precedes-last"] === "never") {
            this.and_blob.single = no_delim;
            this.and_blob.multiple = no_delim;
          } else {
            this.and_blob.single = no_delim;
            this.and_blob.multiple = with_delim;
          }
        }
      };
      CSL3.PublisherOutput.prototype.composeElements = function() {
        for (var i = 0, ilen = 2; i < ilen; i += 1) {
          var varname = ["publisher", "publisher-place"][i];
          for (var j = 0, jlen = this["publisher-list"].length; j < jlen; j += 1) {
            var str = this[varname + "-list"][j];
            var tok = this[varname + "-token"];
            this.state.output.append(str, tok, true);
            this[varname + "-list"][j] = this.state.output.pop();
          }
        }
      };
      CSL3.PublisherOutput.prototype.composePublishers = function() {
        var blobs;
        for (var i = 0, ilen = this["publisher-list"].length; i < ilen; i += 1) {
          blobs = [this[this.varlist[0] + "-list"][i], this[this.varlist[1] + "-list"][i]];
          this["publisher-list"][i] = this._join(blobs, this.group_tok.strings.delimiter);
        }
      };
      CSL3.PublisherOutput.prototype.joinPublishers = function() {
        var blobs = this["publisher-list"];
        var publishers = this._join(blobs, this.group_tok.strings["subgroup-delimiter"], this.and_blob.single, this.and_blob.multiple, this.group_tok);
        this.state.output.append(publishers, "literal");
      };
      CSL3.PublisherOutput.prototype._join = CSL3.NameOutput.prototype._join;
      CSL3.PublisherOutput.prototype._getToken = CSL3.NameOutput.prototype._getToken;
      CSL3.PublisherOutput.prototype.clearVars = function() {
        this.state.tmp["publisher-list"] = false;
        this.state.tmp["publisher-place-list"] = false;
        this.state.tmp["publisher-group-token"] = false;
        this.state.tmp["publisher-token"] = false;
        this.state.tmp["publisher-place-token"] = false;
      };
      CSL3.evaluateLabel = function(node, state, Item, item) {
        var myterm;
        if ("locator" === node.strings.term) {
          if (item && item.label) {
            if (item.label === "sub verbo") {
              myterm = "sub-verbo";
            } else {
              myterm = item.label;
            }
          }
          if (!myterm) {
            myterm = "page";
          }
        } else {
          myterm = node.strings.term;
        }
        var plural = node.strings.plural;
        if ("number" !== typeof plural) {
          var theItem = item && node.strings.term === "locator" ? item : Item;
          if (theItem[node.strings.term]) {
            state.processNumber(false, theItem, node.strings.term, Item.type);
            plural = state.tmp.shadow_numbers[node.strings.term].plural;
            if (!state.tmp.shadow_numbers[node.strings.term].labelForm && !state.tmp.shadow_numbers[node.strings.term].labelDecorations) {
              if (node.strings.form) {
                state.tmp.shadow_numbers[node.strings.term].labelForm = node.strings.form;
              } else if (state.tmp.group_context.tip.label_form) {
                state.tmp.shadow_numbers[node.strings.term].labelForm = state.tmp.group_context.tip.label_form;
              }
              state.tmp.shadow_numbers[node.strings.term].labelCapitalizeIfFirst = node.strings.capitalize_if_first;
              state.tmp.shadow_numbers[node.strings.term].labelDecorations = node.decorations.slice();
            }
            if (["locator", "number", "page"].indexOf(node.strings.term) > -1 && state.tmp.shadow_numbers[node.strings.term].label) {
              myterm = state.tmp.shadow_numbers[node.strings.term].label;
            }
            if (node.decorations && state.opt.development_extensions.csl_reverse_lookup_support) {
              node.decorations.reverse();
              node.decorations.push(["@showid", "true", node.cslid]);
              node.decorations.reverse();
            }
          }
        }
        return CSL3.castLabel(state, node, myterm, plural, CSL3.TOLERANT);
      };
      CSL3.castLabel = function(state, node, term, plural, mode) {
        var label_form = node.strings.form;
        var label_capitalize_if_first = node.strings.capitalize_if_first;
        if (state.tmp.group_context.tip.label_form) {
          if (label_form === "static") {
            state.tmp.group_context.tip.label_static = true;
          } else {
            label_form = state.tmp.group_context.tip.label_form;
          }
        }
        if (state.tmp.group_context.tip.label_capitalize_if_first) {
          label_capitalize_if_first = state.tmp.group_context.tip.label_capitalize_if_first;
        }
        var ret = state.getTerm(term, label_form, plural, false, mode, node.default_locale);
        if (label_capitalize_if_first) {
          ret = CSL3.Output.Formatters["capitalize-first"](state, ret);
        }
        if (state.tmp.strip_periods) {
          ret = ret.replace(/\./g, "");
        } else {
          for (var i = 0, ilen = node.decorations.length; i < ilen; i += 1) {
            if ("@strip-periods" === node.decorations[i][0] && "true" === node.decorations[i][1]) {
              ret = ret.replace(/\./g, "");
              break;
            }
          }
        }
        return ret;
      };
      CSL3.Node.name = {
        build: function(state, target) {
          var func;
          if ([CSL3.SINGLETON, CSL3.START].indexOf(this.tokentype) > -1) {
            var oldTmpRoot;
            if ("undefined" === typeof state.tmp.root) {
              oldTmpRoot = void 0;
              state.tmp.root = "citation";
            } else {
              oldTmpRoot = state.tmp.root;
            }
            if (state.inheritOpt(this, "et-al-subsequent-min") && state.inheritOpt(this, "et-al-subsequent-min") !== state.inheritOpt(this, "et-al-min")) {
              state.opt.update_mode = CSL3.POSITION;
            }
            if (state.inheritOpt(this, "et-al-subsequent-use-first") && state.inheritOpt(this, "et-al-subsequent-use-first") !== state.inheritOpt(this, "et-al-use-first")) {
              state.opt.update_mode = CSL3.POSITION;
            }
            state.tmp.root = oldTmpRoot;
            func = function(state2) {
              state2.tmp.etal_term = "et-al";
              state2.tmp.name_delimiter = state2.inheritOpt(this, "delimiter", "name-delimiter", ", ");
              state2.tmp["delimiter-precedes-et-al"] = state2.inheritOpt(this, "delimiter-precedes-et-al");
              if ("text" === state2.inheritOpt(this, "and")) {
                this.and_term = state2.getTerm("and", "long", 0);
              } else if ("symbol" === state2.inheritOpt(this, "and")) {
                if (state2.opt.development_extensions.expect_and_symbol_form) {
                  this.and_term = state2.getTerm("and", "symbol", 0);
                } else {
                  this.and_term = "&";
                }
              }
              state2.tmp.and_term = this.and_term;
              if (CSL3.STARTSWITH_ROMANESQUE_REGEXP.test(this.and_term)) {
                this.and_prefix_single = " ";
                this.and_prefix_multiple = ", ";
                if ("string" === typeof state2.tmp.name_delimiter) {
                  this.and_prefix_multiple = state2.tmp.name_delimiter;
                }
                this.and_suffix = " ";
              } else {
                this.and_prefix_single = "";
                this.and_prefix_multiple = "";
                this.and_suffix = "";
              }
              if (state2.inheritOpt(this, "delimiter-precedes-last") === "always") {
                this.and_prefix_single = state2.tmp.name_delimiter;
              } else if (state2.inheritOpt(this, "delimiter-precedes-last") === "never") {
                if (this.and_prefix_multiple) {
                  this.and_prefix_multiple = " ";
                }
              } else if (state2.inheritOpt(this, "delimiter-precedes-last") === "after-inverted-name") {
                if (this.and_prefix_single) {
                  this.and_prefix_single = state2.tmp.name_delimiter;
                }
                if (this.and_prefix_multiple) {
                  this.and_prefix_multiple = " ";
                }
              }
              this.and = {};
              if (state2.inheritOpt(this, "and")) {
                state2.output.append(this.and_term, "empty", true);
                this.and.single = state2.output.pop();
                this.and.single.strings.prefix = this.and_prefix_single;
                this.and.single.strings.suffix = this.and_suffix;
                state2.output.append(this.and_term, "empty", true);
                this.and.multiple = state2.output.pop();
                this.and.multiple.strings.prefix = this.and_prefix_multiple;
                this.and.multiple.strings.suffix = this.and_suffix;
              } else if (state2.tmp.name_delimiter) {
                this.and.single = new CSL3.Blob(state2.tmp.name_delimiter);
                this.and.single.strings.prefix = "";
                this.and.single.strings.suffix = "";
                this.and.multiple = new CSL3.Blob(state2.tmp.name_delimiter);
                this.and.multiple.strings.prefix = "";
                this.and.multiple.strings.suffix = "";
              }
              this.ellipsis = {};
              if (state2.inheritOpt(this, "et-al-use-last")) {
                this.ellipsis_term = "\u2026";
                this.ellipsis_prefix_single = " ";
                this.ellipsis_prefix_multiple = state2.inheritOpt(this, "delimiter", "name-delimiter", ", ");
                this.ellipsis_suffix = " ";
                this.ellipsis.single = new CSL3.Blob(this.ellipsis_term);
                this.ellipsis.single.strings.prefix = this.ellipsis_prefix_single;
                this.ellipsis.single.strings.suffix = this.ellipsis_suffix;
                this.ellipsis.multiple = new CSL3.Blob(this.ellipsis_term);
                this.ellipsis.multiple.strings.prefix = this.ellipsis_prefix_multiple;
                this.ellipsis.multiple.strings.suffix = this.ellipsis_suffix;
              }
              if ("undefined" === typeof state2.tmp["et-al-min"]) {
                state2.tmp["et-al-min"] = state2.inheritOpt(this, "et-al-min");
              }
              if ("undefined" === typeof state2.tmp["et-al-use-first"]) {
                state2.tmp["et-al-use-first"] = state2.inheritOpt(this, "et-al-use-first");
              }
              if ("undefined" === typeof state2.tmp["et-al-use-last"]) {
                state2.tmp["et-al-use-last"] = state2.inheritOpt(this, "et-al-use-last");
              }
              state2.nameOutput.name = this;
            };
            state.build.name_flag = true;
            this.execs.push(func);
          }
          target.push(this);
        }
      };
      CSL3.Node["name-part"] = {
        build: function(state) {
          state.build[this.strings.name] = this;
        }
      };
      CSL3.Node.names = {
        build: function(state, target) {
          var func;
          if (this.tokentype === CSL3.START || this.tokentype === CSL3.SINGLETON) {
            CSL3.Util.substituteStart.call(this, state, target);
            state.build.substitute_level.push(1);
          }
          if (this.tokentype === CSL3.SINGLETON) {
            state.build.names_variables[state.build.names_variables.length - 1].concat(this.variables);
            for (var i in this.variables) {
              var variable = this.variables[i];
              var name_labels = state.build.name_label[state.build.name_label.length - 1];
              if (Object.keys(name_labels).length) {
                name_labels[variable] = name_labels[Object.keys(name_labels)[0]];
              }
            }
            func = function(state2) {
              state2.nameOutput.reinit(this, this.variables_real[0]);
            };
            this.execs.push(func);
          }
          if (this.tokentype === CSL3.START) {
            state.build.names_flag = true;
            state.build.name_flag = false;
            state.build.names_level += 1;
            state.build.names_variables.push(this.variables);
            state.build.name_label.push({});
            func = function(state2) {
              state2.tmp.can_substitute.push(true);
              state2.tmp.name_node = {};
              state2.tmp.name_node.children = [];
              state2.nameOutput.init(this);
            };
            this.execs.push(func);
          }
          if (this.tokentype === CSL3.END) {
            for (var i = 0, ilen = 3; i < ilen; i += 1) {
              var key = ["family", "given", "et-al"][i];
              this[key] = state.build[key];
              if (state.build.names_level === 1) {
                state.build[key] = void 0;
              }
            }
            this.label = state.build.name_label[state.build.name_label.length - 1];
            state.build.names_level += -1;
            state.build.names_variables.pop();
            state.build.name_label.pop();
            func = function(state2) {
              if (state2.tmp.etal_node) {
                this.etal_style = state2.tmp.etal_node;
              } else {
                this.etal_style = "empty";
              }
              this.etal_term = state2.getTerm(state2.tmp.etal_term, "long", 0);
              this.etal_prefix_single = " ";
              this.etal_prefix_multiple = state2.tmp.name_delimiter;
              if (state2.tmp["delimiter-precedes-et-al"] === "always") {
                this.etal_prefix_single = state2.tmp.name_delimiter;
              } else if (state2.tmp["delimiter-precedes-et-al"] === "never") {
                this.etal_prefix_multiple = " ";
              } else if (state2.tmp["delimiter-precedes-et-al"] === "after-inverted-name") {
                this.etal_prefix_single = state2.tmp.name_delimiter;
                this.etal_prefix_multiple = " ";
              }
              this.etal_suffix = "";
              if (!CSL3.STARTSWITH_ROMANESQUE_REGEXP.test(this.etal_term)) {
                if (this.etal_prefix_single === " ") {
                  this.etal_prefix_single = "";
                }
                if (this.etal_prefix_multiple === " ") {
                  this.etal_prefix_multiple = "";
                }
                if (this.etal_suffix === " ") {
                  this.etal_suffix = "";
                }
              }
              for (var i2 = 0, ilen2 = 3; i2 < ilen2; i2 += 1) {
                var key2 = ["family", "given"][i2];
                state2.nameOutput[key2] = this[key2];
              }
              state2.nameOutput["with"] = this["with"];
              var mywith = "with";
              var with_default_prefix = "";
              var with_suffix = "";
              if (CSL3.STARTSWITH_ROMANESQUE_REGEXP.test(mywith)) {
                with_default_prefix = " ";
                with_suffix = " ";
              }
              var thewith = {};
              thewith.single = new CSL3.Blob(mywith);
              thewith.single.strings.suffix = with_suffix;
              thewith.multiple = new CSL3.Blob(mywith);
              thewith.multiple.strings.suffix = with_suffix;
              if (state2.inheritOpt(state2.nameOutput.name, "delimiter-precedes-last") === "always") {
                thewith.single.strings.prefix = state2.inheritOpt(this, "delimiter", "names-delimiter");
                thewith.multiple.strings.prefix = state2.inheritOpt(this, "delimiter", "names-delimiter");
              } else if (state2.inheritOpt(state2.nameOutput.name, "delimiter-precedes-last") === "contextual") {
                thewith.single.strings.prefix = with_default_prefix;
                thewith.multiple.strings.prefix = state2.inheritOpt(this, "delimiter", "names-delimiter");
              } else if (state2.inheritOpt(state2.nameOutput.name, "delimiter-precedes-last") === "after-inverted-name") {
                thewith.single.strings.prefix = state2.inheritOpt(this, "delimiter", "names-delimiter");
                thewith.multiple.strings.prefix = with_default_prefix;
              } else {
                thewith.single.strings.prefix = with_default_prefix;
                thewith.multiple.strings.prefix = with_default_prefix;
              }
              state2.nameOutput["with"] = thewith;
              state2.nameOutput.label = this.label;
              state2.nameOutput.etal_style = this.etal_style;
              state2.nameOutput.etal_term = this.etal_term;
              state2.nameOutput.etal_prefix_single = this.etal_prefix_single;
              state2.nameOutput.etal_prefix_multiple = this.etal_prefix_multiple;
              state2.nameOutput.etal_suffix = this.etal_suffix;
              state2.nameOutput.outputNames();
              state2.tmp["et-al-use-first"] = void 0;
              state2.tmp["et-al-min"] = void 0;
              state2.tmp["et-al-use-last"] = void 0;
            };
            this.execs.push(func);
            func = function(state2) {
              if (!state2.tmp.can_substitute.pop()) {
                state2.tmp.can_substitute.replace(false, CSL3.LITERAL);
              }
              if (state2.tmp.can_substitute.mystack.length === 1) {
                state2.tmp.can_block_substitute = false;
              }
            };
            this.execs.push(func);
            state.build.name_flag = false;
          }
          target.push(this);
          if (this.tokentype === CSL3.END || this.tokentype === CSL3.SINGLETON) {
            state.build.substitute_level.pop();
            CSL3.Util.substituteEnd.call(this, state, target);
          }
        }
      };
      CSL3.Node.number = {
        build: function(state, target) {
          var func;
          CSL3.Util.substituteStart.call(this, state, target);
          if (this.strings.form === "roman") {
            this.formatter = state.fun.romanizer;
          } else if (this.strings.form === "ordinal") {
            this.formatter = state.fun.ordinalizer;
          } else if (this.strings.form === "long-ordinal") {
            this.formatter = state.fun.long_ordinalizer;
          }
          if ("undefined" === typeof this.successor_prefix) {
            this.successor_prefix = state[state.build.area].opt.layout_delimiter;
          }
          if ("undefined" === typeof this.splice_prefix) {
            this.splice_prefix = state[state.build.area].opt.layout_delimiter;
          }
          func = function(state2, Item, item) {
            if (this.variables.length === 0) {
              return;
            }
            var varname;
            varname = this.variables[0];
            if ("undefined" === typeof item) {
              var item = {};
            }
            if (["locator", "locator-extra"].indexOf(varname) > -1) {
              if (state2.tmp.just_looking) {
                return;
              }
              if (!item[varname]) {
                return;
              }
            } else {
              if (!Item[varname]) {
                return;
              }
            }
            if (varname === "collection-number" && Item.type === "legal_case") {
              state2.tmp.renders_collection_number = true;
            }
            var node = this;
            if (state2.tmp.group_context.tip.force_suppress) {
              return false;
            }
            if (["locator", "locator-extra"].indexOf(varname) > -1) {
              state2.processNumber.call(state2, node, item, varname, Item.type);
            } else {
              if (!state2.tmp.group_context.tip.condition && Item[varname]) {
                state2.tmp.just_did_number = ("" + Item[varname]).match(/[0-9]$/);
              }
              state2.processNumber.call(state2, node, Item, varname, Item.type);
            }
            if (this.substring) {
              var val = Item[varname].slice(this.substring);
              state2.output.append(val, node);
            } else {
              CSL3.Util.outputNumericField(state2, varname, Item.id);
            }
            if (["locator", "locator-extra"].indexOf(this.variables_real[0]) > -1 && !state2.tmp.just_looking) {
              state2.tmp.done_vars.push(this.variables_real[0]);
              state2.tmp.group_context.tip.done_vars.push(this.variables_real[0]);
            }
          };
          this.execs.push(func);
          target.push(this);
          CSL3.Util.substituteEnd.call(this, state, target);
        }
      };
      CSL3.Node.sort = {
        build: function(state, target) {
          target = state[state.build.root + "_sort"].tokens;
          if (this.tokentype === CSL3.START) {
            if (state.build.area === "citation") {
              state.opt.sort_citations = true;
            }
            state.build.area = state.build.root + "_sort";
            state.build.extension = "_sort";
            var func = function(state2, Item) {
              if (state2.opt.has_layout_locale) {
                var langspec = CSL3.localeResolve(Item.language, state2.opt["default-locale"][0]);
                var sort_locales = state2[state2.tmp.area.slice(0, -5)].opt.sort_locales;
                var langForItem;
                for (var i = 0, ilen = sort_locales.length; i < ilen; i += 1) {
                  langForItem = sort_locales[i][langspec.bare];
                  if (!langForItem) {
                    langForItem = sort_locales[i][langspec.best];
                  }
                  if (langForItem) {
                    break;
                  }
                }
                if (!langForItem) {
                  langForItem = state2.opt["default-locale"][0];
                }
                state2.tmp.lang_sort_hold = state2.opt.lang;
                state2.opt.lang = langForItem;
              }
            };
            this.execs.push(func);
          }
          if (this.tokentype === CSL3.END) {
            state.build.area = state.build.root;
            state.build.extension = "";
            var func = function(state2) {
              if (state2.opt.has_layout_locale) {
                state2.opt.lang = state2.tmp.lang_sort_hold;
                delete state2.tmp.lang_sort_hold;
              }
            };
            this.execs.push(func);
          }
          target.push(this);
        }
      };
      CSL3.Node.substitute = {
        build: function(state, target) {
          var func;
          if (this.tokentype === CSL3.START) {
            var choose_start = new CSL3.Token("choose", CSL3.START);
            CSL3.Node.choose.build.call(choose_start, state, target);
            var if_singleton = new CSL3.Token("if", CSL3.SINGLETON);
            func = function() {
              if (state.tmp.value.length && !state.tmp.common_term_match_fail) {
                return true;
              }
              return false;
            };
            if_singleton.tests = [func];
            if_singleton.test = state.fun.match.any(if_singleton, state, if_singleton.tests);
            target.push(if_singleton);
            func = function(state2) {
              state2.tmp.can_block_substitute = true;
              if (state2.tmp.value.length && !state2.tmp.common_term_match_fail) {
                state2.tmp.can_substitute.replace(false, CSL3.LITERAL);
              }
              state2.tmp.common_term_match_fail = false;
            };
            this.execs.push(func);
            target.push(this);
          }
          if (this.tokentype === CSL3.END) {
            target.push(this);
            var choose_end = new CSL3.Token("choose", CSL3.END);
            CSL3.Node.choose.build.call(choose_end, state, target);
          }
        }
      };
      CSL3.Node.text = {
        build: function(state, target) {
          var func, form, plural, id, num, number, formatter, firstoutput, specialdelimiter, label, suffix, term;
          if (this.postponed_macro) {
            var group_start = CSL3.Util.cloneToken(this);
            group_start.name = "group";
            group_start.tokentype = CSL3.START;
            CSL3.Node.group.build.call(group_start, state, target);
            CSL3.expandMacro.call(state, this, target);
            var group_end = CSL3.Util.cloneToken(this);
            group_end.name = "group";
            group_end.tokentype = CSL3.END;
            if (this.postponed_macro === "juris-locator-label") {
              group_end.isJurisLocatorLabel = true;
            }
            CSL3.Node.group.build.call(group_end, state, target);
          } else {
            CSL3.Util.substituteStart.call(this, state, target);
            if (!this.variables_real) {
              this.variables_real = [];
            }
            if (!this.variables) {
              this.variables = [];
            }
            form = "long";
            plural = 0;
            if (this.strings.form) {
              form = this.strings.form;
            }
            if (this.strings.plural) {
              plural = this.strings.plural;
            }
            if ("citation-number" === this.variables_real[0] || "year-suffix" === this.variables_real[0] || "citation-label" === this.variables_real[0]) {
              if (this.variables_real[0] === "citation-number") {
                if (state.build.root === "citation") {
                  state.opt.update_mode = CSL3.NUMERIC;
                }
                if (state.build.root === "bibliography") {
                  state.opt.bib_mode = CSL3.NUMERIC;
                }
                if ("citation-number" === state[state.tmp.area].opt.collapse) {
                  this.range_prefix = state.getTerm("citation-range-delimiter");
                }
                this.successor_prefix = state[state.build.area].opt.layout_delimiter;
                this.splice_prefix = state[state.build.area].opt.layout_delimiter;
                func = function(state2, Item, item) {
                  id = "" + Item.id;
                  if (!state2.tmp.just_looking) {
                    if (state2.tmp.area.slice(-5) === "_sort" && this.variables[0] === "citation-number") {
                      if (state2.tmp.area === "bibliography_sort") {
                        state2.tmp.group_context.tip.done_vars.push("citation-number");
                      }
                      if (state2.tmp.area === "citation_sort" && state2.bibliography_sort.tmp.citation_number_map) {
                        var num2 = state2.bibliography_sort.tmp.citation_number_map[state2.registry.registry[Item.id].seq];
                      } else {
                        var num2 = state2.registry.registry[Item.id].seq;
                      }
                      if (num2) {
                        num2 = CSL3.Util.padding("" + num2);
                      }
                      state2.output.append(num2, this);
                      return;
                    }
                    if (item && item["author-only"]) {
                      state2.tmp.element_trace.replace("suppress-me");
                    }
                    if (state2.tmp.area !== "bibliography_sort" && state2.bibliography_sort.tmp.citation_number_map && state2.bibliography_sort.opt.citation_number_sort_direction === CSL3.DESCENDING) {
                      num2 = state2.bibliography_sort.tmp.citation_number_map[state2.registry.registry[id].seq];
                    } else {
                      num2 = state2.registry.registry[id].seq;
                    }
                    if (state2.opt.citation_number_slug) {
                      state2.output.append(state2.opt.citation_number_slug, this);
                    } else {
                      number = new CSL3.NumericBlob(state2, false, num2, this, Item.id);
                      if (state2.tmp.in_cite_predecessor) {
                        number.suppress_splice_prefix = true;
                      }
                      state2.output.append(number, "literal");
                    }
                  }
                };
                this.execs.push(func);
              } else if (this.variables_real[0] === "year-suffix") {
                state.opt.has_year_suffix = true;
                if (state[state.tmp.area].opt.collapse === "year-suffix-ranged") {
                  this.range_prefix = state.getTerm("citation-range-delimiter");
                }
                this.successor_prefix = state[state.build.area].opt.layout_delimiter;
                if (state[state.tmp.area].opt["year-suffix-delimiter"]) {
                  this.successor_prefix = state[state.build.area].opt["year-suffix-delimiter"];
                }
                func = function(state2, Item) {
                  if (state2.registry.registry[Item.id] && state2.registry.registry[Item.id].disambig.year_suffix !== false && !state2.tmp.just_looking) {
                    num = parseInt(state2.registry.registry[Item.id].disambig.year_suffix, 10);
                    if (state2[state2.tmp.area].opt.cite_group_delimiter) {
                      this.successor_prefix = state2[state2.tmp.area].opt.cite_group_delimiter;
                    }
                    number = new CSL3.NumericBlob(state2, false, num, this, Item.id);
                    formatter = new CSL3.Util.Suffixator(CSL3.SUFFIX_CHARS);
                    number.setFormatter(formatter);
                    state2.output.append(number, "literal");
                    firstoutput = false;
                    for (var i = 0, ilen = state2.tmp.group_context.mystack.length; i < ilen; i++) {
                      var flags = state2.tmp.group_context.mystack[i];
                      if (!flags.variable_success && (flags.variable_attempt || !flags.variable_attempt && !flags.term_intended)) {
                        firstoutput = true;
                        break;
                      }
                    }
                    specialdelimiter = state2[state2.tmp.area].opt["year-suffix-delimiter"];
                    if (firstoutput && specialdelimiter && !state2.tmp.sort_key_flag) {
                      state2.tmp.splice_delimiter = state2[state2.tmp.area].opt["year-suffix-delimiter"];
                    }
                  }
                };
                this.execs.push(func);
              } else if (this.variables_real[0] === "citation-label") {
                if (state.build.root === "bibliography") {
                  state.opt.bib_mode = CSL3.TRIGRAPH;
                }
                state.opt.has_year_suffix = true;
                func = function(state2, Item) {
                  label = Item["citation-label"];
                  if (!label) {
                    label = state2.getCitationLabel(Item);
                  }
                  if (!state2.tmp.just_looking) {
                    suffix = "";
                    if (state2.registry.registry[Item.id] && state2.registry.registry[Item.id].disambig.year_suffix !== false) {
                      num = parseInt(state2.registry.registry[Item.id].disambig.year_suffix, 10);
                      suffix = state2.fun.suffixator.format(num);
                    }
                    label += suffix;
                  }
                  state2.output.append(label, this);
                };
                this.execs.push(func);
              }
            } else {
              if (this.strings.term) {
                func = function(state2, Item) {
                  var gender = state2.opt.gender[Item.type];
                  var term2 = this.strings.term;
                  term2 = state2.getTerm(term2, form, plural, gender, CSL3.TOLERANT, this.default_locale);
                  var myterm;
                  if (term2 !== "") {
                    state2.tmp.group_context.tip.term_intended = true;
                  }
                  CSL3.UPDATE_GROUP_CONTEXT_CONDITION(state2, term2, null, this);
                  if (!state2.tmp.term_predecessor && !(state2.opt["class"] === "in-text" && state2.tmp.area === "citation")) {
                    myterm = CSL3.Output.Formatters["capitalize-first"](state2, term2);
                  } else {
                    myterm = term2;
                  }
                  if (state2.tmp.strip_periods) {
                    myterm = myterm.replace(/\./g, "");
                  } else {
                    for (var i = 0, ilen = this.decorations.length; i < ilen; i += 1) {
                      if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
                        myterm = myterm.replace(/\./g, "");
                        break;
                      }
                    }
                  }
                  state2.output.append(myterm, this);
                  if (state2.tmp.can_block_substitute) {
                    state2.tmp.can_substitute.replace(false, CSL3.LITERAL);
                  }
                };
                this.execs.push(func);
                state.build.term = false;
                state.build.form = false;
                state.build.plural = false;
              } else if (this.variables_real.length) {
                func = function(state2, Item) {
                  if (this.variables_real[0] !== "locator") {
                    state2.tmp.have_collapsed = false;
                  }
                  if (!state2.tmp.group_context.tip.condition && Item[this.variables[0]]) {
                    state2.tmp.just_did_number = false;
                  }
                  var val = Item[this.variables[0]];
                  if (val && !state2.tmp.group_context.tip.condition) {
                    if (("" + val).slice(-1).match(/[0-9]/)) {
                      state2.tmp.just_did_number = true;
                    } else {
                      state2.tmp.just_did_number = false;
                    }
                  }
                };
                this.execs.push(func);
                if (CSL3.MULTI_FIELDS.indexOf(this.variables_real[0]) > -1 || this.variables_real[0].indexOf("-main") > -1 || this.variables_real[0].indexOf("-sub") > -1 || ["language-name", "language-name-original"].indexOf(this.variables_real[0]) > -1) {
                  var abbrevfam = this.variables[0];
                  var abbrfall = false;
                  var altvar = false;
                  var transfall = false;
                  if (form === "short") {
                    if (this.variables_real[0].slice(-6) !== "-short") {
                      altvar = this.variables_real[0] + "-short";
                    }
                  } else {
                    abbrevfam = false;
                  }
                  if (state.build.extension) {
                    transfall = true;
                  } else {
                    transfall = true;
                    abbrfall = true;
                  }
                  func = state.transform.getOutputFunction(this.variables, abbrevfam, abbrfall, altvar, transfall);
                } else {
                  if (CSL3.CITE_FIELDS.indexOf(this.variables_real[0]) > -1) {
                    func = function(state2, Item, item) {
                      if (item && item[this.variables[0]]) {
                        state2.processNumber(this, item, this.variables[0], Item.type);
                        CSL3.Util.outputNumericField(state2, this.variables[0], Item.id);
                        if (["locator", "locator-extra"].indexOf(this.variables_real[0]) > -1 && !state2.tmp.just_looking) {
                          state2.tmp.done_vars.push(this.variables_real[0]);
                        }
                      }
                    };
                  } else if (["page", "page-first", "chapter-number", "collection-number", "edition", "issue", "number", "number-of-pages", "number-of-volumes", "volume"].indexOf(this.variables_real[0]) > -1) {
                    func = function(state2, Item) {
                      state2.processNumber(this, Item, this.variables[0], Item.type);
                      CSL3.Util.outputNumericField(state2, this.variables[0], Item.id);
                    };
                  } else if (["URL", "DOI"].indexOf(this.variables_real[0]) > -1) {
                    func = function(state2, Item) {
                      var value;
                      if (this.variables[0]) {
                        value = state2.getVariable(Item, this.variables[0], form);
                        if (value) {
                          if (this.variables[0] === "URL" && form === "short") {
                            value = value.replace(/(.*\.[^\/]+)\/.*/, "$1");
                            if (value.match(/\/\/www\./)) {
                              value = value.replace(/https?:\/\//, "");
                            }
                          }
                          if (state2.opt.development_extensions.wrap_url_and_doi) {
                            if (!this.decorations.length || this.decorations[0][0] !== "@" + this.variables[0]) {
                              var clonetoken = CSL3.Util.cloneToken(this);
                              var groupblob = new CSL3.Blob(null, null, "url-wrapper");
                              groupblob.decorations.push(["@DOI", "true"]);
                              if (this.variables_real[0] === "DOI") {
                                var prefix;
                                if (this.strings.prefix && this.strings.prefix.match(/^.*https:\/\/doi\.org\/$/)) {
                                  value = value.replace(/^https?:\/\/doi\.org\//, "");
                                  if (value.match(/^https?:\/\//)) {
                                    prefix = "";
                                  } else {
                                    prefix = "https://doi.org/";
                                  }
                                  clonetoken.strings.prefix = this.strings.prefix.slice(0, clonetoken.strings.prefix.length - 16);
                                }
                                var prefixblob = new CSL3.Blob(prefix);
                                var valueblob = new CSL3.Blob(value);
                                groupblob.push(prefixblob);
                                groupblob.push(valueblob);
                                state2.output.append(groupblob, clonetoken, false, false, true);
                              } else {
                                var valueblob = new CSL3.Blob(value);
                                groupblob.push(valueblob);
                                state2.output.append(groupblob, clonetoken, false, false, true);
                              }
                            } else {
                              state2.output.append(value, this, false, false, true);
                            }
                          } else {
                            if (this.decorations.length) {
                              for (var i = this.decorations.length - 1; i > -1; i--) {
                                if (this.decorations[i][0] === "@" + this.variables[0]) {
                                  this.decorations = this.decorations.slice(0, i).concat(this.decorations.slice(i + 1));
                                }
                              }
                            }
                            state2.output.append(value, this, false, false, true);
                          }
                        }
                      }
                    };
                  } else if (this.variables_real[0] === "section") {
                    func = function(state2, Item) {
                      var value;
                      value = state2.getVariable(Item, this.variables[0], form);
                      if (value) {
                        state2.output.append(value, this);
                      }
                    };
                  } else if (this.variables_real[0] === "hereinafter") {
                    func = function(state2, Item) {
                      var value = state2.transform.abbrevs["default"]["hereinafter"][Item.id];
                      if (value) {
                        state2.output.append(value, this);
                        state2.tmp.group_context.tip.variable_success = true;
                      }
                    };
                  } else {
                    func = function(state2, Item) {
                      var value;
                      if (this.variables[0]) {
                        value = state2.getVariable(Item, this.variables[0], form);
                        if (value) {
                          value = "" + value;
                          value = value.split("\\").join("");
                          state2.output.append(value, this);
                        }
                      }
                    };
                  }
                }
                this.execs.push(func);
              } else if (this.strings.value) {
                func = function(state2) {
                  state2.tmp.group_context.tip.term_intended = true;
                  CSL3.UPDATE_GROUP_CONTEXT_CONDITION(state2, this.strings.value, true, this);
                  state2.output.append(this.strings.value, this);
                  if (state2.tmp.can_block_substitute) {
                    state2.tmp.can_substitute.replace(false, CSL3.LITERAL);
                  }
                };
                this.execs.push(func);
              }
            }
            target.push(this);
            CSL3.Util.substituteEnd.call(this, state, target);
          }
        }
      };
      CSL3.Node.intext = {
        build: function(state, target) {
          if (this.tokentype === CSL3.START) {
            state.build.area = "intext";
            state.build.root = "intext";
            state.build.extension = "";
            var func = function(state2, Item) {
              state2.tmp.area = "intext";
              state2.tmp.root = "intext";
              state2.tmp.extension = "";
            };
            this.execs.push(func);
          }
          if (this.tokentype === CSL3.END) {
            state.intext_sort = {
              opt: {
                sort_directions: state.citation_sort.opt.sort_directions
              }
            };
            state.intext.srt = state.citation.srt;
          }
          target.push(this);
        }
      };
      CSL3.Attributes = {};
      CSL3.Attributes["@disambiguate"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        if (arg === "true") {
          state.opt.has_disambiguate = true;
          var func = function(Item) {
            if (state.tmp.area === "bibliography") {
              if (state.tmp.disambiguate_count < state.registry.registry[Item.id].disambig.disambiguate) {
                state.tmp.disambiguate_count += 1;
                return true;
              }
            } else {
              state.tmp.disambiguate_maxMax += 1;
              if (state.tmp.disambig_settings.disambiguate && state.tmp.disambiguate_count < state.tmp.disambig_settings.disambiguate) {
                state.tmp.disambiguate_count += 1;
                return true;
              }
            }
            return false;
          };
          this.tests.push(func);
        } else if (arg === "check-ambiguity-and-backreference") {
          var func = function(Item) {
            if (state.registry.registry[Item.id].disambig.disambiguate && state.registry.registry[Item.id]["citation-count"] > 1) {
              return true;
            }
            return false;
          };
          this.tests.push(func);
        }
      };
      CSL3.Attributes["@is-numeric"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var variables = arg.split(/\s+/);
        var maketest = function(variable) {
          return function(Item, item) {
            var myitem = Item;
            if (item && ["locator", "locator-extra"].indexOf(variable) > -1) {
              myitem = item;
            }
            if (!myitem[variable]) {
              return false;
            }
            if (CSL3.NUMERIC_VARIABLES.indexOf(variable) > -1) {
              if (!state.tmp.shadow_numbers[variable]) {
                state.processNumber(false, myitem, variable, Item.type);
              }
              if (state.tmp.shadow_numbers[variable].numeric) {
                return true;
              }
            } else if (["title", "version"].indexOf(variable) > -1) {
              if (myitem[variable].slice(-1) === "" + parseInt(myitem[variable].slice(-1), 10)) {
                return true;
              }
            }
            return false;
          };
        };
        for (var i = 0; i < variables.length; i += 1) {
          this.tests.push(maketest(variables[i]));
        }
      };
      CSL3.Attributes["@is-uncertain-date"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var variables = arg.split(/\s+/);
        var maketest = function(myvariable) {
          return function(Item) {
            if (Item[myvariable] && Item[myvariable].circa) {
              return true;
            } else {
              return false;
            }
          };
        };
        for (var i = 0, ilen = variables.length; i < ilen; i += 1) {
          this.tests.push(maketest(variables[i]));
        }
      };
      CSL3.Attributes["@locator"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var trylabels = arg.replace("sub verbo", "sub-verbo");
        trylabels = trylabels.split(/\s+/);
        var maketest = function(trylabel) {
          return function(Item, item) {
            var label;
            state.processNumber(false, item, "locator");
            label = state.tmp.shadow_numbers.locator.label;
            if (label && trylabel === label) {
              return true;
            } else {
              return false;
            }
          };
        };
        for (var i = 0, ilen = trylabels.length; i < ilen; i += 1) {
          this.tests.push(maketest(trylabels[i]));
        }
      };
      CSL3.Attributes["@position"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var tryposition;
        state.opt.update_mode = CSL3.POSITION;
        var trypositions = arg.split(/\s+/);
        var testSubsequentNear = function(Item, item) {
          if (item && CSL3.POSITION_MAP[item.position] >= CSL3.POSITION_MAP[CSL3.POSITION_SUBSEQUENT] && item["near-note"]) {
            return true;
          }
          return false;
        };
        var testSubsequentNotNear = function(Item, item) {
          if (item && CSL3.POSITION_MAP[item.position] == CSL3.POSITION_MAP[CSL3.POSITION_SUBSEQUENT] && !item["near-note"]) {
            return true;
          }
          return false;
        };
        var maketest = function(tryposition2) {
          return function(Item, item) {
            if (state.tmp.area === "bibliography") {
              return false;
            }
            if (item && "undefined" === typeof item.position) {
              item.position = 0;
            }
            if (item && typeof item.position === "number") {
              if (item.position === 0 && tryposition2 === 0) {
                return true;
              } else if (tryposition2 > 0 && CSL3.POSITION_MAP[item.position] >= CSL3.POSITION_MAP[tryposition2]) {
                return true;
              }
            } else if (tryposition2 === 0) {
              return true;
            }
            return false;
          };
        };
        for (var i = 0, ilen = trypositions.length; i < ilen; i += 1) {
          var tryposition = trypositions[i];
          if (tryposition === "first") {
            tryposition = CSL3.POSITION_FIRST;
          } else if (tryposition === "container-subsequent") {
            tryposition = CSL3.POSITION_CONTAINER_SUBSEQUENT;
          } else if (tryposition === "subsequent") {
            tryposition = CSL3.POSITION_SUBSEQUENT;
          } else if (tryposition === "ibid") {
            tryposition = CSL3.POSITION_IBID;
          } else if (tryposition === "ibid-with-locator") {
            tryposition = CSL3.POSITION_IBID_WITH_LOCATOR;
          }
          if ("near-note" === tryposition) {
            this.tests.push(testSubsequentNear);
          } else if ("far-note" === tryposition) {
            this.tests.push(testSubsequentNotNear);
          } else {
            this.tests.push(maketest(tryposition));
          }
        }
      };
      CSL3.Attributes["@type"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var types = arg.split(/\s+/);
        var maketest = function(mytype) {
          return function(Item) {
            var ret = Item.type === mytype;
            if (ret) {
              return true;
            } else {
              return false;
            }
          };
        };
        var tests = [];
        for (var i = 0, ilen = types.length; i < ilen; i += 1) {
          tests.push(maketest(types[i]));
        }
        this.tests.push(state.fun.match.any(this, state, tests));
      };
      CSL3.Attributes["@variable"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var func;
        this.variables = arg.split(/\s+/);
        this.variables_real = this.variables.slice();
        if ("label" === this.name && this.variables[0]) {
          this.strings.term = this.variables[0];
        } else if (["names", "date", "text", "number"].indexOf(this.name) > -1) {
          func = function(state2, Item, item) {
            for (var i2 = this.variables.length - 1; i2 > -1; i2 += -1) {
              this.variables.pop();
            }
            for (var i2 = 0, ilen2 = this.variables_real.length; i2 < ilen2; i2++) {
              if (state2.tmp.done_vars.indexOf(this.variables_real[i2]) === -1) {
                this.variables.push(this.variables_real[i2]);
              }
              if (state2.tmp.can_block_substitute) {
                state2.tmp.done_vars.push(this.variables_real[i2]);
              }
            }
          };
          this.execs.push(func);
          func = function(state2, Item, item) {
            var output = false;
            for (var i2 = 0, ilen2 = this.variables.length; i2 < ilen2; i2++) {
              var variable = this.variables[i2];
              if (["authority", "committee"].indexOf(variable) > -1 && "string" === typeof Item[variable] && "names" === this.name) {
                var isValid = true;
                var rawNames = Item[variable].split(/\s*;\s*/);
                var rawMultiNames = {};
                if (Item.multi && Item.multi._keys[variable]) {
                  for (var langTag in Item.multi._keys[variable]) {
                    rawMultiNames[langTag] = Item.multi._keys[variable][langTag].split(/\s*;\s*/);
                    if (rawMultiNames[langTag].length !== rawNames.length) {
                      isValid = false;
                      break;
                    }
                  }
                }
                if (!isValid) {
                  rawNames = [Item[variable]];
                  rawMultiNames = Item.multi._keys[variable];
                }
                for (var j = 0, jlen = rawNames.length; j < jlen; j++) {
                  var creatorParent = {
                    literal: rawNames[j],
                    multi: {
                      _key: {}
                    }
                  };
                  for (var langTag in rawMultiNames) {
                    var creatorChild = {
                      literal: rawMultiNames[langTag][j]
                    };
                    creatorParent.multi._key[langTag] = creatorChild;
                  }
                  rawNames[j] = creatorParent;
                }
                Item[variable] = rawNames;
              }
              if (this.strings.form === "short" && !Item[variable]) {
                if (variable === "title") {
                  variable = "title-short";
                } else if (variable === "container-title") {
                  variable = "container-title-short";
                }
              }
              if (variable === "year-suffix") {
                output = true;
                break;
              } else if (CSL3.DATE_VARIABLES.indexOf(variable) > -1) {
                if (state2.opt.development_extensions.locator_date_and_revision && "locator-date" === variable) {
                  output = true;
                  break;
                }
                if (Item[variable]) {
                  for (var key in Item[variable]) {
                    if (this.dateparts.indexOf(key) === -1 && "literal" !== key) {
                      continue;
                    }
                    if (Item[variable][key]) {
                      output = true;
                      break;
                    }
                  }
                  if (output) {
                    break;
                  }
                }
              } else if ("locator" === variable) {
                if (item && item.locator) {
                  output = true;
                }
                break;
              } else if ("locator-extra" === variable) {
                if (item && item["locator-extra"]) {
                  output = true;
                }
                break;
              } else if (["citation-number", "citation-label"].indexOf(variable) > -1) {
                output = true;
                break;
              } else if ("first-reference-note-number" === variable) {
                if (item && item["first-reference-note-number"]) {
                  output = true;
                }
                break;
              } else if ("first-container-reference-note-number" === variable) {
                if (item && item["first-container-reference-note-number"]) {
                  output = true;
                }
                break;
              } else if ("hereinafter" === variable) {
                if (state2.transform.abbrevs["default"].hereinafter[Item.id] && state2.sys.getAbbreviation && Item.id) {
                  output = true;
                }
                break;
              } else if ("object" === typeof Item[variable]) {
                break;
              } else if ("string" === typeof Item[variable] && Item[variable]) {
                output = true;
                break;
              } else if ("number" === typeof Item[variable]) {
                output = true;
                break;
              }
              if (output) {
                break;
              }
            }
            if (output) {
              for (var i2 = 0, ilen2 = this.variables_real.length; i2 < ilen2; i2++) {
                var variable = this.variables_real[i2];
                if (variable !== "citation-number" || state2.tmp.area !== "bibliography") {
                  state2.tmp.cite_renders_content = true;
                }
                state2.tmp.group_context.tip.variable_success = true;
                if (state2.tmp.can_substitute.value() && state2.tmp.area === "bibliography" && "string" === typeof Item[variable]) {
                  state2.tmp.name_node.top = state2.output.current.value();
                  state2.tmp.rendered_name.push(Item[variable]);
                }
              }
              state2.tmp.can_substitute.replace(false, CSL3.LITERAL);
            } else {
              state2.tmp.group_context.tip.variable_attempt = true;
            }
          };
          this.execs.push(func);
        } else if (["if", "else-if", "condition"].indexOf(this.name) > -1) {
          var maketest = function(variable) {
            return function(Item, item) {
              var myitem = Item;
              if (item && ["locator", "locator-extra", "first-reference-note-number", "first-container-reference-note-number", "locator-date"].indexOf(variable) > -1) {
                myitem = item;
              }
              if (variable === "hereinafter" && state.sys.getAbbreviation && myitem.id) {
                if (state.transform.abbrevs["default"].hereinafter[myitem.id]) {
                  return true;
                }
              } else if (myitem[variable]) {
                if ("number" === typeof myitem[variable] || "string" === typeof myitem[variable]) {
                  return true;
                } else if ("object" === typeof myitem[variable]) {
                  for (var key in myitem[variable]) {
                    if (myitem[variable][key]) {
                      return true;
                    }
                  }
                }
              }
              return false;
            };
          };
          for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
            this.tests.push(maketest(this.variables[i]));
          }
        }
      };
      CSL3.Attributes["@page"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var trylabels = arg.replace("sub verbo", "sub-verbo");
        trylabels = trylabels.split(/\s+/);
        var maketest = function(trylabel) {
          return function(Item) {
            var label;
            state.processNumber(false, Item, "page", Item.type);
            if (!state.tmp.shadow_numbers.page.label) {
              label = "page";
            } else if (state.tmp.shadow_numbers.page.label === "sub verbo") {
              label = "sub-verbo";
            } else {
              label = state.tmp.shadow_numbers.page.label;
            }
            if (state.tmp.shadow_numbers.page.values.length > 0) {
              if (state.tmp.shadow_numbers.page.values[0].gotosleepability) {
                state.tmp.shadow_numbers.page.values[0].labelVisibility = false;
              }
            }
            if (trylabel === label) {
              return true;
            } else {
              return false;
            }
          };
        };
        for (var i = 0, ilen = trylabels.length; i < ilen; i += 1) {
          this.tests.push(maketest(trylabels[i]));
        }
      };
      CSL3.Attributes["@number"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var trylabels = arg.split(/\s+/);
        var maketest = function(trylabel) {
          return function(Item) {
            var label;
            state.processNumber(false, Item, "number", Item.type);
            if (!state.tmp.shadow_numbers.number.label) {
              label = "number";
            } else {
              label = state.tmp.shadow_numbers.number.label;
            }
            if (trylabel === label) {
              return true;
            } else {
              return false;
            }
          };
        };
        for (var i = 0, ilen = trylabels.length; i < ilen; i += 1) {
          this.tests.push(maketest(trylabels[i]));
        }
      };
      CSL3.Attributes["@jurisdiction"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var tryjurisdictions = arg.split(/\s+/);
        var maketests = function(tryjurisdictions2) {
          return function(Item) {
            if (!Item.jurisdiction) {
              return false;
            }
            var jurisdiction = Item.jurisdiction;
            for (var i = 0, ilen = tryjurisdictions2.length; i < ilen; i++) {
              if (jurisdiction === tryjurisdictions2[i]) {
                return true;
              }
            }
            return false;
          };
        };
        this.tests.push(maketests(tryjurisdictions));
      };
      CSL3.Attributes["@country"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var trycountries = arg.split(/\s+/);
        var maketests = function(trycountries2) {
          return function(Item) {
            if (!Item.country) {
              return false;
            }
            var country = Item.country;
            for (var i = 0, ilen = trycountries2.length; i < ilen; i++) {
              if (country === trycountries2[i]) {
                return true;
              }
            }
            return false;
          };
        };
        this.tests.push(maketests(trycountries));
      };
      CSL3.Attributes["@context"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var func = function() {
          if (["bibliography", "citation"].indexOf(arg) > -1) {
            var area = state.tmp.area.slice(0, arg.length);
            if (area === arg) {
              return true;
            }
            return false;
          } else if ("alternative" === arg) {
            return !!state.tmp.abort_alternative;
          }
        };
        this.tests.push(func);
      };
      CSL3.Attributes["@has-year-only"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var trydates = arg.split(/\s+/);
        var maketest = function(trydate) {
          return function(Item) {
            var date = Item[trydate];
            if (!date || date.month || date.season) {
              return false;
            } else {
              return true;
            }
          };
        };
        for (var i = 0, ilen = trydates.length; i < ilen; i += 1) {
          this.tests.push(maketest(trydates[i]));
        }
      };
      CSL3.Attributes["@has-to-month-or-season"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var trydates = arg.split(/\s+/);
        var maketest = function(trydate) {
          return function(Item) {
            var date = Item[trydate];
            if (!date || !date.month && !date.season || date.day) {
              return false;
            } else {
              return true;
            }
          };
        };
        for (var i = 0, ilen = trydates.length; i < ilen; i += 1) {
          this.tests.push(maketest(trydates[i]));
        }
      };
      CSL3.Attributes["@has-day"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var trydates = arg.split(/\s+/);
        var maketest = function(trydate) {
          return function(Item) {
            var date = Item[trydate];
            if (!date || !date.day) {
              return false;
            } else {
              return true;
            }
          };
        };
        for (var i = 0, ilen = trydates.length; i < ilen; i += 1) {
          this.tests.push(maketest(trydates[i]));
        }
      };
      CSL3.Attributes["@is-plural"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var func = function(Item) {
          var nameList = Item[arg];
          if (nameList && nameList.length) {
            var persons = 0;
            var institutions = 0;
            var last_is_person = false;
            for (var i = 0, ilen = nameList.length; i < ilen; i += 1) {
              if (state.opt.development_extensions.spoof_institutional_affiliations && (nameList[i].literal || nameList[i].isInstitution && nameList[i].family && !nameList[i].given)) {
                institutions += 1;
                last_is_person = false;
              } else {
                persons += 1;
                last_is_person = true;
              }
            }
            if (persons > 1) {
              return true;
            } else if (institutions > 1) {
              return true;
            } else if (institutions && last_is_person) {
              return true;
            }
          }
          return false;
        };
        this.tests.push(func);
      };
      CSL3.Attributes["@is-multiple"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var func = function(Item) {
          var val = "" + Item[arg];
          var lst = val.split(/(?:,\s|\s(?:tot\sen\smet|līdz|oraz|and|bis|έως|και|och|až|do|en|et|in|ir|ja|og|sa|to|un|und|és|și|i|u|y|à|e|a|и|-|–)\s|—|\&)/);
          if (lst.length > 1) {
            return true;
          }
          return false;
        };
        this.tests.push(func);
      };
      CSL3.Attributes["@locale"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var ret, langspec, lang, lst, i, ilen;
        var locale_default = state.opt["default-locale"][0];
        if (this.name === "layout") {
          this.locale_raw = arg;
          if (this.tokentype === CSL3.START) {
            if (!state.opt.multi_layout) {
              state.opt.multi_layout = [];
            }
            var locale_data = [];
            var locales = arg.split(/\s+/);
            var sort_locale = {};
            var localeMaster = CSL3.localeResolve(locales[0], locale_default);
            locale_data.push(localeMaster);
            if (localeMaster.generic) {
              sort_locale[localeMaster.generic] = localeMaster.best;
            } else {
              sort_locale[localeMaster.best] = localeMaster.best;
            }
            for (var i = 1, ilen = locales.length; i < ilen; i += 1) {
              var localeServant = CSL3.localeResolve(locales[i], locale_default);
              locale_data.push(localeServant);
              if (localeServant.generic) {
                sort_locale[localeServant.generic] = localeMaster.best;
              } else {
                sort_locale[localeServant.best] = localeMaster.best;
              }
            }
            state[state.build.area].opt.sort_locales.push(sort_locale);
            state.opt.multi_layout.push(locale_data);
          }
          state.opt.has_layout_locale = true;
        } else {
          lst = arg.split(/\s+/);
          var locale_bares = [];
          for (i = 0, ilen = lst.length; i < ilen; i += 1) {
            lang = lst[i];
            langspec = CSL3.localeResolve(lang, locale_default);
            if (lst[i].length === 2) {
              locale_bares.push(langspec.bare);
            }
            state.localeConfigure(langspec, true);
            lst[i] = langspec;
          }
          var locale_list = lst.slice();
          var maketest = function(locale_list2, locale_default2, locale_bares2) {
            return function(Item) {
              var res;
              ret = [];
              res = false;
              var langspec2 = false;
              var lang2;
              if (!Item.language) {
                lang2 = locale_default2;
              } else {
                lang2 = Item.language;
              }
              langspec2 = CSL3.localeResolve(lang2, locale_default2);
              for (i = 0, ilen = locale_list2.length; i < ilen; i += 1) {
                if (langspec2.best === locale_list2[i].best) {
                  state.tmp.condition_lang_counter_arr.push(state.tmp.condition_counter);
                  state.tmp.condition_lang_val_arr.push(state.opt.lang);
                  state.opt.lang = locale_list2[0].best;
                  res = true;
                  break;
                }
              }
              if (!res && locale_bares2.indexOf(langspec2.bare) > -1) {
                state.tmp.condition_lang_counter_arr.push(state.tmp.condition_counter);
                state.tmp.condition_lang_val_arr.push(state.opt.lang);
                state.opt.lang = locale_list2[0].best;
                res = true;
              }
              return res;
            };
          };
          this.tests.push(maketest(locale_list, locale_default, locale_bares));
        }
      };
      CSL3.Attributes["@alternative-node-internal"] = function(state) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var maketest = function() {
          return function() {
            return !state.tmp.abort_alternative;
          };
        };
        var me = this;
        this.tests.push(maketest(me));
      };
      CSL3.Attributes["@locale-internal"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var langspec, lang, lst, i, ilen;
        lst = arg.split(/\s+/);
        this.locale_bares = [];
        for (i = 0, ilen = lst.length; i < ilen; i += 1) {
          lang = lst[i];
          langspec = CSL3.localeResolve(lang, state.opt["default-locale"][0]);
          if (lst[i].length === 2) {
            this.locale_bares.push(langspec.bare);
          }
          state.localeConfigure(langspec);
          lst[i] = langspec;
        }
        this.locale_default = state.opt["default-locale"][0];
        this.locale = lst[0].best;
        this.locale_list = lst.slice();
        var maketest = function(me2) {
          return function(Item) {
            var ret, res;
            ret = [];
            res = false;
            var langspec2 = false;
            if (Item.language) {
              lang = Item.language;
              langspec2 = CSL3.localeResolve(lang, state.opt["default-locale"][0]);
              if (langspec2.best === state.opt["default-locale"][0]) {
                langspec2 = false;
              }
            }
            if (langspec2) {
              for (i = 0, ilen = me2.locale_list.length; i < ilen; i += 1) {
                if (langspec2.best === me2.locale_list[i].best) {
                  state.opt.lang = me2.locale;
                  state.tmp.last_cite_locale = me2.locale;
                  state.output.openLevel("empty");
                  state.output.current.value().new_locale = me2.locale;
                  res = true;
                  break;
                }
              }
              if (!res && me2.locale_bares.indexOf(langspec2.bare) > -1) {
                state.opt.lang = me2.locale;
                state.tmp.last_cite_locale = me2.locale;
                state.output.openLevel("empty");
                state.output.current.value().new_locale = me2.locale;
                res = true;
              }
            }
            return res;
          };
        };
        var me = this;
        this.tests.push(maketest(me));
      };
      CSL3.Attributes["@court-class"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var tryclasses = arg.split(/\s+/);
        var maketest = function(tryclass) {
          return function(Item) {
            var cls = CSL3.GET_COURT_CLASS(state, Item);
            if (cls === tryclass) {
              return true;
            } else {
              return false;
            }
          };
        };
        for (var i = 0, ilen = tryclasses.length; i < ilen; i++) {
          this.tests.push(maketest(tryclasses[i]));
        }
      };
      CSL3.Attributes["@container-multiple"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var retval = "true" === arg ? true : false;
        var maketest = function(retval2) {
          return function(Item) {
            if (!state.tmp.container_item_count[Item.container_id]) {
              return !retval2;
            } else if (state.tmp.container_item_count[Item.container_id] > 1) {
              return retval2;
            }
            return !retval2;
          };
        };
        this.tests.push(maketest(retval));
      };
      CSL3.Attributes["@container-subsequent"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var retval = "true" === arg ? true : false;
        var maketest = function(retval2) {
          return function(Item) {
            if (state.tmp.container_item_pos[Item.container_id] > 1) {
              return retval2;
            }
            return !retval2;
          };
        };
        this.tests.push(maketest(retval));
      };
      CSL3.Attributes["@has-subunit"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var maketest = function(namevar) {
          return function(Item) {
            var subunit_count = 0;
            for (var i in Item[namevar]) {
              var name = Item[namevar][i];
              if (!name.given) {
                var institution = name.literal ? name.literal : name.family;
                var length = institution.split("|").length;
                if (subunit_count === 0 || length < subunit_count) {
                  subunit_count = length;
                }
              }
            }
            return subunit_count > 1;
          };
        };
        this.tests.push(maketest(arg));
      };
      CSL3.Attributes["@cite-form"] = function(state, arg) {
        if (!this.tests) {
          this.tests = [];
        }
        ;
        var maketest = function(citeForm) {
          return function(Item) {
            if (Item["cite-form"] === citeForm) {
              return true;
            }
            return false;
          };
        };
        this.tests.push(maketest(arg));
      };
      CSL3.Attributes["@disable-duplicate-year-suppression"] = function(state, arg) {
        state.opt.disable_duplicate_year_suppression = arg.split(/\s+/);
      };
      CSL3.Attributes["@consolidate-containers"] = function(state, arg) {
        CSL3.Attributes["@track-containers"](state, arg);
        var args = arg.split(/\s+/);
        state.bibliography.opt.consolidate_containers = args;
      };
      CSL3.Attributes["@track-containers"] = function(state, arg) {
        var args = arg.split(/\s+/);
        if (!state.bibliography.opt.track_container_items) {
          state.bibliography.opt.track_container_items = [];
        }
        if (!state.bibliography.opt.consolidate_containers) {
          state.bibliography.opt.consolidate_containers = [];
        }
        state.bibliography.opt.track_container_items = state.bibliography.opt.track_container_items.concat(args);
      };
      CSL3.Attributes["@parallel-first"] = function(state, arg) {
        state.opt.parallel.enable = true;
        var vars = arg.split(/\s+/);
        if (!state.opt.track_repeat) {
          state.opt.track_repeat = {};
        }
        this.parallel_first = {};
        for (var i in vars) {
          var v = vars[i];
          this.parallel_first[v] = true;
          state.opt.track_repeat[v] = true;
        }
      };
      CSL3.Attributes["@parallel-last"] = function(state, arg) {
        state.opt.parallel.enable = true;
        var vars = arg.split(/\s+/);
        if (!state.opt.track_repeat) {
          state.opt.track_repeat = {};
        }
        this.parallel_last = {};
        for (var i in vars) {
          var v = vars[i];
          this.parallel_last[v] = true;
          state.opt.track_repeat[v] = true;
        }
      };
      CSL3.Attributes["@parallel-last-to-first"] = function(state, arg) {
        state.opt.parallel.enable = true;
        var vars = arg.split(/\s+/);
        this.parallel_last_to_first = {};
        for (var i = 0, ilen = vars.length; i < ilen; i++) {
          this.parallel_last_to_first[vars[i]] = true;
        }
      };
      CSL3.Attributes["@parallel-delimiter-override"] = function(state, arg) {
        state.opt.parallel.enable = true;
        this.strings.set_parallel_delimiter_override = arg;
      };
      CSL3.Attributes["@parallel-delimiter-override-on-suppress"] = function(state, arg) {
        state.opt.parallel.enable = true;
        this.strings.set_parallel_delimiter_override_on_suppress = arg;
      };
      CSL3.Attributes["@no-repeat"] = function(state, arg) {
        state.opt.parallel.enable = true;
        var vars = arg.split(/\s+/);
        if (!state.opt.track_repeat) {
          state.opt.track_repeat = {};
        }
        this.non_parallel = {};
        for (var i in vars) {
          var v = vars[i];
          this.non_parallel[v] = true;
          state.opt.track_repeat[v] = true;
        }
      };
      CSL3.Attributes["@require"] = function(state, arg) {
        state.opt.use_context_condition = true;
        this.strings.require = arg;
      };
      CSL3.Attributes["@reject"] = function(state, arg) {
        state.opt.use_context_condition = true;
        this.strings.reject = arg;
      };
      CSL3.Attributes["@require-comma-on-symbol"] = function(state, arg) {
        state.opt.require_comma_on_symbol = arg;
      };
      CSL3.Attributes["@gender"] = function(state, arg) {
        this.gender = arg;
      };
      CSL3.Attributes["@cslid"] = function(state, arg) {
        this.cslid = parseInt(arg, 10);
      };
      CSL3.Attributes["@capitalize-if-first"] = function(state, arg) {
        this.strings.capitalize_if_first_override = arg;
      };
      CSL3.Attributes["@label-capitalize-if-first"] = function(state, arg) {
        this.strings.label_capitalize_if_first_override = arg;
      };
      CSL3.Attributes["@label-form"] = function(state, arg) {
        this.strings.label_form_override = arg;
      };
      CSL3.Attributes["@part-separator"] = function(state, arg) {
        this.strings["part-separator"] = arg;
      };
      CSL3.Attributes["@leading-noise-words"] = function(state, arg) {
        this["leading-noise-words"] = arg;
      };
      CSL3.Attributes["@name-never-short"] = function(state, arg) {
        this["name-never-short"] = arg;
      };
      CSL3.Attributes["@class"] = function(state, arg) {
        state.opt["class"] = arg;
      };
      CSL3.Attributes["@version"] = function(state, arg) {
        state.opt.version = arg;
      };
      CSL3.Attributes["@value"] = function(state, arg) {
        this.strings.value = arg;
      };
      CSL3.Attributes["@name"] = function(state, arg) {
        this.strings.name = arg;
      };
      CSL3.Attributes["@form"] = function(state, arg) {
        this.strings.form = arg;
      };
      CSL3.Attributes["@date-parts"] = function(state, arg) {
        this.strings["date-parts"] = arg;
      };
      CSL3.Attributes["@range-delimiter"] = function(state, arg) {
        this.strings["range-delimiter"] = arg;
      };
      CSL3.Attributes["@macro"] = function(state, arg) {
        this.postponed_macro = arg;
      };
      CSL3.Attributes["@term"] = function(state, arg) {
        if (arg === "sub verbo") {
          this.strings.term = "sub-verbo";
        } else {
          this.strings.term = arg;
        }
      };
      CSL3.Attributes["@xmlns"] = function() {
      };
      CSL3.Attributes["@lang"] = function(state, arg) {
        if (arg) {
          state.build.lang = arg;
        }
      };
      CSL3.Attributes["@lingo"] = function() {
      };
      CSL3.Attributes["@macro-has-date"] = function() {
        this["macro-has-date"] = true;
      };
      CSL3.Attributes["@suffix"] = function(state, arg) {
        this.strings.suffix = arg;
      };
      CSL3.Attributes["@prefix"] = function(state, arg) {
        this.strings.prefix = arg;
      };
      CSL3.Attributes["@delimiter"] = function(state, arg) {
        this.strings.delimiter = arg;
      };
      CSL3.Attributes["@match"] = function(state, arg) {
        this.match = arg;
      };
      CSL3.Attributes["@names-min"] = function(state, arg) {
        var val = parseInt(arg, 10);
        if (state[state.build.area].opt.max_number_of_names < val) {
          state[state.build.area].opt.max_number_of_names = val;
        }
        this.strings["et-al-min"] = val;
      };
      CSL3.Attributes["@names-use-first"] = function(state, arg) {
        this.strings["et-al-use-first"] = parseInt(arg, 10);
      };
      CSL3.Attributes["@names-use-last"] = function(state, arg) {
        if (arg === "true") {
          this.strings["et-al-use-last"] = true;
        } else {
          this.strings["et-al-use-last"] = false;
        }
      };
      CSL3.Attributes["@sort"] = function(state, arg) {
        if (arg === "descending") {
          this.strings.sort_direction = CSL3.DESCENDING;
        }
      };
      CSL3.Attributes["@plural"] = function(state, arg) {
        if ("always" === arg || "true" === arg) {
          this.strings.plural = 1;
        } else if ("never" === arg || "false" === arg) {
          this.strings.plural = 0;
        } else if ("contextual" === arg) {
          this.strings.plural = false;
        }
      };
      CSL3.Attributes["@has-publisher-and-publisher-place"] = function() {
        this.strings["has-publisher-and-publisher-place"] = true;
      };
      CSL3.Attributes["@publisher-delimiter-precedes-last"] = function(state, arg) {
        this.strings["publisher-delimiter-precedes-last"] = arg;
      };
      CSL3.Attributes["@publisher-delimiter"] = function(state, arg) {
        this.strings["publisher-delimiter"] = arg;
      };
      CSL3.Attributes["@publisher-and"] = function(state, arg) {
        this.strings["publisher-and"] = arg;
      };
      CSL3.Attributes["@givenname-disambiguation-rule"] = function(state, arg) {
        if (CSL3.GIVENNAME_DISAMBIGUATION_RULES.indexOf(arg) > -1) {
          state.citation.opt["givenname-disambiguation-rule"] = arg;
        }
      };
      CSL3.Attributes["@collapse"] = function(state, arg) {
        if (arg) {
          state[this.name].opt.collapse = arg;
        }
      };
      CSL3.Attributes["@cite-group-delimiter"] = function(state, arg) {
        if (arg) {
          state[state.tmp.area].opt.cite_group_delimiter = arg;
        }
      };
      CSL3.Attributes["@names-delimiter"] = function(state, arg) {
        state.setOpt(this, "names-delimiter", arg);
      };
      CSL3.Attributes["@name-form"] = function(state, arg) {
        state.setOpt(this, "name-form", arg);
      };
      CSL3.Attributes["@subgroup-delimiter"] = function(state, arg) {
        this.strings["subgroup-delimiter"] = arg;
      };
      CSL3.Attributes["@subgroup-delimiter-precedes-last"] = function(state, arg) {
        this.strings["subgroup-delimiter-precedes-last"] = arg;
      };
      CSL3.Attributes["@name-delimiter"] = function(state, arg) {
        state.setOpt(this, "name-delimiter", arg);
      };
      CSL3.Attributes["@et-al-min"] = function(state, arg) {
        var val = parseInt(arg, 10);
        if (state[state.build.area].opt.max_number_of_names < val) {
          state[state.build.area].opt.max_number_of_names = val;
        }
        state.setOpt(this, "et-al-min", val);
      };
      CSL3.Attributes["@et-al-use-first"] = function(state, arg) {
        state.setOpt(this, "et-al-use-first", parseInt(arg, 10));
      };
      CSL3.Attributes["@et-al-use-last"] = function(state, arg) {
        if (arg === "true") {
          state.setOpt(this, "et-al-use-last", true);
        } else {
          state.setOpt(this, "et-al-use-last", false);
        }
      };
      CSL3.Attributes["@et-al-subsequent-min"] = function(state, arg) {
        var val = parseInt(arg, 10);
        if (state[state.build.area].opt.max_number_of_names < val) {
          state[state.build.area].opt.max_number_of_names = val;
        }
        state.setOpt(this, "et-al-subsequent-min", val);
      };
      CSL3.Attributes["@et-al-subsequent-use-first"] = function(state, arg) {
        state.setOpt(this, "et-al-subsequent-use-first", parseInt(arg, 10));
      };
      CSL3.Attributes["@suppress-min"] = function(state, arg) {
        this.strings["suppress-min"] = parseInt(arg, 10);
      };
      CSL3.Attributes["@suppress-max"] = function(state, arg) {
        this.strings["suppress-max"] = parseInt(arg, 10);
      };
      CSL3.Attributes["@and"] = function(state, arg) {
        state.setOpt(this, "and", arg);
      };
      CSL3.Attributes["@delimiter-precedes-last"] = function(state, arg) {
        state.setOpt(this, "delimiter-precedes-last", arg);
      };
      CSL3.Attributes["@delimiter-precedes-et-al"] = function(state, arg) {
        state.setOpt(this, "delimiter-precedes-et-al", arg);
      };
      CSL3.Attributes["@initialize-with"] = function(state, arg) {
        state.setOpt(this, "initialize-with", arg);
      };
      CSL3.Attributes["@initialize"] = function(state, arg) {
        if (arg === "false") {
          state.setOpt(this, "initialize", false);
        }
      };
      CSL3.Attributes["@name-as-reverse-order"] = function(state, arg) {
        this["name-as-reverse-order"] = arg;
      };
      CSL3.Attributes["@name-as-sort-order"] = function(state, arg) {
        if (this.name === "style-options") {
          this["name-as-sort-order"] = arg;
        } else {
          state.setOpt(this, "name-as-sort-order", arg);
        }
      };
      CSL3.Attributes["@sort-separator"] = function(state, arg) {
        state.setOpt(this, "sort-separator", arg);
      };
      CSL3.Attributes["@require-match"] = function(state, arg) {
        if (arg === "true") {
          this.requireMatch = true;
        }
      };
      CSL3.Attributes["@exclude-types"] = function(state, arg) {
        state.bibliography.opt.exclude_types = arg.split(/\s+/);
      };
      CSL3.Attributes["@exclude-with-fields"] = function(state, arg) {
        state.bibliography.opt.exclude_with_fields = arg.split(/\s+/);
      };
      CSL3.Attributes["@year-suffix-delimiter"] = function(state, arg) {
        state[this.name].opt["year-suffix-delimiter"] = arg;
      };
      CSL3.Attributes["@after-collapse-delimiter"] = function(state, arg) {
        state[this.name].opt["after-collapse-delimiter"] = arg;
      };
      CSL3.Attributes["@subsequent-author-substitute"] = function(state, arg) {
        state[this.name].opt["subsequent-author-substitute"] = arg;
      };
      CSL3.Attributes["@subsequent-author-substitute-rule"] = function(state, arg) {
        state[this.name].opt["subsequent-author-substitute-rule"] = arg;
      };
      CSL3.Attributes["@disambiguate-add-names"] = function(state, arg) {
        if (arg === "true") {
          state.opt["disambiguate-add-names"] = true;
        }
      };
      CSL3.Attributes["@disambiguate-add-givenname"] = function(state, arg) {
        if (arg === "true") {
          state.opt["disambiguate-add-givenname"] = true;
        }
      };
      CSL3.Attributes["@disambiguate-add-year-suffix"] = function(state, arg) {
        if (arg === "true" && state.opt.xclass !== "numeric") {
          state.opt["disambiguate-add-year-suffix"] = true;
        }
      };
      CSL3.Attributes["@second-field-align"] = function(state, arg) {
        if (arg === "flush" || arg === "margin") {
          state[this.name].opt["second-field-align"] = arg;
        }
      };
      CSL3.Attributes["@hanging-indent"] = function(state, arg) {
        if (arg === "true") {
          if (state.opt.development_extensions.hanging_indent_legacy_number) {
            state[this.name].opt.hangingindent = 2;
          } else {
            state[this.name].opt.hangingindent = true;
          }
        }
      };
      CSL3.Attributes["@line-spacing"] = function(state, arg) {
        if (arg && arg.match(/^[.0-9]+$/)) {
          state[this.name].opt["line-spacing"] = parseFloat(arg, 10);
        }
      };
      CSL3.Attributes["@entry-spacing"] = function(state, arg) {
        if (arg && arg.match(/^[.0-9]+$/)) {
          state[this.name].opt["entry-spacing"] = parseFloat(arg, 10);
        }
      };
      CSL3.Attributes["@near-note-distance"] = function(state, arg) {
        state[this.name].opt["near-note-distance"] = parseInt(arg, 10);
      };
      CSL3.Attributes["@substring"] = function(state, arg) {
        this.substring = parseInt(arg, 10);
      };
      CSL3.Attributes["@text-case"] = function(state, arg) {
        var func = function(state2, Item) {
          if (arg === "normal") {
            this.text_case_normal = true;
          } else {
            this.strings["text-case"] = arg;
            if (arg === "title") {
              if (Item.jurisdiction) {
                this.strings["text-case"] = "passthrough";
              }
            }
          }
        };
        this.execs.push(func);
      };
      CSL3.Attributes["@page-range-format"] = function(state, arg) {
        state.opt["page-range-format"] = arg;
      };
      CSL3.Attributes["@year-range-format"] = function(state, arg) {
        state.opt["year-range-format"] = arg;
      };
      CSL3.Attributes["@default-locale"] = function(state, arg) {
        if (this.name === "style") {
          var lst, len, pos, m, ret;
          var m = arg.match(/-x-(sort|translit|translat)-/g);
          if (m) {
            for (pos = 0, len = m.length; pos < len; pos += 1) {
              m[pos] = m[pos].replace(/^-x-/, "").replace(/-$/, "");
            }
          }
          lst = arg.split(/-x-(?:sort|translit|translat)-/);
          ret = [lst[0]];
          for (pos = 1, len = lst.length; pos < len; pos += 1) {
            ret.push(m[pos - 1]);
            ret.push(lst[pos]);
          }
          lst = ret.slice();
          len = lst.length;
          for (pos = 1; pos < len; pos += 2) {
            state.opt["locale-" + lst[pos]].push(lst[pos + 1].replace(/^\s*/g, "").replace(/\s*$/g, ""));
          }
          if (lst.length) {
            state.opt["default-locale"] = lst.slice(0, 1);
          } else {
            state.opt["default-locale"] = ["en"];
          }
        } else if (arg === "true") {
          this.default_locale = true;
        }
      };
      CSL3.Attributes["@default-locale-sort"] = function(state, arg) {
        state.opt["default-locale-sort"] = arg;
      };
      CSL3.Attributes["@demote-non-dropping-particle"] = function(state, arg) {
        state.opt["demote-non-dropping-particle"] = arg;
      };
      CSL3.Attributes["@initialize-with-hyphen"] = function(state, arg) {
        if (arg === "false") {
          state.opt["initialize-with-hyphen"] = false;
        }
      };
      CSL3.Attributes["@institution-parts"] = function(state, arg) {
        this.strings["institution-parts"] = arg;
      };
      CSL3.Attributes["@if-short"] = function(state, arg) {
        if (arg === "true") {
          this.strings["if-short"] = true;
        }
      };
      CSL3.Attributes["@substitute-use-first"] = function(state, arg) {
        this.strings["substitute-use-first"] = parseInt(arg, 10);
      };
      CSL3.Attributes["@use-first"] = function(state, arg) {
        this.strings["use-first"] = parseInt(arg, 10);
      };
      CSL3.Attributes["@use-last"] = function(state, arg) {
        this.strings["use-last"] = parseInt(arg, 10);
      };
      CSL3.Attributes["@stop-first"] = function(state, arg) {
        this.strings["stop-first"] = parseInt(arg, 10);
      };
      CSL3.Attributes["@stop-last"] = function(state, arg) {
        this.strings["stop-last"] = parseInt(arg, 10) * -1;
      };
      CSL3.Attributes["@reverse-order"] = function(state, arg) {
        if ("true" === arg) {
          this.strings["reverse-order"] = true;
        }
      };
      CSL3.Attributes["@display"] = function(state, arg) {
        if (state.bibliography.tokens.length === 2) {
          state.opt.using_display = true;
        }
        this.strings.cls = arg;
      };
      CSL3.Stack = function(val, literal) {
        this.mystack = [];
        if (literal || val) {
          this.mystack.push(val);
        }
        this.tip = this.mystack[0];
      };
      CSL3.Stack.prototype.push = function(val, literal) {
        if (literal || val) {
          this.mystack.push(val);
        } else {
          this.mystack.push("");
        }
        this.tip = this.mystack[this.mystack.length - 1];
      };
      CSL3.Stack.prototype.clear = function() {
        this.mystack = [];
        this.tip = {};
      };
      CSL3.Stack.prototype.replace = function(val, literal) {
        if (this.mystack.length === 0) {
          CSL3.error("Internal CSL processor error: attempt to replace nonexistent stack item with " + val);
        }
        if (literal || val) {
          this.mystack[this.mystack.length - 1] = val;
        } else {
          this.mystack[this.mystack.length - 1] = "";
        }
        this.tip = this.mystack[this.mystack.length - 1];
      };
      CSL3.Stack.prototype.pop = function() {
        var ret = this.mystack.pop();
        if (this.mystack.length) {
          this.tip = this.mystack[this.mystack.length - 1];
        } else {
          this.tip = {};
        }
        return ret;
      };
      CSL3.Stack.prototype.value = function() {
        return this.mystack.slice(-1)[0];
      };
      CSL3.Stack.prototype.length = function() {
        return this.mystack.length;
      };
      CSL3.Parallel = function(state) {
        this.state = state;
      };
      CSL3.Parallel.prototype.StartCitation = function(sortedItems, out) {
        this.state.tmp.suppress_repeats = [];
        if (sortedItems.length < 2) return;
        var idxEnd = 0;
        var parallelMatchList = false;
        var siblingRanges = [];
        for (var i = 0, ilen = sortedItems.length - 1; i < ilen; i++) {
          var currItem = sortedItems[i][0];
          var nextItem = sortedItems[i + 1][0];
          var freshMatchList = false;
          var info = {};
          if (sortedItems[i][0].seeAlso && sortedItems[i][0].seeAlso.length > 0 && !parallelMatchList) {
            freshMatchList = true;
            parallelMatchList = [sortedItems[i][0].id].concat(sortedItems[i][0].seeAlso);
            var tempMatchList = parallelMatchList.slice();
            var remainder = sortedItems.slice(i);
            remainder[0][1].parallel = "first";
            for (var j = 0, jlen = remainder.length; j < jlen; j++) {
              var itemID = remainder[j][0].id;
              var ididx = tempMatchList.indexOf(itemID);
              idxEnd = false;
              if (ididx === -1) {
                idxEnd = i + j - 1;
              } else if (i + j === sortedItems.length - 1) {
                idxEnd = i + j;
              }
              if (idxEnd) {
                siblingRanges.push([i, idxEnd]);
                break;
              } else {
                tempMatchList = tempMatchList.slice(0, ididx).concat(tempMatchList.slice(ididx + 1));
              }
            }
          }
          if (i > 0 && freshMatchList) {
            this.state.tmp.suppress_repeats[i - 1].START = true;
            freshMatchList = false;
          }
          for (var varname in this.state.opt.track_repeat) {
            if (!currItem[varname] || !nextItem[varname]) {
              info[varname] = false;
            } else if ("string" === typeof nextItem[varname] || "number" === typeof nextItem[varname]) {
              if (varname === "title" && currItem["title-short"] && nextItem["title-short"]) {
                var currVal = currItem["title-short"];
                var nextVal = nextItem["title-short"];
              } else {
                var currVal = currItem[varname];
                var nextVal = nextItem[varname];
              }
              if (currVal == nextVal) {
                info[varname] = true;
              } else {
                info[varname] = false;
              }
            } else if ("undefined" === typeof currItem[varname].length) {
              info[varname] = false;
              var currYear = currItem[varname].year;
              var nextYear = nextItem[varname].year;
              if (currYear && nextYear) {
                if (currYear == nextYear) {
                  info[varname] = true;
                }
              }
            } else {
              var currVal = JSON.stringify(currItem[varname]);
              var nextVal = JSON.stringify(nextItem[varname]);
              if (currVal === nextVal) {
                info[varname] = true;
              } else {
                info[varname] = false;
              }
            }
          }
          if (!parallelMatchList) {
            info.ORPHAN = true;
          }
          if (idxEnd === i) {
            info.END = true;
            parallelMatchList = false;
          }
          this.state.tmp.suppress_repeats.push(info);
        }
        for (var j = 0, jlen = siblingRanges.length; j < jlen; j++) {
          var masterID = sortedItems[siblingRanges[j][0]][0].id;
          this.state.registry.registry[masterID].master = true;
          this.state.registry.registry[masterID].siblings = [];
          var start = siblingRanges[j][0];
          var end = siblingRanges[j][1];
          for (var k = start; k < end; k++) {
            this.state.tmp.suppress_repeats[k].SIBLING = true;
            var siblingID = sortedItems[k + 1][0].id;
            sortedItems[k + 1][1].parallel = "other";
            this.state.registry.registry[masterID].siblings.push(siblingID);
          }
        }
      };
      CSL3.Parallel.prototype.checkRepeats = function(params) {
        var idx = this.state.tmp.cite_index;
        if (this.state.tmp.suppress_repeats) {
          if (params.parallel_first && Object.keys(params.parallel_first).length > 0) {
            var arr = [{}].concat(this.state.tmp.suppress_repeats);
            var ret = true;
            for (var varname in params.parallel_first) {
              if (!arr[idx][varname] || arr[idx].START) {
                ret = false;
              }
            }
            return ret;
          }
          if (params.parallel_last && Object.keys(params.parallel_last).length > 0) {
            var arr = this.state.tmp.suppress_repeats.concat([{}]);
            var ret = Object.keys(params.parallel_last).length > 0 ? true : false;
            for (var varname in params.parallel_last) {
              if (!arr[idx][varname] || arr[idx].END) {
                ret = false;
              }
            }
            return ret;
          }
          if (params.non_parallel && Object.keys(params.non_parallel).length > 0) {
            var arr = [{}].concat(this.state.tmp.suppress_repeats);
            var ret = true;
            for (var varname in params.non_parallel) {
              if (!arr[idx][varname]) {
                ret = false;
              }
            }
            return ret;
          }
        }
        return false;
      };
      CSL3.Util = {};
      CSL3.Util.Match = function() {
        this.any = function(token, state, tests) {
          return function(Item, item) {
            for (var i = 0, ilen = tests.length; i < ilen; i += 1) {
              var result = tests[i](Item, item);
              if (result) {
                return true;
              }
            }
            return false;
          };
        };
        this.none = function(token, state, tests) {
          return function(Item, item) {
            for (var i = 0, ilen = tests.length; i < ilen; i += 1) {
              var result = tests[i](Item, item);
              if (result) {
                return false;
              }
            }
            return true;
          };
        };
        this.all = function(token, state, tests) {
          return function(Item, item) {
            for (var i = 0, ilen = tests.length; i < ilen; i += 1) {
              var result = tests[i](Item, item);
              if (!result) {
                return false;
              }
            }
            return true;
          };
        };
        this[void 0] = this.all;
        this.nand = function(token, state, tests) {
          return function(Item, item) {
            for (var i = 0, ilen = tests.length; i < ilen; i += 1) {
              var result = tests[i](Item, item);
              if (!result) {
                return true;
              }
            }
            return false;
          };
        };
      };
      CSL3.Transform = function(state) {
        this.abbrevs = {};
        this.abbrevs["default"] = new state.sys.AbbreviationSegments();
        function getCountryOrJurisdiction(variable, normalizedKey, quashCountry) {
          var value = "";
          if (state.sys.getHumanForm) {
            if (variable === "country") {
              value = state.sys.getHumanForm(normalizedKey.toLowerCase(), false, true);
              value = value.split("|")[0];
            } else if (variable === "jurisdiction") {
              value = state.sys.getHumanForm(normalizedKey.toLowerCase(), false, true);
              if (!quashCountry) {
                value = value.split("|").slice(1).join(", ");
              } else {
                value = "";
              }
            }
          }
          return value;
        }
        function abbreviate(state2, tok, Item, altvar, basevalue, family_var, use_field) {
          var value = "";
          var myabbrev_family = CSL3.FIELD_CATEGORY_REMAP[family_var];
          var preferredJurisdiction;
          if (!myabbrev_family) {
            return basevalue;
          }
          var variable = family_var;
          var normalizedKey = basevalue;
          if (state2.sys.normalizeAbbrevsKey) {
            normalizedKey = state2.sys.normalizeAbbrevsKey(family_var, basevalue);
          }
          var quashCountry = false;
          if (variable === "jurisdiction" && normalizedKey) {
            quashCountry = normalizedKey.indexOf(":") === -1;
          }
          if (["jurisdiction", "country"].indexOf(family_var) > -1 && basevalue === basevalue.toLowerCase()) {
            normalizedKey = basevalue.toUpperCase();
          }
          if (state2.sys.getAbbreviation) {
            if (["jurisdiction", "country", "language-name", "language-name-original"].indexOf(variable) > -1) {
              preferredJurisdiction = "default";
            } else if (Item.jurisdiction) {
              preferredJurisdiction = Item.jurisdiction;
            } else {
              preferredJurisdiction = "default";
            }
            var jurisdiction = state2.transform.loadAbbreviation(preferredJurisdiction, myabbrev_family, normalizedKey, Item.language);
            if (state2.transform.abbrevs[jurisdiction][myabbrev_family] && normalizedKey) {
              var abbrev = state2.transform.abbrevs[jurisdiction][myabbrev_family][normalizedKey];
              if (tok.strings.form === "short" && abbrev) {
                if (quashCountry) {
                  value = "";
                } else {
                  value = abbrev;
                }
              } else {
                value = getCountryOrJurisdiction(variable, normalizedKey, quashCountry);
              }
            }
          }
          if (!value && (!state2.opt.development_extensions.require_explicit_legal_case_title_short || Item.type !== "legal_case") && altvar && Item[altvar] && use_field) {
            value = Item[altvar];
          }
          if (!value && !state2.sys.getAbbreviation && state2.sys.getHumanForm) {
            value = getCountryOrJurisdiction(variable, normalizedKey, quashCountry);
          }
          if (!value && !quashCountry && (!state2.sys.getHumanForm || variable !== "jurisdiction")) {
            value = basevalue;
          }
          if (state2.opt.development_extensions.force_title_abbrev_fallback) {
            if (variable === "title" && value === basevalue && Item["title-short"]) {
              value = Item["title-short"];
            }
          }
          return value;
        }
        function getFieldLocale(Item, field) {
          var ret = state.opt["default-locale"][0].slice(0, 2);
          var localeRex;
          if (state.opt.development_extensions.strict_text_case_locales) {
            localeRex = new RegExp("^([a-zA-Z]{2})(?:$|-.*| .*)");
          } else {
            localeRex = new RegExp("^([a-zA-Z]{2})(?:$|-.*|.*)");
          }
          if (Item.language) {
            var m = ("" + Item.language).match(localeRex);
            if (m) {
              ret = m[1];
            } else {
              ret = "tlh";
            }
          }
          if (Item.multi && Item.multi && Item.multi.main && Item.multi.main[field]) {
            ret = Item.multi.main[field];
          }
          if (!state.opt.development_extensions.strict_text_case_locales || state.opt.development_extensions.normalize_lang_keys_to_lowercase) {
            ret = ret.toLowerCase();
          }
          return ret;
        }
        function getTextSubField(Item, field, locale_type, use_default, stopOrig, family_var) {
          var opt, o, ret, opts;
          var usedOrig = stopOrig;
          var usingOrig = false;
          if (!Item[field]) {
            return {
              name: "",
              usedOrig: stopOrig,
              token: CSL3.Util.cloneToken(this)
            };
          }
          var stickyLongForm = false;
          if (CSL3.VARIABLES_WITH_SHORT_FORM.indexOf(field) > -1 && family_var) {
            field = field + "-short";
            stickyLongForm = true;
          }
          var breakMe = false;
          var firstValue = null;
          var fieldsToTry = [];
          if (field.slice(-6) === "-short") {
            fieldsToTry.push(field);
            fieldsToTry.push(field.slice(0, -6));
          } else {
            fieldsToTry.push(field);
          }
          for (var h = 0, hlen = fieldsToTry.length; h < hlen; h++) {
            var variantMatch = false;
            var field = fieldsToTry[h];
            ret = { name: "", usedOrig: stopOrig, locale: getFieldLocale(Item, field) };
            opts = state.opt[locale_type] ? state.opt[locale_type].slice() : [];
            var hasVal = false;
            if (locale_type === "locale-orig") {
              if (!stopOrig) {
                ret.name = Item[field];
                ret.usedOrig = false;
              }
              hasVal = true;
              usingOrig = true;
            } else if (use_default && ("undefined" === typeof opts || opts.length === 0)) {
              ret.name = Item[field];
              ret.usedOrig = true;
              hasVal = true;
              usingOrig = true;
            }
            if (!hasVal) {
              for (var i = 0, ilen = opts.length; i < ilen; i += 1) {
                opt = opts[i];
                o = opt.split(/[\-_]/)[0];
                if (opt && Item.multi && Item.multi._keys[field] && Item.multi._keys[field][opt]) {
                  ret.name = Item.multi._keys[field][opt];
                  ret.locale = opt;
                  hasVal = true;
                  variantMatch = true;
                  usingOrig = false;
                  break;
                } else if (o && Item.multi && Item.multi._keys[field] && Item.multi._keys[field][o]) {
                  ret.name = Item.multi._keys[field][o];
                  ret.locale = o;
                  hasVal = true;
                  variantMatch = true;
                  usingOrig = false;
                  break;
                }
              }
              if (!ret.name && use_default) {
                ret = { name: Item[field], usedOrig: true, locale: getFieldLocale(Item, field) };
                usingOrig = true;
              }
            }
            ret.token = CSL3.Util.cloneToken(this);
            if (h === 0) {
              if (variantMatch) {
                ret.found_variant_ok = true;
              }
              firstValue = ret;
              if (!stickyLongForm && ("undefined" === typeof opts || opts.length === 0)) {
                breakMe = true;
              }
              if (variantMatch) {
                breakMe = true;
              }
            } else {
              if (!stickyLongForm && !variantMatch && firstValue) {
                ret = firstValue;
                field = fieldsToTry[0];
              } else if (variantMatch) {
                ret.found_variant_ok = true;
              }
            }
            if (["title", "container-title"].indexOf(field) > -1) {
              if (!usedOrig && (!ret.token.strings["text-case"] || ret.token.strings["text-case"] === "sentence" || ret.token.strings["text-case"] === "normal")) {
                var locale = state.opt.lang;
                var lang;
                if (usingOrig) {
                  lang = false;
                } else {
                  lang = ret.locale;
                }
                var seg = field.slice(0, -5);
                var sentenceCase = ret.token.strings["text-case"] === "sentence" ? true : false;
                ret.name = CSL3.titlecaseSentenceOrNormal(state, Item, seg, lang, sentenceCase);
                delete ret.token.strings["text-case"];
              }
            }
            if (breakMe) {
              break;
            }
          }
          return ret;
        }
        this.getTextSubField = getTextSubField;
        function loadAbbreviation(jurisdiction, category, orig, lang) {
          if (!jurisdiction) {
            jurisdiction = "default";
          }
          var country = jurisdiction.split(":")[0];
          var domain = CSL3.getAbbrevsDomain(state, country, lang);
          if (domain) {
            jurisdiction += "@" + domain;
          }
          if (!orig) {
            if (!state.transform.abbrevs[jurisdiction]) {
              state.transform.abbrevs[jurisdiction] = new state.sys.AbbreviationSegments();
            }
            if (!state.transform.abbrevs[jurisdiction][category]) {
              state.transform.abbrevs[jurisdiction][category] = {};
            }
            return jurisdiction;
          }
          if (state.sys.getAbbreviation) {
            jurisdiction = state.sys.getAbbreviation(state.opt.styleID, state.transform.abbrevs, jurisdiction, category, orig);
            if (!jurisdiction) {
              jurisdiction = "default";
              if (domain) {
                jurisdiction += "@" + domain;
              }
            }
          }
          return jurisdiction;
        }
        this.loadAbbreviation = loadAbbreviation;
        function publisherCheck(tok, Item, primary, family_var) {
          var varname = tok.variables[0];
          if (state.publisherOutput && primary) {
            if (["publisher", "publisher-place"].indexOf(varname) === -1) {
              return false;
            } else {
              state.publisherOutput[varname + "-token"] = tok;
              state.publisherOutput.varlist.push(varname);
              var lst = primary.split(/;\s*/);
              if (lst.length === state.publisherOutput[varname + "-list"].length) {
                state.publisherOutput[varname + "-list"] = lst;
              }
              for (var i = 0, ilen = lst.length; i < ilen; i += 1) {
                lst[i] = abbreviate(state, tok, Item, false, lst[i], family_var, true);
              }
              state.tmp[varname + "-token"] = tok;
              return true;
            }
          }
          return false;
        }
        function citeFormCheck(Item, value) {
          var m = value.match(/^#([0-9]+).*>>>/);
          if (m && m[1]) {
            Item["cite-form"] = m[1];
          }
        }
        function quashCheck(jurisdiction, value) {
          var m = value.match(/^(?:#[0-9]+)*(?:!((?:[-_a-z]+(?:(?:.*)))(?:,(?:[-_a-z]+(?:(?:.*))))*))*>>>/);
          if (m) {
            value = value.slice(m[0].length);
            if (m[1]) {
              var fields = m[1].split(",");
              for (var i = 0, ilen = fields.length; i < ilen; i += 1) {
                var rawField = fields[i];
                var mm = rawField.match(/^([-_a-z]+)(?:\:(.*))*$/);
                var field = mm[1];
                var trimmer = state.tmp.abbrev_trimmer;
                if (mm[2]) {
                  if (trimmer && jurisdiction) {
                    if (!trimmer[jurisdiction]) {
                      trimmer[jurisdiction] = {};
                    }
                    trimmer[jurisdiction][field] = mm[2];
                  }
                } else if (state.tmp.done_vars.indexOf(field) === -1) {
                  if (trimmer && jurisdiction) {
                    if (!trimmer.QUASHES[jurisdiction]) {
                      trimmer.QUASHES[jurisdiction] = {};
                    }
                    trimmer.QUASHES[jurisdiction][field] = true;
                  }
                  state.tmp.done_vars.push(field);
                }
              }
            }
          }
          return value;
        }
        this.quashCheck = quashCheck;
        function getOutputFunction(variables, family_var, abbreviation_fallback, alternative_varname) {
          var localesets;
          var langPrefs = CSL3.LangPrefsMap[variables[0]];
          if (!langPrefs) {
            localesets = false;
          } else {
            localesets = state.opt["cite-lang-prefs"][langPrefs];
          }
          return function(state2, Item, item) {
            var primary, primary_locale, secondary, secondary_locale, tertiary, tertiary_locale, primary_tok;
            if (!variables[0] || !Item[variables[0]] && !Item[alternative_varname]) {
              return null;
            }
            if (!state2.tmp.just_looking && item && item["suppress-author"]) {
              if (!state2.tmp.probably_rendered_something && state2.tmp.can_substitute.length() > 1) {
                return null;
              }
            }
            var slot = { primary: false, secondary: false, tertiary: false };
            if (state2.tmp.area.slice(-5) === "_sort") {
              slot.primary = "locale-sort";
            } else {
              if (localesets && localesets.length === 1 && localesets[0] === "locale-orig") {
                slot.primary = "locale-orig";
                localesets = false;
              } else if (localesets && !state2.tmp.multi_layout) {
                var slotnames = ["primary", "secondary", "tertiary"];
                for (var i = 0, ilen = slotnames.length; i < ilen; i += 1) {
                  if (localesets.length - 1 < i) {
                    break;
                  }
                  if (localesets[i]) {
                    slot[slotnames[i]] = "locale-" + localesets[i];
                  }
                }
              } else {
                slot.primary = "locale-orig";
              }
            }
            if (variables[0] === "title-short" || state2.tmp.area !== "bibliography" && !(state2.tmp.area === "citation" && state2.opt.xclass === "note" && item && !item.position)) {
              slot.secondary = false;
              slot.tertiary = false;
            }
            if (state2.tmp.multi_layout) {
              slot.secondary = false;
              slot.tertiary = false;
            }
            if (state2.tmp["publisher-list"]) {
              if (variables[0] === "publisher") {
                state2.tmp["publisher-token"] = this;
              } else if (variables[0] === "publisher-place") {
                state2.tmp["publisher-place-token"] = this;
              }
              return null;
            }
            var oldLangArray = state2.tmp.lang_array.slice();
            var res = getTextSubField.call(this, Item, variables[0], slot.primary, true, null, family_var);
            primary = res.name;
            primary_locale = res.locale;
            var primary_tok = res.token;
            var primaryUsedOrig = res.usedOrig;
            if (family_var && !res.found_variant_ok) {
              primary = abbreviate(state2, primary_tok, Item, alternative_varname, primary, family_var, true);
              if (primary) {
                citeFormCheck(Item, primary);
                if (!state2.tmp.just_looking) {
                  primary = quashCheck(Item.jurisdiction, primary);
                }
              }
            }
            if (publisherCheck(this, Item, primary, family_var)) {
              state2.tmp.lang_array = oldLangArray;
              return null;
            }
            secondary = false;
            tertiary = false;
            var secondary_tok;
            var tertiary_tok;
            if (slot.secondary) {
              res = getTextSubField.call(this, Item, variables[0], slot.secondary, false, res.usedOrig, null, family_var);
              secondary = res.name;
              secondary_locale = res.locale;
              secondary_tok = res.token;
              if (family_var && !res.found_variant_ok) {
                if (secondary) {
                  secondary = abbreviate(state2, secondary_tok, Item, false, secondary, family_var, true);
                }
              }
            }
            if (slot.tertiary) {
              res = getTextSubField.call(this, Item, variables[0], slot.tertiary, false, res.usedOrig, null, family_var);
              tertiary = res.name;
              tertiary_locale = res.locale;
              tertiary_tok = res.token;
              if (family_var && !res.found_variant_ok) {
                if (tertiary) {
                  tertiary = abbreviate(state2, tertiary_tok, Item, false, tertiary, family_var, true);
                }
              }
            }
            var primaryPrefix;
            if (slot.primary === "locale-translit") {
              primaryPrefix = state2.opt.citeAffixes[langPrefs][slot.primary].prefix;
            }
            if (primaryPrefix === "<i>" && variables[0] === "title" && !primaryUsedOrig) {
              var hasItalic = false;
              for (var i = 0, ilen = primary_tok.decorations.length; i < ilen; i += 1) {
                if (primary_tok.decorations[i][0] === "@font-style" && primary_tok.decorations[i][1] === "italic") {
                  hasItalic = true;
                }
              }
              if (!hasItalic) {
                primary_tok.decorations.push(["@font-style", "italic"]);
              }
            }
            if (primary_locale !== "en" && primary_tok.strings["text-case"] === "title") {
              primary_tok.strings["text-case"] = "passthrough";
            }
            if ("title" === variables[0]) {
              primary = CSL3.demoteNoiseWords(state2, primary, this["leading-noise-words"]);
            }
            if (secondary || tertiary) {
              state2.output.openLevel("empty");
              primary_tok.strings.suffix = primary_tok.strings.suffix.replace(/[ .,]+$/, "");
              if (primary_locale) {
                state2.tmp.lang_array = [primary_locale].concat(oldLangArray);
              }
              CSL3.UPDATE_GROUP_CONTEXT_CONDITION(state2, null, null, primary_tok, primary_tok.strings.prefix + primary);
              state2.output.append(primary, primary_tok);
              state2.tmp.probably_rendered_something = true;
              if (primary === secondary) {
                secondary = false;
              }
              if (secondary) {
                secondary_tok.strings.prefix = state2.opt.citeAffixes[langPrefs][slot.secondary].prefix;
                secondary_tok.strings.suffix = state2.opt.citeAffixes[langPrefs][slot.secondary].suffix;
                if (!secondary_tok.strings.prefix) {
                  secondary_tok.strings.prefix = " ";
                }
                for (var i = secondary_tok.decorations.length - 1; i > -1; i += -1) {
                  if (["@quotes/true", "@font-style/italic", "@font-style/oblique", "@font-weight/bold"].indexOf(secondary_tok.decorations[i].join("/")) > -1) {
                    secondary_tok.decorations = secondary_tok.decorations.slice(0, i).concat(secondary_tok.decorations.slice(i + 1));
                  }
                }
                if (secondary_locale !== "en" && secondary_tok.strings["text-case"] === "title") {
                  secondary_tok.strings["text-case"] = "passthrough";
                }
                if (secondary_locale) {
                  state2.tmp.lang_array = [secondary_locale].concat(oldLangArray);
                }
                var secondary_outer = new CSL3.Token();
                secondary_outer.decorations.push(["@font-style", "normal"]);
                secondary_outer.decorations.push(["@font-weight", "normal"]);
                state2.output.openLevel(secondary_outer);
                state2.output.append(secondary, secondary_tok);
                state2.output.closeLevel();
                var blob_obj = state2.output.current.value();
                var blobs_pos = state2.output.current.value().blobs.length - 1;
              }
              if (primary === tertiary) {
                tertiary = false;
              }
              if (tertiary) {
                tertiary_tok.strings.prefix = state2.opt.citeAffixes[langPrefs][slot.tertiary].prefix;
                tertiary_tok.strings.suffix = state2.opt.citeAffixes[langPrefs][slot.tertiary].suffix;
                if (!tertiary_tok.strings.prefix) {
                  tertiary_tok.strings.prefix = " ";
                }
                for (var i = tertiary_tok.decorations.length - 1; i > -1; i += -1) {
                  if (["@quotes/true", "@font-style/italic", "@font-style/oblique", "@font-weight/bold"].indexOf(tertiary_tok.decorations[i].join("/")) > -1) {
                    tertiary_tok.decorations = tertiary_tok.decorations.slice(0, i).concat(tertiary_tok.decorations.slice(i + 1));
                  }
                }
                if (tertiary_locale !== "en" && tertiary_tok.strings["text-case"] === "title") {
                  tertiary_tok.strings["text-case"] = "passthrough";
                }
                if (tertiary_locale) {
                  state2.tmp.lang_array = [tertiary_locale].concat(oldLangArray);
                }
                var tertiary_outer = new CSL3.Token();
                tertiary_outer.decorations.push(["@font-style", "normal"]);
                tertiary_outer.decorations.push(["@font-weight", "normal"]);
                state2.output.openLevel(tertiary_outer);
                state2.output.append(tertiary, tertiary_tok);
                state2.output.closeLevel();
                var blob_obj = state2.output.current.value();
                var blobs_pos = state2.output.current.value().blobs.length - 1;
              }
              state2.output.closeLevel();
            } else {
              if (primary_locale) {
                state2.tmp.lang_array = [primary_locale].concat(oldLangArray);
              }
              CSL3.UPDATE_GROUP_CONTEXT_CONDITION(state2, null, null, primary_tok, primary_tok.strings.prefix + primary);
              state2.output.append(primary, primary_tok);
              state2.tmp.probably_rendered_something = true;
            }
            state2.tmp.lang_array = oldLangArray;
            if (state2.tmp.can_block_substitute) {
              state2.tmp.name_node.children.push(state2.output.current.value());
            }
            return null;
          };
        }
        this.getOutputFunction = getOutputFunction;
      };
      CSL3.Token = function(name, tokentype, conditional) {
        this.name = name;
        this.strings = {};
        this.strings.delimiter = void 0;
        this.strings.prefix = "";
        this.strings.suffix = "";
        this.decorations = [];
        this.variables = [];
        this.execs = [];
        this.tokentype = tokentype;
      };
      CSL3.Util.cloneToken = function(token) {
        var newtok, key, pos, len;
        if ("string" === typeof token) {
          return token;
        }
        newtok = new CSL3.Token(token.name, token.tokentype);
        for (var key in token.strings) {
          if (token.strings.hasOwnProperty(key)) {
            newtok.strings[key] = token.strings[key];
          }
        }
        if (token.decorations) {
          newtok.decorations = [];
          for (pos = 0, len = token.decorations.length; pos < len; pos += 1) {
            newtok.decorations.push(token.decorations[pos].slice());
          }
        }
        if (token.variables) {
          newtok.variables = token.variables.slice();
        }
        if (token.execs) {
          newtok.execs = token.execs.slice();
          if (token.tests) {
            newtok.tests = token.tests.slice();
          }
        }
        return newtok;
      };
      CSL3.AmbigConfig = function() {
        this.maxvals = [];
        this.minval = 1;
        this.names = [];
        this.givens = [];
        this.year_suffix = false;
        this.disambiguate = 0;
      };
      CSL3.Blob = function(str, token, levelname) {
        var len, pos, key;
        this.levelname = levelname;
        if (token) {
          this.strings = { "prefix": "", "suffix": "" };
          for (var key in token.strings) {
            if (token.strings.hasOwnProperty(key)) {
              this.strings[key] = token.strings[key];
            }
          }
          this.decorations = [];
          if (token.decorations === void 0) {
            len = 0;
          } else {
            len = token.decorations.length;
          }
          for (pos = 0; pos < len; pos += 1) {
            this.decorations.push(token.decorations[pos].slice());
          }
        } else {
          this.strings = {};
          this.strings.prefix = "";
          this.strings.suffix = "";
          this.strings.delimiter = "";
          this.decorations = [];
        }
        if ("string" === typeof str) {
          this.blobs = str;
        } else if (str) {
          this.blobs = [str];
        } else {
          this.blobs = [];
        }
        this.alldecor = [this.decorations];
      };
      CSL3.Blob.prototype.push = function(blob) {
        if ("string" === typeof this.blobs) {
          CSL3.error("Attempt to push blob onto string object");
        } else if (false !== blob) {
          blob.alldecor = blob.alldecor.concat(this.alldecor);
          this.blobs.push(blob);
        }
      };
      CSL3.NumericBlob = function(state, particle, num, mother_token, id) {
        this.id = id;
        this.alldecor = [];
        this.num = num;
        this.particle = particle;
        this.blobs = num.toString();
        this.status = CSL3.START;
        this.strings = {};
        if (mother_token) {
          if (mother_token.strings["text-case"]) {
            var textCase = mother_token.strings["text-case"];
            this.particle = CSL3.Output.Formatters[textCase](state, this.particle);
            this.blobs = CSL3.Output.Formatters[textCase](state, this.blobs);
          }
          this.gender = mother_token.gender;
          this.decorations = mother_token.decorations;
          this.strings.prefix = mother_token.strings.prefix;
          this.strings.suffix = mother_token.strings.suffix;
          this.strings["text-case"] = mother_token.strings["text-case"];
          this.successor_prefix = mother_token.successor_prefix;
          this.range_prefix = mother_token.range_prefix;
          this.splice_prefix = mother_token.splice_prefix;
          this.formatter = mother_token.formatter;
          if (!this.formatter) {
            this.formatter = new CSL3.Output.DefaultFormatter();
          }
          if (this.formatter) {
            this.type = this.formatter.format(1);
          }
        } else {
          this.decorations = [];
          this.strings.prefix = "";
          this.strings.suffix = "";
          this.successor_prefix = "";
          this.range_prefix = "";
          this.splice_prefix = "";
          this.formatter = new CSL3.Output.DefaultFormatter();
        }
      };
      CSL3.NumericBlob.prototype.setFormatter = function(formatter) {
        this.formatter = formatter;
        this.type = this.formatter.format(1);
      };
      CSL3.Output.DefaultFormatter = function() {
      };
      CSL3.Output.DefaultFormatter.prototype.format = function(num) {
        return num.toString();
      };
      CSL3.NumericBlob.prototype.checkNext = function(next, start) {
        if (start) {
          this.status = CSL3.START;
          if ("object" === typeof next) {
            if (next.num === this.num + 1) {
              next.status = CSL3.SUCCESSOR;
            } else {
              next.status = CSL3.SEEN;
            }
          }
        } else if (!next || !next.num || this.type !== next.type || next.num !== this.num + 1) {
          if (this.status === CSL3.SUCCESSOR_OF_SUCCESSOR) {
            this.status = CSL3.END;
          }
          if ("object" === typeof next) {
            next.status = CSL3.SEEN;
          }
        } else {
          if (this.status === CSL3.START || this.status === CSL3.SEEN) {
            next.status = CSL3.SUCCESSOR;
          } else if (this.status === CSL3.SUCCESSOR || this.status === CSL3.SUCCESSOR_OF_SUCCESSOR) {
            if (this.range_prefix) {
              next.status = CSL3.SUCCESSOR_OF_SUCCESSOR;
              this.status = CSL3.SUPPRESS;
            } else {
              next.status = CSL3.SUCCESSOR;
            }
          }
        }
      };
      CSL3.NumericBlob.prototype.checkLast = function(last) {
        if (this.status === CSL3.SEEN || last.num !== this.num - 1 && this.status === CSL3.SUCCESSOR) {
          this.status = CSL3.SUCCESSOR;
          return true;
        }
        return false;
      };
      CSL3.Util.fixDateNode = function(parent, pos, node) {
        var form, variable, datexml, subnode, partname, attr, val, prefix, suffix, children, subchildren, display, cslid;
        var lingo = this.cslXml.getAttributeValue(node, "lingo");
        var default_locale = this.cslXml.getAttributeValue(node, "default-locale");
        this.build.date_key = true;
        form = this.cslXml.getAttributeValue(node, "form");
        var lingo;
        if (default_locale) {
          lingo = this.opt["default-locale"][0];
        } else {
          lingo = this.cslXml.getAttributeValue(node, "lingo");
        }
        if (!this.getDate(form, default_locale)) {
          return parent;
        }
        var dateparts = this.cslXml.getAttributeValue(node, "date-parts");
        variable = this.cslXml.getAttributeValue(node, "variable");
        prefix = this.cslXml.getAttributeValue(node, "prefix");
        suffix = this.cslXml.getAttributeValue(node, "suffix");
        display = this.cslXml.getAttributeValue(node, "display");
        cslid = this.cslXml.getAttributeValue(node, "cslid");
        datexml = this.cslXml.nodeCopy(this.getDate(form, default_locale));
        this.cslXml.setAttribute(datexml, "lingo", this.opt.lang);
        this.cslXml.setAttribute(datexml, "form", form);
        this.cslXml.setAttribute(datexml, "date-parts", dateparts);
        this.cslXml.setAttribute(datexml, "cslid", cslid);
        this.cslXml.setAttribute(datexml, "variable", variable);
        this.cslXml.setAttribute(datexml, "default-locale", default_locale);
        if (prefix) {
          this.cslXml.setAttribute(datexml, "prefix", prefix);
        }
        if (suffix) {
          this.cslXml.setAttribute(datexml, "suffix", suffix);
        }
        if (display) {
          this.cslXml.setAttribute(datexml, "display", display);
        }
        children = this.cslXml.children(datexml);
        for (var key in children) {
          subnode = children[key];
          if ("date-part" === this.cslXml.nodename(subnode)) {
            partname = this.cslXml.getAttributeValue(subnode, "name");
            if (default_locale) {
              this.cslXml.setAttributeOnNodeIdentifiedByNameAttribute(datexml, "date-part", partname, "@default-locale", "true");
            }
          }
        }
        children = this.cslXml.children(node);
        for (var key in children) {
          subnode = children[key];
          if ("date-part" === this.cslXml.nodename(subnode)) {
            partname = this.cslXml.getAttributeValue(subnode, "name");
            subchildren = this.cslXml.attributes(subnode);
            for (attr in subchildren) {
              if ("@name" === attr) {
                continue;
              }
              if (lingo && lingo !== this.opt.lang) {
                if (["@suffix", "@prefix", "@form"].indexOf(attr) > -1) {
                  continue;
                }
              }
              val = subchildren[attr];
              this.cslXml.setAttributeOnNodeIdentifiedByNameAttribute(datexml, "date-part", partname, attr, val);
            }
          }
        }
        if ("year" === this.cslXml.getAttributeValue(node, "date-parts")) {
          this.cslXml.deleteNodeByNameAttribute(datexml, "month");
          this.cslXml.deleteNodeByNameAttribute(datexml, "day");
        } else if ("year-month" === this.cslXml.getAttributeValue(node, "date-parts")) {
          this.cslXml.deleteNodeByNameAttribute(datexml, "day");
        } else if ("month-day" === this.cslXml.getAttributeValue(node, "date-parts")) {
          var childNodes = this.cslXml.children(datexml);
          for (var i = 1, ilen = this.cslXml.numberofnodes(childNodes); i < ilen; i++) {
            if (this.cslXml.getAttributeValue(childNodes[i], "name") === "year") {
              this.cslXml.setAttribute(childNodes[i - 1], "suffix", "");
              break;
            }
          }
          this.cslXml.deleteNodeByNameAttribute(datexml, "year");
        }
        return this.cslXml.insertChildNodeAfter(parent, node, pos, datexml);
      };
      CSL3.dateMacroAsSortKey = function(state, Item) {
        CSL3.dateAsSortKey.call(this, state, Item, true);
      };
      CSL3.dateAsSortKey = function(state, Item, isMacro) {
        var dp, elem, value, e, yr, prefix, i, ilen;
        var variable = this.variables[0];
        var macroFlag = "empty";
        if (isMacro && state.tmp.extension) {
          macroFlag = "macro-with-date";
        }
        dp = Item[variable];
        if ("undefined" === typeof dp) {
          dp = { "date-parts": [[0]] };
        }
        if ("undefined" === typeof this.dateparts) {
          this.dateparts = ["year", "month", "day"];
        }
        if (dp.raw) {
          dp = state.fun.dateparser.parseDateToArray(dp.raw);
        } else if (dp["date-parts"]) {
          dp = state.dateParseArray(dp);
        }
        if ("undefined" === typeof dp) {
          dp = {};
        }
        if (dp.year) {
          for (i = 0, ilen = CSL3.DATE_PARTS_INTERNAL.length; i < ilen; i += 1) {
            elem = CSL3.DATE_PARTS_INTERNAL[i];
            value = 0;
            e = elem;
            if (e.slice(-4) === "_end") {
              e = e.slice(0, -4);
            }
            if (dp[elem] && this.dateparts.indexOf(e) > -1) {
              value = dp[elem];
            }
            if (elem.slice(0, 4) === "year") {
              yr = CSL3.Util.Dates[e].numeric(state, value);
              var prefix = "1";
              if (yr[0] === "-") {
                prefix = "0";
                yr = yr.slice(1);
                yr = 9999 - parseInt(yr, 10);
              }
              state.output.append(CSL3.Util.Dates[elem.slice(0, 4)].numeric(state, prefix + yr), macroFlag);
            } else {
              value = CSL3.Util.Dates[e]["numeric-leading-zeros"](state, value);
              if (!value) {
                value = "00";
              }
              state.output.append(value, macroFlag);
            }
          }
        }
      };
      CSL3.Engine.prototype.dateParseArray = function(date_obj) {
        var ret, field, dp, exts;
        ret = {};
        for (field in date_obj) {
          if (field === "date-parts") {
            dp = date_obj["date-parts"];
            if (dp.length > 1) {
              if (dp[0].length !== dp[1].length) {
                CSL3.error("CSL data error: element mismatch in date range input.");
              }
            }
            exts = ["", "_end"];
            for (var i = 0, ilen = dp.length; i < ilen; i += 1) {
              for (var j = 0, jlen = CSL3.DATE_PARTS.length; j < jlen; j += 1) {
                if (isNaN(parseInt(dp[i][j], 10))) {
                  ret[CSL3.DATE_PARTS[j] + exts[i]] = void 0;
                } else {
                  ret[CSL3.DATE_PARTS[j] + exts[i]] = parseInt(dp[i][j], 10);
                }
              }
            }
          } else if (date_obj.hasOwnProperty(field)) {
            if (field === "literal" && "object" === typeof date_obj.literal && "string" === typeof date_obj.literal.part) {
              CSL3.debug("Warning: fixing up weird literal date value");
              ret.literal = date_obj.literal.part;
            } else {
              ret[field] = date_obj[field];
            }
          }
        }
        return ret;
      };
      CSL3.Util.Names = {};
      CSL3.Util.Names.compareNamesets = CSL3.NameOutput.prototype._compareNamesets;
      CSL3.Util.Names.unInitialize = function(state, name) {
        var i, ilen, namelist, punctlist, ret;
        if (!name) {
          return "";
        }
        namelist = name.split(/(?:\-|\s+)/);
        punctlist = name.match(/(\-|\s+)/g);
        ret = "";
        for (i = 0, ilen = namelist.length; i < ilen; i += 1) {
          ret += namelist[i];
          if (i < ilen - 1) {
            ret += punctlist[i];
          }
        }
        return ret;
      };
      CSL3.Util.Names.initializeWith = function(state, name, terminator, normalizeOnly) {
        var i, ilen, mm, lst, ret;
        if (!name) {
          return "";
        }
        if (!terminator) {
          terminator = "";
        }
        if (["Lord", "Lady"].indexOf(name) > -1 || !name.replace(/^(?:<[^>]+>)*/, "").match(CSL3.STARTSWITH_ROMANESQUE_REGEXP) && !terminator.match("%s")) {
          return name;
        }
        if (state.opt["initialize-with-hyphen"] === false) {
          name = name.replace(/\-/g, " ");
        }
        name = name.replace(/\s*\-\s*/g, "-").replace(/\s+/g, " ");
        name = name.replace(/-([a-z])/g, "\u2013$1");
        for (var i = name.length - 2; i > -1; i += -1) {
          if (name.slice(i, i + 1) === "." && name.slice(i + 1, i + 2) !== " ") {
            name = name.slice(0, i) + ". " + name.slice(i + 1);
          }
        }
        var nameSplits = CSL3.Output.Formatters.nameDoppel.split(name);
        var namelist = [];
        namelist = [nameSplits.strings[0]];
        if (nameSplits.tags.length === 0) {
          var mmm = namelist[0].match(/[^\.]+$/);
          if (mmm && mmm[0].length === 1 && mmm[0] !== mmm[0].toLowerCase()) {
            namelist[0] += ".";
          }
        }
        for (i = 1, ilen = nameSplits.strings.length; i < ilen; i += 1) {
          namelist.push(nameSplits.tags[i - 1]);
          namelist.push(nameSplits.strings[i]);
        }
        if (normalizeOnly) {
          ret = this.doNormalize(state, namelist, terminator);
        } else {
          ret = this.doInitialize(state, namelist, terminator);
        }
        ret = ret.replace(/\u2013([a-z])/g, "-$1");
        return ret;
      };
      CSL3.Util.Names.notag = function(str) {
        return str.replace(/^(?:<[^>]+>)*/, "");
      };
      CSL3.Util.Names.mergetag = function(state, tagstr, newstr) {
        var m = tagstr.match(/(?:-*<[^>]+>-*)/g);
        if (!m) {
          return newstr;
        } else {
          tagstr = m.join("");
        }
        m = newstr.match(/^(.*[^\s])*(\s+)$/);
        if (m) {
          m[1] = m[1] ? m[1] : "";
          newstr = m[1] + tagstr + m[2];
        } else {
          newstr = newstr + tagstr;
        }
        return newstr;
      };
      CSL3.Util.Names.tagonly = function(state, str) {
        var m = str.match(/(?:<[^>]+>)+/);
        if (!m) {
          return str;
        } else {
          return m.join("");
        }
      };
      CSL3.Util.Names.doNormalize = function(state, namelist, terminator) {
        var i, ilen;
        terminator = terminator ? terminator : "";
        var isAbbrev = [];
        for (i = 0, ilen = namelist.length; i < ilen; i += 1) {
          if (this.notag(namelist[i]).length > 1 && this.notag(namelist[i]).slice(-1) === ".") {
            namelist[i] = namelist[i].replace(/^(.*)\.(.*)$/, "$1$2");
            isAbbrev.push(true);
          } else if (namelist[i].length === 1 && namelist[i].toUpperCase() === namelist[i]) {
            isAbbrev.push(true);
          } else {
            isAbbrev.push(false);
          }
        }
        for (i = 0, ilen = namelist.length; i < ilen; i += 2) {
          if (isAbbrev[i]) {
            if (i < namelist.length - 2) {
              namelist[i + 1] = this.tagonly(state, namelist[i + 1]);
              if (!isAbbrev[i + 2]) {
                namelist[i + 1] = this.tagonly(state, namelist[i + 1]) + " ";
              }
              if (namelist[i + 2].length > 1) {
                namelist[i + 1] = terminator.replace(/\ufeff$/, "") + namelist[i + 1];
              } else {
                namelist[i + 1] = this.mergetag(state, namelist[i + 1], terminator);
              }
            }
            if (i === namelist.length - 1) {
              namelist[i] = namelist[i] + terminator;
            }
          }
        }
        return namelist.join("").replace(/[\u0009\u000a\u000b\u000c\u000d\u0020\ufeff\u00a0]+$/, "").replace(/\s*\-\s*/g, "-").replace(/[\u0009\u000a\u000b\u000c\u000d\u0020]+/g, " ");
      };
      CSL3.Util.Names.doInitialize = function(state, namelist, terminator) {
        var i, ilen, m, j, jlen, lst, n;
        for (i = 0, ilen = namelist.length; i < ilen; i += 2) {
          n = namelist[i];
          if (!n) {
            continue;
          }
          m = n.match(CSL3.NAME_INITIAL_REGEXP);
          if (!m && (!n.match(CSL3.STARTSWITH_ROMANESQUE_REGEXP) && n.length > 1 && terminator.match("%s"))) {
            m = n.match(/(.)(.*)/);
          }
          if (m && m[2] && m[3]) {
            m[1] = m[1] + m[2];
            m[2] = "";
          }
          if (m && m[1].slice(0, 1) === m[1].slice(0, 1).toUpperCase()) {
            var extra = "";
            if (m[2]) {
              var s = "";
              lst = m[2].split("");
              for (j = 0, jlen = lst.length; j < jlen; j += 1) {
                var c = lst[j];
                if (c === c.toUpperCase()) {
                  s += c;
                } else {
                  break;
                }
              }
              if (s.length < m[2].length) {
                extra = CSL3.toLocaleLowerCase.call(state, s);
              }
            }
            namelist[i] = m[1] + extra;
            if (i < ilen - 1) {
              if (terminator.match("%s")) {
                namelist[i] = terminator.replace("%s", namelist[i]);
              } else {
                if (namelist[i + 1].indexOf("-") > -1) {
                  namelist[i + 1] = this.mergetag(state, namelist[i + 1].replace("-", ""), terminator) + "-";
                } else {
                  namelist[i + 1] = this.mergetag(state, namelist[i + 1], terminator);
                }
              }
            } else {
              if (terminator.match("%s")) {
                namelist[i] = terminator.replace("%s", namelist[i]);
              } else {
                namelist.push(terminator);
              }
            }
          } else if (n.match(CSL3.ROMANESQUE_REGEXP) && (!m || !m[3])) {
            namelist[i] = " " + n;
          }
        }
        var ret = namelist.join("");
        ret = ret.replace(/[\u0009\u000a\u000b\u000c\u000d\u0020\ufeff\u00a0]+$/, "").replace(/\s*\-\s*/g, "-").replace(/[\u0009\u000a\u000b\u000c\u000d\u0020]+/g, " ");
        return ret;
      };
      CSL3.Util.Names.getRawName = function(name) {
        var ret = [];
        if (name.literal) {
          ret.push(name.literal);
        } else {
          if (name.given) {
            ret.push(name.given);
          }
          if (name.family) {
            ret.push(name.family);
          }
        }
        return ret.join(" ");
      };
      CSL3.Util.Dates = {};
      CSL3.Util.Dates.year = {};
      CSL3.Util.Dates.year["long"] = function(state, num) {
        if (!num) {
          if ("boolean" === typeof num) {
            num = "";
          } else {
            num = 0;
          }
        }
        return num.toString();
      };
      CSL3.Util.Dates.year.imperial = function(state, num, end) {
        var year = "";
        if (!num) {
          if ("boolean" === typeof num) {
            num = "";
          } else {
            num = 0;
          }
        }
        end = end ? "_end" : "";
        var month = state.tmp.date_object["month" + end];
        month = month ? "" + month : "1";
        while (month.length < 2) {
          month = "0" + month;
        }
        var day = state.tmp.date_object["day" + end];
        day = day ? "" + day : "1";
        while (day.length < 2) {
          day = "0" + day;
        }
        var date = parseInt(num + month + day, 10);
        var label;
        var offset;
        if (date >= 18680908 && date < 19120730) {
          label = "\u660E\u6CBB";
          offset = 1867;
        } else if (date >= 19120730 && date < 19261225) {
          label = "\u5927\u6B63";
          offset = 1911;
        } else if (date >= 19261225 && date < 19890108) {
          label = "\u662D\u548C";
          offset = 1925;
        } else if (date >= 19890108) {
          label = "\u5E73\u6210";
          offset = 1988;
        }
        if (label && offset) {
          var normalizedKey = label;
          if (state.sys.normalizeAbbrevsKey) {
            normalizedKey = state.sys.normalizeAbbrevsKey("number", label);
          }
          if (!state.transform.abbrevs["default"]["number"][normalizedKey]) {
            state.transform.loadAbbreviation("default", "number", normalizedKey, null);
          }
          if (state.transform.abbrevs["default"]["number"][normalizedKey]) {
            label = state.transform.abbrevs["default"]["number"][normalizedKey];
          }
          year = label + (num - offset);
        }
        return year;
      };
      CSL3.Util.Dates.year["short"] = function(state, num) {
        num = num.toString();
        if (num && num.length === 4) {
          return num.substr(2);
        }
      };
      CSL3.Util.Dates.year.numeric = function(state, num) {
        var m, pre;
        num = "" + num;
        var m = num.match(/([0-9]*)$/);
        if (m) {
          pre = num.slice(0, m[1].length * -1);
          num = m[1];
        } else {
          pre = num;
          num = "";
        }
        while (num.length < 4) {
          num = "0" + num;
        }
        return pre + num;
      };
      CSL3.Util.Dates.normalizeMonth = function(num, useSeason) {
        var ret;
        if (!num) {
          num = 0;
        }
        num = "" + num;
        if (!num.match(/^[0-9]+$/)) {
          num = 0;
        }
        num = parseInt(num, 10);
        if (useSeason) {
          var res = { stub: "month-", num };
          if (res.num < 1 || res.num > 24) {
            res.num = 0;
          } else {
            while (res.num > 16) {
              res.num = res.num - 4;
            }
            if (res.num > 12) {
              res.stub = "season-";
              res.num = res.num - 12;
            }
          }
          ret = res;
        } else {
          if (num < 1 || num > 12) {
            num = 0;
          }
          ret = num;
        }
        return ret;
      };
      CSL3.Util.Dates.month = {};
      CSL3.Util.Dates.month.numeric = function(state, num) {
        var num = CSL3.Util.Dates.normalizeMonth(num);
        if (!num) {
          num = "";
        }
        return num;
      };
      CSL3.Util.Dates.month["numeric-leading-zeros"] = function(state, num) {
        var num = CSL3.Util.Dates.normalizeMonth(num);
        if (!num) {
          num = "";
        } else {
          num = "" + num;
          while (num.length < 2) {
            num = "0" + num;
          }
        }
        return num;
      };
      CSL3.Util.Dates.month["long"] = function(state, num, gender, forceDefaultLocale) {
        var res = CSL3.Util.Dates.normalizeMonth(num, true);
        var num = res.num;
        if (!num) {
          num = "";
        } else {
          num = "" + num;
          while (num.length < 2) {
            num = "0" + num;
          }
          num = state.getTerm(res.stub + num, "long", 0, 0, false, forceDefaultLocale);
        }
        return num;
      };
      CSL3.Util.Dates.month["short"] = function(state, num, gender, forceDefaultLocale) {
        var res = CSL3.Util.Dates.normalizeMonth(num, true);
        var num = res.num;
        if (!num) {
          num = "";
        } else {
          num = "" + num;
          while (num.length < 2) {
            num = "0" + num;
          }
          num = state.getTerm(res.stub + num, "short", 0, 0, false, forceDefaultLocale);
        }
        return num;
      };
      CSL3.Util.Dates.day = {};
      CSL3.Util.Dates.day.numeric = function(state, num) {
        return num.toString();
      };
      CSL3.Util.Dates.day["long"] = CSL3.Util.Dates.day.numeric;
      CSL3.Util.Dates.day["numeric-leading-zeros"] = function(state, num) {
        if (!num) {
          num = 0;
        }
        num = num.toString();
        while (num.length < 2) {
          num = "0" + num;
        }
        return num.toString();
      };
      CSL3.Util.Dates.day.ordinal = function(state, num, gender) {
        return state.fun.ordinalizer.format(num, gender);
      };
      CSL3.Util.Sort = {};
      CSL3.Util.Sort.strip_prepositions = function(str) {
        var m;
        if ("string" === typeof str) {
          m = str.match(/^(([aA]|[aA][nN]|[tT][hH][eE])\s+)/);
        }
        if (m) {
          str = str.substr(m[1].length);
        }
        return str;
      };
      CSL3.Util.substituteStart = function(state, target) {
        var element_trace, display, bib_first, func, choose_start, if_start, nodetypes;
        func = function(state2, Item, item) {
          for (var i = 0, ilen = this.decorations.length; i < ilen; i += 1) {
            if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
              state2.tmp.strip_periods += 1;
              break;
            }
          }
        };
        this.execs.push(func);
        if (this.decorations && state.opt.development_extensions.csl_reverse_lookup_support) {
          this.decorations.reverse();
          this.decorations.push(["@showid", "true", this.cslid]);
          this.decorations.reverse();
        }
        nodetypes = ["number", "date", "names"];
        if ("text" === this.name && !this.postponed_macro || nodetypes.indexOf(this.name) > -1) {
          element_trace = function(state2, Item, item) {
            if (state2.tmp.element_trace.value() === "author" || "names" === this.name) {
              if (!state2.tmp.just_looking && item && item["author-only"] && state2.tmp.area !== "intext") {
                if (!state2.tmp.probably_rendered_something) {
                } else {
                  state2.tmp.element_trace.push("suppress-me");
                }
              }
              if (!state2.tmp.just_looking && item && item["suppress-author"]) {
                if (!state2.tmp.probably_rendered_something) {
                  state2.tmp.element_trace.push("suppress-me");
                }
              }
            } else if ("date" === this.name) {
              if (!state2.tmp.just_looking && item && item["author-only"] && state2.tmp.area !== "intext") {
                if (state2.tmp.probably_rendered_something) {
                  state2.tmp.element_trace.push("suppress-me");
                }
              }
            } else {
              if (!state2.tmp.just_looking && item && item["author-only"] && state2.tmp.area !== "intext") {
                if (!state2.tmp.probably_rendered_something && state2.tmp.can_block_substitute) {
                } else {
                  state2.tmp.element_trace.push("suppress-me");
                }
              } else if (item && item["suppress-author"]) {
                state2.tmp.element_trace.push("do-not-suppress-me");
              }
            }
          };
          this.execs.push(element_trace);
        }
        display = this.strings.cls;
        this.strings.cls = false;
        if (state.build.render_nesting_level === 0) {
          if (state.build.area === "bibliography" && state.bibliography.opt["second-field-align"]) {
            bib_first = new CSL3.Token("group", CSL3.START);
            bib_first.decorations = [["@display", "left-margin"]];
            func = function(state2, Item) {
              if (!state2.tmp.render_seen) {
                bib_first.strings.first_blob = Item.id;
                state2.output.startTag("bib_first", bib_first);
              }
            };
            bib_first.execs.push(func);
            target.push(bib_first);
          } else if (CSL3.DISPLAY_CLASSES.indexOf(display) > -1) {
            bib_first = new CSL3.Token("group", CSL3.START);
            bib_first.decorations = [["@display", display]];
            func = function(state2, Item) {
              bib_first.strings.first_blob = Item.id;
              state2.output.startTag("bib_first", bib_first);
            };
            bib_first.execs.push(func);
            target.push(bib_first);
          }
          state.build.cls = display;
        }
        state.build.render_nesting_level += 1;
        if (state.build.substitute_level.value() === 1) {
          choose_start = new CSL3.Token("choose", CSL3.START);
          CSL3.Node.choose.build.call(choose_start, state, target);
          if_start = new CSL3.Token("if", CSL3.START);
          func = function() {
            if (state.tmp.can_substitute.value()) {
              return true;
            }
            return false;
          };
          if_start.tests ? {} : if_start.tests = [];
          if_start.tests.push(func);
          if_start.test = state.fun.match.any(this, state, if_start.tests);
          target.push(if_start);
        }
        if (state.sys.variableWrapper && this.variables_real && this.variables_real.length) {
          func = function(state2, Item, item) {
            if (!state2.tmp.just_looking && !state2.tmp.suppress_decorations) {
              var variable_entry = new CSL3.Token("text", CSL3.START);
              variable_entry.decorations = [["@showid", "true"]];
              state2.output.startTag("variable_entry", variable_entry);
              var position = null;
              if (item) {
                position = item.position;
              }
              if (!position) {
                position = 0;
              }
              var positionMap = [
                "first",
                "container-subsequent",
                "subsequent",
                "ibid",
                "ibid-with-locator"
              ];
              var noteNumber = 0;
              if (item && item.noteIndex) {
                noteNumber = item.noteIndex;
              }
              var firstReferenceNoteNumber = 0;
              if (item && item["first-reference-note-number"]) {
                firstReferenceNoteNumber = item["first-reference-note-number"];
              }
              var firstContainerReferenceNoteNumber = 0;
              if (item && item["first-container-reference-note-number"]) {
                firstContainerReferenceNoteNumber = item["first-container-reference-note-number"];
              }
              var citationNumber = 0;
              if (item && item["citation-number"]) {
                citationNumber = item["citation-number"];
              }
              var index = 0;
              if (item && item.index) {
                index = item.index;
              }
              var params = {
                itemData: Item,
                variableNames: this.variables,
                context: state2.tmp.area,
                xclass: state2.opt.xclass,
                position: positionMap[position],
                "note-number": noteNumber,
                "first-reference-note-number": firstReferenceNoteNumber,
                "first-container-reference-note-number": firstContainerReferenceNoteNumber,
                "citation-number": citationNumber,
                "index": index,
                "mode": state2.opt.mode
              };
              state2.output.current.value().params = params;
            }
          };
          this.execs.push(func);
        }
      };
      CSL3.Util.substituteEnd = function(state, target) {
        var func, bib_first_end, bib_other, if_end, choose_end, author_substitute, str;
        if (state.sys.variableWrapper && (this.hasVariable || this.variables_real && this.variables_real.length)) {
          func = function(state2) {
            if (!state2.tmp.just_looking && !state2.tmp.suppress_decorations) {
              state2.output.endTag("variable_entry");
            }
          };
          this.execs.push(func);
        }
        func = function(state2) {
          for (var i = 0, ilen = this.decorations.length; i < ilen; i += 1) {
            if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
              state2.tmp.strip_periods += -1;
              break;
            }
          }
        };
        this.execs.push(func);
        state.build.render_nesting_level += -1;
        if (state.build.render_nesting_level === 0) {
          if (state.build.cls) {
            func = function(state2) {
              state2.output.endTag("bib_first");
            };
            this.execs.push(func);
            state.build.cls = false;
          } else if (state.build.area === "bibliography" && state.bibliography.opt["second-field-align"]) {
            bib_first_end = new CSL3.Token("group", CSL3.END);
            func = function(state2) {
              if (!state2.tmp.render_seen) {
                state2.output.endTag("bib_first");
              }
            };
            bib_first_end.execs.push(func);
            target.push(bib_first_end);
            bib_other = new CSL3.Token("group", CSL3.START);
            bib_other.decorations = [["@display", "right-inline"]];
            func = function(state2) {
              if (!state2.tmp.render_seen) {
                state2.tmp.render_seen = true;
                state2.output.startTag("bib_other", bib_other);
              }
            };
            bib_other.execs.push(func);
            target.push(bib_other);
          }
        }
        if (state.build.substitute_level.value() === 1) {
          if_end = new CSL3.Token("if", CSL3.END);
          target.push(if_end);
          choose_end = new CSL3.Token("choose", CSL3.END);
          CSL3.Node.choose.build.call(choose_end, state, target);
        }
        if ("names" === this.name || "text" === this.name && this.variables_real !== "title") {
          author_substitute = new CSL3.Token("text", CSL3.SINGLETON);
          var substitution_name = this.name;
          func = function(state2, Item) {
            if (state2.tmp.area !== "bibliography") {
              return;
            }
            if ("string" !== typeof state2.bibliography.opt["subsequent-author-substitute"]) {
              return;
            }
            if (this.variables_real && !Item[this.variables_real]) {
              return;
            }
            if (this.variables_real && substitution_name === "names") {
              return;
            }
            var subrule = state2.bibliography.opt["subsequent-author-substitute-rule"];
            var i, ilen;
            var printing = !state2.tmp.suppress_decorations;
            if (printing && state2.tmp.subsequent_author_substitute_ok) {
              if (state2.tmp.rendered_name) {
                if ("partial-each" === subrule || "partial-first" === subrule) {
                  var dosub = true;
                  var rendered_name = [];
                  for (i = 0, ilen = state2.tmp.name_node.children.length; i < ilen; i += 1) {
                    var name = state2.tmp.rendered_name[i];
                    if (dosub && state2.tmp.last_rendered_name && state2.tmp.last_rendered_name.length > i - 1 && name && !name.localeCompare(state2.tmp.last_rendered_name[i])) {
                      str = new CSL3.Blob(state2[state2.tmp.area].opt["subsequent-author-substitute"]);
                      state2.tmp.name_node.children[i].blobs = [str];
                      if ("partial-first" === subrule) {
                        dosub = false;
                      }
                    } else {
                      dosub = false;
                    }
                    rendered_name.push(name);
                  }
                  state2.tmp.last_rendered_name = rendered_name;
                } else if ("complete-each" === subrule) {
                  var rendered_name = state2.tmp.rendered_name.join(",");
                  if (rendered_name) {
                    if (state2.tmp.last_rendered_name && !rendered_name.localeCompare(state2.tmp.last_rendered_name)) {
                      for (i = 0, ilen = state2.tmp.name_node.children.length; i < ilen; i += 1) {
                        str = new CSL3.Blob(state2[state2.tmp.area].opt["subsequent-author-substitute"]);
                        state2.tmp.name_node.children[i].blobs = [str];
                      }
                    }
                    state2.tmp.last_rendered_name = rendered_name;
                  }
                } else {
                  var rendered_name = state2.tmp.rendered_name.join(",");
                  if (rendered_name) {
                    if (state2.tmp.last_rendered_name && !rendered_name.localeCompare(state2.tmp.last_rendered_name)) {
                      str = new CSL3.Blob(state2[state2.tmp.area].opt["subsequent-author-substitute"]);
                      if (state2.tmp.label_blob) {
                        state2.tmp.name_node.top.blobs = [str, state2.tmp.label_blob];
                      } else if (state2.tmp.name_node.top.blobs.length) {
                        state2.tmp.name_node.top.blobs[0].blobs = [str];
                      } else {
                        state2.tmp.name_node.top.blobs = [str];
                      }
                      state2.tmp.substituted_variable = substitution_name;
                    }
                    state2.tmp.last_rendered_name = rendered_name;
                  }
                }
                state2.tmp.subsequent_author_substitute_ok = false;
              }
            }
          };
          this.execs.push(func);
        }
        if ("text" === this.name && !this.postponed_macro || ["number", "date", "names"].indexOf(this.name) > -1) {
          func = function(state2, Item) {
            if (state2.tmp.element_trace.mystack.length > 1) {
              state2.tmp.element_trace.pop();
            }
          };
          this.execs.push(func);
        }
      };
      CSL3.Util.padding = function(num) {
        var m = num.match(/\s*(-{0,1}[0-9]+)/);
        if (m) {
          num = parseInt(m[1], 10);
          if (num < 0) {
            num = 1e20 + num;
          }
          num = "" + num;
          while (num.length < 20) {
            num = "0" + num;
          }
        }
        return num;
      };
      CSL3.Util.LongOrdinalizer = function() {
      };
      CSL3.Util.LongOrdinalizer.prototype.init = function(state) {
        this.state = state;
      };
      CSL3.Util.LongOrdinalizer.prototype.format = function(num, gender) {
        if (num < 10) {
          num = "0" + num;
        }
        var ret = CSL3.Engine.getField(
          CSL3.LOOSE,
          this.state.locale[this.state.opt.lang].terms,
          "long-ordinal-" + num,
          "long",
          0,
          gender
        );
        if (!ret) {
          ret = this.state.fun.ordinalizer.format(num, gender);
        }
        this.state.tmp.cite_renders_content = true;
        return ret;
      };
      CSL3.Util.Ordinalizer = function(state) {
        this.state = state;
        this.suffixes = {};
      };
      CSL3.Util.Ordinalizer.prototype.init = function() {
        if (!this.suffixes[this.state.opt.lang]) {
          this.suffixes[this.state.opt.lang] = {};
          for (var i = 0, ilen = 3; i < ilen; i += 1) {
            var gender = [void 0, "masculine", "feminine"][i];
            this.suffixes[this.state.opt.lang][gender] = [];
            for (var j = 1; j < 5; j += 1) {
              var ordinal = this.state.getTerm("ordinal-0" + j, "long", false, gender);
              if ("undefined" === typeof ordinal) {
                delete this.suffixes[this.state.opt.lang][gender];
                break;
              }
              this.suffixes[this.state.opt.lang][gender].push(ordinal);
            }
          }
        }
      };
      CSL3.Util.Ordinalizer.prototype.format = function(num, gender) {
        var str;
        num = parseInt(num, 10);
        str = "" + num;
        var suffix = "";
        var trygenders = [];
        if (gender) {
          trygenders.push(gender);
        }
        trygenders.push("neuter");
        if (this.state.locale[this.state.opt.lang].ord["1.0.1"]) {
          suffix = this.state.getTerm("ordinal", false, 0, gender);
          var trygender;
          for (var i = 0, ilen = trygenders.length; i < ilen; i += 1) {
            trygender = trygenders[i];
            var ordinfo = this.state.locale[this.state.opt.lang].ord["1.0.1"];
            if (ordinfo["whole-number"][str] && ordinfo["whole-number"][str][trygender]) {
              suffix = this.state.getTerm(this.state.locale[this.state.opt.lang].ord["1.0.1"]["whole-number"][str][trygender], false, 0, gender);
            } else if (ordinfo["last-two-digits"][str.slice(str.length - 2)] && ordinfo["last-two-digits"][str.slice(str.length - 2)][trygender]) {
              suffix = this.state.getTerm(this.state.locale[this.state.opt.lang].ord["1.0.1"]["last-two-digits"][str.slice(str.length - 2)][trygender], false, 0, gender);
            } else if (ordinfo["last-digit"][str.slice(str.length - 1)] && ordinfo["last-digit"][str.slice(str.length - 1)][trygender]) {
              suffix = this.state.getTerm(this.state.locale[this.state.opt.lang].ord["1.0.1"]["last-digit"][str.slice(str.length - 1)][trygender], false, 0, gender);
            }
            if (suffix) {
              break;
            }
          }
        } else {
          if (!gender) {
            gender = void 0;
          }
          this.state.fun.ordinalizer.init();
          if (num / 10 % 10 === 1 || num > 10 && num < 20) {
            suffix = this.suffixes[this.state.opt.lang][gender][3];
          } else if (num % 10 === 1 && num % 100 !== 11) {
            suffix = this.suffixes[this.state.opt.lang][gender][0];
          } else if (num % 10 === 2 && num % 100 !== 12) {
            suffix = this.suffixes[this.state.opt.lang][gender][1];
          } else if (num % 10 === 3 && num % 100 !== 13) {
            suffix = this.suffixes[this.state.opt.lang][gender][2];
          } else {
            suffix = this.suffixes[this.state.opt.lang][gender][3];
          }
        }
        str = str += suffix;
        return str;
      };
      CSL3.Util.Romanizer = function() {
      };
      CSL3.Util.Romanizer.prototype.format = function(num) {
        var ret, pos, n, numstr, len;
        ret = "";
        if (num < 6e3) {
          numstr = num.toString().split("");
          numstr.reverse();
          pos = 0;
          n = 0;
          len = numstr.length;
          for (pos = 0; pos < len; pos += 1) {
            n = parseInt(numstr[pos], 10);
            ret = CSL3.ROMAN_NUMERALS[pos][n] + ret;
          }
        }
        return ret;
      };
      CSL3.Util.Suffixator = function(slist) {
        if (!slist) {
          slist = CSL3.SUFFIX_CHARS;
        }
        this.slist = slist.split(",");
      };
      CSL3.Util.Suffixator.prototype.format = function(N) {
        var X;
        N += 1;
        var key = "";
        do {
          X = N % 26 === 0 ? 26 : N % 26;
          var key = this.slist[X - 1] + key;
          N = (N - X) / 26;
        } while (N !== 0);
        return key;
      };
      CSL3.Engine.prototype.processNumber = function(node, ItemObject, variable) {
        var val;
        var me = this;
        var realVariable = variable;
        variable = variable === "page-first" ? "page" : variable;
        var fullformAnd = ",\\s+and\\s+|\\s+and\\s+";
        if (this.opt.lang.slice(0, 2) !== "en") {
          fullformAnd += "|,\\s+" + this.getTerm("and") + "\\s+|\\s+" + this.getTerm("and") + "\\s+";
        }
        var symbolAnd = "\\s*&\\s*";
        var andRex = new RegExp("^" + symbolAnd + "$");
        var joinerMatchRex = new RegExp("(" + symbolAnd + "|" + fullformAnd + "|;\\s+|,\\s+|\\s*\\\\*[\\-\\u2013]+\\s*)", "g");
        var joinerSplitRex = new RegExp("(?:" + symbolAnd + "|" + fullformAnd + "|;\\s+|,\\s+|\\s*\\\\*[\\-\\u2013]+\\s*)");
        var localeAnd = this.getTerm("and");
        var localeAmpersand = this.getTerm("and", "symbol");
        if (localeAnd === localeAmpersand) {
          localeAmpersand = "&";
        }
        function normalizeFieldValue(str) {
          str = str.trim();
          var m = str.match(/^([^ ]+)/);
          if (m && !CSL3.STATUTE_SUBDIV_STRINGS[m[1]]) {
            var embeddedLabel = null;
            if (["locator", "locator-extra", "page"].indexOf(variable) > -1) {
              if (ItemObject.label) {
                embeddedLabel = CSL3.STATUTE_SUBDIV_STRINGS_REVERSE[ItemObject.label];
              } else {
                embeddedLabel = "p.";
              }
            } else {
              embeddedLabel = CSL3.STATUTE_SUBDIV_STRINGS_REVERSE[variable];
            }
            if (embeddedLabel) {
              str = embeddedLabel + " " + str;
            }
          }
          return str;
        }
        function composeNumberInfo(origLabel, label, val2, joiningSuffix, parsePosition) {
          joiningSuffix = joiningSuffix ? joiningSuffix : "";
          var info2 = {};
          if (!label && !CSL3.STATUTE_SUBDIV_STRINGS_REVERSE[variable]) {
            label = "var:" + variable;
          }
          if (label) {
            var m = label.match(/(\s*)([^\s]+)(\s*)/);
            if (realVariable === "page" && parsePosition === 0 && ["p.", "pp."].indexOf(m[2]) === -1) {
              info2.gotosleepability = true;
              info2.labelVisibility = true;
            } else {
              info2.labelVisibility = false;
            }
            info2.label = m[2];
            info2.origLabel = origLabel;
            info2.labelSuffix = m[3] ? m[3] : "";
            info2.plural = 0;
          }
          var m = val2.match(/^([0-9]*[a-zA-Z]+0*)?([0-9]+(?:[a-zA-Z]*|[-,a-zA-Z]+))$/);
          if (m) {
            info2.particle = m[1] ? m[1] : "";
            info2.value = m[2];
          } else {
            info2.particle = "";
            info2.value = val2;
          }
          info2.joiningSuffix = joiningSuffix.replace(/\s*-\s*/, "-");
          return info2;
        }
        function fixupSubsections(elems) {
          for (var i = elems.length - 2; i > -1; i -= 2) {
            if (elems[i] === "-" && elems[i - 1].match(/^(?:(?:[a-z]|[a-z][a-z]|[a-z][a-z][a-z]|[a-z][a-z][a-z][a-z])\.  *)*[0-9]+[,a-zA-Z]+$/) && elems[i + 1].match(/^[,a-zA-Z]+$/)) {
              elems[i - 1] = elems.slice(i - 1, i + 2).join("");
              elems = elems.slice(0, i).concat(elems.slice(i + 2));
            }
          }
          return elems;
        }
        function parseString(str, defaultLabel2) {
          defaultLabel2 = defaultLabel2 ? defaultLabel2 : "";
          str = normalizeFieldValue(str, defaultLabel2);
          var jmrex, jsrex, mystr;
          if ("page" === variable) {
            if (str.indexOf("\u2013") > -1) {
              str = str.replace(/\u2013/g, "-");
            }
          }
          if (str.indexOf("\\-") > -1) {
            jmrex = new RegExp(joinerMatchRex.source.replace("\\-", ""));
            jsrex = new RegExp(joinerSplitRex.source.replace("\\-", ""));
            var lst = str.split("\\-");
            for (var i = 0, ilen = lst.length; i < ilen; i++) {
              lst[i] = lst[i].replace(/\-/g, "\u2013");
            }
            mystr = lst.join("\\-");
            mystr = mystr.replace(/\\/g, "");
          } else {
            jmrex = joinerMatchRex;
            jsrex = joinerSplitRex;
            mystr = str;
          }
          var elems = [];
          var m = mystr.match(jmrex);
          if (m) {
            var lst = mystr.split(jsrex);
            for (var i = 0, ilen = m.length; i < ilen; i++) {
              if (m[i].match(andRex)) {
                if (lst[i].match(/[a-zA-Z]$/) && lst[i].match(/^[a-zA-Z]/)) {
                  m[i] = localeAmpersand;
                } else {
                  m[i] = " " + localeAmpersand + " ";
                }
              }
            }
            var recombine = false;
            for (var i in lst) {
              if (("" + lst[i]).replace(/^[a-z]\.\s+/, "").match(/[^\s0-9ivxlcmIVXLCM]/)) {
                break;
              }
            }
            if (recombine) {
              elems = [mystr];
            } else {
              for (var i = 0, ilen = lst.length - 1; i < ilen; i++) {
                elems.push(lst[i]);
                elems.push(m[i]);
              }
              elems.push(lst[lst.length - 1]);
              elems = fixupSubsections(elems);
            }
          } else {
            var elems = [mystr];
          }
          var values2 = [];
          var label = defaultLabel2;
          var origLabel = "";
          for (var i = 0, ilen = elems.length; i < ilen; i += 2) {
            var m = elems[i].match(/((?:^| )(?:[a-z]|[a-z][a-z]|[a-z][a-z][a-z]|[a-z][a-z][a-z][a-z]|subpara|subch|amend|bibliog|annot|illus|princ|intro|sched|subdiv|subsec)(?:\.| ) *)/g);
            if (m) {
              var lst = elems[i].split(/(?:(?:^| )(?:[a-z]|[a-z][a-z]|[a-z][a-z][a-z]|[a-z][a-z][a-z][a-z]|subpara|subch|amend|bibliog|annot|illus|princ|intro|sched|subdiv|subsec)(?:\.| ) *)/);
              for (var j = lst.length - 1; j > 0; j--) {
                if (lst[j - 1] && (!lst[j].match(/^[0-9]+([-;,:a-zA-Z]*)$/) || !lst[j - 1].match(/^[0-9]+([-;,:a-zA-Z]*)$/))) {
                  lst[j - 1] = lst[j - 1] + m[j - 1] + lst[j];
                  lst = lst.slice(0, j).concat(lst.slice(j + 1));
                  m = m.slice(0, j - 1).concat(m.slice(j));
                }
              }
              if (m.length > 0) {
                var slug = m[0].trim();
                var notAlabel = !CSL3.STATUTE_SUBDIV_STRINGS[slug] || "undefined" === typeof me.getTerm(CSL3.STATUTE_SUBDIV_STRINGS[slug]) || ["locator", "number", "locator-extra", "page"].indexOf(variable) === -1 && CSL3.STATUTE_SUBDIV_STRINGS[slug] !== variable;
                if (notAlabel) {
                  if (i === 0) {
                    m = m.slice(1);
                    lst[0] = lst[0] + " " + slug + " " + lst[1];
                    lst = lst.slice(0, 1).concat(lst.slice(2));
                  }
                } else {
                  origLabel = slug;
                }
              }
              for (var j = 0, jlen = lst.length; j < jlen; j++) {
                if (lst[j] || j === lst.length - 1) {
                  var filteredOrigLabel;
                  label = m[j - 1] ? m[j - 1] : label;
                  if (origLabel === label.trim()) {
                    filteredOrigLabel = "";
                  } else {
                    filteredOrigLabel = origLabel;
                  }
                  mystr = lst[j] ? lst[j].trim() : "";
                  if (j === lst.length - 1) {
                    values2.push(composeNumberInfo(filteredOrigLabel, label, mystr, elems[i + 1], i));
                  } else {
                    values2.push(composeNumberInfo(filteredOrigLabel, label, mystr, null, i));
                  }
                }
              }
            } else {
              var filteredOrigLabel;
              if (origLabel === label.trim()) {
                filteredOrigLabel = "";
              } else {
                filteredOrigLabel = origLabel;
              }
              values2.push(composeNumberInfo(filteredOrigLabel, label, elems[i], elems[i + 1]));
            }
          }
          return values2;
        }
        function setSpaces(values2) {
          for (var i = 0, ilen = values2.length - 1; i < ilen; i++) {
            if (!values2[i].joiningSuffix && values2[i + 1].label) {
              values2[i].joiningSuffix = " ";
            }
          }
        }
        function fixNumericAndCount(values2, i, currentLabelInfo) {
          var master = values2[currentLabelInfo.pos];
          var val2 = values2[i].value;
          var isEscapedHyphen = master.joiningSuffix === "\\-";
          if (val2.particle && val2.particle !== master.particle) {
            currentLabelInfo.collapsible = false;
          }
          var mVal = val2.match(/^[0-9]+([-,:a-zA-Z]*)$/);
          var mCurrentLabel = master.value.match(/^(?:[0-9]+|[ixv]+)([-,:a-zA-Z]*|\-[\-0-9]+)$/);
          if (!val2 || !mVal || !mCurrentLabel || isEscapedHyphen) {
            currentLabelInfo.collapsible = false;
            if (!val2 || !mCurrentLabel) {
              currentLabelInfo.numeric = false;
            }
            if (isEscapedHyphen) {
              currentLabelInfo.count--;
            }
          }
          if (mVal && mVal[1] || mCurrentLabel && mCurrentLabel[1]) {
            currentLabelInfo.collapsible = false;
          }
          if (void 0 === values2[i].collapsible) {
            for (var j = i, jlen = i + currentLabelInfo.count; j < jlen; j++) {
              if (isNaN(parseInt(values2[j].value)) && !values2[j].value.match(/^[ivxlcmIVXLCM]+$/)) {
                values2[j].collapsible = false;
              } else {
                values2[j].collapsible = true;
              }
            }
            currentLabelInfo.collapsible = values2[i].collapsible;
          }
          var isCollapsible = currentLabelInfo.collapsible;
          for (var j = currentLabelInfo.pos, jlen = currentLabelInfo.pos + currentLabelInfo.count; j < jlen; j++) {
            if (currentLabelInfo.count > 1 && isCollapsible) {
              values2[j].plural = 1;
            }
            values2[j].numeric = currentLabelInfo.numeric;
            values2[j].collapsible = currentLabelInfo.collapsible;
          }
        }
        function fixLabelVisibility(values2, groupStartPos, currentLabelInfo) {
          if (currentLabelInfo.label.slice(0, 4) !== "var:") {
            if (currentLabelInfo.pos === 0) {
              if (["locator", "number", "locator-extra", "page"].indexOf(variable) > -1) {
                if ("undefined" === typeof me.getTerm(CSL3.STATUTE_SUBDIV_STRINGS[currentLabelInfo.label])) {
                  values2[currentLabelInfo.pos].labelVisibility = true;
                }
              }
              if (["locator", "number", "locator-extra", "page"].indexOf(variable) === -1) {
                if (CSL3.STATUTE_SUBDIV_STRINGS[currentLabelInfo.label] !== variable) {
                  values2[0].labelVisibility = true;
                }
              }
            } else {
              values2[currentLabelInfo.pos].labelVisibility = true;
            }
          }
        }
        function setPluralsAndNumerics(values2) {
          if (values2.length === 0) {
            return;
          }
          var groupStartPos = 0;
          var groupCount = 1;
          for (var i = 1, ilen = values2.length; i < ilen; i++) {
            var lastVal = values2[i - 1];
            var thisVal = values2[i];
            if (lastVal.label === thisVal.label && lastVal.particle === lastVal.particle) {
              groupCount++;
            } else {
              var currentLabelInfo = JSON.parse(JSON.stringify(values2[groupStartPos]));
              currentLabelInfo.pos = groupStartPos;
              currentLabelInfo.count = groupCount;
              currentLabelInfo.numeric = true;
              fixNumericAndCount(values2, groupStartPos, currentLabelInfo);
              if (lastVal.label !== thisVal.label) {
                fixLabelVisibility(values2, groupStartPos, currentLabelInfo);
              }
              groupStartPos = i;
              groupCount = 1;
            }
          }
          var currentLabelInfo = JSON.parse(JSON.stringify(values2[groupStartPos]));
          currentLabelInfo.pos = groupStartPos;
          currentLabelInfo.count = groupCount;
          currentLabelInfo.numeric = true;
          fixNumericAndCount(values2, groupStartPos, currentLabelInfo);
          fixLabelVisibility(values2, groupStartPos, currentLabelInfo);
          if (values2.length && values2[0].numeric && variable.slice(0, 10) === "number-of-") {
            if (parseInt(ItemObject[realVariable], 10) > 1) {
              values2[0].plural = 1;
            }
          }
        }
        function stripHyphenBackslash(joiningSuffix) {
          return joiningSuffix.replace("\\-", "-");
        }
        function setStyling(values2) {
          var masterNode = CSL3.Util.cloneToken(node);
          var masterStyling = new CSL3.Token();
          if (!me.tmp.just_looking) {
            masterStyling.decorations = masterNode.decorations;
            masterNode.decorations = [];
            masterStyling.strings.prefix = masterNode.strings.prefix;
            masterNode.strings.prefix = "";
            masterStyling.strings.suffix = masterNode.strings.suffix;
            masterNode.strings.suffix = "";
          }
          var masterLabel = values2.length ? values2[0].label : null;
          if (values2.length) {
            for (var i = 0, ilen = values2.length; i < ilen; i++) {
              var val2 = values2[i];
              var newnode = CSL3.Util.cloneToken(masterNode);
              newnode.gender = node.gender;
              if (masterLabel === val2.label) {
                newnode.formatter = node.formatter;
              }
              if (val2.numeric) {
                newnode.successor_prefix = val2.successor_prefix;
              }
              newnode.strings.suffix = newnode.strings.suffix + stripHyphenBackslash(val2.joiningSuffix);
              val2.styling = newnode;
            }
            if (!me.tmp.just_looking) {
              if (values2[0].value.slice(0, 1) === '"' && values2[values2.length - 1].value.slice(-1) === '"') {
                values2[0].value = values2[0].value.slice(1);
                values2[values2.length - 1].value = values2[values2.length - 1].value.slice(0, -1);
                masterStyling.decorations.push(["@quotes", true]);
              }
            }
          }
          return masterStyling;
        }
        function checkTerm(variable2, val2) {
          var ret = true;
          if (["locator", "locator-extra", "page"].indexOf(variable2) > -1) {
            var label;
            if (val2.origLabel) {
              label = val2.origLabel;
            } else {
              label = val2.label;
            }
            ret = !!me.getTerm(CSL3.STATUTE_SUBDIV_STRINGS[label]);
          }
          return ret;
        }
        function checkPage(variable2, val2) {
          return "page" === variable2 || ["locator", "locator-extra"].indexOf(variable2) > -1 && (["p."].indexOf(val2.label) > -1 || ["p."].indexOf(val2.origLabel) > -1);
        }
        function fixupRangeDelimiter(variable2, val2, rangeDelimiter, isNumeric) {
          var isPage = checkPage(variable2, val2);
          var hasTerm = checkTerm(variable2, val2);
          if (hasTerm && rangeDelimiter === "-") {
            if (isNumeric) {
              if (isPage || ["locator", "locator-extra", "issue", "volume", "edition", "number"].indexOf(variable2) > -1) {
                rangeDelimiter = me.getTerm("page-range-delimiter");
                if (!rangeDelimiter) {
                  rangeDelimiter = "\u2013";
                }
              }
              if (variable2 === "collection-number") {
                rangeDelimiter = me.getTerm("year-range-delimiter");
                if (!rangeDelimiter) {
                  rangeDelimiter = "\u2013";
                }
              }
            }
          }
          return rangeDelimiter;
        }
        function manglePageNumbers(values2, i, currentInfo) {
          if (i < 1) {
            return;
          }
          if (currentInfo.count !== 2) {
            return;
          }
          if (values2[i - 1].particle !== values2[i].particle) {
            return;
          }
          if (values2[i - 1].joiningSuffix !== "-") {
            currentInfo.count = 1;
            return;
          }
          if (!me.opt["page-range-format"] && parseInt(values2[i - 1].value, 10) > parseInt(values2[i].value, 10)) {
            values2[i - 1].joiningSuffix = fixupRangeDelimiter(variable, values2[i], values2[i - 1].joiningSuffix, true);
            return;
          }
          var val2 = values2[i];
          var isPage = checkPage(variable, val2);
          var str;
          if (isPage && !isNaN(parseInt(values2[i - 1].value)) && !isNaN(parseInt(values2[i].value))) {
            str = values2[i - 1].particle + values2[i - 1].value + " - " + values2[i].particle + values2[i].value;
            str = me.fun.page_mangler(str);
          } else {
            if (("" + values2[i - 1].value).match(/^([0-9]+|[ivxlcmIVXLCM]+)$/) && ("" + values2[i].value).match(/^([0-9]+|[ivxlcmIVXLCM]+)$/)) {
              values2[i - 1].joiningSuffix = me.getTerm("page-range-delimiter");
            }
            str = values2[i - 1].value + stripHyphenBackslash(values2[i - 1].joiningSuffix) + values2[i].value;
          }
          var m = str.match(/^((?:[0-9]*[a-zA-Z]+0*))?([0-9]+[a-z]*)(\s*[^0-9]+\s*)([-,a-zA-Z]?0*)([0-9]+[a-z]*)$/);
          if (m) {
            var rangeDelimiter = m[3];
            rangeDelimiter = fixupRangeDelimiter(variable, val2, rangeDelimiter, values2[i].numeric);
            values2[i - 1].particle = m[1];
            values2[i - 1].value = m[2];
            values2[i - 1].joiningSuffix = rangeDelimiter;
            values2[i].particle = m[4];
            values2[i].value = m[5];
          }
          currentInfo.count = 0;
        }
        function fixRanges(values2) {
          if (!node) {
            return;
          }
          if (["page", "chapter-number", "collection-number", "edition", "issue", "number", "number-of-pages", "number-of-volumes", "volume", "locator", "locator-extra"].indexOf(variable) === -1) {
            return;
          }
          var currentInfo = {
            count: 0,
            label: null,
            lastHadRangeDelimiter: false
          };
          for (var i = 0, ilen = values2.length; i < ilen; i++) {
            var val2 = values2[i];
            if (!val2.collapsible) {
              currentInfo.count = 0;
              currentInfo.label = null;
              var isNumeric = val2.numeric;
              val2.joiningSuffix = fixupRangeDelimiter(variable, val2, val2.joiningSuffix, isNumeric);
            } else if (currentInfo.label === val2.label && val2.joiningSuffix === "-") {
              currentInfo.count = 1;
            } else if (currentInfo.label === val2.label && val2.joiningSuffix !== "-") {
              currentInfo.count++;
              if (currentInfo.count === 2) {
                manglePageNumbers(values2, i, currentInfo);
              }
            } else if (currentInfo.label !== val2.label) {
              currentInfo.label = val2.label;
              currentInfo.count = 1;
            } else {
              currentInfo.count = 1;
              currentInfo.label = val2.label;
            }
          }
          if (currentInfo.count === 2) {
            manglePageNumbers(values2, values2.length - 1, currentInfo);
          }
        }
        function setVariableParams(shadow_numbers, realVariable2, values2) {
          var obj2 = shadow_numbers[realVariable2];
          if (values2.length) {
            obj2.numeric = values2[0].numeric;
            obj2.collapsible = values2[0].collapsible;
            obj2.plural = values2[0].plural;
            obj2.label = CSL3.STATUTE_SUBDIV_STRINGS[values2[0].label];
            if (variable === "number" && obj2.label === "issue" && me.getTerm("number")) {
              obj2.label = "number";
            }
          }
        }
        if (node && this.tmp.shadow_numbers[realVariable] && this.tmp.shadow_numbers[realVariable].values.length) {
          var values = this.tmp.shadow_numbers[realVariable].values;
          fixRanges(values);
          this.tmp.shadow_numbers[realVariable].masterStyling = setStyling(values);
          return;
        }
        if (!this.tmp.shadow_numbers[realVariable]) {
          this.tmp.shadow_numbers[realVariable] = {
            values: []
          };
        }
        if (!ItemObject) {
          return;
        }
        var languageRole = CSL3.LangPrefsMap[variable];
        if (languageRole) {
          var localeType = this.opt["cite-lang-prefs"][languageRole][0];
          val = this.transform.getTextSubField(ItemObject, realVariable, "locale-" + localeType, true);
          val = val.name;
        } else {
          val = ItemObject[realVariable];
        }
        if (val && realVariable === "number" && ItemObject.type === "legal_case") {
          val = val.replace(/[\\]*-/g, "\\-");
        }
        if (val && this.sys.getAbbreviation) {
          if (this.sys.normalizeAbbrevsKey) {
            var normval = this.sys.normalizeAbbrevsKey(realVariable, val);
          } else {
            var normval = val;
          }
          var jurisdiction = this.transform.loadAbbreviation(ItemObject.jurisdiction, "number", normval, ItemObject.language);
          if (this.transform.abbrevs[jurisdiction].number) {
            if (this.transform.abbrevs[jurisdiction].number[normval]) {
              val = this.transform.abbrevs[jurisdiction].number[normval];
            } else {
              if ("undefined" !== typeof this.transform.abbrevs[jurisdiction].number[normval]) {
                delete this.transform.abbrevs[jurisdiction].number[normval];
              }
            }
          }
        }
        if ("undefined" !== typeof val && ("string" === typeof val || "number" === typeof val)) {
          if ("number" === typeof val) {
            val = "" + val;
          }
          var defaultLabel = CSL3.STATUTE_SUBDIV_STRINGS_REVERSE[variable];
          if (this.tmp.shadow_numbers[realVariable].values.length === 0) {
            var values = parseString(val, defaultLabel);
            setSpaces(values);
            setPluralsAndNumerics(values);
            for (var obj of values) {
              if (!obj.numeric) obj.plural = 0;
            }
            this.tmp.shadow_numbers[realVariable].values = values;
            if (node) {
              fixRanges(values);
              this.tmp.shadow_numbers[realVariable].masterStyling = setStyling(values);
            }
            setVariableParams(this.tmp.shadow_numbers, realVariable, values);
          }
          var info = this.tmp.shadow_numbers[realVariable];
          if (variable === "number") {
            if (info.values.length === 1 && info.values[0].value.indexOf("|") > -1) {
              info.values[0].value = info.values[0].value.replace(/\|/g, ", ");
              info.values[0].numeric = true;
              info.values[0].plural = 1;
              info.values[0].collapsible = false;
              info.numeric = true;
              info.plural = 1;
              info.collapsible = false;
            }
          }
          if (info.values.length === 1) {
            if (info.values[0].value.match(/^[0-9]+(?:\/[0-9]+)+$/)) {
              info.values[0].numeric = true;
              info.values[0].plural = 0;
              info.values[0].collapsible = false;
              info.numeric = true;
              info.plural = 0;
              info.collapsible = false;
            }
          }
          if (variable === "page") {
            if (info.values.length > 0) {
              if (info.values[0].gotosleepability) {
                info.labelForm = "short";
              }
            }
          }
        }
      };
      CSL3.Util.outputNumericField = function(state, varname, itemID) {
        state.output.openLevel(state.tmp.shadow_numbers[varname].masterStyling);
        var masterStyling = state.tmp.shadow_numbers[varname].masterStyling;
        var nums = state.tmp.shadow_numbers[varname].values;
        var masterLabel = nums.length ? nums[0].label : null;
        var labelForm = state.tmp.shadow_numbers[varname].labelForm;
        var tryStatic = state.tmp.group_context.tip.label_static;
        var embeddedLabelForm;
        if (labelForm) {
          embeddedLabelForm = labelForm;
        } else {
          embeddedLabelForm = "short";
        }
        var labelCapitalizeIfFirst = state.tmp.shadow_numbers[varname].labelCapitalizeIfFirst;
        var labelDecorations = state.tmp.shadow_numbers[varname].labelDecorations;
        var lastLabelName = null;
        for (var i = 0, ilen = nums.length; i < ilen; i++) {
          var num = nums[i];
          var label = "";
          var labelName;
          if (num.label) {
            if ("var:" === num.label.slice(0, 4)) {
              labelName = num.label.slice(4);
            } else {
              labelName = CSL3.STATUTE_SUBDIV_STRINGS[num.label];
            }
            if (labelName) {
              if (num.label === masterLabel) {
                if (tryStatic) {
                  label = state.getTerm(labelName, "static", num.plural);
                  if (label.indexOf("%s") === -1) {
                    label = "";
                  }
                }
                if (!label) {
                  label = state.getTerm(labelName, labelForm, num.plural);
                }
              } else {
                if (tryStatic) {
                  label = state.getTerm(labelName, "static", num.plural);
                  if (label.indexOf("%s") === -1) {
                    label = "";
                  }
                }
                if (!label) {
                  label = state.getTerm(labelName, embeddedLabelForm, num.plural);
                }
              }
              if (labelCapitalizeIfFirst) {
                label = CSL3.Output.Formatters["capitalize-first"](state, label);
              }
            }
          }
          var labelPlaceholderPos = -1;
          if (label) {
            labelPlaceholderPos = label.indexOf("%s");
          }
          var numStyling = CSL3.Util.cloneToken(num.styling);
          numStyling.formatter = num.styling.formatter;
          numStyling.type = num.styling.type;
          numStyling.num = num.styling.num;
          numStyling.gender = num.styling.gender;
          if (labelPlaceholderPos > 0 && labelPlaceholderPos < label.length - 2) {
            numStyling.strings.prefix += label.slice(0, labelPlaceholderPos);
            numStyling.strings.suffix = label.slice(labelPlaceholderPos + 2) + numStyling.strings.suffix;
          } else if (num.labelVisibility) {
            if (!label) {
              label = num.label;
              labelName = num.label;
            }
            if (labelPlaceholderPos > 0) {
              var prefixLabelStyling = new CSL3.Token();
              prefixLabelStyling.decorations = labelDecorations;
              state.output.append(label.slice(0, labelPlaceholderPos), prefixLabelStyling);
            } else if (labelPlaceholderPos === label.length - 2 || labelPlaceholderPos === -1) {
              state.output.append(label + num.labelSuffix, "empty");
            }
          }
          CSL3.UPDATE_GROUP_CONTEXT_CONDITION(state, masterStyling.strings.prefix, null, masterStyling, `${num.particle}${num.value}`);
          if (num.collapsible) {
            var blob;
            if (num.value.match(/^[1-9][0-9]*$/) && Number.isSafeInteger(parseInt(num.value, 10))) {
              blob = new CSL3.NumericBlob(state, num.particle, parseInt(num.value, 10), numStyling, itemID);
            } else {
              blob = new CSL3.NumericBlob(state, num.particle, num.value, numStyling, itemID);
            }
            if ("undefined" === typeof blob.gender) {
              blob.gender = state.locale[state.opt.lang]["noun-genders"][varname];
            }
            state.output.append(blob, "literal");
          } else {
            state.output.append(num.particle + num.value, numStyling);
          }
          if (labelPlaceholderPos === 0 && labelPlaceholderPos < label.length - 2) {
            if (lastLabelName === null) {
              lastLabelName = labelName;
            }
            if (labelName !== lastLabelName || i === nums.length - 1) {
              var suffixLabelStyling = new CSL3.Token();
              suffixLabelStyling.decorations = labelDecorations;
              state.output.append(label.slice(labelPlaceholderPos + 2), suffixLabelStyling);
            }
          }
          lastLabelName = labelName;
          state.tmp.term_predecessor = true;
        }
        state.output.closeLevel();
      };
      CSL3.Util.PageRangeMangler = {};
      CSL3.Util.PageRangeMangler.getFunction = function(state, rangeType) {
        var rangerex, pos, len, stringify2, listify, expand, minimize, minimize_internal, chicago15, chicago16, lst, m, b, e, ret, begin, end, ret_func;
        var range_delimiter = state.getTerm(rangeType + "-range-delimiter");
        rangerex = /([0-9]*[a-zA-Z]+0*)?([0-9]+[a-z]*)\s*(?:\u2013|-)\s*([0-9]*[a-zA-Z]+0*)?([0-9]+[a-z]*)/;
        stringify2 = function(lst2) {
          len = lst2.length;
          for (pos = 1; pos < len; pos += 2) {
            if ("object" === typeof lst2[pos]) {
              lst2[pos] = lst2[pos].join("");
            }
          }
          var ret2 = lst2.join("");
          ret2 = ret2.replace(/([^\\])\-/g, "$1" + state.getTerm(rangeType + "-range-delimiter"));
          return ret2;
        };
        listify = function(str) {
          var m2, lst2, ret2;
          var hyphens = "\\s+\\-\\s+";
          var this_range_delimiter = range_delimiter === "-" ? "" : range_delimiter;
          var delimRex = new RegExp("([^\\\\])[-" + this_range_delimiter + "\\u2013]", "g");
          str = str.replace(delimRex, "$1 - ").replace(/\s+-\s+/g, " - ");
          var rexm = new RegExp("((?:[0-9]*[a-zA-Z]+0*)?[0-9]+[a-z]*" + hyphens + "(?:[0-9]*[a-zA-Z]+0*)?[0-9]+[a-z]*)", "g");
          var rexlst = new RegExp("(?:[0-9]*[a-zA-Z]+0*)?[0-9]+[a-z]*" + hyphens + "(?:[0-9]*[a-zA-Z]+0*)?[0-9]+[a-z]*");
          m2 = str.match(rexm);
          lst2 = str.split(rexlst);
          if (lst2.length === 0) {
            ret2 = m2;
          } else {
            ret2 = [lst2[0]];
            for (pos = 1, len = lst2.length; pos < len; pos += 1) {
              ret2.push(m2[pos - 1].replace(/\s*\-\s*/g, "-"));
              ret2.push(lst2[pos]);
            }
          }
          return ret2;
        };
        expand = function(str) {
          str = "" + str;
          lst = listify(str);
          len = lst.length;
          for (pos = 1; pos < len; pos += 2) {
            m = lst[pos].match(rangerex);
            if (m) {
              if (!m[3] || m[1] === m[3]) {
                if (m[4].length < m[2].length) {
                  m[4] = m[2].slice(0, m[2].length - m[4].length) + m[4];
                }
                if (parseInt(m[2], 10) < parseInt(m[4], 10)) {
                  m[3] = range_delimiter + (m[1] ? m[1] : "");
                  lst[pos] = m.slice(1);
                }
              }
            }
            if ("string" === typeof lst[pos]) {
              lst[pos] = lst[pos].replace(/\-/g, range_delimiter);
            }
          }
          return lst;
        };
        minimize = function(lst2, minchars, isyear) {
          len = lst2.length;
          for (var i = 1, ilen = lst2.length; i < ilen; i += 2) {
            if ("object" === typeof lst2[i]) {
              lst2[i][3] = minimize_internal(lst2[i][1], lst2[i][3], minchars, isyear);
              if (lst2[i][2].slice(1) === lst2[i][0]) {
                lst2[i][2] = range_delimiter;
              }
            }
          }
          return stringify2(lst2);
        };
        minimize_internal = function(begin2, end2, minchars, isyear) {
          if (!minchars) {
            minchars = 0;
          }
          b = ("" + begin2).split("");
          e = ("" + end2).split("");
          ret = e.slice();
          ret.reverse();
          if (b.length === e.length) {
            for (var i = 0, ilen = b.length; i < ilen; i += 1) {
              if (b[i] === e[i] && ret.length > minchars) {
                ret.pop();
              } else {
                if (minchars && isyear && ret.length === 3) {
                  var front = b.slice(0, i);
                  front.reverse();
                  ret = ret.concat(front);
                }
                break;
              }
            }
          }
          ret.reverse();
          return ret.join("");
        };
        chicago15 = function(lst2) {
          len = lst2.length;
          for (pos = 1; pos < len; pos += 2) {
            if ("object" === typeof lst2[pos]) {
              m = lst2[pos];
              begin = parseInt(m[1], 10);
              end = parseInt(m[3], 10);
              if (begin > 100 && begin % 100 && parseInt(begin / 100, 10) === parseInt(end / 100, 10)) {
                m[3] = "" + end % 100;
              } else if (begin >= 1e4) {
                m[3] = "" + end % 1e3;
              }
            }
            if (m[2].slice(1) === m[0]) {
              m[2] = range_delimiter;
            }
          }
          return stringify2(lst2);
        };
        chicago16 = function(lst2) {
          len = lst2.length;
          for (pos = 1; pos < len; pos += 2) {
            if ("object" === typeof lst2[pos]) {
              m = lst2[pos];
              begin = parseInt(m[1], 10);
              end = parseInt(m[3], 10);
              e = "" + end;
              if (begin > 100 && begin % 100) {
                for (var i = 2; i < e.length; i++) {
                  var divisor = Math.pow(10, i);
                  if (Math.floor(begin / divisor) === Math.floor(end / divisor)) {
                    m[3] = "" + end % divisor;
                    break;
                  }
                }
              }
            }
            if (m[2].slice(1) === m[0]) {
              m[2] = range_delimiter;
            }
          }
          return stringify2(lst2);
        };
        var sniff = function(str, func, minchars, isyear) {
          var ret2;
          str = "" + str;
          var lst2 = expand(str);
          var ret2 = func(lst2, minchars, isyear);
          return ret2;
        };
        if (!state.opt[rangeType + "-range-format"]) {
          ret_func = function(str) {
            return sniff(str, stringify2);
          };
        } else if (state.opt[rangeType + "-range-format"] === "expanded") {
          ret_func = function(str) {
            return sniff(str, stringify2);
          };
        } else if (state.opt[rangeType + "-range-format"] === "minimal") {
          ret_func = function(str) {
            return sniff(str, minimize);
          };
        } else if (state.opt[rangeType + "-range-format"] === "minimal-two") {
          ret_func = function(str, isyear) {
            return sniff(str, minimize, 2, isyear);
          };
        } else if (state.opt[rangeType + "-range-format"] === "chicago") {
          ret_func = function(str) {
            return sniff(str, chicago15);
          };
        } else if (state.opt[rangeType + "-range-format"] === "chicago-15") {
          ret_func = function(str) {
            return sniff(str, chicago15);
          };
        } else if (state.opt[rangeType + "-range-format"] === "chicago-16") {
          ret_func = function(str) {
            return sniff(str, chicago16);
          };
        }
        return ret_func;
      };
      CSL3.Util.FlipFlopper = function(state) {
        var _nestingState = [];
        var _nestingData = {
          '<span class="nocase">': {
            type: "nocase",
            opener: '<span class="nocase">',
            closer: "</span>",
            attr: null,
            outer: null,
            flipflop: null
          },
          '<span class="nodecor">': {
            type: "nodecor",
            opener: '<span class="nodecor">',
            closer: "</span>",
            attr: "@class",
            outer: "nodecor",
            flipflop: {
              "nodecor": "nodecor"
            }
          },
          '<span style="font-variant:small-caps;">': {
            type: "tag",
            opener: '<span style="font-variant:small-caps;">',
            closer: "</span>",
            attr: "@font-variant",
            outer: "small-caps",
            flipflop: {
              "small-caps": "normal",
              "normal": "small-caps"
            }
          },
          "<sc>": {
            type: "tag",
            opener: "<sc>",
            closer: "</sc>",
            attr: "@font-variant",
            outer: "small-caps",
            flipflop: {
              "small-caps": "normal",
              "normal": "small-caps"
            }
          },
          "<i>": {
            type: "tag",
            opener: "<i>",
            closer: "</i>",
            attr: "@font-style",
            outer: "italic",
            flipflop: {
              "italic": "normal",
              "normal": "italic"
            }
          },
          "<b>": {
            type: "tag",
            opener: "<b>",
            closer: "</b>",
            attr: "@font-weight",
            outer: "bold",
            flipflop: {
              "bold": "normal",
              "normal": "bold"
            }
          },
          "<sup>": {
            type: "tag",
            opener: "<sup>",
            closer: "</sup>",
            attr: "@vertical-align",
            outer: "sup",
            flipflop: {
              "sub": "sup",
              "sup": "sup"
            }
          },
          "<sub>": {
            type: "tag",
            opener: "<sub>",
            closer: "</sub>",
            attr: "@vertical-align",
            outer: "sub",
            flipflop: {
              "sup": "sub",
              "sub": "sub"
            }
          },
          ' "': {
            type: "quote",
            opener: ' "',
            closer: '"',
            attr: "@quotes",
            outer: "true",
            flipflop: {
              "true": "inner",
              "inner": "true",
              "false": "true"
            }
          },
          " '": {
            type: "quote",
            opener: " '",
            closer: "'",
            attr: "@quotes",
            outer: "inner",
            flipflop: {
              "true": "inner",
              "inner": "true",
              "false": "true"
            }
          }
        };
        _nestingData['("'] = _nestingData[' "'];
        _nestingData["('"] = _nestingData[" '"];
        var localeOpenQuote = state.getTerm("open-quote");
        var localeCloseQuote = state.getTerm("close-quote");
        var localeOpenInnerQuote = state.getTerm("open-inner-quote");
        var localeCloseInnerQuote = state.getTerm("close-inner-quote");
        if (localeOpenQuote && localeCloseQuote && [' "', " '", '"', "'"].indexOf(localeOpenQuote) === -1) {
          _nestingData[localeOpenQuote] = JSON.parse(JSON.stringify(_nestingData[' "']));
          _nestingData[localeOpenQuote].opener = localeOpenQuote;
          _nestingData[localeOpenQuote].closer = localeCloseQuote;
        }
        if (localeOpenInnerQuote && localeCloseInnerQuote && [' "', " '", '"', "'"].indexOf(localeOpenInnerQuote) === -1) {
          _nestingData[localeOpenInnerQuote] = JSON.parse(JSON.stringify(_nestingData[" '"]));
          _nestingData[localeOpenInnerQuote].opener = localeOpenInnerQuote;
          _nestingData[localeOpenInnerQuote].closer = localeCloseInnerQuote;
        }
        function _setOuterQuoteForm(quot) {
          var flip = {
            " '": ' "',
            ' "': " '",
            '("': "('",
            "('": '("'
          };
          _nestingData[quot].outer = "true";
          _nestingData[flip[quot]].outer = "inner";
        }
        function _getNestingOpenerParams(opener) {
          var openers = [];
          var keys = Object.keys(_nestingData);
          for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            if (_nestingData[opener].type !== "quote" || !_nestingData[opener]) {
              openers.push(key);
            }
          }
          var ret = _nestingData[opener];
          ret.opener = new RegExp("^(?:" + openers.map(function(str) {
            return str.replace("(", "\\(");
          }).join("|") + ")");
          return ret;
        }
        var _nestingParams = function() {
          var ret = {};
          var keys = Object.keys(_nestingData);
          for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            ret[key] = _getNestingOpenerParams(key);
          }
          return ret;
        }();
        var _tagRex = function() {
          var openers = [];
          var closers = [];
          var vals = {};
          for (var opener in _nestingParams) {
            openers.push(opener);
            vals[_nestingParams[opener].closer] = true;
          }
          var keys = Object.keys(vals);
          for (var i = 0, l = keys.length; i < l; i++) {
            var closer = keys[i];
            closers.push(closer);
          }
          var all = openers.concat(closers).map(function(str) {
            return str.replace("(", "\\(");
          }).join("|");
          return {
            matchAll: new RegExp("((?:" + all + "))", "g"),
            splitAll: new RegExp("(?:" + all + ")", "g"),
            open: new RegExp("(^(?:" + openers.map(function(str) {
              return str.replace("(", "\\(");
            }).join("|") + ")$)"),
            close: new RegExp("(^(?:" + closers.join("|") + ")$)")
          };
        }();
        function _tryOpen(tag, pos) {
          var params = _nestingState[_nestingState.length - 1];
          if (!params || tag.match(params.opener)) {
            _nestingState.push({
              type: _nestingParams[tag].type,
              opener: _nestingParams[tag].opener,
              closer: _nestingParams[tag].closer,
              pos
            });
            return false;
          } else {
            _nestingState.pop();
            _nestingState.push({
              type: _nestingParams[tag].type,
              opener: _nestingParams[tag].opener,
              closer: _nestingParams[tag].closer,
              pos
            });
            return {
              fixtag: params.pos
            };
          }
        }
        function _tryClose(tag, pos) {
          var params = _nestingState[_nestingState.length - 1];
          if (params && tag === params.closer) {
            _nestingState.pop();
            if (params.type === "nocase") {
              return {
                nocase: {
                  open: params.pos,
                  close: pos
                }
              };
            } else {
              return false;
            }
          } else {
            if (params) {
              return {
                fixtag: params.pos
              };
            } else {
              return {
                fixtag: pos
              };
            }
          }
        }
        function _pushNestingState(tag, pos) {
          if (tag.match(_tagRex.open)) {
            return _tryOpen(tag, pos);
          } else {
            return _tryClose(tag, pos);
          }
        }
        function _doppelString(str) {
          var forcedSpaces = [];
          str = str.replace(/(<span)\s+(style=\"font-variant:)\s*(small-caps);?\"[^>]*(>)/g, '$1 $2$3;"$4');
          str = str.replace(/(<span)\s+(class=\"no(?:case|decor)\")[^>]*(>)/g, "$1 $2$3");
          var match = str.match(_tagRex.matchAll);
          if (!match) {
            return {
              tags: [],
              strings: [str],
              forcedSpaces: []
            };
          }
          var split = str.split(_tagRex.splitAll);
          for (var i = 0, ilen = match.length - 1; i < ilen; i++) {
            if (_nestingData[match[i]]) {
              if (split[i + 1] === "" && ['"', "'"].indexOf(match[i + 1]) > -1) {
                match[i + 1] = " " + match[i + 1];
                forcedSpaces.push(true);
              } else {
                forcedSpaces.push(false);
              }
            }
          }
          return {
            tags: match,
            strings: split,
            forcedSpaces
          };
        }
        var TagReg = function(blob) {
          var _stack = [];
          this.set = function(tag) {
            var attr = _nestingData[tag].attr;
            var decor = null;
            for (var i = _stack.length - 1; i > -1; i--) {
              var _decor = _stack[i];
              if (_decor[0] === attr) {
                decor = _decor;
                break;
              }
            }
            if (!decor) {
              var allTheDecor = [state[state.tmp.area].opt.layout_decorations].concat(blob.alldecor);
              outer:
                for (var i = allTheDecor.length - 1; i > -1; i--) {
                  var decorset = allTheDecor[i];
                  if (!decorset) {
                    continue;
                  }
                  for (var j = decorset.length - 1; j > -1; j--) {
                    var _decor = decorset[j];
                    if (_decor[0] === attr) {
                      decor = _decor;
                      break outer;
                    }
                  }
                }
            }
            if (!decor) {
              decor = [attr, _nestingData[tag].outer];
            } else {
              decor = [attr, _nestingData[tag].flipflop[decor[1]]];
            }
            _stack.push(decor);
          };
          this.pair = function() {
            return _stack[_stack.length - 1];
          };
          this.pop = function() {
            _stack.pop();
          };
        };
        function _apostropheForce(tag, str) {
          if (tag === "'") {
            if (str && str.match(/^[^\,\.\?\:\;\ ]/)) {
              return "\u2019";
            }
          } else if (tag === " '" && str && str.match(/^[\ ]/)) {
            return " \u2019";
          }
          return false;
        }
        function _undoppelToQueue(blob, doppel, leadingSpace) {
          var firstString = true;
          var tagReg = new TagReg(blob);
          blob.blobs = [];
          function Stack(blob2) {
            this.stack = [blob2];
            this.latest = blob2;
            this.addStyling = function(str2, decor) {
              if (firstString) {
                if (str2.slice(0, 1) === " ") {
                  str2 = str2.slice(1);
                }
                if (str2.slice(0, 1) === " ") {
                  str2 = str2.slice(1);
                }
                firstString = false;
              }
              this.latest = this.stack[this.stack.length - 1];
              if (decor) {
                if ("string" === typeof this.latest.blobs) {
                  var child = new CSL3.Blob();
                  child.blobs = this.latest.blobs;
                  child.alldecor = this.latest.alldecor.slice();
                  this.latest.blobs = [child];
                }
                var tok = new CSL3.Token();
                var newblob = new CSL3.Blob(null, tok);
                newblob.alldecor = this.latest.alldecor.slice();
                if (decor[0] === "@class" && decor[1] === "nodecor") {
                  var newdecorset = [];
                  var seen = {};
                  var allTheDecor = [state[state.tmp.area].opt.layout_decorations].concat(newblob.alldecor);
                  for (var i2 = allTheDecor.length - 1; i2 > -1; i2--) {
                    var _decorset = allTheDecor[i2];
                    if (!_decorset) {
                      continue;
                    }
                    for (var j = _decorset.length - 1; j > -1; j--) {
                      var _olddecor = _decorset[j];
                      if (["@font-weight", "@font-style", "@font-variant"].indexOf(_olddecor[0]) > -1 && !seen[_olddecor[0]]) {
                        if (decor[1] !== "normal") {
                          newblob.decorations.push([_olddecor[0], "normal"]);
                          newdecorset.push([_olddecor[0], "normal"]);
                        }
                        seen[_olddecor[0]] = true;
                      }
                    }
                  }
                  newblob.alldecor.push(newdecorset);
                } else {
                  newblob.decorations.push(decor);
                  newblob.alldecor.push([decor]);
                }
                this.latest.blobs.push(newblob);
                this.stack.push(newblob);
                this.latest = newblob;
                if (str2) {
                  var tok = new CSL3.Token();
                  var newblob = new CSL3.Blob(null, tok);
                  newblob.blobs = str2;
                  newblob.alldecor = this.latest.alldecor.slice();
                  this.latest.blobs.push(newblob);
                }
              } else {
                if (str2) {
                  var child = new CSL3.Blob();
                  child.blobs = str2;
                  child.alldecor = this.latest.alldecor.slice();
                  this.latest.blobs.push(child);
                }
              }
            };
            this.popStyling = function() {
              this.stack.pop();
            };
          }
          var stack = new Stack(blob);
          if (doppel.strings.length) {
            var str = doppel.strings[0];
            if (leadingSpace) {
              str = " " + str;
            }
            stack.addStyling(str);
          }
          for (var i = 0, ilen = doppel.tags.length; i < ilen; i++) {
            var tag = doppel.tags[i];
            var str = doppel.strings[i + 1];
            if (tag.match(_tagRex.open)) {
              tagReg.set(tag);
              stack.addStyling(str, tagReg.pair());
            } else {
              tagReg.pop();
              stack.popStyling();
              stack.addStyling(str);
            }
          }
        }
        this.processTags = function(blob) {
          var str = blob.blobs;
          var leadingSpace = false;
          if (str.slice(0, 1) === " " && !str.match(/^\s+[\'\"]/)) {
            leadingSpace = true;
          }
          var rex = new RegExp("(" + CSL3.ROMANESQUE_REGEXP.source + ")\u2019(" + CSL3.ROMANESQUE_REGEXP.source + ")", "g");
          var str = " " + str.replace(rex, "$1'$2");
          var doppel = _doppelString(str);
          if (doppel.tags.length === 0) {
            return;
          }
          var quoteFormSeen = false;
          for (var i = 0, ilen = doppel.tags.length; i < ilen; i++) {
            var tag = doppel.tags[i];
            var str = doppel.strings[i + 1];
            var apostrophe = _apostropheForce(tag, str);
            if (apostrophe) {
              doppel.strings[i + 1] = apostrophe + doppel.strings[i + 1];
              doppel.tags[i] = "";
            } else {
              var tagInfo;
              while (true) {
                tagInfo = _pushNestingState(tag, i);
                if (tagInfo) {
                  if (Object.keys(tagInfo).indexOf("fixtag") > -1) {
                    if (tag.match(_tagRex.close) && tag === "'") {
                      doppel.strings[i + 1] = "\u2019" + doppel.strings[i + 1];
                      doppel.tags[i] = "";
                    } else {
                      var failedTag = doppel.tags[tagInfo.fixtag];
                      if (doppel.forcedSpaces[tagInfo.fixtag - 1]) {
                        failedTag = failedTag.slice(1);
                      }
                      doppel.strings[tagInfo.fixtag + 1] = failedTag + doppel.strings[tagInfo.fixtag + 1];
                      doppel.tags[tagInfo.fixtag] = "";
                    }
                    if (_nestingState.length > 0) {
                      if (tag !== "'") {
                        _nestingState.pop();
                      } else {
                        break;
                      }
                    } else {
                      break;
                    }
                  } else if (tagInfo.nocase) {
                    doppel.tags[tagInfo.nocase.open] = "";
                    doppel.tags[tagInfo.nocase.close] = "";
                    break;
                  } else {
                    break;
                  }
                } else {
                  break;
                }
              }
              if (tagInfo && (tagInfo.fixtag || tagInfo.fixtag === 0)) {
                doppel.strings[i + 1] = doppel.tags[i] + doppel.strings[i + 1];
                doppel.tags[i] = "";
              }
            }
          }
          for (var i = _nestingState.length - 1; i > -1; i--) {
            var tagPos = _nestingState[i].pos;
            var tag = doppel.tags[tagPos];
            if (tag === " '" || tag === "'") {
              doppel.strings[tagPos + 1] = " \u2019" + doppel.strings[tagPos + 1];
            } else {
              doppel.strings[tagPos + 1] = doppel.tags[tagPos] + doppel.strings[tagPos + 1];
            }
            doppel.tags[tagPos] = "";
            _nestingState.pop();
          }
          for (var i = doppel.tags.length - 1; i > -1; i--) {
            if (!doppel.tags[i]) {
              doppel.tags = doppel.tags.slice(0, i).concat(doppel.tags.slice(i + 1));
              doppel.strings[i] = doppel.strings[i] + doppel.strings[i + 1];
              doppel.strings = doppel.strings.slice(0, i + 1).concat(doppel.strings.slice(i + 2));
            }
          }
          for (var i = 0, ilen = doppel.tags.length; i < ilen; i++) {
            var tag = doppel.tags[i];
            var forcedSpace = doppel.forcedSpaces[i - 1];
            if ([' "', " '", '("', "('"].indexOf(tag) > -1) {
              if (!quoteFormSeen) {
                _setOuterQuoteForm(tag);
                quoteFormSeen = true;
              }
              if (!forcedSpace) {
                doppel.strings[i] += tag.slice(0, 1);
              }
            }
          }
          _undoppelToQueue(blob, doppel, leadingSpace);
        };
      };
      CSL3.Output.Formatters = function() {
        var rexStr = `(?:\u2018|\u2019|\u201C|\u201D| "| '|"|'|[-\u2013\u2014/.,;?!:]|\\[|\\]|\\(|\\)|<span style="font-variant: small-caps;">|<span class="no(?:case|decor)">|</span>|</?(?:i|sc|b|sub|sup)>)`;
        var tagDoppel = new CSL3.Doppeler(rexStr, function(str) {
          return str.replace(/(<span)\s+(class=\"no(?:case|decor)\")[^>]*(>)/g, "$1 $2$3").replace(/(<span)\s+(style=\"font-variant:)\s*(small-caps);?(\")[^>]*(>)/g, "$1 $2 $3;$4$5");
        });
        var rexNameStr = '(?:[-\\s]*<\\/*(?:spans+class="no(?:case|decor)"|i|sc|b|sub|sup)>[-\\s]*|[-\\s]+)';
        var nameDoppel = new CSL3.Doppeler(rexNameStr);
        var wordDoppel = new CSL3.Doppeler("(?:[\xA0 \xA0\u2000-\u200B\u205F\u3000]+)");
        var _tagParams = {
          '<span style="font-variant: small-caps;">': "</span>",
          '<span class="nocase">': "</span>",
          '<span class="nodecor">': "</span>",
          "<sc>": "</sc>",
          "<sub>": "</sub>",
          "<sup>": "</sup>"
        };
        function _capitalise(word) {
          var m = word.match(/(^\s*)((?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]))(.*)/);
          if (m && !(m[2].match(/^[\u0370-\u03FF]$/) && !m[3])) {
            return m[1] + CSL3.toLocaleUpperCase.call(this, m[2]) + m[3];
          }
          return word;
        }
        function _textcaseEngine(config, string) {
          if (!string) {
            return "";
          }
          config.doppel = tagDoppel.split(string);
          var quoteParams = {
            ' "': {
              opener: " '",
              closer: '"'
            },
            " '": {
              opener: ' "',
              closer: "'"
            },
            "\u2018": {
              opener: "\u2018",
              closer: "\u2019"
            },
            "\u201C": {
              opener: "\u201C",
              closer: "\u201D"
            }
          };
          function tryOpen(tag2, pos) {
            if (config.quoteState.length === 0 || tag2 === config.quoteState[config.quoteState.length - 1].opener) {
              config.quoteState.push({
                opener: quoteParams[tag2].opener,
                closer: quoteParams[tag2].closer,
                pos
              });
              return false;
            } else {
              var prevPos = config.quoteState[config.quoteState.length - 1].pos;
              config.quoteState.pop();
              config.quoteState.push({
                opener: quoteParams[tag2].opener,
                closer: quoteParams[tag2].closer,
                positions: pos
              });
              return prevPos;
            }
          }
          function tryClose(tag2, pos) {
            if (config.quoteState.length > 0 && tag2 === config.quoteState[config.quoteState.length - 1].closer) {
              config.quoteState.pop();
            } else {
              return pos;
            }
          }
          function pushQuoteState(tag2, pos) {
            var isOpener = ["\u201C", "\u2018", ' "', " '"].indexOf(tag2) > -1 ? true : false;
            if (isOpener) {
              return tryOpen(tag2, pos);
            } else {
              return tryClose(tag2, pos);
            }
          }
          function quoteFix(tag2, positions) {
            var m = tag2.match(/(^(?:\u2018|\u2019|\u201C|\u201D|\"|\')|(?: \"| \')$)/);
            if (m) {
              return pushQuoteState(m[1], positions);
            }
          }
          if (config.doppel.strings.length && config.doppel.strings[0].trim()) {
            config.doppel.strings[0] = config.capitaliseWords(config.doppel.strings[0], 0, config.doppel.tags[0]);
          }
          for (var i = 0, ilen = config.doppel.tags.length; i < ilen; i++) {
            var tag = config.doppel.tags[i];
            var str = config.doppel.strings[i + 1];
            if (config.tagState !== null) {
              if (_tagParams[tag]) {
                config.tagState.push(_tagParams[tag]);
              } else if (config.tagState.length && tag === config.tagState[config.tagState.length - 1]) {
                config.tagState.pop();
              }
            }
            if (config.afterPunct !== null) {
              if (tag.match(/[\!\?\:]$/)) {
                config.afterPunct = true;
              }
            }
            if (config.tagState.length === 0) {
              config.doppel.strings[i + 1] = config.capitaliseWords(str, i + 1, config.doppel, config.doppel.tags[i + 1]);
            } else if (config.doppel.strings[i + 1].trim()) {
              config.lastWordPos = null;
            }
            if (config.quoteState !== null) {
              var quotePos = quoteFix(tag, i);
              if (quotePos || quotePos === 0) {
                var origChar = config.doppel.origStrings[quotePos + 1].slice(0, 1);
                config.doppel.strings[quotePos + 1] = origChar + config.doppel.strings[quotePos + 1].slice(1);
                config.lastWordPos = null;
              }
            }
            if (config.isFirst) {
              if (str.trim()) {
                config.isFirst = false;
              }
            }
            if (config.afterPunct) {
              if (str.trim()) {
                config.afterPunct = false;
              }
            }
          }
          if (config.quoteState) {
            for (var i = 0, ilen = config.quoteState.length; i < ilen; i++) {
              var quotePos = config.quoteState[i].pos;
              if (typeof quotePos !== "undefined") {
                var origChar = config.doppel.origStrings[quotePos + 1].slice(0, 1);
                config.doppel.strings[quotePos + 1] = origChar + config.doppel.strings[quotePos + 1].slice(1);
              }
            }
          }
          if (config.lastWordPos) {
            var lastWords = wordDoppel.split(config.doppel.strings[config.lastWordPos.strings]);
            var lastWord = lastWords.strings[config.lastWordPos.words];
            if (lastWord.length > 1 && CSL3.toLocaleLowerCase.call(this, lastWord).match(config.skipWordsRex)) {
              lastWord = _capitalise.call(this, lastWord);
              lastWords.strings[config.lastWordPos.words] = lastWord;
            }
            config.doppel.strings[config.lastWordPos.strings] = wordDoppel.join(lastWords);
          }
          return tagDoppel.join(config.doppel);
        }
        function passthrough(state, str) {
          return str;
        }
        function lowercase(state, string) {
          var config = {
            quoteState: null,
            capitaliseWords: function(str) {
              var words = str.split(" ");
              for (var i = 0, ilen = words.length; i < ilen; i++) {
                var word = words[i];
                if (word) {
                  words[i] = CSL3.toLocaleLowerCase.call(state, word);
                }
              }
              return words.join(" ");
            },
            skipWordsRex: null,
            tagState: [],
            afterPunct: null,
            isFirst: null
          };
          return _textcaseEngine.call(state, config, string);
        }
        function uppercase(state, string) {
          var config = {
            quoteState: null,
            capitaliseWords: function(str) {
              var words = str.split(" ");
              for (var i = 0, ilen = words.length; i < ilen; i++) {
                var word = words[i];
                if (word) {
                  words[i] = CSL3.toLocaleUpperCase.call(state, word);
                }
              }
              return words.join(" ");
            },
            skipWordsRex: null,
            tagState: [],
            afterPunct: null,
            isFirst: null
          };
          return _textcaseEngine.call(state, config, string);
        }
        function sentence(state, string) {
          var config = {
            quoteState: [],
            capitaliseWords: function(str) {
              var words = str.split(" ");
              for (var i = 0, ilen = words.length; i < ilen; i++) {
                var word = words[i];
                if (word) {
                  if (config.isFirst) {
                    words[i] = _capitalise.call(state, word);
                    config.isFirst = false;
                  } else {
                    words[i] = CSL3.toLocaleLowerCase.call(state, word);
                  }
                }
              }
              return words.join(" ");
            },
            skipWordsRex: null,
            tagState: [],
            afterPunct: null,
            isFirst: true
          };
          return _textcaseEngine.call(state, config, string);
        }
        function title(state, string) {
          var config = {
            quoteState: [],
            capitaliseWords: function(str, i, followingTag) {
              if (str.trim()) {
                var wordle = wordDoppel.split(str);
                var words = wordle.strings;
                for (var j = 0, jlen = words.length; j < jlen; j++) {
                  var word = words[j];
                  if (!word) {
                    continue;
                  }
                  let lcase = CSL3.toLocaleLowerCase.call(state, word);
                  let capitalize = false;
                  if (word.length > 1 && !lcase.match(config.skipWordsRex)) {
                    capitalize = true;
                  } else if (j === words.length - 1 && followingTag === "-") {
                    capitalize = true;
                  } else if (config.isFirst) {
                    capitalize = true;
                  } else if (config.afterPunct) {
                    capitalize = true;
                  }
                  if (capitalize && word === lcase) {
                    words[j] = _capitalise.call(state, word);
                  }
                  config.afterPunct = false;
                  config.isFirst = false;
                  config.lastWordPos = {
                    strings: i,
                    words: j
                  };
                }
                str = wordDoppel.join(wordle);
              }
              return str;
            },
            skipWordsRex: state.locale[state.opt.lang].opts["skip-words-regexp"],
            tagState: [],
            afterPunct: false,
            isFirst: true
          };
          return _textcaseEngine.call(state, config, string);
        }
        function capitalizeFirst(state, string) {
          var config = {
            quoteState: [],
            capitaliseWords: function(str) {
              var wordle = wordDoppel.split(str);
              var words = wordle.strings;
              for (var i = 0, ilen = words.length; i < ilen; i++) {
                var word = words[i];
                if (word) {
                  if (config.isFirst) {
                    if (word === CSL3.toLocaleLowerCase.call(state, word)) {
                      words[i] = _capitalise.call(state, word);
                    }
                    config.isFirst = false;
                    break;
                  }
                }
              }
              return wordDoppel.join(wordle);
            },
            skipWordsRex: null,
            tagState: [],
            afterPunct: null,
            isFirst: true
          };
          return _textcaseEngine.call(state, config, string);
        }
        function capitalizeAll(state, string) {
          var config = {
            quoteState: [],
            capitaliseWords: function(str) {
              var wordle = wordDoppel.split(str);
              var words = wordle.strings;
              for (var i = 0, ilen = words.length; i < ilen; i++) {
                var word = words[i];
                if (word) {
                  if (word === CSL3.toLocaleLowerCase.call(state, word)) {
                    words[i] = _capitalise.call(state, word);
                  }
                }
              }
              return wordDoppel.join(wordle);
            },
            skipWordsRex: null,
            tagState: [],
            afterPunct: null,
            isFirst: null
          };
          return _textcaseEngine.call(state, config, string);
        }
        return {
          nameDoppel,
          passthrough,
          lowercase,
          uppercase,
          sentence,
          title,
          "capitalize-first": capitalizeFirst,
          "capitalize-all": capitalizeAll
        };
      }();
      CSL3.Output.Formats = function() {
      };
      CSL3.Output.Formats.prototype.html = {
        //
        // text_escape: Format-specific function for escaping text destined
        // for output.  Takes the text to be escaped as sole argument.  Function
        // will be run only once across each portion of text to be escaped, it
        // need not be idempotent.
        //
        "text_escape": function(text) {
          if (!text) {
            text = "";
          }
          return text.replace(/&/g, "&#38;").replace(/</g, "&#60;").replace(/>/g, "&#62;").replace(/\s\s/g, "\xA0 ").replace(
            CSL3.SUPERSCRIPTS_REGEXP,
            function(aChar) {
              return "<sup>" + CSL3.SUPERSCRIPTS[aChar] + "</sup>";
            }
          );
        },
        "bibstart": '<div class="csl-bib-body">\n',
        "bibend": "</div>",
        "@font-style/italic": "<i>%%STRING%%</i>",
        "@font-style/oblique": "<em>%%STRING%%</em>",
        "@font-style/normal": '<span style="font-style:normal;">%%STRING%%</span>',
        "@font-variant/small-caps": '<span style="font-variant:small-caps;">%%STRING%%</span>',
        "@passthrough/true": CSL3.Output.Formatters.passthrough,
        "@font-variant/normal": '<span style="font-variant:normal;">%%STRING%%</span>',
        "@font-weight/bold": "<b>%%STRING%%</b>",
        "@font-weight/normal": '<span style="font-weight:normal;">%%STRING%%</span>',
        "@font-weight/light": false,
        "@text-decoration/none": '<span style="text-decoration:none;">%%STRING%%</span>',
        "@text-decoration/underline": '<span style="text-decoration:underline;">%%STRING%%</span>',
        "@vertical-align/sup": "<sup>%%STRING%%</sup>",
        "@vertical-align/sub": "<sub>%%STRING%%</sub>",
        "@vertical-align/baseline": '<span style="baseline">%%STRING%%</span>',
        "@strip-periods/true": CSL3.Output.Formatters.passthrough,
        "@strip-periods/false": CSL3.Output.Formatters.passthrough,
        "@quotes/true": function(state, str) {
          if ("undefined" === typeof str) {
            return state.getTerm("open-quote");
          }
          return state.getTerm("open-quote") + str + state.getTerm("close-quote");
        },
        "@quotes/inner": function(state, str) {
          if ("undefined" === typeof str) {
            return "\u2019";
          }
          return state.getTerm("open-inner-quote") + str + state.getTerm("close-inner-quote");
        },
        "@quotes/false": false,
        //"@bibliography/body": function (state,str){
        //    return "<div class=\"csl-bib-body\">\n"+str+"</div>";
        //},
        "@cite/entry": function(state, str) {
          return state.sys.wrapCitationEntry(str, this.item_id, this.locator_txt, this.suffix_txt);
        },
        "@bibliography/entry": function(state, str) {
          var insert = "";
          if (state.sys.embedBibliographyEntry) {
            insert = state.sys.embedBibliographyEntry(this.item_id) + "\n";
          }
          return '  <div class="csl-entry">' + str + "</div>\n" + insert;
        },
        "@display/block": function(state, str) {
          return '\n\n    <div class="csl-block">' + str + "</div>\n";
        },
        "@display/left-margin": function(state, str) {
          return '\n    <div class="csl-left-margin">' + str + "</div>";
        },
        "@display/right-inline": function(state, str) {
          return '<div class="csl-right-inline">' + str + "</div>\n  ";
        },
        "@display/indent": function(state, str) {
          return '<div class="csl-indent">' + str + "</div>\n  ";
        },
        "@showid/true": function(state, str, cslid) {
          if (!state.tmp.just_looking && !state.tmp.suppress_decorations) {
            if (cslid) {
              return '<span class="' + state.opt.nodenames[cslid] + '" cslid="' + cslid + '">' + str + "</span>";
            } else if (this.params && "string" === typeof str) {
              var prePunct = "";
              if (str) {
                var m = str.match(CSL3.VARIABLE_WRAPPER_PREPUNCT_REX);
                prePunct = m[1];
                str = m[2];
              }
              var postPunct = "";
              if (str && CSL3.SWAPPING_PUNCTUATION.indexOf(str.slice(-1)) > -1) {
                postPunct = str.slice(-1);
                str = str.slice(0, -1);
              }
              return state.sys.variableWrapper(this.params, prePunct, str, postPunct);
            } else {
              return str;
            }
          } else {
            return str;
          }
        },
        "@URL/true": function(state, str) {
          return '<a href="' + str + '">' + str + "</a>";
        },
        "@DOI/true": function(state, str) {
          var doiurl = str;
          if (!str.match(/^https?:\/\//)) {
            doiurl = "https://doi.org/" + str;
          }
          return '<a href="' + doiurl + '">' + str + "</a>";
        }
      };
      CSL3.Output.Formats.prototype.text = {
        //
        // text_escape: Format-specific function for escaping text destined
        // for output.  Takes the text to be escaped as sole argument.  Function
        // will be run only once across each portion of text to be escaped, it
        // need not be idempotent.
        //
        "text_escape": function(text) {
          if (!text) {
            text = "";
          }
          return text;
        },
        "bibstart": "",
        "bibend": "",
        "@font-style/italic": false,
        "@font-style/oblique": false,
        "@font-style/normal": false,
        "@font-variant/small-caps": false,
        "@passthrough/true": CSL3.Output.Formatters.passthrough,
        "@font-variant/normal": false,
        "@font-weight/bold": false,
        "@font-weight/normal": false,
        "@font-weight/light": false,
        "@text-decoration/none": false,
        "@text-decoration/underline": false,
        "@vertical-align/baseline": false,
        "@vertical-align/sup": false,
        "@vertical-align/sub": false,
        "@strip-periods/true": CSL3.Output.Formatters.passthrough,
        "@strip-periods/false": CSL3.Output.Formatters.passthrough,
        "@quotes/true": function(state, str) {
          if ("undefined" === typeof str) {
            return state.getTerm("open-quote");
          }
          return state.getTerm("open-quote") + str + state.getTerm("close-quote");
        },
        "@quotes/inner": function(state, str) {
          if ("undefined" === typeof str) {
            return "\u2019";
          }
          return state.getTerm("open-inner-quote") + str + state.getTerm("close-inner-quote");
        },
        "@quotes/false": false,
        //"@bibliography/body": function (state,str){
        //    return "<div class=\"csl-bib-body\">\n"+str+"</div>";
        //},
        "@cite/entry": function(state, str) {
          return state.sys.wrapCitationEntry(str, this.item_id, this.locator_txt, this.suffix_txt);
        },
        "@bibliography/entry": function(state, str) {
          return str + "\n";
        },
        "@display/block": function(state, str) {
          return "\n" + str;
        },
        "@display/left-margin": function(state, str) {
          return str + " ";
        },
        "@display/right-inline": function(state, str) {
          return str;
        },
        "@display/indent": function(state, str) {
          return "\n    " + str;
        },
        "@showid/true": function(state, str) {
          return str;
        },
        "@URL/true": function(state, str) {
          return str;
        },
        "@DOI/true": function(state, str) {
          return str;
        }
      };
      CSL3.Output.Formats.prototype.rtf = {
        //
        // text_escape: Format-specific function for escaping text destined
        // for output.  Takes the text to be escaped as sole argument.  Function
        // will be run only once across each portion of text to be escaped, it
        // need not be idempotent.
        //
        "text_escape": function(text) {
          if (!text) {
            text = "";
          }
          return text.replace(/([\\{}])/g, "\\$1").replace(
            CSL3.SUPERSCRIPTS_REGEXP,
            function(aChar) {
              return "\\super " + CSL3.SUPERSCRIPTS[aChar] + "\\nosupersub{}";
            }
          ).replace(
            /[\u007F-\uFFFF]/g,
            function(aChar) {
              return "\\uc0\\u" + aChar.charCodeAt(0).toString() + "{}";
            }
          ).split("	").join("\\tab{}");
        },
        "@passthrough/true": CSL3.Output.Formatters.passthrough,
        "@font-style/italic": "{\\i{}%%STRING%%}",
        "@font-style/normal": "{\\i0{}%%STRING%%}",
        "@font-style/oblique": "{\\i{}%%STRING%%}",
        "@font-variant/small-caps": "{\\scaps %%STRING%%}",
        "@font-variant/normal": "{\\scaps0{}%%STRING%%}",
        "@font-weight/bold": "{\\b{}%%STRING%%}",
        "@font-weight/normal": "{\\b0{}%%STRING%%}",
        "@font-weight/light": false,
        "@text-decoration/none": false,
        "@text-decoration/underline": "{\\ul{}%%STRING%%}",
        "@vertical-align/baseline": false,
        "@vertical-align/sup": "\\super %%STRING%%\\nosupersub{}",
        "@vertical-align/sub": "\\sub %%STRING%%\\nosupersub{}",
        "@strip-periods/true": CSL3.Output.Formatters.passthrough,
        "@strip-periods/false": CSL3.Output.Formatters.passthrough,
        "@quotes/true": function(state, str) {
          if ("undefined" === typeof str) {
            return CSL3.Output.Formats.rtf.text_escape(state.getTerm("open-quote"));
          }
          return CSL3.Output.Formats.rtf.text_escape(state.getTerm("open-quote")) + str + CSL3.Output.Formats.rtf.text_escape(state.getTerm("close-quote"));
        },
        "@quotes/inner": function(state, str) {
          if ("undefined" === typeof str) {
            return CSL3.Output.Formats.rtf.text_escape("\u2019");
          }
          return CSL3.Output.Formats.rtf.text_escape(state.getTerm("open-inner-quote")) + str + CSL3.Output.Formats.rtf.text_escape(state.getTerm("close-inner-quote"));
        },
        "@quotes/false": false,
        "bibstart": "{\\rtf ",
        "bibend": "}",
        "@display/block": "\\line{}%%STRING%%\\line\r\n",
        "@cite/entry": function(state, str) {
          return state.sys.wrapCitationEntry(str, this.item_id, this.locator_txt, this.suffix_txt);
        },
        "@bibliography/entry": function(state, str) {
          return str;
        },
        "@display/left-margin": function(state, str) {
          return str + "\\tab ";
        },
        "@display/right-inline": function(state, str) {
          return str + "\r\n";
        },
        "@display/indent": function(state, str) {
          return "\n\\tab " + str + "\\line\r\n";
        },
        "@showid/true": function(state, str) {
          if (!state.tmp.just_looking && !state.tmp.suppress_decorations) {
            var prePunct = "";
            if (str) {
              var m = str.match(CSL3.VARIABLE_WRAPPER_PREPUNCT_REX);
              prePunct = m[1];
              str = m[2];
            }
            var postPunct = "";
            if (str && CSL3.SWAPPING_PUNCTUATION.indexOf(str.slice(-1)) > -1) {
              postPunct = str.slice(-1);
              str = str.slice(0, -1);
            }
            return state.sys.variableWrapper(this.params, prePunct, str, postPunct);
          } else {
            return str;
          }
        },
        "@URL/true": function(state, str) {
          return str;
        },
        "@DOI/true": function(state, str) {
          return str;
        }
      };
      CSL3.Output.Formats.prototype.asciidoc = {
        "text_escape": function(text) {
          if (!text) {
            text = "";
          }
          return text.replace("*", "pass:[*]", "g").replace("_", "pass:[_]", "g").replace("#", "pass:[#]", "g").replace("^", "pass:[^]", "g").replace("~", "pass:[~]", "g").replace("[[", "pass:[[[]", "g").replace("  ", "&#160; ", "g").replace(CSL3.SUPERSCRIPTS_REGEXP, function(aChar) {
            return "^" + CSL3.SUPERSCRIPTS[aChar] + "^";
          });
        },
        "bibstart": "",
        "bibend": "",
        "@passthrough/true": CSL3.Output.Formatters.passthrough,
        "@font-style/italic": "__%%STRING%%__",
        "@font-style/oblique": "__%%STRING%%__",
        "@font-style/normal": false,
        "@font-variant/small-caps": "[small-caps]#%%STRING%%#",
        "@font-variant/normal": false,
        "@font-weight/bold": "**%%STRING%%**",
        "@font-weight/normal": false,
        "@font-weight/light": false,
        "@text-decoration/none": false,
        "@text-decoration/underline": "[underline]##%%STRING%%##",
        "@vertical-align/sup": "^^%%STRING%%^^",
        "@vertical-align/sub": "~~%%STRING%%~~",
        "@vertical-align/baseline": false,
        "@strip-periods/true": CSL3.Output.Formatters.passthrough,
        "@strip-periods/false": CSL3.Output.Formatters.passthrough,
        "@quotes/true": function(state, str) {
          if ("undefined" === typeof str) {
            return "``";
          }
          return "``" + str + "''";
        },
        "@quotes/inner": function(state, str) {
          if ("undefined" === typeof str) {
            return "`";
          }
          return "`" + str + "'";
        },
        "@quotes/false": false,
        "@cite/entry": function(state, str) {
          return state.sys.wrapCitationEntry(str, this.item_id, this.locator_txt, this.suffix_txt);
        },
        "@bibliography/entry": function(state, str) {
          return str + "\n";
        },
        "@display/block": function(state, str) {
          return str;
        },
        "@display/left-margin": function(state, str) {
          return str;
        },
        "@display/right-inline": function(state, str) {
          return " " + str;
        },
        "@display/indent": function(state, str) {
          return " " + str;
        },
        "@showid/true": function(state, str) {
          if (!state.tmp.just_looking && !state.tmp.suppress_decorations && this.params && "string" === typeof str) {
            var prePunct = "";
            if (str) {
              var m = str.match(CSL3.VARIABLE_WRAPPER_PREPUNCT_REX);
              prePunct = m[1];
              str = m[2];
            }
            var postPunct = "";
            if (str && CSL3.SWAPPING_PUNCTUATION.indexOf(str.slice(-1)) > -1) {
              postPunct = str.slice(-1);
              str = str.slice(0, -1);
            }
            return state.sys.variableWrapper(this.params, prePunct, str, postPunct);
          } else {
            return str;
          }
        },
        "@URL/true": function(state, str) {
          return str;
        },
        "@DOI/true": function(state, str) {
          var doiurl = str;
          if (!str.match(/^https?:\/\//)) {
            doiurl = "https://doi.org/" + str;
          }
          return doiurl + "[" + str + "]";
        }
      };
      CSL3.Output.Formats.prototype.fo = {
        "text_escape": function(text) {
          if (!text) {
            text = "";
          }
          return text.replace(/&/g, "&#38;").replace(/</g, "&#60;").replace(/>/g, "&#62;").replace("  ", "&#160; ", "g").replace(CSL3.SUPERSCRIPTS_REGEXP, function(aChar) {
            return '<fo:inline vertical-align="super">' + CSL3.SUPERSCRIPTS[aChar] + "</fo:inline>";
          });
        },
        "bibstart": "",
        "bibend": "",
        "@passthrough/true": CSL3.Output.Formatters.passthrough,
        "@font-style/italic": '<fo:inline font-style="italic">%%STRING%%</fo:inline>',
        "@font-style/oblique": '<fo:inline font-style="oblique">%%STRING%%</fo:inline>',
        "@font-style/normal": '<fo:inline font-style="normal">%%STRING%%</fo:inline>',
        "@font-variant/small-caps": '<fo:inline font-variant="small-caps">%%STRING%%</fo:inline>',
        "@font-variant/normal": '<fo:inline font-variant="normal">%%STRING%%</fo:inline>',
        "@font-weight/bold": '<fo:inline font-weight="bold">%%STRING%%</fo:inline>',
        "@font-weight/normal": '<fo:inline font-weight="normal">%%STRING%%</fo:inline>',
        "@font-weight/light": '<fo:inline font-weight="lighter">%%STRING%%</fo:inline>',
        "@text-decoration/none": '<fo:inline text-decoration="none">%%STRING%%</fo:inline>',
        "@text-decoration/underline": '<fo:inline text-decoration="underline">%%STRING%%</fo:inline>',
        "@vertical-align/sup": '<fo:inline vertical-align="super">%%STRING%%</fo:inline>',
        "@vertical-align/sub": '<fo:inline vertical-align="sub">%%STRING%%</fo:inline>',
        "@vertical-align/baseline": '<fo:inline vertical-align="baseline">%%STRING%%</fo:inline>',
        "@strip-periods/true": CSL3.Output.Formatters.passthrough,
        "@strip-periods/false": CSL3.Output.Formatters.passthrough,
        "@quotes/true": function(state, str) {
          if ("undefined" === typeof str) {
            return state.getTerm("open-quote");
          }
          return state.getTerm("open-quote") + str + state.getTerm("close-quote");
        },
        "@quotes/inner": function(state, str) {
          if ("undefined" === typeof str) {
            return "\u2019";
          }
          return state.getTerm("open-inner-quote") + str + state.getTerm("close-inner-quote");
        },
        "@quotes/false": false,
        "@cite/entry": function(state, str) {
          return state.sys.wrapCitationEntry(str, this.item_id, this.locator_txt, this.suffix_txt);
        },
        "@bibliography/entry": function(state, str) {
          var indent = "";
          if (state.bibliography && state.bibliography.opt && state.bibliography.opt.hangingindent) {
            var hi = state.bibliography.opt.hangingindent;
            indent = ' start-indent="' + hi + 'em" text-indent="-' + hi + 'em"';
          }
          var insert = "";
          if (state.sys.embedBibliographyEntry) {
            insert = state.sys.embedBibliographyEntry(this.item_id) + "\n";
          }
          return '<fo:block id="' + this.system_id + '"' + indent + ">" + str + "</fo:block>\n" + insert;
        },
        "@display/block": function(state, str) {
          return "\n  <fo:block>" + str + "</fo:block>\n";
        },
        "@display/left-margin": function(state, str) {
          return '\n  <fo:table table-layout="fixed" width="100%">\n    <fo:table-column column-number="1" column-width="$$$__COLUMN_WIDTH_1__$$$"/>\n    <fo:table-column column-number="2" column-width="proportional-column-width(1)"/>\n    <fo:table-body>\n      <fo:table-row>\n        <fo:table-cell>\n          <fo:block>' + str + "</fo:block>\n        </fo:table-cell>\n        ";
        },
        "@display/right-inline": function(state, str) {
          return "<fo:table-cell>\n          <fo:block>" + str + "</fo:block>\n        </fo:table-cell>\n      </fo:table-row>\n    </fo:table-body>\n  </fo:table>\n";
        },
        "@display/indent": function(state, str) {
          return '<fo:block margin-left="2em">' + str + "</fo:block>\n";
        },
        "@showid/true": function(state, str) {
          if (!state.tmp.just_looking && !state.tmp.suppress_decorations && this.params && "string" === typeof str) {
            var prePunct = "";
            if (str) {
              var m = str.match(CSL3.VARIABLE_WRAPPER_PREPUNCT_REX);
              prePunct = m[1];
              str = m[2];
            }
            var postPunct = "";
            if (str && CSL3.SWAPPING_PUNCTUATION.indexOf(str.slice(-1)) > -1) {
              postPunct = str.slice(-1);
              str = str.slice(0, -1);
            }
            return state.sys.variableWrapper(this.params, prePunct, str, postPunct);
          } else {
            return str;
          }
        },
        "@URL/true": function(state, str) {
          return `<fo:basic-link external-destination="url('` + str + `')">` + str + "</fo:basic-link>";
        },
        "@DOI/true": function(state, str) {
          var doiurl = str;
          if (!str.match(/^https?:\/\//)) {
            doiurl = "https://doi.org/" + str;
          }
          return `<fo:basic-link external-destination="url('` + doiurl + `')">` + str + "</fo:basic-link>";
        }
      };
      CSL3.Output.Formats.prototype.latex = {
        "text_escape": function(text) {
          if (!text) {
            text = "";
          }
          return text;
        },
        "bibstart": "\\begin{thebibliography}{4}",
        "bibend": "\\end{thebibliography}",
        "@font-style/italic": "{\\em %%STRING%%}",
        "@font-style/oblique": false,
        "@font-style/normal": false,
        "@font-variant/small-caps": false,
        "@passthrough/true": CSL3.Output.Formatters.passthrough,
        "@font-variant/normal": false,
        "@font-weight/bold": "{\\bf %%STRING%%}",
        "@font-weight/normal": false,
        "@font-weight/light": false,
        "@text-decoration/none": false,
        "@text-decoration/underline": false,
        "@vertical-align/baseline": false,
        "@vertical-align/sup": false,
        "@vertical-align/sub": false,
        "@strip-periods/true": CSL3.Output.Formatters.passthrough,
        "@strip-periods/false": CSL3.Output.Formatters.passthrough,
        "@quotes/true": function(state, str) {
          if ("undefined" === typeof str) {
            return state.getTerm("open-quote");
          }
          return state.getTerm("open-quote") + str + state.getTerm("close-quote");
        },
        "@quotes/inner": function(state, str) {
          if ("undefined" === typeof str) {
            return "\u2019";
          }
          return state.getTerm("open-inner-quote") + str + state.getTerm("close-inner-quote");
        },
        "@quotes/false": false,
        //"@bibliography/body": function (state,str){
        //    return "<div class=\"csl-bib-body\">\n"+str+"</div>";
        //},
        "@cite/entry": function(state, str) {
          return state.sys.wrapCitationEntry(str, this.item_id, this.locator_txt, this.suffix_txt);
        },
        "@bibliography/entry": function(state, str) {
          return "\\bibitem{" + state.sys.embedBibliographyEntry(this.item_id) + "}\n";
        },
        "@display/block": function(state, str) {
          return "\n" + str;
        },
        "@display/left-margin": function(state, str) {
          return str;
        },
        "@display/right-inline": function(state, str) {
          return str;
        },
        "@display/indent": function(state, str) {
          return "\n    " + str;
        },
        "@showid/true": function(state, str, cslid) {
          return str;
        },
        "@URL/true": function(state, str) {
          return str;
        },
        "@DOI/true": function(state, str) {
          return str;
        }
      };
      CSL3.Output.Formats = new CSL3.Output.Formats();
      CSL3.Registry = function(state) {
        this.debug = false;
        this.state = state;
        this.registry = {};
        this.reflist = [];
        this.refhash = {};
        this.namereg = new CSL3.Registry.NameReg(state);
        this.citationreg = new CSL3.Registry.CitationReg(state);
        this.authorstrings = {};
        this.masterMap = {};
        this.mylist = [];
        this.myhash = {};
        this.deletes = [];
        this.inserts = [];
        this.uncited = {};
        this.refreshes = {};
        this.akeys = {};
        this.oldseq = {};
        this.return_data = {};
        this.ambigcites = {};
        this.ambigresets = {};
        this.sorter = new CSL3.Registry.Comparifier(state, "bibliography_sort");
        this.getSortedIds = function() {
          var ret = [];
          for (var i = 0, ilen = this.reflist.length; i < ilen; i += 1) {
            ret.push("" + this.reflist[i].id);
          }
          return ret;
        };
        this.getSortedRegistryItems = function() {
          var ret = [];
          for (var i = 0, ilen = this.reflist.length; i < ilen; i += 1) {
            ret.push(this.reflist[i]);
          }
          return ret;
        };
      };
      CSL3.Registry.prototype.init = function(itemIDs, uncited_flag) {
        var i, ilen;
        this.oldseq = {};
        if (uncited_flag) {
          this.uncited = {};
          for (var i = 0, ilen = itemIDs.length; i < ilen; i += 1) {
            if (!this.myhash[itemIDs[i]]) {
              this.mylist.push("" + itemIDs[i]);
            }
            this.uncited[itemIDs[i]] = true;
            this.myhash[itemIDs[i]] = true;
          }
        } else {
          for (var key in this.uncited) {
            itemIDs.push(key);
          }
          var myhash = {};
          for (i = itemIDs.length - 1; i > -1; i += -1) {
            if (myhash[itemIDs[i]]) {
              itemIDs = itemIDs.slice(0, i).concat(itemIDs.slice(i + 1));
            } else {
              myhash[itemIDs[i]] = true;
            }
          }
          this.mylist = itemIDs;
          this.myhash = myhash;
        }
        this.refreshes = {};
        this.touched = {};
        this.ambigsTouched = {};
        this.ambigresets = {};
      };
      CSL3.Registry.prototype.dopurge = function(myhash) {
        for (var i = this.mylist.length - 1; i > -1; i += -1) {
          if (this.citationreg.citationsByItemId) {
            if ((!this.citationreg.citationsByItemId || !this.citationreg.citationsByItemId[this.mylist[i]]) && !myhash[this.mylist[i]]) {
              delete this.myhash[this.mylist[i]];
              delete this.uncited[this.mylist[i]];
              this.mylist = this.mylist.slice(0, i).concat(this.mylist.slice(i + 1));
            }
          }
        }
        this.dodeletes(this.myhash);
      };
      CSL3.Registry.prototype.dodeletes = function(myhash) {
        var otheritems, key, ambig, pos, len, items, kkey, mypos, id;
        if ("string" === typeof myhash) {
          var key = myhash;
          myhash = {};
          myhash[key] = true;
        }
        for (var key in this.registry) {
          if (!myhash[key]) {
            if (this.uncited[key]) {
              continue;
            }
            otheritems = this.namereg.delitems(key);
            for (kkey in otheritems) {
              this.refreshes[kkey] = true;
            }
            ambig = this.registry[key].ambig;
            mypos = this.ambigcites[ambig].indexOf(key);
            if (mypos > -1) {
              items = this.ambigcites[ambig].slice();
              this.ambigcites[ambig] = items.slice(0, mypos).concat(items.slice(mypos + 1, items.length));
              this.ambigresets[ambig] = this.ambigcites[ambig].length;
            }
            len = this.ambigcites[ambig].length;
            for (pos = 0; pos < len; pos += 1) {
              id = "" + this.ambigcites[ambig][pos];
              this.refreshes[id] = true;
            }
            if (this.registry[key].siblings) {
              if (this.registry[key].siblings.length == 1) {
                var loneSiblingID = this.registry[key].siblings[0];
                if (this.registry[loneSiblingID].siblings) {
                  this.registry[loneSiblingID].siblings.pop();
                  this.registry[loneSiblingID].master = true;
                }
              } else if (this.registry[key].siblings.length > 1) {
                var removeIDs = [key];
                if (this.registry[key].master) {
                  var newmasterID = this.registry[key].siblings[0];
                  var newmaster = this.registry[newmasterID];
                  newmaster.master = true;
                  removeIDs.push(newmasterID);
                }
                var buffer = [];
                for (var k = this.registry[key].siblings.length - 1; k > -1; k += -1) {
                  var siblingID = this.registry[key].siblings.pop();
                  if (removeIDs.indexOf(siblingID) === -1) {
                    buffer.push(siblingID);
                  }
                }
                for (var k = buffer.length - 1; k > -1; k += -1) {
                  this.registry[key].siblings.push(buffer[k]);
                }
              }
            }
            for (var i = this.reflist.length - 1; i > -1; i--) {
              if (this.reflist[i].id === key) {
                this.reflist = this.reflist.slice(0, i).concat(this.reflist.slice(i + 1));
              }
            }
            delete this.registry[key];
            delete this.refhash[key];
            this.return_data.bibchange = true;
          }
        }
      };
      CSL3.Registry.prototype.doinserts = function(mylist) {
        var item, Item, akey, newitem, abase, i, ilen;
        if ("string" === typeof mylist) {
          mylist = [mylist];
        }
        for (var i = 0, ilen = mylist.length; i < ilen; i += 1) {
          item = mylist[i];
          if (!this.registry[item]) {
            Item = this.state.retrieveItem(item);
            akey = CSL3.getAmbiguousCite.call(this.state, Item);
            this.ambigsTouched[akey] = true;
            if (!Item.legislation_id) {
              this.akeys[akey] = true;
            }
            newitem = {
              "id": "" + item,
              "seq": 0,
              "offset": 0,
              "sortkeys": false,
              "ambig": false,
              "rendered": false,
              "disambig": false,
              "ref": Item,
              "newItem": true
            };
            this.registry[item] = newitem;
            if (this.citationreg.citationsByItemId && this.citationreg.citationsByItemId[item]) {
              this.registry[item]["first-reference-note-number"] = this.citationreg.citationsByItemId[item][0].properties.noteIndex;
            }
            abase = CSL3.getAmbigConfig.call(this.state);
            this.registerAmbigToken(akey, item, abase);
            this.touched[item] = true;
            this.return_data.bibchange = true;
          }
        }
      };
      CSL3.Registry.prototype.rebuildlist = function(nosort) {
        var len, pos, item, Item;
        if (!nosort) {
          this.reflist_inserts = [];
          len = this.mylist.length;
          for (pos = 0; pos < len; pos += 1) {
            item = this.mylist[pos];
            Item = this.registry[item];
            if (Item.newItem) {
              this.reflist_inserts.push(Item);
            }
            this.oldseq[item] = this.registry[item].seq;
            this.registry[item].seq = pos + 1;
          }
        } else {
          this.reflist = [];
          len = this.mylist.length;
          for (pos = 0; pos < len; pos += 1) {
            item = this.mylist[pos];
            Item = this.registry[item];
            this.reflist.push(Item);
            this.oldseq[item] = this.registry[item].seq;
            this.registry[item].seq = pos + 1;
          }
        }
      };
      CSL3.Registry.prototype.dorefreshes = function() {
        var key, regtoken, Item, akey, abase;
        for (var key in this.refreshes) {
          regtoken = this.registry[key];
          if (!regtoken) {
            continue;
          }
          regtoken.sortkeys = void 0;
          Item = this.state.refetchItem(key);
          var akey = regtoken.ambig;
          if ("undefined" === typeof akey) {
            this.state.tmp.disambig_settings = false;
            akey = CSL3.getAmbiguousCite.call(this.state, Item);
            abase = CSL3.getAmbigConfig.call(this.state);
            this.registerAmbigToken(akey, key, abase);
          }
          for (var akkey in this.ambigresets) {
            if (this.ambigresets[akkey] === 1) {
              var loneKey = this.ambigcites[akey][0];
              var Item = this.state.refetchItem(loneKey);
              this.registry[loneKey].disambig = new CSL3.AmbigConfig();
              this.state.tmp.disambig_settings = false;
              var akey = CSL3.getAmbiguousCite.call(this.state, Item);
              var abase = CSL3.getAmbigConfig.call(this.state);
              this.registerAmbigToken(akey, loneKey, abase);
            }
          }
          this.state.tmp.taintedItemIDs[key] = true;
          this.ambigsTouched[akey] = true;
          if (!Item.legislation_id) {
            this.akeys[akey] = true;
          }
          this.touched[key] = true;
        }
      };
      CSL3.Registry.prototype.setdisambigs = function() {
        for (var akey in this.ambigsTouched) {
          this.state.disambiguate.run(akey);
        }
        this.ambigsTouched = {};
        this.akeys = {};
      };
      CSL3.Registry.prototype.renumber = function() {
        var len, pos, item;
        if (this.state.bibliography_sort.opt.citation_number_sort_direction === CSL3.DESCENDING) {
          this.state.bibliography_sort.tmp.citation_number_map = {};
        }
        len = this.reflist.length;
        for (pos = 0; pos < len; pos += 1) {
          item = this.reflist[pos];
          item.seq = pos + 1;
          if (this.state.bibliography_sort.opt.citation_number_sort_direction === CSL3.DESCENDING) {
            this.state.bibliography_sort.tmp.citation_number_map[item.seq] = this.reflist.length - item.seq + 1;
          }
          if (this.state.opt.update_mode === CSL3.NUMERIC && item.seq != this.oldseq[item.id]) {
            this.state.tmp.taintedItemIDs[item.id] = true;
          }
          if (item.seq != this.oldseq[item.id]) {
            this.return_data.bibchange = true;
          }
        }
      };
      CSL3.Registry.prototype.setsortkeys = function() {
        var key;
        for (var i = 0, ilen = this.mylist.length; i < ilen; i += 1) {
          var key = this.mylist[i];
          if (this.touched[key] || this.state.tmp.taintedItemIDs[key] || !this.registry[key].sortkeys) {
            this.registry[key].sortkeys = CSL3.getSortKeys.call(this.state, this.state.retrieveItem(key), "bibliography_sort");
          }
        }
      };
      CSL3.Registry.prototype._insertItem = function(element, array) {
        array.splice(this._locationOf(element, array) + 1, 0, element);
        return array;
      };
      CSL3.Registry.prototype._locationOf = function(element, array, start, end) {
        if (array.length === 0) {
          return -1;
        }
        start = start || 0;
        end = end || array.length;
        var pivot = start + end >> 1;
        var c = this.sorter.compareKeys(element, array[pivot]);
        if (end - start <= 1) {
          return c == -1 ? pivot - 1 : pivot;
        }
        switch (c) {
          case -1:
            return this._locationOf(element, array, start, pivot);
          case 0:
            return pivot;
          case 1:
            return this._locationOf(element, array, pivot, end);
        }
      };
      CSL3.Registry.prototype.sorttokens = function(nosort) {
        var len, item, Item, pos;
        if (!nosort) {
          this.reflist_inserts = [];
          len = this.mylist.length;
          for (pos = 0; pos < len; pos += 1) {
            item = this.mylist[pos];
            Item = this.registry[item];
            if (Item.newItem) {
              this.reflist_inserts.push(Item);
            }
          }
          for (var key in this.state.tmp.taintedItemIDs) {
            if (this.registry[key] && !this.registry[key].newItem) {
              for (var i = this.reflist.length - 1; i > -1; i--) {
                if (this.reflist[i].id === key) {
                  this.reflist_inserts.push(this.reflist[i]);
                  this.reflist = this.reflist.slice(0, i).concat(this.reflist.slice(i + 1));
                }
              }
            }
          }
          for (var i = 0, ilen = this.reflist_inserts.length; i < ilen; i++) {
            var Item = this.reflist_inserts[i];
            delete Item.newItem;
            this.reflist = this._insertItem(Item, this.reflist);
          }
          for (pos = 0; pos < len; pos += 1) {
            item = this.mylist[pos];
            Item = this.registry[item];
            this.registry[item].seq = pos + 1;
          }
        }
      };
      CSL3.Registry.Comparifier = function(state, keyset) {
        var sort_directions, len, pos, compareKeys;
        var sortCompare = CSL3.getSortCompare.call(state, state.opt["default-locale-sort"]);
        sort_directions = state[keyset].opt.sort_directions;
        this.compareKeys = function(a, b) {
          len = a.sortkeys ? a.sortkeys.length : 0;
          for (pos = 0; pos < len; pos += 1) {
            var cmp = 0;
            if (a.sortkeys[pos] === b.sortkeys[pos]) {
              cmp = 0;
            } else if ("undefined" === typeof a.sortkeys[pos]) {
              cmp = sort_directions[pos][1];
            } else if ("undefined" === typeof b.sortkeys[pos]) {
              cmp = sort_directions[pos][0];
            } else {
              cmp = sortCompare(a.sortkeys[pos], b.sortkeys[pos]);
            }
            if (0 < cmp) {
              return sort_directions[pos][1];
            } else if (0 > cmp) {
              return sort_directions[pos][0];
            }
          }
          if (a.seq > b.seq) {
            return 1;
          } else if (a.seq < b.seq) {
            return -1;
          }
          return 0;
        };
        compareKeys = this.compareKeys;
        this.compareCompositeKeys = function(a, b) {
          return compareKeys(a[1], b[1]);
        };
      };
      CSL3.Registry.prototype.compareRegistryTokens = function(a, b) {
        if (a.seq > b.seq) {
          return 1;
        } else if (a.seq < b.seq) {
          return -1;
        }
        return 0;
      };
      CSL3.Registry.prototype.registerAmbigToken = function(akey, id, ambig_config) {
        if (!this.registry[id]) {
          CSL3.debug("Warning: unregistered item: itemID=(" + id + "), akey=(" + akey + ")");
        }
        if (this.registry[id] && this.registry[id].disambig && this.registry[id].disambig.names) {
          for (var i = 0, ilen = ambig_config.names.length; i < ilen; i += 1) {
            var new_names_params = ambig_config.names[i];
            var old_names_params = this.registry[id].disambig.names[i];
            if (new_names_params !== old_names_params) {
              this.state.tmp.taintedItemIDs[id] = true;
            } else if (ambig_config.givens[i]) {
              for (var j = 0, jlen = ambig_config.givens[i].length; j < jlen; j += 1) {
                var new_gnames_params = ambig_config.givens[i][j];
                var old_gnames_params = this.registry[id].disambig.givens[i][j];
                if (new_gnames_params !== old_gnames_params) {
                  this.state.tmp.taintedItemIDs[id] = true;
                }
              }
            }
          }
        }
        if (!this.ambigcites[akey]) {
          this.ambigcites[akey] = [];
        }
        if (this.ambigcites[akey].indexOf("" + id) === -1) {
          this.ambigcites[akey].push("" + id);
        }
        this.registry[id].ambig = akey;
        this.registry[id].disambig = CSL3.cloneAmbigConfig(ambig_config);
      };
      CSL3.getSortKeys = function(Item, key_type) {
        var area, root, extension, strip_prepositions, len, pos;
        if (false) {
          CSL3.debug("KEY TYPE: " + key_type);
        }
        area = this.tmp.area;
        root = this.tmp.root;
        extension = this.tmp.extension;
        strip_prepositions = CSL3.Util.Sort.strip_prepositions;
        this.tmp.area = key_type;
        this.tmp.root = key_type.indexOf("_") > -1 ? key_type.slice(0, -5) : key_type;
        this.tmp.extension = "_sort";
        this.tmp.disambig_override = true;
        this.tmp.disambig_request = false;
        this.tmp.suppress_decorations = true;
        CSL3.getCite.call(this, Item);
        this.tmp.suppress_decorations = false;
        this.tmp.disambig_override = false;
        len = this[key_type].keys.length;
        for (pos = 0; pos < len; pos += 1) {
          this[key_type].keys[pos] = strip_prepositions(this[key_type].keys[pos]);
        }
        if (false) {
          CSL3.debug("sort keys (" + key_type + "): " + this[key_type].keys);
        }
        this.tmp.area = area;
        this.tmp.root = root;
        this.tmp.extension = extension;
        return this[key_type].keys;
      };
      CSL3.Registry.NameReg = function(state) {
        var pkey, ikey, skey, dagopt, gdropt, items, strip_periods, set_keys, evalname, delitems, addname, myitems;
        this.state = state;
        this.namereg = {};
        this.nameind = {};
        this.nameindpkeys = {};
        this.itemkeyreg = {};
        strip_periods = function(str) {
          if (!str) {
            str = "";
          }
          return str.replace(/\./g, " ").replace(/\s+/g, " ").replace(/\s+$/, "");
        };
        set_keys = function(state2, itemid, nameobj) {
          pkey = strip_periods(nameobj.family);
          if (state2.opt["demote-non-dropping-particle"] === "never" && nameobj["non-dropping-particle"] && nameobj["family"]) {
            pkey = `${pkey} ${nameobj["non-dropping-particle"]}`;
          }
          skey = strip_periods(nameobj.given);
          var m = skey.match(/[,\!]* ([^,]+)$/);
          if (m && m[1] === m[1].toLowerCase()) {
            skey = skey.replace(/[,\!]* [^,]+$/, "");
          }
          ikey = CSL3.Util.Names.initializeWith(state2, skey, "%s");
          if (state2.citation.opt["givenname-disambiguation-rule"] === "by-cite") {
            pkey = "" + itemid + pkey;
          }
        };
        evalname = function(item_id, nameobj, namenum, request_base, form, initials) {
          var param;
          if (state.tmp.area.slice(0, 12) === "bibliography" && !form) {
            if ("string" === typeof initials) {
              return 1;
            } else {
              return 2;
            }
          }
          var res = state.nameOutput.getName(nameobj, "locale-translit", true);
          nameobj = res.name;
          set_keys(this.state, "" + item_id, nameobj);
          param = 2;
          dagopt = state.opt["disambiguate-add-givenname"];
          gdropt = state.citation.opt["givenname-disambiguation-rule"];
          var gdropt_orig = gdropt;
          if (gdropt === "by-cite") {
            gdropt = "all-names";
          }
          if ("short" === form) {
            param = 0;
          } else if ("string" === typeof initials) {
            param = 1;
          }
          if ("undefined" === typeof this.namereg[pkey] || "undefined" === typeof this.namereg[pkey].ikey[ikey]) {
            return param;
          }
          if (gdropt_orig === "by-cite" && param <= request_base) {
            return request_base;
          }
          if (!dagopt) {
            return param;
          }
          if ("string" === typeof gdropt && gdropt.slice(0, 12) === "primary-name" && namenum > 0) {
            return param;
          }
          if (!gdropt || gdropt === "all-names" || gdropt === "primary-name") {
            if (this.namereg[pkey].count > 1) {
              param = 1;
            }
            if (this.namereg[pkey].ikey && this.namereg[pkey].ikey[ikey].count > 1 || this.namereg[pkey].count > 1 && "string" !== typeof initials) {
              param = 2;
            }
          } else if (gdropt === "all-names-with-initials" || gdropt === "primary-name-with-initials") {
            if (this.namereg[pkey].count > 1) {
              param = 1;
            } else {
              param = 0;
            }
          }
          if (!state.registry.registry[item_id]) {
            if (form == "short") {
              return 0;
            } else if ("string" == typeof initials) {
              return 1;
            }
          } else {
            return param;
          }
        };
        delitems = function(ids) {
          var pos, len, posB, id, fullkey;
          if ("string" === typeof ids || "number" === typeof ids) {
            ids = ["" + ids];
          }
          var ret = {};
          len = ids.length;
          for (pos = 0; pos < len; pos += 1) {
            id = "" + ids[pos];
            if (!this.nameind[id]) {
              continue;
            }
            for (fullkey in this.nameind[id]) {
              if (this.nameind[id].hasOwnProperty(fullkey)) {
                var key = fullkey.split("::");
                pkey = key[0];
                ikey = key[1];
                skey = key[2];
                if ("undefined" === typeof this.namereg[pkey]) {
                  continue;
                }
                items = this.namereg[pkey].items;
                if (skey && this.namereg[pkey].ikey[ikey] && this.namereg[pkey].ikey[ikey].skey[skey]) {
                  myitems = this.namereg[pkey].ikey[ikey].skey[skey].items;
                  posB = myitems.indexOf("" + id);
                  if (posB > -1) {
                    this.namereg[pkey].ikey[ikey].skey[skey].items = myitems.slice(0, posB).concat(myitems.slice([posB + 1]));
                  }
                  if (this.namereg[pkey].ikey[ikey].skey[skey].items.length === 0) {
                    delete this.namereg[pkey].ikey[ikey].skey[skey];
                    this.namereg[pkey].ikey[ikey].count += -1;
                    if (this.namereg[pkey].ikey[ikey].count < 2) {
                      for (var i = 0, ilen = this.namereg[pkey].ikey[ikey].items.length; i < ilen; i += 1) {
                        state.tmp.taintedItemIDs[this.namereg[pkey].ikey[ikey].items[i]] = true;
                      }
                    }
                  }
                }
                if (ikey && this.namereg[pkey].ikey[ikey]) {
                  posB = this.namereg[pkey].ikey[ikey].items.indexOf("" + id);
                  if (posB > -1) {
                    items = this.namereg[pkey].ikey[ikey].items.slice();
                    this.namereg[pkey].ikey[ikey].items = items.slice(0, posB).concat(items.slice([posB + 1]));
                  }
                  if (this.namereg[pkey].ikey[ikey].items.length === 0) {
                    delete this.namereg[pkey].ikey[ikey];
                    this.namereg[pkey].count += -1;
                    if (this.namereg[pkey].count < 2) {
                      for (var i = 0, ilen = this.namereg[pkey].items.length; i < ilen; i += 1) {
                        state.tmp.taintedItemIDs[this.namereg[pkey].items[i]] = true;
                      }
                    }
                  }
                }
                if (pkey) {
                  posB = this.namereg[pkey].items.indexOf("" + id);
                  if (posB > -1) {
                    items = this.namereg[pkey].items.slice();
                    this.namereg[pkey].items = items.slice(0, posB).concat(items.slice([posB + 1], items.length));
                  }
                  if (this.namereg[pkey].items.length < 2) {
                    delete this.namereg[pkey];
                  }
                }
                delete this.nameind[id][fullkey];
              }
            }
            delete this.nameind[id];
            delete this.nameindpkeys[id];
          }
          return ret;
        };
        addname = function(item_id, nameobj, pos) {
          var i, ilen;
          var res = state.nameOutput.getName(nameobj, "locale-translit", true);
          nameobj = res.name;
          if (state.citation.opt["givenname-disambiguation-rule"] && state.citation.opt["givenname-disambiguation-rule"].slice(0, 8) === "primary-" && pos !== 0) {
            return;
          }
          set_keys(this.state, "" + item_id, nameobj);
          if (pkey) {
            if ("undefined" === typeof this.namereg[pkey]) {
              this.namereg[pkey] = {};
              this.namereg[pkey].count = 0;
              this.namereg[pkey].ikey = {};
              this.namereg[pkey].items = [item_id];
            } else if (this.namereg[pkey].items.indexOf(item_id) === -1) {
              this.namereg[pkey].items.push(item_id);
            }
          }
          if (pkey && ikey) {
            if ("undefined" === typeof this.namereg[pkey].ikey[ikey]) {
              this.namereg[pkey].ikey[ikey] = {};
              this.namereg[pkey].ikey[ikey].count = 0;
              this.namereg[pkey].ikey[ikey].skey = {};
              this.namereg[pkey].ikey[ikey].items = [item_id];
              this.namereg[pkey].count += 1;
              if (this.namereg[pkey].count === 2) {
                for (var i = 0, ilen = this.namereg[pkey].items.length; i < ilen; i += 1) {
                  state.tmp.taintedItemIDs[this.namereg[pkey].items[i]] = true;
                }
              }
            } else if (this.namereg[pkey].ikey[ikey].items.indexOf(item_id) === -1) {
              this.namereg[pkey].ikey[ikey].items.push(item_id);
            }
          }
          if (pkey && ikey && skey) {
            if ("undefined" === typeof this.namereg[pkey].ikey[ikey].skey[skey]) {
              this.namereg[pkey].ikey[ikey].skey[skey] = {};
              this.namereg[pkey].ikey[ikey].skey[skey].items = [item_id];
              this.namereg[pkey].ikey[ikey].count += 1;
              if (this.namereg[pkey].ikey[ikey].count === 2) {
                for (var i = 0, ilen = this.namereg[pkey].ikey[ikey].items.length; i < ilen; i += 1) {
                  state.tmp.taintedItemIDs[this.namereg[pkey].ikey[ikey].items[i]] = true;
                }
              }
            } else if (this.namereg[pkey].ikey[ikey].skey[skey].items.indexOf(item_id) === -1) {
              this.namereg[pkey].ikey[ikey].skey[skey].items.push(item_id);
            }
          }
          if ("undefined" === typeof this.nameind[item_id]) {
            this.nameind[item_id] = {};
            this.nameindpkeys[item_id] = {};
          }
          if (pkey) {
            this.nameind[item_id][pkey + "::" + ikey + "::" + skey] = true;
            this.nameindpkeys[item_id][pkey] = this.namereg[pkey];
          }
        };
        this.addname = addname;
        this.delitems = delitems;
        this.evalname = evalname;
      };
      CSL3.Registry.CitationReg = function() {
        this.citationById = {};
        this.citationByIndex = [];
      };
      CSL3.Disambiguation = function(state) {
        this.state = state;
        this.sys = this.state.sys;
        this.registry = state.registry.registry;
        this.ambigcites = state.registry.ambigcites;
        this.configModes();
        this.debug = false;
      };
      CSL3.Disambiguation.prototype.run = function(akey) {
        if (!this.modes.length) {
          return;
        }
        if (this.debug) {
          this.state.sys.print("[A] === RUN ===");
        }
        this.akey = akey;
        if (this.initVars(akey)) {
          this.runDisambig();
        }
      };
      CSL3.Disambiguation.prototype.runDisambig = function() {
        var ismax;
        if (this.debug) {
          this.state.sys.print("[C] === runDisambig() ===");
        }
        this.initGivens = true;
        while (this.lists.length) {
          this.gnameset = 0;
          this.gname = 0;
          this.clashes = [1, 0];
          while (this.lists[0][1].length) {
            this.listpos = 0;
            if (!this.base) {
              this.base = this.lists[0][0];
            }
            ismax = this.incrementDisambig();
            this.scanItems(this.lists[0]);
            this.evalScan(ismax);
          }
          this.lists = this.lists.slice(1);
        }
      };
      CSL3.Disambiguation.prototype.scanItems = function(list) {
        var pos, len, otherItem;
        if (this.debug) {
          this.state.sys.print("[2] === scanItems() ===");
        }
        this.Item = list[1][0];
        this.ItemCite = CSL3.getAmbiguousCite.call(this.state, this.Item, this.base, true);
        this.scanlist = list[1];
        this.partners = [];
        this.partners.push(this.Item);
        this.nonpartners = [];
        var clashes = 0;
        for (var pos = 1, len = list[1].length; pos < len; pos += 1) {
          otherItem = list[1][pos];
          var otherItemCite = CSL3.getAmbiguousCite.call(this.state, otherItem, this.base, true);
          if (this.debug) {
            if (pos > 1) {
              this.state.sys.print("  -----------");
            }
          }
          if (this.ItemCite === otherItemCite) {
            if (this.debug) {
              this.state.sys.print("  [CLASH]--> " + this.Item.id + ": " + this.ItemCite);
              this.state.sys.print("             " + otherItem.id + ": " + otherItemCite);
            }
            clashes += 1;
            this.partners.push(otherItem);
          } else {
            if (this.debug) {
              this.state.sys.print("  [clear]--> " + this.Item.id + ": " + this.ItemCite);
              this.state.sys.print("             " + otherItem.id + ": " + otherItemCite);
            }
            this.nonpartners.push(otherItem);
          }
        }
        this.clashes[0] = this.clashes[1];
        this.clashes[1] = clashes;
      };
      CSL3.Disambiguation.prototype.evalScan = function(maxed) {
        this[this.modes[this.modeindex]](maxed);
        if (maxed) {
          if (this.modeindex < this.modes.length - 1) {
            this.modeindex += 1;
          } else {
            this.lists[this.listpos + 1] = [this.base, []];
          }
        }
      };
      CSL3.Disambiguation.prototype.disNames = function(ismax) {
        var i, ilen;
        if (this.debug) {
          this.state.sys.print("[3] == disNames() ==");
        }
        if (this.clashes[1] === 0 && this.nonpartners.length === 1) {
          this.captureStepToBase();
          if (this.debug) {
            this.state.sys.print("  ** RESOLUTION [a]: lone partner, one nonpartner");
            this.state.sys.print("  registering " + this.partners[0].id + " and " + this.nonpartners[0].id);
          }
          this.state.registry.registerAmbigToken(this.akey, "" + this.nonpartners[0].id, this.betterbase);
          this.state.registry.registerAmbigToken(this.akey, "" + this.partners[0].id, this.betterbase);
          this.lists[this.listpos] = [this.betterbase, []];
        } else if (this.clashes[1] === 0) {
          this.captureStepToBase();
          if (this.debug) {
            this.state.sys.print("  ** RESOLUTION [b]: lone partner, unknown number of remaining nonpartners");
            this.state.sys.print("  registering " + this.partners[0].id);
          }
          this.state.registry.registerAmbigToken(this.akey, "" + this.partners[0].id, this.betterbase);
          this.lists[this.listpos] = [this.betterbase, this.nonpartners];
          if (this.nonpartners.length) {
            this.initGivens = true;
          }
        } else if (this.nonpartners.length === 1) {
          this.captureStepToBase();
          if (this.debug) {
            this.state.sys.print("  ** RESOLUTION [c]: lone nonpartner, unknown number of partners remaining");
            this.state.sys.print("  registering " + this.nonpartners[0].id);
          }
          this.state.registry.registerAmbigToken(this.akey, "" + this.nonpartners[0].id, this.betterbase);
          this.lists[this.listpos] = [this.betterbase, this.partners];
        } else if (this.clashes[1] < this.clashes[0]) {
          this.captureStepToBase();
          if (this.debug) {
            this.state.sys.print("  ** RESOLUTION [d]: better result, but no entries safe to register");
          }
          this.lists[this.listpos] = [this.betterbase, this.partners];
          this.lists.push([this.betterbase, this.nonpartners]);
        } else {
          if (this.debug) {
            this.state.sys.print("  ** RESOLUTION [e]: no improvement, and clashes remain");
          }
          if (ismax) {
            this.lists[this.listpos] = [this.betterbase, this.nonpartners];
            this.lists.push([this.betterbase, this.partners]);
            if (this.modeindex === this.modes.length - 1) {
              if (this.debug) {
                this.state.sys.print("     (registering clashing entries because we've run out of options)");
              }
              for (var i = 0, ilen = this.partners.length; i < ilen; i += 1) {
                this.state.registry.registerAmbigToken(this.akey, "" + this.partners[i].id, this.betterbase);
              }
              this.lists[this.listpos] = [this.betterbase, []];
            }
          }
        }
      };
      CSL3.Disambiguation.prototype.disExtraText = function() {
        if (this.debug) {
          this.state.sys.print("[3] === disExtraText ==");
        }
        var done = false;
        if (this.clashes[1] === 0 && this.nonpartners.length < 2) {
          done = true;
        }
        if (!done && (!this.base.disambiguate || this.state.tmp.disambiguate_count !== this.state.tmp.disambiguate_maxMax)) {
          this.modeindex = 0;
          this.base.disambiguate = this.state.tmp.disambiguate_count;
          this.betterbase.disambiguate = this.state.tmp.disambiguate_count;
          if (!this.base.disambiguate) {
            this.initGivens = true;
            this.base.disambiguate = 1;
            for (var i = 0, ilen = this.lists[this.listpos][1].length; i < ilen; i += 1) {
              this.state.tmp.taintedItemIDs[this.lists[this.listpos][1][i].id] = true;
            }
          } else {
            this.disNames();
          }
        } else if (done || this.state.tmp.disambiguate_count === this.state.tmp.disambiguate_maxMax) {
          if (done || this.modeindex === this.modes.length - 1) {
            var base = this.lists[this.listpos][0];
            for (var i = 0, ilen = this.lists[this.listpos][1].length; i < ilen; i += 1) {
              this.state.tmp.taintedItemIDs[this.lists[this.listpos][1][i].id] = true;
              this.state.registry.registerAmbigToken(this.akey, "" + this.lists[this.listpos][1][i].id, base);
            }
            this.lists[this.listpos] = [this.betterbase, []];
          } else {
            this.modeindex = this.modes.length - 1;
            var base = this.lists[this.listpos][0];
            base.disambiguate = true;
            for (var i = 0, ilen = this.lists[this.listpos][1].length; i < ilen; i += 1) {
              this.state.tmp.taintedItemIDs[this.lists[this.listpos][1][i].id] = true;
              this.state.registry.registerAmbigToken(this.akey, "" + this.lists[this.listpos][1][i].id, base);
            }
          }
        }
      };
      CSL3.Disambiguation.prototype.disYears = function() {
        var pos, len, tokens, token;
        if (this.debug) {
          this.state.sys.print("[3] === disYears ==");
        }
        tokens = [];
        var base = this.lists[this.listpos][0];
        if (this.clashes[1]) {
          for (var i = 0, ilen = this.state.registry.mylist.length; i < ilen; i += 1) {
            var origid = this.state.registry.mylist[i];
            for (var j = 0, jlen = this.lists[this.listpos][1].length; j < jlen; j += 1) {
              var token = this.lists[this.listpos][1][j];
              if (token.id == origid) {
                tokens.push(this.registry[token.id]);
                break;
              }
            }
          }
        }
        tokens.sort(this.state.registry.sorter.compareKeys);
        for (var pos = 0, len = tokens.length; pos < len; pos += 1) {
          base.year_suffix = "" + pos;
          var oldBase = this.state.registry.registry[tokens[pos].id].disambig;
          this.state.registry.registerAmbigToken(this.akey, "" + tokens[pos].id, base);
          if (CSL3.ambigConfigDiff(oldBase, base)) {
            this.state.tmp.taintedItemIDs[tokens[pos].id] = true;
          }
        }
        this.lists[this.listpos] = [this.betterbase, []];
      };
      CSL3.Disambiguation.prototype.incrementDisambig = function() {
        if (this.debug) {
          this.state.sys.print("\n[1] === incrementDisambig() ===");
        }
        if (this.initGivens) {
          this.initGivens = false;
          return false;
        }
        var maxed = false;
        var increment_names = true;
        if ("disNames" === this.modes[this.modeindex]) {
          increment_names = false;
          if ("number" !== typeof this.givensMax) {
            increment_names = true;
          }
          var increment_namesets = false;
          if ("number" !== typeof this.namesMax) {
            increment_namesets = true;
          }
          if ("number" === typeof this.givensMax) {
            if (this.base.givens.length && this.base.givens[this.gnameset][this.gname] < this.givensMax) {
              this.base.givens[this.gnameset][this.gname] += 1;
            } else {
              increment_names = true;
            }
          }
          if ("number" === typeof this.namesMax && increment_names) {
            if (this.state.opt["disambiguate-add-names"]) {
              increment_namesets = false;
              if (this.gname < this.namesMax) {
                this.base.names[this.gnameset] += 1;
                this.gname += 1;
              } else {
                increment_namesets = true;
              }
            } else {
              increment_namesets = true;
            }
          }
          if ("number" === typeof this.namesetsMax && increment_namesets) {
            if (this.gnameset < this.namesetsMax) {
              this.gnameset += 1;
              this.base.names[this.gnameset] = 1;
              this.gname = 0;
            }
          }
          if (this.debug) {
            this.state.sys.print("    ------------------");
            this.state.sys.print("    incremented values");
            this.state.sys.print("    ------------------");
            this.state.sys.print("    | gnameset: " + this.gnameset);
            this.state.sys.print("    | gname: " + this.gname);
            this.state.sys.print("    | names value: " + this.base.names[this.gnameset]);
            if (this.base.givens.length) {
              this.state.sys.print("    | givens value: " + this.base.givens[this.gnameset][this.gname]);
            } else {
              this.state.sys.print("    | givens value: nil");
            }
            this.state.sys.print("    | namesetsMax: " + this.namesetsMax);
            this.state.sys.print("    | namesMax: " + this.namesMax);
            this.state.sys.print("    | givensMax: " + this.givensMax);
          }
          if (("number" !== typeof this.namesetsMax || this.namesetsMax === -1 || this.gnameset === this.namesetsMax) && (!this.state.opt["disambiguate-add-names"] || "number" !== typeof this.namesMax || this.gname === this.namesMax) && ("number" != typeof this.givensMax || "undefined" === typeof this.base.givens[this.gnameset] || "undefined" === typeof this.base.givens[this.gnameset][this.gname] || this.base.givens[this.gnameset][this.gname] === this.givensMax)) {
            maxed = true;
            if (this.debug) {
              this.state.sys.print("    MAXED");
            }
          }
        } else if ("disExtraText" === this.modes[this.modeindex]) {
          this.base.disambiguate += 1;
          this.betterbase.disambiguate += 1;
        }
        return maxed;
      };
      CSL3.Disambiguation.prototype.initVars = function(akey) {
        var i, ilen, myIds, myItemBundles, myItems;
        if (this.debug) {
          this.state.sys.print("[B] === initVars() ===");
        }
        this.lists = [];
        this.base = false;
        this.betterbase = false;
        this.akey = akey;
        this.maxNamesByItemId = {};
        myItemBundles = [];
        myIds = this.ambigcites[akey];
        if (!myIds || !myIds.length) {
          return false;
        }
        var myItem = this.state.refetchItem("" + myIds[0]);
        this.getCiteData(myItem);
        this.base = CSL3.getAmbigConfig.call(this.state);
        if (myIds && myIds.length > 1) {
          myItemBundles.push([this.maxNamesByItemId[myItem.id], myItem]);
          for (var i = 1, ilen = myIds.length; i < ilen; i += 1) {
            myItem = this.state.refetchItem("" + myIds[i]);
            this.getCiteData(myItem, this.base);
            myItemBundles.push([this.maxNamesByItemId[myItem.id], myItem]);
          }
          myItemBundles.sort(
            function(a, b) {
              if (a[0] > b[0]) {
                return 1;
              } else if (a[0] < b[0]) {
                return -1;
              } else {
                if (a[1].id > b[1].id) {
                  return 1;
                } else if (a[1].id < b[1].id) {
                  return -1;
                } else {
                  return 0;
                }
              }
            }
          );
          myItems = [];
          for (var i = 0, ilen = myItemBundles.length; i < ilen; i += 1) {
            myItems.push(myItemBundles[i][1]);
          }
          this.lists.push([this.base, myItems]);
          this.Item = this.lists[0][1][0];
        } else {
          this.Item = this.state.refetchItem("" + myIds[0]);
        }
        this.modeindex = 0;
        if (this.state.citation.opt["disambiguate-add-names"] || true) {
          this.namesMax = this.maxNamesByItemId[this.Item.id][0];
        } else {
          var namesMax = this.base.names[0];
          for (var i = 1, ilen = this.base.names.length; i < ilen; i += 1) {
            namesMax = Math.max(namesMax, this.base.names.names[i]);
          }
        }
        this.padBase(this.base);
        this.padBase(this.betterbase);
        this.base.year_suffix = false;
        this.base.disambiguate = false;
        this.betterbase.year_suffix = false;
        this.betterbase.disambiguate = false;
        if (this.state.citation.opt["givenname-disambiguation-rule"] === "by-cite" && this.state.opt["disambiguate-add-givenname"]) {
          this.givensMax = 2;
        }
        return true;
      };
      CSL3.Disambiguation.prototype.padBase = function(base) {
        for (var i = 0, ilen = base.names.length; i < ilen; i += 1) {
          if (!base.givens[i]) {
            base.givens[i] = [];
          }
          for (var j = 0, jlen = base.names[i]; j < jlen; j += 1) {
            if (!base.givens[i][j]) {
              base.givens[i][j] = 0;
            }
          }
        }
      };
      CSL3.Disambiguation.prototype.configModes = function() {
        var dagopt, gdropt;
        this.modes = [];
        dagopt = this.state.opt["disambiguate-add-givenname"];
        gdropt = this.state.citation.opt["givenname-disambiguation-rule"];
        if (this.state.opt["disambiguate-add-names"] || dagopt && gdropt === "by-cite") {
          this.modes.push("disNames");
        }
        if (this.state.opt.development_extensions.prioritize_disambiguate_condition) {
          if (this.state.opt.has_disambiguate) {
            this.modes.push("disExtraText");
          }
          if (this.state.opt["disambiguate-add-year-suffix"]) {
            this.modes.push("disYears");
          }
        } else {
          if (this.state.opt["disambiguate-add-year-suffix"]) {
            this.modes.push("disYears");
          }
          if (this.state.opt.has_disambiguate) {
            this.modes.push("disExtraText");
          }
        }
      };
      CSL3.Disambiguation.prototype.getCiteData = function(Item, base) {
        if (!this.maxNamesByItemId[Item.id]) {
          CSL3.getAmbiguousCite.call(this.state, Item, base);
          base = CSL3.getAmbigConfig.call(this.state);
          this.maxNamesByItemId[Item.id] = CSL3.getMaxVals.call(this.state);
          this.state.registry.registry[Item.id].disambig.givens = this.state.tmp.disambig_settings.givens.slice();
          for (var i = 0, ilen = this.state.registry.registry[Item.id].disambig.givens.length; i < ilen; i += 1) {
            this.state.registry.registry[Item.id].disambig.givens[i] = this.state.tmp.disambig_settings.givens[i].slice();
          }
          this.namesetsMax = this.state.registry.registry[Item.id].disambig.names.length - 1;
          if (!this.base) {
            this.base = base;
            this.betterbase = CSL3.cloneAmbigConfig(base);
          }
          if (base.names.length < this.base.names.length) {
            this.base = base;
          }
          for (var i = 0, ilen = base.names.length; i < ilen; i += 1) {
            if (base.names[i] > this.base.names[i]) {
              this.base.givens[i] = base.givens[i].slice();
              this.base.names[i] = base.names[i];
              this.betterbase.names = this.base.names.slice();
              this.betterbase.givens = this.base.givens.slice();
              this.padBase(this.base);
              this.padBase(this.betterbase);
            }
          }
          this.betterbase.givens = this.base.givens.slice();
          for (var j = 0, jlen = this.base.givens.length; j < jlen; j += 1) {
            this.betterbase.givens[j] = this.base.givens[j].slice();
          }
        }
      };
      CSL3.Disambiguation.prototype.captureStepToBase = function() {
        if (this.state.citation.opt["givenname-disambiguation-rule"] === "by-cite" && this.base.givens && this.base.givens.length) {
          if ("undefined" !== typeof this.base.givens[this.gnameset][this.gname]) {
            if (this.betterbase.givens.length < this.base.givens.length) {
              this.betterbase.givens = JSON.parse(JSON.stringify(this.base.givens));
            }
            this.betterbase.givens[this.gnameset][this.gname] = this.base.givens[this.gnameset][this.gname];
          }
        }
        this.betterbase.names[this.gnameset] = this.base.names[this.gnameset];
      };
      CSL3.Engine.prototype.getJurisdictionList = function(jurisdiction) {
        var jurisdictionList = [];
        var jurisdictionElems = jurisdiction.split(":");
        for (var j = jurisdictionElems.length; j > 0; j--) {
          var composedID = jurisdictionElems.slice(0, j).join(":");
          jurisdictionList.push(composedID);
          if (this.opt.jurisdiction_fallbacks[composedID]) {
            var fallback = this.opt.jurisdiction_fallbacks[composedID];
            jurisdictionList.push(fallback);
          }
        }
        if (jurisdictionList.indexOf("us") === -1) {
          jurisdictionList.push("us");
        }
        return jurisdictionList;
      };
      CSL3.Engine.prototype.loadStyleModule = function(jurisdiction, xmlSource, skipFallback) {
        var myFallback = null;
        var macroCount = 0;
        this.juris[jurisdiction] = {};
        var myXml = CSL3.setupXml(xmlSource);
        myXml.addMissingNameNodes(myXml.dataObj);
        myXml.addInstitutionNodes(myXml.dataObj);
        myXml.insertPublisherAndPlace(myXml.dataObj);
        myXml.flagDateMacros(myXml.dataObj);
        var myNodes = myXml.getNodesByName(myXml.dataObj, "law-module");
        for (var i = 0, ilen = myNodes.length; i < ilen; i++) {
          var myTypes = myXml.getAttributeValue(myNodes[i], "types");
          if (myTypes) {
            this.juris[jurisdiction].types = {};
            myTypes = myTypes.split(/\s+/);
            for (var j = 0, jlen = myTypes.length; j < jlen; j++) {
              this.juris[jurisdiction].types[myTypes[j]] = true;
            }
          }
          if (!skipFallback) {
            myFallback = myXml.getAttributeValue(myNodes[i], "fallback");
            if (myFallback) {
              if (jurisdiction !== "us") {
                this.opt.jurisdiction_fallbacks[jurisdiction] = myFallback;
              }
            }
          }
        }
        var lang = this.opt.lang ? this.opt.lang : this.opt["default-locale"][0];
        CSL3.SET_COURT_CLASSES(this, lang, myXml, myXml.dataObj);
        if (!this.juris[jurisdiction].types) {
          this.juris[jurisdiction].types = CSL3.MODULE_TYPES;
        }
        var myNodes = myXml.getNodesByName(myXml.dataObj, "macro");
        for (var i = 0, ilen = myNodes.length; i < ilen; i++) {
          var myName = myXml.getAttributeValue(myNodes[i], "name");
          if (!CSL3.MODULE_MACROS[myName]) {
            CSL3.debug('CSL: skipping non-modular macro name "' + myName + '" in module context');
            continue;
          }
          macroCount++;
          this.juris[jurisdiction][myName] = [];
          this.buildTokenLists(myNodes[i], this.juris[jurisdiction][myName]);
          this.configureTokenList(this.juris[jurisdiction][myName]);
        }
        return myFallback;
      };
      CSL3.Engine.prototype.retrieveAllStyleModules = function(jurisdictionList) {
        var ret = {};
        var preferences = this.locale[this.opt.lang].opts["jurisdiction-preference"];
        preferences = preferences ? preferences : [];
        preferences = [""].concat(preferences);
        for (var i = preferences.length - 1; i > -1; i--) {
          var preference = preferences[i];
          for (var j = 0, jlen = jurisdictionList.length; j < jlen; j++) {
            var jurisdiction = jurisdictionList[j];
            if (this.opt.jurisdictions_seen[jurisdiction]) {
              continue;
            }
            var res = this.sys.retrieveStyleModule(jurisdiction, preference);
            if (!res && !preference || res) {
              this.opt.jurisdictions_seen[jurisdiction] = true;
            }
            if (!res) {
              continue;
            }
            ret[jurisdiction] = res;
          }
        }
        return ret;
      };
      CSL3.ParticleList = /* @__PURE__ */ function() {
        var always_dropping_1 = [[[0, 1], null]];
        var always_dropping_3 = [[[0, 3], null]];
        var always_non_dropping_1 = [[null, [0, 1]]];
        var always_non_dropping_2 = [[null, [0, 2]]];
        var always_non_dropping_3 = [[null, [0, 3]]];
        var either_1 = [[null, [0, 1]], [[0, 1], null]];
        var either_2 = [[null, [0, 2]], [[0, 2], null]];
        var either_1_dropping_best = [[[0, 1], null], [null, [0, 1]]];
        var either_2_dropping_best = [[[0, 2], null], [null, [0, 2]]];
        var either_3_dropping_best = [[[0, 3], null], [null, [0, 3]]];
        var non_dropping_2_alt_dropping_1_non_dropping_1 = [[null, [0, 2]], [[0, 1], [1, 2]]];
        var PARTICLES = [
          ["'s", always_non_dropping_1],
          ["'s-", always_non_dropping_1],
          ["'t", always_non_dropping_1],
          ["a", always_non_dropping_1],
          ["aan 't", always_non_dropping_2],
          ["aan de", always_non_dropping_2],
          ["aan den", always_non_dropping_2],
          ["aan der", always_non_dropping_2],
          ["aan het", always_non_dropping_2],
          ["aan t", always_non_dropping_2],
          ["aan", always_non_dropping_1],
          ["ad-", either_1],
          ["adh-", either_1],
          ["af", either_1],
          ["al", either_1],
          ["al-", either_1],
          ["am de", always_non_dropping_2],
          ["am", always_non_dropping_1],
          ["an-", either_1],
          ["ar-", either_1],
          ["as-", either_1],
          ["ash-", either_1],
          ["at-", either_1],
          ["ath-", either_1],
          ["auf dem", either_2_dropping_best],
          ["auf den", either_2_dropping_best],
          ["auf der", either_2_dropping_best],
          ["auf ter", always_non_dropping_2],
          ["auf", either_1_dropping_best],
          ["aus 'm", either_2_dropping_best],
          ["aus dem", either_2_dropping_best],
          ["aus den", either_2_dropping_best],
          ["aus der", either_2_dropping_best],
          ["aus m", either_2_dropping_best],
          ["aus", either_1_dropping_best],
          ["aus'm", either_2_dropping_best],
          ["az-", either_1],
          ["a\u0161-", either_1],
          ["a\u1E0D-", either_1],
          ["a\u1E0F-", either_1],
          ["a\u1E63-", either_1],
          ["a\u1E6D-", either_1],
          ["a\u1E6F-", either_1],
          ["a\u1E93-", either_1],
          ["ben", always_non_dropping_1],
          ["bij 't", always_non_dropping_2],
          ["bij de", always_non_dropping_2],
          ["bij den", always_non_dropping_2],
          ["bij het", always_non_dropping_2],
          ["bij t", always_non_dropping_2],
          ["bij", always_non_dropping_1],
          ["bin", always_non_dropping_1],
          ["boven d", always_non_dropping_2],
          ["boven d'", always_non_dropping_2],
          ["d", always_non_dropping_1],
          ["d'", either_1],
          ["da", either_1],
          ["dal", always_non_dropping_1],
          ["dal'", always_non_dropping_1],
          ["dall'", always_non_dropping_1],
          ["dalla", always_non_dropping_1],
          ["das", either_1],
          ["de die le", always_non_dropping_3],
          ["de die", always_non_dropping_2],
          ["de l", always_non_dropping_2],
          ["de l'", always_non_dropping_2],
          ["de la", non_dropping_2_alt_dropping_1_non_dropping_1],
          ["de las", non_dropping_2_alt_dropping_1_non_dropping_1],
          ["de le", always_non_dropping_2],
          ["de li", either_2],
          ["de van der", always_non_dropping_3],
          ["de", either_1],
          ["de'", either_1],
          ["deca", always_non_dropping_1],
          ["degli", either_1],
          ["dei", either_1],
          ["del", either_1],
          ["dela", always_dropping_1],
          ["dell'", either_1],
          ["della", either_1],
          ["delle", either_1],
          ["dello", either_1],
          ["den", either_1],
          ["der", either_1],
          ["des", either_1],
          ["di", either_1],
          ["die le", always_non_dropping_2],
          ["do", always_non_dropping_1],
          ["don", always_non_dropping_1],
          ["dos", either_1],
          ["du", either_1],
          ["ed-", either_1],
          ["edh-", either_1],
          ["el", either_1],
          ["el-", either_1],
          ["en-", either_1],
          ["er-", either_1],
          ["es-", either_1],
          ["esh-", either_1],
          ["et-", either_1],
          ["eth-", either_1],
          ["ez-", either_1],
          ["e\u0161-", either_1],
          ["e\u1E0D-", either_1],
          ["e\u1E0F-", either_1],
          ["e\u1E63-", either_1],
          ["e\u1E6D-", either_1],
          ["e\u1E6F-", either_1],
          ["e\u1E93-", either_1],
          ["het", always_non_dropping_1],
          ["i", always_non_dropping_1],
          ["il", always_dropping_1],
          ["im", always_non_dropping_1],
          ["in 't", always_non_dropping_2],
          ["in de", always_non_dropping_2],
          ["in den", always_non_dropping_2],
          ["in der", either_2],
          ["in het", always_non_dropping_2],
          ["in t", always_non_dropping_2],
          ["in", always_non_dropping_1],
          ["l", always_non_dropping_1],
          ["l'", always_non_dropping_1],
          ["la", always_non_dropping_1],
          ["las", always_non_dropping_1],
          ["le", always_non_dropping_1],
          ["les", either_1],
          ["lo", either_1],
          ["los", always_non_dropping_1],
          ["lou", always_non_dropping_1],
          ["of", always_non_dropping_1],
          ["onder 't", always_non_dropping_2],
          ["onder de", always_non_dropping_2],
          ["onder den", always_non_dropping_2],
          ["onder het", always_non_dropping_2],
          ["onder t", always_non_dropping_2],
          ["onder", always_non_dropping_1],
          ["op 't", always_non_dropping_2],
          ["op de", either_2],
          ["op den", always_non_dropping_2],
          ["op der", always_non_dropping_2],
          ["op gen", always_non_dropping_2],
          ["op het", always_non_dropping_2],
          ["op t", always_non_dropping_2],
          ["op ten", always_non_dropping_2],
          ["op", always_non_dropping_1],
          ["over 't", always_non_dropping_2],
          ["over de", always_non_dropping_2],
          ["over den", always_non_dropping_2],
          ["over het", always_non_dropping_2],
          ["over t", always_non_dropping_2],
          ["over", always_non_dropping_1],
          ["s", always_non_dropping_1],
          ["s'", always_non_dropping_1],
          ["sen", always_dropping_1],
          ["t", always_non_dropping_1],
          ["te", always_non_dropping_1],
          ["ten", always_non_dropping_1],
          ["ter", always_non_dropping_1],
          ["tho", always_non_dropping_1],
          ["thoe", always_non_dropping_1],
          ["thor", always_non_dropping_1],
          ["to", always_non_dropping_1],
          ["toe", always_non_dropping_1],
          ["tot", always_non_dropping_1],
          ["uijt 't", always_non_dropping_2],
          ["uijt de", always_non_dropping_2],
          ["uijt den", always_non_dropping_2],
          ["uijt te de", always_non_dropping_3],
          ["uijt ten", always_non_dropping_2],
          ["uijt", always_non_dropping_1],
          ["uit 't", always_non_dropping_2],
          ["uit de", always_non_dropping_2],
          ["uit den", always_non_dropping_2],
          ["uit het", always_non_dropping_2],
          ["uit t", always_non_dropping_2],
          ["uit te de", always_non_dropping_3],
          ["uit ten", always_non_dropping_2],
          ["uit", always_non_dropping_1],
          ["unter", always_non_dropping_1],
          ["v", always_non_dropping_1],
          ["v.", always_non_dropping_1],
          ["v.d.", always_non_dropping_1],
          ["van 't", always_non_dropping_2],
          ["van de l", always_non_dropping_3],
          ["van de l'", always_non_dropping_3],
          ["van de", always_non_dropping_2],
          ["van de", always_non_dropping_2],
          ["van den", always_non_dropping_2],
          ["van der", always_non_dropping_2],
          ["van gen", always_non_dropping_2],
          ["van het", always_non_dropping_2],
          ["van la", always_non_dropping_2],
          ["van t", always_non_dropping_2],
          ["van ter", always_non_dropping_2],
          ["van van de", always_non_dropping_3],
          ["van", either_1],
          ["vander", always_non_dropping_1],
          ["vd", always_non_dropping_1],
          ["ver", always_non_dropping_1],
          ["vom und zum", always_dropping_3],
          ["vom", either_1],
          ["von 't", always_non_dropping_2],
          ["von dem", either_2_dropping_best],
          ["von den", either_2_dropping_best],
          ["von der", either_2_dropping_best],
          ["von t", always_non_dropping_2],
          ["von und zu", either_3_dropping_best],
          ["von zu", either_2_dropping_best],
          ["von", either_1_dropping_best],
          ["voor 't", always_non_dropping_2],
          ["voor de", always_non_dropping_2],
          ["voor den", always_non_dropping_2],
          ["voor in 't", always_non_dropping_3],
          ["voor in t", always_non_dropping_3],
          ["voor", always_non_dropping_1],
          ["vor der", either_2_dropping_best],
          ["vor", either_1_dropping_best],
          ["z", always_dropping_1],
          ["ze", always_dropping_1],
          ["zu", either_1_dropping_best],
          ["zum", either_1],
          ["zur", either_1]
        ];
        return PARTICLES;
      }();
      CSL3.parseParticles = /* @__PURE__ */ function() {
        function splitParticles(nameValue, firstNameFlag, caseOverride) {
          var origNameValue = nameValue;
          nameValue = caseOverride ? nameValue.toLowerCase() : nameValue;
          var particleList = [];
          var rex;
          var hasParticle;
          if (firstNameFlag) {
            nameValue = nameValue.split("").reverse().join("");
            rex = CSL3.PARTICLE_GIVEN_REGEXP;
          } else {
            rex = CSL3.PARTICLE_FAMILY_REGEXP;
          }
          var m = nameValue.match(rex);
          while (m) {
            var m1 = firstNameFlag ? m[1].split("").reverse().join("") : m[1];
            var firstChar = m ? m1 : false;
            var firstChar = firstChar ? m1.replace(/^[-\'\u02bb\u2019\s]*(.).*$/, "$1") : false;
            hasParticle = firstChar ? firstChar.toUpperCase() !== firstChar : false;
            if (!hasParticle) {
              break;
            }
            if (firstNameFlag) {
              particleList.push(origNameValue.slice(m1.length * -1));
              origNameValue = origNameValue.slice(0, m1.length * -1);
            } else {
              particleList.push(origNameValue.slice(0, m1.length));
              origNameValue = origNameValue.slice(m1.length);
            }
            nameValue = m[2];
            m = nameValue.match(rex);
          }
          if (firstNameFlag) {
            nameValue = nameValue.split("").reverse().join("");
            particleList.reverse();
            for (var i = 1, ilen = particleList.length; i < ilen; i++) {
              if (particleList[i].slice(0, 1) == " ") {
                particleList[i - 1] += " ";
              }
            }
            for (var i = 0, ilen = particleList.length; i < ilen; i++) {
              if (particleList[i].slice(0, 1) == " ") {
                particleList[i] = particleList[i].slice(1);
              }
            }
            nameValue = origNameValue.slice(0, nameValue.length);
          } else {
            nameValue = origNameValue.slice(nameValue.length * -1);
          }
          return [hasParticle, nameValue, particleList];
        }
        function trimLast(str) {
          var lastChar = str.slice(-1);
          str = str.trim();
          if (lastChar === " " && ["'", "\u2019"].indexOf(str.slice(-1)) > -1) {
            str += " ";
          }
          return str;
        }
        function parseSuffix(nameObj) {
          if (!nameObj.suffix && nameObj.given) {
            var m = nameObj.given.match(/(\s*,!*\s*)/);
            if (m) {
              var idx = nameObj.given.indexOf(m[1]);
              var possible_suffix = nameObj.given.slice(idx + m[1].length);
              var possible_comma = nameObj.given.slice(idx, idx + m[1].length).replace(/\s*/g, "");
              if (possible_suffix.replace(/\./g, "") === "et al" && !nameObj["dropping-particle"]) {
                nameObj["dropping-particle"] = possible_suffix;
                nameObj["comma-dropping-particle"] = ",";
              } else {
                if (possible_comma.length === 2) {
                  nameObj["comma-suffix"] = true;
                }
                nameObj.suffix = possible_suffix;
              }
              nameObj.given = nameObj.given.slice(0, idx);
            }
          }
        }
        return function(nameObj) {
          var res = splitParticles(nameObj.family);
          var lastNameValue = res[1];
          var lastParticleList = res[2];
          nameObj.family = lastNameValue;
          var nonDroppingParticle = trimLast(lastParticleList.join(""));
          if (nonDroppingParticle) {
            nameObj["non-dropping-particle"] = nonDroppingParticle;
          }
          parseSuffix(nameObj);
          var res = splitParticles(nameObj.given, true);
          var firstNameValue = res[1];
          var firstParticleList = res[2];
          nameObj.given = firstNameValue;
          var droppingParticle = firstParticleList.join("").trim();
          if (droppingParticle) {
            nameObj["dropping-particle"] = droppingParticle;
          }
        };
      }();
      module.exports = CSL3;
    }
  });

  // gen/babel/langmap.json
  var require_langmap = __commonJS({
    "gen/babel/langmap.json"(exports, module) {
      module.exports = { "aa": "afar", "aa-aa": "afar", "ab": "abkhazian", "ab-ab": "abkhazian", "abk": "abkhazian", "abkhazian": "abkhazian", "aca": "acadian", "acadian": "acadian", "acadien": "acadian", "ae": "avestan", "ae-ae": "avestan", "af": "afrikaans", "af-af": "afrikaans", "afa": "afar", "afar": "afar", "afr": "afrikaans", "afrikaans": "afrikaans", "agh": "aghem", "aghem": "aghem", "agq": "aghem", "ak": "akan", "ak-ak": "akan", "aka": "akan", "akan": "akan", "akk": "akkadian", "akkadian": "akkadian", "alb": "albanian", "albanian": "albanian", "alt": "southernaltai", "am": "amharic", "am-am": "amharic", "ame": "american", "american": "american", "american english": "american", "americanenglish": "american", "amh": "amharic", "amharic": "amharic", "anar\xE2\u0161kiel\xE2": "inarisami", "anc": "ancientegyptian", "ancient egyptian": "ancientegyptian", "ancient greek": "greek", "ancientegyptian": "ancientegyptian", "ancientgreek": "greek", "ar": "arabic", "ar-ar": "arabic", "ar-dz": "arabic-algeria", "ar-eg": "arabic-egypt", "ar-iq": "arabic-iraq", "ar-jo": "arabic-jordan", "ar-lb": "arabic-lebanon", "ar-ma": "arabic-morocco", "ar-ps": "arabic-palestinianterritories", "ar-sa": "arabic-saudiarabia", "ar-sy": "arabic-syria", "ar-tn": "arabic-tunisia", "ara": "arabic", "arabic": "arabic", "arabic-algeria": "arabic-algeria", "arabic-dz": "arabic-algeria", "arabic-eg": "arabic-egypt", "arabic-egypt": "arabic-egypt", "arabic-iq": "arabic-iraq", "arabic-iraq": "arabic-iraq", "arabic-jo": "arabic-jordan", "arabic-jordan": "arabic-jordan", "arabic-lb": "arabic-lebanon", "arabic-lebanon": "arabic-lebanon", "arabic-ma": "arabic-morocco", "arabic-morocco": "arabic-morocco", "arabic-palestinianterritories": "arabic-palestinianterritories", "arabic-ps": "arabic-palestinianterritories", "arabic-sa": "arabic-saudiarabia", "arabic-saudiarabia": "arabic-saudiarabia", "arabic-sy": "arabic-syria", "arabic-syria": "arabic-syria", "arabic-tn": "arabic-tunisia", "arabic-tunisia": "arabic-tunisia", "aramaic": "aramaic", "aramaic-nabataean": "aramaic-nabataean", "aramaic-nbat": "aramaic-nabataean", "aramaic-palm": "aramaic-palmyrene", "aramaic-palmyrene": "aramaic-palmyrene", "arc": "aramaic", "arc-nbat": "aramaic-nabataean", "arc-palm": "aramaic-palmyrene", "arm": "armenian", "armenian": "armenian", "arz": "egyptianarabic", "as": "assamese", "as-as": "assamese", "asa": "asu", "ass": "assamese", "assamese": "assamese", "ast": "asturian", "asturian": "asturian", "asturianu": "asturian", "asu": "asu", "ats": "atsam", "atsam": "atsam", "australian": "australian", "australian english": "australian", "australianenglish": "australian", "austrian": "austrian", "austrian german": "austrian", "austrian-traditional": "austrian", "austriangerman": "austrian", "austriangerman-traditional": "austrian", "ava\xF1e\u2019\u1EBD": "guarani", "ave": "avestan", "avestan": "avestan", "awa": "awadhi", "awadhi": "awadhi", "ay": "aymara", "ay-ay": "aymara", "aym": "aymara", "aymar aru": "aymara", "aymara": "aymara", "az": "azerbaijani", "az-az": "azerbaijani", "az-cyrl": "azerbaijani-cyrillic", "az-latn": "azerbaijani-latin", "azerbaijani": "azerbaijani", "azerbaijani-cyrillic": "azerbaijani-cyrillic", "azerbaijani-cyrl": "azerbaijani-cyrillic", "azerbaijani-latin": "azerbaijani-latin", "azerbaijani-latn": "azerbaijani-latin", "az\u0259rbaycan": "azerbaijani", "ba": "bashkir", "ba-ba": "bashkir", "baf": "bafia", "bafia": "bafia", "bahasa melayu": "malay", "bal": "baluchi", "balinese": "balinese", "baluchi": "baluchi", "bam": "bambara", "bamanakan": "bambara", "bambara": "bambara", "ban": "balinese", "bangla": "bangla", "bar": "bavarian", "bas": "basaa", "basa bali": "balinese", "basa mangkasara\u02BC": "makasar", "basa sunda": "sundanese", "basaa": "basaa", "bashkir": "bashkir", "basque": "basque", "bat": "bataktoba", "batak toba": "bataktoba", "bataktoba": "bataktoba", "bav": "bavarian", "bavarian": "bavarian", "bbc": "bataktoba", "be": "belarusian", "be-be": "belarusian", "bel": "belarusian", "belarusian": "belarusian", "bem": "bemba", "bemba": "bemba", "ben": "bena", "bena": "bena", "bengali": "bangla", "bez": "bena", "bg": "bulgarian", "bg-bg": "bulgarian", "bgc": "haryanvi", "bho": "bhojpuri", "bhojpuri": "bhojpuri", "bli": "blin", "blin": "blin", "bm": "bambara", "bm-bm": "bambara", "bn": "bangla", "bn-bn": "bangla", "bo": "tibetan", "bo-bo": "tibetan", "boarisch": "bavarian", "bod": "bodo", "bodo": "bodo", "bosanski": "bosnian", "bosnian": "bosnian", "bosnian-cyrillic": "bosnian-cyrillic", "bosnian-cyrl": "bosnian-cyrillic", "bosnian-latin": "bosnian-latin", "bosnian-latn": "bosnian-latin", "br": "breton", "br-br": "breton", "bra": "brazilian", "brazilian": "brazilian", "brazilian portuguese": "brazilian", "brazilianportuguese": "brazilian", "bre": "breton", "breton": "breton", "brezhoneg": "breton", "bri": "british", "british": "british", "british english": "british", "britishenglish": "british", "brx": "bodo", "bs": "bosnian", "bs-bs": "bosnian", "bs-cyrl": "bosnian-cyrillic", "bs-latn": "bosnian-latin", "bua": "buriat", "bul": "bulgarian", "bulgarian": "bulgarian", "buriat": "buriat", "burmese": "burmese", "byn": "blin", "ca": "catalan", "ca-ca": "catalan", "canadian": "canadian", "canadian english": "canadian", "canadian french": "canadien", "canadianenglish": "canadian", "canadianfrench": "canadien", "canadien": "canadien", "cantonese": "cantonese", "cat": "catalan", "catalan": "catalan", "catal\xE0": "catalan", "cch": "atsam", "ccp": "chakma", "ce": "chechen", "ce-ce": "chechen", "ceb": "cebuano", "cebuano": "cebuano", "cen": "centralatlastamazight", "central atlas tamazight": "centralatlastamazight", "central kurdish": "sorani", "centralatlastamazight": "centralatlastamazight", "centralkurdish": "sorani", "centralkurdish-latin": "sorani", "cgg": "chiga", "cha": "chakma", "chakma": "chakma", "chechen": "chechen", "cherokee": "cherokee", "chiga": "chiga", "chimakonde": "makonde", "chinese": "chinese", "chinese-hans": "chinese-simplified", "chinese-hans-hk": "chinese-simplified-hongkongsarchina", "chinese-hans-mo": "chinese-simplified-macausarchina", "chinese-hans-sg": "chinese-simplified-singapore", "chinese-hant": "chinese-traditional", "chinese-hant-hk": "chinese-traditional-hongkongsarchina", "chinese-hant-mo": "chinese-traditional-macausarchina", "chinese-simplified": "chinese-simplified", "chinese-simplified-hongkongsarchina": "chinese-simplified-hongkongsarchina", "chinese-simplified-macausarchina": "chinese-simplified-macausarchina", "chinese-simplified-singapore": "chinese-simplified-singapore", "chinese-traditional": "chinese-traditional", "chinese-traditional-hongkongsarchina": "chinese-traditional-hongkongsarchina", "chinese-traditional-macausarchina": "chinese-traditional-macausarchina", "chishona": "shona", "chr": "cherokee", "church slavic": "churchslavic", "churchslavic": "churchslavic", "churchslavic-glagolitic": "churchslavic-glagolitic", "churchslavic-oldcyrillic": "churchslavic-oldcyrillic", "churchslavonic": "churchslavic", "chuvash": "chuvash", "ckb": "sorani", "ckb-arab": "sorani", "ckb-latn": "sorani", "classical latin": "classicallatin", "classical mandaic": "classicalmandaic", "classicallatin": "classicallatin", "classicalmandaic": "classicalmandaic", "co": "corsican", "co-co": "corsican", "col": "colognian", "colognian": "colognian", "cop": "coptic", "coptic": "coptic", "cornish": "cornish", "corsican": "corsican", "corsu": "corsican", "cro": "croatian", "croatian": "croatian", "cs": "czech", "cs-cs": "czech", "cu": "churchslavic", "cu-cu": "churchslavic", "cu-cyrs": "churchslavic-oldcyrillic", "cu-glag": "churchslavic-glagolitic", "cv": "chuvash", "cv-cv": "chuvash", "cy": "welsh", "cy-cy": "welsh", "cymraeg": "welsh", "cze": "czech", "czech": "czech", "da": "danish", "da-da": "danish", "dan": "danish", "danish": "danish", "dansk": "danish", "dav": "taita", "davvis\xE1megiella": "northernsami", "de": "ngerman", "de-1901": "german", "de-1996": "ngerman", "de-at": "austrian", "de-at-1901": "austrian", "de-at-1996": "naustrian", "de-ch": "nswissgerman", "de-ch-1901": "german", "de-ch-1996": "nswissgerman", "de-de": "ngerman", "deutsch": "ngerman", "dholuo": "luo", "din\xE9 bizaad": "navajo", "div": "divehi", "divehi": "divehi", "dje": "zarma", "dog": "dogri", "dogri": "dogri", "doi": "dogri", "dolnoserb\u0161\u0107ina": "lowersorbian", "dsb": "lowersorbian", "dua": "duala", "duala": "duala", "dut": "dutch", "dutch": "dutch", "du\xE1l\xE1": "duala", "dv": "divehi", "dv-dv": "divehi", "dyo": "jolafonyi", "dz": "dzongkha", "dz-dz": "dzongkha", "dzo": "dzongkha", "dzongkha": "dzongkha", "ebu": "embu", "ecc": "ecclesiasticallatin", "ecclesiastical latin": "ecclesiasticallatin", "ecclesiasticallatin": "ecclesiasticallatin", "ee": "ewe", "ee-ee": "ewe", "eesti": "estonian", "egy": "ancientegyptian", "egyptian arabic": "egyptianarabic", "egyptianarabic": "egyptianarabic", "ekegusii": "gusii", "el": "greek", "el-el": "greek", "el-polyton": "greek", "emb": "embu", "embu": "embu", "en": "english", "en-au": "australian", "en-ca": "canadian", "en-en": "english", "en-gb": "british", "en-nz": "newzealand", "en-us": "american", "eng": "english", "english": "english", "english-au": "australian", "english-australia": "australian", "english-ca": "canadian", "english-canada": "canadian", "english-gb": "british", "english-newzealand": "newzealand", "english-nz": "newzealand", "english-unitedkingdom": "british", "english-unitedstates": "american", "english-us": "american", "eo": "esperanto", "eo-eo": "esperanto", "erz": "erzya", "erzya": "erzya", "es": "spanish", "es-es": "spanish", "es-mx": "mexican", "esp": "esperanto", "espa\xF1ol": "spanish", "espa\xF1ol de m\xE9xico": "mexican", "esperanto": "esperanto", "est": "estonian", "estonian": "estonian", "et": "estonian", "et-et": "estonian", "eu": "basque", "eu-eu": "basque", "european portuguese": "portuguese", "europeanportuguese": "portuguese", "euskara": "basque", "ewe": "ewe", "ewo": "ewondo", "ewondo": "ewondo", "e\u028Begbe": "ewe", "fa": "persian", "fa-fa": "persian", "far": "faroese", "faroese": "faroese", "ff": "fulah", "ff-ff": "fulah", "fi": "finnish", "fi-fi": "finnish", "fil": "filipino", "filipino": "filipino", "fin": "finnish", "finnish": "finnish", "fo": "faroese", "fo-fo": "faroese", "fr": "french", "fr-be": "french", "fr-ca": "canadien", "fr-ch": "french-switzerland", "fr-fr": "french", "fr-lu": "french", "fr-x-acadian": "acadian", "fran\xE7ais": "french", "fran\xE7ais canadien": "canadien", "fran\xE7ais suisse": "french-switzerland", "french": "french", "french-be": "french", "french-belgium": "french", "french-ca": "canadien", "french-canada": "canadien", "french-ch": "french-switzerland", "french-lu": "french", "french-luxembourg": "french", "french-switzerland": "french-switzerland", "fri": "friulian", "friulian": "friulian", "frr": "northernfrisian", "frysk": "westernfrisian", "ful": "fulah", "fulah": "fulah", "fur": "friulian", "furlan": "friulian", "fy": "westernfrisian", "fy-fy": "westernfrisian", "f\xF8royskt": "faroese", "ga": "irish", "ga-ga": "irish", "gaa": "ga", "gaeilge": "irish", "gaelg": "manx", "gaelic": "scottishgaelic", "gal": "galician", "galego": "galician", "galician": "galician", "gan": "ganda", "ganda": "ganda", "gd": "scottishgaelic", "gd-gd": "scottishgaelic", "gee": "geez", "geez": "geez", "geo": "georgian", "georgian": "georgian", "ger": "german", "german": "german", "german-at": "austrian", "german-at-traditional": "austrian", "german-austria": "austrian", "german-austria-traditional": "austrian", "german-ch": "nswissgerman", "german-ch-traditional": "german", "german-switzerland": "nswissgerman", "german-switzerland-traditional": "german", "german-traditional": "german", "gez": "geez", "gikuyu": "kikuyu", "gl": "galician", "gl-gl": "galician", "gn": "guarani", "gn-gn": "guarani", "got": "gothic", "gothic": "gothic", "grc": "greek", "gre": "greek", "greek": "greek", "gsw": "swissgerman", "gu": "gujarati", "gu-gu": "gujarati", "gua": "guarani", "guarani": "guarani", "guj": "gujarati", "gujarati": "gujarati", "gus": "gusii", "gusii": "gusii", "guz": "gusii", "gv": "manx", "gv-gv": "manx", "g\xE0idhlig": "scottishgaelic", "g\xE3": "ga", "g\xE3-g\xE3": "ga", "ha": "hausa", "ha-gh": "hausa-ghana", "ha-ha": "hausa", "ha-ne": "hausa-niger", "har": "haryanvi", "haryanvi": "haryanvi", "hausa": "hausa", "hausa-gh": "hausa-ghana", "hausa-ghana": "hausa-ghana", "hausa-ne": "hausa-niger", "hausa-niger": "hausa-niger", "haw": "hawaiian", "hawaiian": "hawaiian", "he": "hebrew", "he-he": "hebrew", "heb": "hebrew", "hebrew": "hebrew", "hi": "hindi", "hi-hi": "hindi", "hibena": "bena", "hin": "hindi", "hindi": "hindi", "hmo": "hmongnjua", "hmong njua": "hmongnjua", "hmongnjua": "hmongnjua", "hnj": "hmongnjua", "hornjoserb\u0161\u0107ina": "uppersorbian", "hr": "croatian", "hr-hr": "croatian", "hrvatski": "croatian", "hsb": "uppersorbian", "hu": "hungarian", "hu-hu": "hungarian", "hun": "hungarian", "hungarian": "hungarian", "hy": "armenian", "hy-hy": "armenian", "ia": "interlingua", "ia-ia": "interlingua", "ice": "icelandic", "icelandic": "icelandic", "ichibemba": "bemba", "id": "indonesian", "id-id": "indonesian", "ig": "igbo", "ig-ig": "igbo", "igb": "igbo", "igbo": "igbo", "ii": "sichuanyi", "ii-ii": "sichuanyi", "ikirundi": "rundi", "ina": "inarisami", "inari sami": "inarisami", "inarisami": "inarisami", "ind": "indonesian", "indonesia": "indonesian", "indonesian": "indonesian", "ing": "ingush", "ingush": "ingush", "inh": "ingush", "int": "interlingua", "interlingua": "interlingua", "inu": "inuktitut", "inuktitut": "inuktitut", "iri": "irish", "irish": "irish", "is": "icelandic", "is-is": "icelandic", "ishisangu": "sangu", "isixhosa": "xhosa", "isizulu": "zulu", "it": "italian", "it-it": "italian", "ita": "italian", "italian": "italian", "italiano": "italian", "iu": "inuktitut", "iu-iu": "inuktitut", "ja": "japanese", "ja-ja": "japanese", "jap": "japanese", "japanese": "japanese", "jav": "javanese", "javanese": "javanese", "jawa": "javanese", "jgo": "ngomba", "jju": "jju", "jmc": "machame", "jol": "jolafonyi", "jola-fonyi": "jolafonyi", "jolafonyi": "jolafonyi", "joola": "jolafonyi", "jv": "javanese", "jv-jv": "javanese", "ka": "georgian", "ka-ka": "georgian", "kab": "kabyle", "kabuverdianu": "kabuverdianu", "kabyle": "kabyle", "kai": "kaingang", "kaingang": "kaingang", "kaj": "jju", "kaje": "jju", "kak": "kako", "kako": "kako", "kak\u0254": "kako", "kalaallisut": "kalaallisut", "kalenjin": "kalenjin", "kam": "kamba", "kamba": "kamba", "kan": "kannada", "kanhg\xE1g": "kaingang", "kannada": "kannada", "kas": "kashmiri", "kashmiri": "kashmiri", "katab": "tyap", "kaz": "kazakh", "kazakh": "kazakh", "kcg": "tyap", "kde": "makonde", "kea": "kabuverdianu", "kernewek": "cornish", "kgp": "kaingang", "khb": "lu", "khm": "khmer", "khmer": "khmer", "khoekhoegowab": "nama", "khq": "koyrachiini", "ki": "kikuyu", "ki-ki": "kikuyu", "kihorombo": "rombo", "kik": "kikuyu", "kikamba": "kamba", "kikuyu": "kikuyu", "kimachame": "machame", "kin": "kinyarwanda", "kinyarwanda": "kinyarwanda", "kipare": "asu", "kiruwa": "rwa", "kisampur": "samburu", "kishambaa": "shambala", "kiswahili": "swahili", "kitaita": "taita", "kiteso": "teso", "kk": "kazakh", "kk-kk": "kazakh", "kkj": "kako", "kl": "kalaallisut", "kl-kl": "kalaallisut", "kln": "kalenjin", "km": "khmer", "km-km": "khmer", "kmr": "kurmanji", "kmr-arab": "kurmanji", "kmr-latn": "kurmanji", "kn": "kannada", "kn-kn": "kannada", "ko": "korean-han", "ko-ko": "korean-han", "kok": "konkani", "kom": "komi", "komi": "komi", "kon": "konkani", "konkani": "konkani", "kor": "korean-han", "korean": "korean-han", "korean-han": "korean-han", "korean-hani": "korean-han", "koyra chiini": "koyrachiini", "koyra ciini": "koyrachiini", "koyraboro senni": "koyraborosenni", "koyraborosenni": "koyraborosenni", "koyrachiini": "koyrachiini", "kreol morisien": "morisyen", "ks": "kashmiri", "ks-ks": "kashmiri", "ksb": "shambala", "ksf": "bafia", "ksh": "colognian", "kur": "kurmanji", "kurd\xEEy nawend\xEE": "sorani", "kurmanc\xEE": "kurmanji", "kurmanji": "kurmanji", "kv": "komi", "kv-kv": "komi", "kw": "cornish", "kw-kw": "cornish", "kwa": "kwasio", "kwasio": "kwasio", "ky": "kyrgyz", "ky-ky": "kyrgyz", "kyivunjo": "vunjo", "kyr": "kyrgyz", "kyrgyz": "kyrgyz", "k\xF6lsch": "colognian", "k\u0129embu": "embu", "k\u0129m\u0129r\u0169": "meru", "k\u0268laangi": "langi", "la": "latin", "la-la": "latin", "la-x-classic": "classicallatin", "la-x-ecclesia": "ecclesiasticallatin", "la-x-medieval": "medievallatin", "lab": "lineara", "lad": "ladino", "ladino": "ladino", "lag": "langi", "lak": "lakota", "lakota": "lakota", "lak\u021F\xF3l\u02BCiyapi": "lakota", "lan": "langi", "langi": "langi", "lao": "lao", "latin": "latin", "latvian": "latvian", "latvie\u0161u": "latvian", "lb": "luxembourgish", "lb-lb": "luxembourgish", "lea fakatonga": "tongan", "lep": "lepcha", "lepcha": "lepcha", "lg": "ganda", "lg-lg": "ganda", "lietuvi\u0173": "lithuanian", "lif": "limbu", "lif-limb": "limbu-limbu", "lig": "ligurian", "ligure": "ligurian", "ligurian": "ligurian", "lij": "ligurian", "limbu": "limbu", "limbu-limb": "limbu-limbu", "limbu-limbu": "limbu-limbu", "linear a": "lineara", "lineara": "lineara", "lingala": "lingala", "ling\xE1la": "lingala", "lit": "lithuanian", "lithuanian": "lithuanian", "lkt": "lakota", "lmo": "lombard", "ln": "lingala", "ln-ln": "lingala", "lo": "lao", "lo-lo": "lao", "lom": "lombard", "lombard": "lombard", "low german": "lowgerman", "lower sorbian": "lowersorbian", "lowersorbian": "lowersorbian", "lowgerman": "lowgerman", "lrc": "northernluri", "lsorbian": "lowersorbian", "lt": "lithuanian", "lt-lt": "lithuanian", "lu": "lubakatanga", "lu-lu": "lubakatanga", "lub": "lubakatanga", "luba-katanga": "lubakatanga", "lubakatanga": "lubakatanga", "luganda": "ganda", "luluhia": "luyia", "luo": "luo", "lux": "luxembourgish", "luxembourgish": "luxembourgish", "luy": "luyia", "luyia": "luyia", "lv": "latvian", "lv-lv": "latvian", "l\xEBtzebuergesch": "luxembourgish", "l\xFC": "lu", "l\xFC-l\xFC": "lu", "maa": "masai", "macedonian": "macedonian", "machame": "machame", "magyar": "hungarian", "mai": "maithili", "maithili": "maithili", "mak": "makasar", "mak-bugi": "makasar-buginese", "makasar": "makasar", "makasar-bugi": "makasar-buginese", "makasar-buginese": "makasar-buginese", "makhuwa-meetto": "makhuwameetto", "makhuwameetto": "makhuwameetto", "makonde": "makonde", "makua": "makhuwameetto", "malagasy": "malagasy", "malay": "malay", "malay-bn": "malay-brunei", "malay-brunei": "malay-brunei", "malay-sg": "malay-singapore", "malay-singapore": "malay-singapore", "malayalam": "malayalam", "maltese": "maltese", "malti": "maltese", "manipuri": "manipuri", "manx": "manx", "mao": "maori", "maori": "maori", "mar": "marathi", "marathi": "marathi", "mas": "masai", "masai": "masai", "maz": "mazanderani", "mazanderani": "mazanderani", "med": "medievallatin", "medieval latin": "medievallatin", "medievallatin": "medievallatin", "melayu": "malay", "mer": "meru", "meru": "meru", "met": "meta", "meta": "meta", "meta\u02BC": "meta", "mex": "mexican", "mexican": "mexican", "mexican spanish": "mexican", "mexicanspanish": "mexican", "mfe": "morisyen", "mg": "malagasy", "mg-mg": "malagasy", "mgh": "makhuwameetto", "mgo": "meta", "mi": "maori", "mi-mi": "maori", "mk": "macedonian", "mk-mk": "macedonian", "ml": "malayalam", "ml-ml": "malayalam", "mn": "mongolian", "mn-mn": "mongolian", "mni": "manipuri", "mol": "moldavian", "moldavian": "moldavian", "mon": "mongolian", "mongolian": "mongolian", "monotonicgreek": "greek", "montenegrin": "serbianc", "mor": "morisyen", "morisyen": "morisyen", "mr": "marathi", "mr-mr": "marathi", "ms": "malay", "ms-bn": "malay-brunei", "ms-ms": "malay", "ms-sg": "malay-singapore", "mt": "maltese", "mt-mt": "maltese", "mua": "mundang", "mun": "mundang", "mundang": "mundang", "munda\u014B": "mundang", "mus": "muscogee", "muscogee": "muscogee", "mvskoke": "muscogee", "my": "burmese", "my-my": "burmese", "myv": "erzya", "myz": "classicalmandaic", "mzn": "mazanderani", "m\u0101ori": "maori", "naij\xEDri\xE1 p\xEDjin": "nigerianpidgin", "nam": "nama", "nama": "nama", "naq": "nama", "nau": "naustrian", "naustrian": "naustrian", "nav": "navajo", "navajo": "navajo", "nb": "norwegianbokmal", "nb-nb": "norwegianbokmal", "nd": "northndebele", "nd-nd": "northndebele", "nda\uA78Ca": "ngomba", "nds": "lowgerman", "ne": "nepali", "ne-ne": "nepali", "neddersass\u2019sch": "lowgerman", "nederlands": "dutch", "nep": "nepali", "nepali": "nepali", "new": "newari", "newari": "newari", "newzealand": "newzealand", "nge": "ngerman", "ngerman": "ngerman", "ngi": "ngiemboon", "ngiemboon": "ngiemboon", "ngo": "ngomba", "ngomba": "ngomba", "nhe": "nheengatu", "nheengatu": "nheengatu", "nhe\u1EBDgatu": "nheengatu", "nig": "nigerianpidgin", "nigerian pidgin": "nigerianpidgin", "nigerianpidgin": "nigerianpidgin", "nko": "nko", "nl": "dutch", "nl-nl": "dutch", "nmg": "kwasio", "nn": "nynorsk", "nn-nn": "nynorsk", "nnh": "ngiemboon", "no": "norsk", "no-no": "norsk", "non": "oldnorse", "nordfriisk": "northernfrisian", "norr\u01FFnt m\xE1l": "oldnorse", "norsk": "norsk", "norsk bokm\xE5l": "norwegianbokmal", "norsk nynorsk": "nynorsk", "north ndebele": "northndebele", "northern frisian": "northernfrisian", "northern kurdish": "kurmanji", "northern luri": "northernluri", "northern sami": "northernsami", "northern sotho": "northernsotho", "northernfrisian": "northernfrisian", "northernkurdish": "kurmanji", "northernkurdish-arabic": "kurmanji", "northernluri": "northernluri", "northernsami": "northernsami", "northernsotho": "northernsotho", "northndebele": "northndebele", "norwegian": "norsk", "norwegian bokm\xE5l": "norwegianbokmal", "norwegian nynorsk": "nynorsk", "norwegianbokmal": "norwegianbokmal", "norwegiannynorsk": "nynorsk", "nqo": "nko", "nr": "southndebele", "nr-nr": "southndebele", "nso": "northernsotho", "nsw": "nswissgerman", "nswissgerman": "nswissgerman", "nuasue": "yangben", "nue": "nuer", "nuer": "nuer", "nus": "nuer", "nv": "navajo", "nv-nv": "navajo", "ny": "nyanja", "ny-ny": "nyanja", "nyanja": "nyanja", "nyankole": "nyankole", "nyn": "nyankole", "nynorsk": "nynorsk", "n\u2019ko": "nko", "oc": "occitan", "oc-oc": "occitan", "occ": "occitan", "occitan": "occitan", "odi": "odia", "odia": "odia", "old": "oldnorse", "old norse": "oldnorse", "oldnorse": "oldnorse", "olusoga": "soga", "om": "oromo", "om-om": "oromo", "or": "odia", "or-or": "odia", "oriya": "odia", "oro": "oromo", "oromo": "oromo", "oromoo": "oromo", "os": "ossetic", "os-os": "ossetic", "oss": "ossetic", "ossetic": "ossetic", "o\u2018zbek": "uzbek", "pa": "punjabi", "pa-arab": "punjabi-arabic", "pa-guru": "punjabi-gurmukhi", "pa-pa": "punjabi", "pap": "papiamento", "papiamento": "papiamento", "papiamentu": "papiamento", "pas": "pashto", "pashto": "pashto", "patas taroko": "taroko", "pcm": "nigerianpidgin", "per": "persian", "persian": "persian", "phn": "phoenician", "pho": "phoenician", "phoenician": "phoenician", "pie": "piedmontese", "piedmontese": "piedmontese", "pl": "polish", "pl-pl": "polish", "pms": "piedmontese", "pol": "polish", "polish": "polish", "polski": "polish", "polytonic greek": "greek", "polytonicgreek": "greek", "por": "portuguese", "portuguese": "portuguese", "portuguese-br": "brazilian", "portuguese-brazil": "brazilian", "portuguese-portugal": "portuguese", "portuguese-pt": "portuguese", "portugu\xEAs": "portuguese", "portugu\xEAs europeu": "portuguese", "prg": "prussian", "pru": "prussian", "prussian": "prussian", "pr\u016Bsiskan": "prussian", "ps": "pashto", "ps-ps": "pashto", "pt": "portuguese", "pt-br": "brazilian", "pt-pt": "portuguese", "pulaar": "fulah", "punjabi": "punjabi", "punjabi-arab": "punjabi-arabic", "punjabi-arabic": "punjabi-arabic", "punjabi-gurmukhi": "punjabi-gurmukhi", "punjabi-guru": "punjabi-gurmukhi", "qafar": "afar", "qu": "quechua", "qu-qu": "quechua", "que": "quechua", "quechua": "quechua", "raj": "rajasthani", "rajasthani": "rajasthani", "rikpa": "bafia", "rm": "romansh", "rm-rm": "romansh", "rmo": "sinteromani", "rn": "rundi", "rn-rn": "rundi", "ro": "romanian", "ro-md": "moldavian", "ro-ro": "romanian", "rof": "rombo", "romanian": "romanian", "romanian-md": "moldavian", "romanian-moldova": "moldavian", "romansh": "romansh", "rombo": "rombo", "rom\xE2n\u0103": "romanian", "ru": "russian", "ru-ru": "russian", "rukiga": "chiga", "rumantsch": "romansh", "run": "rundi", "runasimi": "quechua", "rundi": "rundi", "runyankore": "nyankole", "rus": "russian", "russian": "russian", "rw": "kinyarwanda", "rw-rw": "kinyarwanda", "rwa": "rwa", "rwk": "rwa", "sa": "sanskrit", "sa-beng": "sanskrit", "sa-deva": "sanskrit", "sa-gujr": "sanskrit", "sa-knda": "sanskrit", "sa-mlym": "sanskrit", "sa-sa": "sanskrit", "sa-telu": "sanskrit", "sah": "sakha", "saho": "saho", "sak": "sakha", "sakha": "sakha", "samaritan": "samaritan", "samburu": "samburu", "sami": "northernsami", "samin": "northernsami", "sango": "sango", "sangu": "sangu", "sanskrit": "sanskrit", "santali": "santali", "saq": "samburu", "saraiki": "saraiki", "sardinian": "sardinian", "sardu": "sardinian", "sat": "santali", "sbp": "sangu", "sc": "sardinian", "sc-sc": "sardinian", "schweizer hochdeutsch": "nswissgerman", "schwiizert\xFC\xFCtsch": "swissgerman", "scn": "sicilian", "sco": "scottishgaelic", "scottish gaelic": "scottishgaelic", "scottishgaelic": "scottishgaelic", "sd": "sindhi", "sd-deva": "sindhi-devanagari", "sd-khoj": "sindhi-khojki", "sd-sd": "sindhi", "sd-sind": "sindhi-khudawadi", "se": "northernsami", "se-se": "northernsami", "seh": "sena", "sen": "sena", "sena": "sena", "serbian": "serbian", "serbian-cyrillic": "serbian", "serbian-cyrillic-bosniaherzegovina": "serbian", "serbian-cyrillic-kosovo": "serbian", "serbian-cyrillic-montenegro": "serbian-cyrillic-montenegro", "serbian-cyrl": "serbian", "serbian-cyrl-ba": "serbian", "serbian-cyrl-me": "serbian-cyrillic-montenegro", "serbian-cyrl-xk": "serbian", "serbian-ijekavsk": "serbian", "serbian-latin": "serbian", "serbian-latin-bosniaherzegovina": "serbian", "serbian-latin-ijekavsk": "serbian", "serbian-latin-kosovo": "serbian", "serbian-latin-montenegro": "serbian-latin-montenegro", "serbian-latn": "serbian", "serbian-latn-ba": "serbian", "serbian-latn-ijekavsk": "serbian", "serbian-latn-me": "serbian-latin-montenegro", "serbian-latn-xk": "serbian", "serbian.ijekav": "serbian", "serbianc": "serbianc", "serbianc.ijekav": "serbian", "ses": "koyraborosenni", "sesotho": "southernsotho", "sesotho sa leboa": "northernsotho", "setswana": "tswana", "sg": "sango", "sg-sg": "sango", "sha": "shambala", "shambala": "shambala", "shi": "tachelhit", "shi-latn": "tachelhit-latin", "shi-tfng": "tachelhit-tifinagh", "sho": "shona", "shona": "shona", "shqip": "albanian", "shw\xF3\u014B\xF2 ngiemb\u0254\u0254n": "ngiemboon", "si": "sinhala", "si-si": "sinhala", "sichuan yi": "sichuanyi", "sichuanyi": "sichuanyi", "sicilian": "sicilian", "sicilianu": "sicilian", "sil": "silesian", "silesian": "silesian", "simplified chinese": "chinese-simplified", "sindhi": "sindhi", "sindhi-deva": "sindhi-devanagari", "sindhi-devanagari": "sindhi-devanagari", "sindhi-khoj": "sindhi-khojki", "sindhi-khojki": "sindhi-khojki", "sindhi-khudawadi": "sindhi-khudawadi", "sindhi-sind": "sindhi-khudawadi", "sinhala": "sinhala", "sinte romani": "sinteromani", "sinteromani": "sinteromani", "sintitikes": "sinteromani", "siswati": "swati", "sk": "slovak", "sk-sk": "slovak", "skr": "saraiki", "sl": "slovene", "sl-sl": "slovene", "slovak": "slovak", "slovene": "slovene", "slovenian": "slovene", "sloven\u010Dina": "slovak", "sloven\u0161\u010Dina": "slovene", "smn": "inarisami", "smp": "samaritan", "sn": "shona", "sn-sn": "shona", "so": "somali", "so-so": "somali", "sog": "soga", "soga": "soga", "som": "somali", "somali": "somali", "soomaali": "somali", "sor": "sorani", "sorani": "sorani", "south ndebele": "southndebele", "southern altai": "southernaltai", "southern sotho": "southernsotho", "southernaltai": "southernaltai", "southernsotho": "southernsotho", "southndebele": "southndebele", "spa": "spanish", "spanish": "spanish", "spanish-mexico": "mexican", "spanish-mx": "mexican", "sq": "albanian", "sq-sq": "albanian", "sr": "serbianc", "sr-cyrl": "serbian", "sr-cyrl-ba": "serbian", "sr-cyrl-me": "serbian-cyrillic-montenegro", "sr-cyrl-xk": "serbian", "sr-ijekavsk": "serbian", "sr-latn": "serbian", "sr-latn-ba": "serbian", "sr-latn-ijekavsk": "serbian", "sr-latn-me": "serbian-latin-montenegro", "sr-latn-xk": "serbian", "sr-sr": "serbianc", "srpski": "serbian", "ss": "swati", "ss-ss": "swati", "ssy": "saho", "st": "southernsotho", "st-st": "southernsotho", "sta": "standardmoroccantamazight", "standard moroccan tamazight": "standardmoroccantamazight", "standardmoroccantamazight": "standardmoroccantamazight", "su": "sundanese", "su-su": "sundanese", "sun": "sundanese", "sundanese": "sundanese", "suomi": "finnish", "sv": "swedish", "sv-sv": "swedish", "svenska": "swedish", "sw": "swahili", "sw-sw": "swahili", "swahili": "swahili", "swati": "swati", "swe": "swedish", "swedish": "swedish", "swi": "swissgerman", "swiss french": "french-switzerland", "swiss german": "swissgerman", "swiss high german": "nswissgerman", "swissfrench": "french-switzerland", "swissgerman": "swissgerman", "swisshighgerman": "nswissgerman", "swisshighgerman-traditional": "german", "syr": "syriac", "syriac": "syriac", "szl": "silesian", "s\xE4ng\xF6": "sango", "ta": "tamil", "ta-ta": "tamil", "tachelhit": "tachelhit", "tachelhit-latin": "tachelhit-latin", "tachelhit-latn": "tachelhit-latin", "tachelhit-tfng": "tachelhit-tifinagh", "tachelhit-tifinagh": "tachelhit-tifinagh", "tai n\xFCa": "tainua", "tainua": "tainua", "taita": "taita", "taj": "tajik", "tajik": "tajik", "tam": "tamil", "tamazi\u0263t n la\u1E6Dla\u1E63": "centralatlastamazight", "tamil": "tamil", "tan": "tangut", "tangut": "tangut", "taqbaylit": "kabyle", "tar": "taroko", "taroko": "taroko", "tas": "tasawaq", "tasawaq": "tasawaq", "tasawaq senni": "tasawaq", "tashel\u1E25iyt": "tachelhit-latin", "tat": "tatar", "tatar": "tatar", "tdd": "tainua", "te": "telugu", "te-te": "telugu", "tel": "telugu", "telugu": "telugu", "teo": "teso", "tes": "teso", "teso": "teso", "tg": "tajik", "tg-tg": "tajik", "th": "thai", "th-th": "thai", "tha": "thai", "thai": "thai", "thok nath": "nuer", "ti": "tigrinya", "ti-ti": "tigrinya", "tib": "tibetan", "tibetan": "tibetan", "tig": "tigre", "tigre": "tigre", "tigrinya": "tigrinya", "ti\u1EBFng vi\u1EC7t": "vietnamese", "tk": "turkmen", "tk-tk": "turkmen", "tn": "tswana", "tn-tn": "tswana", "to": "tongan", "to-to": "tongan", "tok": "tokpisin", "tok pisin": "tokpisin", "tokpisin": "tokpisin", "ton": "tongan", "tongan": "tongan", "tpi": "tokpisin", "tr": "turkish", "tr-tr": "turkish", "traditional chinese": "chinese-traditional", "trv": "taroko", "ts": "tsonga", "ts-ts": "tsonga", "tshiluba": "lubakatanga", "tshiven\u1E13a": "venda", "tso": "tsonga", "tsonga": "tsonga", "tsw": "tswana", "tswana": "tswana", "tt": "tatar", "tt-tt": "tatar", "turkish": "turkish", "turkmen": "turkmen", "tw": "chinese-traditional", "twq": "tasawaq", "txg": "tangut", "tya": "tyap", "tyap": "tyap", "tzm": "centralatlastamazight", "t\xFCrkmen dili": "turkmen", "t\xFCrk\xE7e": "turkish", "ug": "uyghur", "ug-ug": "uyghur", "uk": "ukrainian", "uk-uk": "ukrainian", "ukenglish": "british", "ukr": "ukrainian", "ukrainian": "ukrainian", "upp": "uppersorbian", "upper sorbian": "uppersorbian", "uppersorbian": "uppersorbian", "ur": "urdu", "ur-ur": "urdu", "urd": "urdu", "urdu": "urdu", "usenglish": "american", "usorbian": "uppersorbian", "uyg": "uyghur", "uyghur": "uyghur", "uz": "uzbek", "uz-arab": "uzbek-arabic", "uz-cyrl": "uzbek-cyrillic", "uz-latn": "uzbek-latin", "uz-uz": "uzbek", "uzbek": "uzbek", "uzbek-arab": "uzbek-arabic", "uzbek-arabic": "uzbek-arabic", "uzbek-cyrillic": "uzbek-cyrillic", "uzbek-cyrl": "uzbek-cyrillic", "uzbek-latin": "uzbek-latin", "uzbek-latn": "uzbek-latin", "vai": "vai", "vai-latin": "vai-latin", "vai-latn": "vai-latin", "vai-vai": "vai-vai", "vai-vaii": "vai-vai", "ve": "venda", "ve-ve": "venda", "ven": "venda", "venda": "venda", "vi": "vietnamese", "vi-vi": "vietnamese", "vie": "vietnamese", "vietnam": "vietnamese", "vietnamese": "vietnamese", "vo": "volapuk", "vo-vo": "volapuk", "vol": "volapuk", "volapuk": "volapuk", "volap\xFCk": "volapuk", "vun": "vunjo", "vunjo": "vunjo", "wae": "walser", "wal": "wolaytta", "walser": "walser", "war": "waray", "waray": "waray", "wel": "welsh", "welsh": "welsh", "wes": "westernfrisian", "western frisian": "westernfrisian", "westernfrisian": "westernfrisian", "wo": "wolof", "wo-wo": "wolof", "wolaytta": "wolaytta", "wolof": "wolof", "xh": "xhosa", "xh-xh": "xhosa", "xho": "xhosa", "xhosa": "xhosa", "xitsonga": "tsonga", "xog": "soga", "yan": "yangben", "yangben": "yangben", "yav": "yangben", "yi": "yiddish", "yi-yi": "yiddish", "yid": "yiddish", "yiddish": "yiddish", "yo": "yoruba", "yo-yo": "yoruba", "yor": "yoruba", "yoruba": "yoruba", "yrl": "nheengatu", "yue": "cantonese", "zar": "zarma", "zarma": "zarma", "zarmaciine": "zarma", "zgh": "standardmoroccantamazight", "zh": "chinese", "zh-hans": "chinese-simplified", "zh-hans-hk": "chinese-simplified-hongkongsarchina", "zh-hans-mo": "chinese-simplified-macausarchina", "zh-hans-sg": "chinese-simplified-singapore", "zh-hant": "chinese-traditional", "zh-hant-hk": "chinese-traditional-hongkongsarchina", "zh-hant-mo": "chinese-traditional-macausarchina", "zh-tw": "chinese-traditional", "zh-zh": "chinese", "zu": "zulu", "zu-zu": "zulu", "zul": "zulu", "zulu": "zulu", "\xE8d\xE8 yor\xF9b\xE1": "yoruba", "\xEDslenska": "icelandic", "\xF6sterreichisches deutsch": "austrian", "\u010De\u0161tina": "czech", "\u015Bl\u014Dnski": "silesian", "\u0253\xE0s\xE0a": "basaa", "\u02BB\u014Dlelo hawai\u02BBi": "hawaiian", "\u03B1\u03C1\u03C7\u03B1\u03AF\u03B1 \u03B5\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC": "greek", "\u03B5\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC": "greek", "\u03EF\u2C99\u2C89\u2CA7\u2CA3\u2C89\u2C99\u2C9B\u0300\u2CAD\u2C8F\u2C99\u2C93": "coptic", "\u0430\u0437\u04D9\u0440\u0431\u0430\u0458\u04B9\u0430\u043D": "azerbaijani-cyrillic", "\u0430\u0525\u0441\u0448\u04D9\u0430": "abkhazian", "\u0431\u0430\u0448\u04A1\u043E\u0440\u0442 \u0442\u0435\u043B\u0435": "bashkir", "\u0431\u0435\u043B\u0430\u0440\u0443\u0441\u043A\u0430\u044F": "belarusian", "\u0431\u043E\u0441\u0430\u043D\u0441\u043A\u0438": "bosnian-cyrillic", "\u0431\u0443\u0440\u044F\u0430\u0434": "buriat", "\u0431\u044A\u043B\u0433\u0430\u0440\u0441\u043A\u0438": "bulgarian", "\u0433\u04CF\u0430\u043B\u0433\u04CF\u0430\u0439 \u043C\u043E\u0442\u0442": "ingush", "\u0438\u0440\u043E\u043D": "ossetic", "\u043A\u043E\u043C\u0438 \u043A\u044B\u0432": "komi", "\u043A\u044B\u0440\u0433\u044B\u0437\u0447\u0430": "kyrgyz", "\u043C\u0430\u043A\u0435\u0434\u043E\u043D\u0441\u043A\u0438": "macedonian", "\u043C\u043E\u043D\u0433\u043E\u043B": "mongolian", "\u043D\u043E\u0445\u0447\u0438\u0439\u043D": "chechen", "\u0440\u0443\u0441\u0441\u043A\u0438\u0439": "russian", "\u0441\u0430\u0445\u0430 \u0442\u044B\u043B\u0430": "sakha", "\u0441\u043B\u043E\u0432\u0463\u0301\u043D\u044C\u0441\u043A\u044A \u0469\uA641\uA651\u0301\u043A\u044A": "churchslavic-oldcyrillic", "\u0441\u0440\u043F\u0441\u043A\u0438": "serbianc", "\u0442\u0430\u0442\u0430\u0440": "tatar", "\u0442\u043E\u04B7\u0438\u043A\u04E3": "tajik", "\u0443\u043A\u0440\u0430\u0457\u043D\u0441\u044C\u043A\u0430": "ukrainian", "\u0446\u0440\u044C\u043A\u044A\u0432\u044C\u043D\u043E\u0441\u043B\u043E\u0432\u0463\u043D\u044C\u0441\u043A\u044A \u0469\u0437\u044B\u043A\u044A": "churchslavic", "\u0447\u04D1\u0432\u0430\u0448": "chuvash", "\u044D\u0440\u0437\u044F\u043D\u044C \u043A\u0435\u043B\u044C": "erzya", "\u045E\u0437\u0431\u0435\u043A\u0447\u0430": "uzbek-cyrillic", "\u049B\u0430\u0437\u0430\u049B \u0442\u0456\u043B\u0456": "kazakh", "\u0570\u0561\u0575\u0565\u0580\u0565\u0576": "armenian", "\u05D9\u05D9\u05B4\u05D3\u05D9\u05E9": "yiddish", "\u05E2\u05D1\u05E8\u05D9\u05EA": "hebrew", "\u0626\u06C7\u064A\u063A\u06C7\u0631\u0686\u06D5": "uyghur", "\u0627\u0631\u062F\u0648": "urdu", "\u0627\u0644\u0639\u0631\u0628\u064A\u0629": "arabic", "\u0627\u0648\u0632\u0628\u06CC\u06A9": "uzbek-arabic", "\u0628\u0644\u06C6\u0686\u06CC": "baluchi", "\u0633\u0631\u0627\u0626\u06CC\u06A9\u06CC": "saraiki", "\u0633\u0646\u068C\u064A": "sindhi", "\u0641\u0627\u0631\u0633\u06CC": "persian", "\u0644\u06CA\u0631\u06CC \u0634\u0648\u0645\u0627\u0644\u06CC": "northernluri", "\u0645\u0627\u0632\u0631\u0648\u0646\u06CC": "mazanderani", "\u0645\u0635\u0631\u0649": "egyptianarabic", "\u067E\u0646\u062C\u0627\u0628\u06CC": "punjabi-arabic", "\u067E\u069A\u062A\u0648": "pashto", "\u06A9\u0648\u0631\u062F\u06CC\u06CC \u0646\u0627\u0648\u06D5\u0646\u062F\u06CC": "sorani", "\u06A9\u0648\u0631\u0645\u0627\u0646\u062C\u06CC": "kurmanji", "\u06A9\u0672\u0634\u064F\u0631": "kashmiri", "\u0720\u072B\u0722\u0710 \u0723\u0718\u072A\u071D\u071D\u0710": "syriac", "\u078B\u07A8\u0788\u07AC\u0780\u07A8\u0784\u07A6\u0790\u07B0": "divehi", "\u07D2\u07DE\u07CF": "nko", "\u080F\u0801\u0813\u0809\u0815": "samaritan", "\u0853\u0840\u0848\u084D\u0840": "classicalmandaic", "\u0905\u0935\u0927\u0940": "awadhi", "\u0915\u094B\u0902\u0915\u0923\u0940": "konkani", "\u0921\u094B\u0917\u0930\u0940": "dogri", "\u0928\u0947\u092A\u093E\u0932\u0940": "nepali", "\u0928\u0947\u0935\u093E\u0903 \u092D\u093E\u092F\u094D": "newari", "\u092C\u0930\u2019": "bodo", "\u092D\u094B\u091C\u092A\u0941\u0930\u0940": "bhojpuri", "\u092E\u0930\u093E\u0920\u0940": "marathi", "\u092E\u0948\u0925\u093F\u0932\u0940": "maithili", "\u0930\u093E\u091C\u0938\u094D\u0925\u093E\u0928\u0940": "rajasthani", "\u0932\u093F\u092E\u094D\u092C\u0941 \u092D\u093E\u0937\u093E": "limbu", "\u0938\u0902\u0938\u094D\u0915\u0943\u0924": "sanskrit", "\u0938\u093F\u0928\u094D\u0927\u0940": "sindhi-devanagari", "\u0939\u0930\u093F\u092F\u093E\u0923\u0935\u0940": "haryanvi", "\u0939\u093F\u0928\u094D\u0926\u0940": "hindi", "\u0985\u09B8\u09AE\u09C0\u09AF\u09BC\u09BE": "assamese", "\u09AC\u09BE\u0982\u09B2\u09BE": "bangla", "\u09AE\u09C8\u09A4\u09C8\u09B2\u09CB\u09A8\u09CD": "manipuri", "\u0A2A\u0A70\u0A1C\u0A3E\u0A2C\u0A40": "punjabi", "\u0A97\u0AC1\u0A9C\u0AB0\u0ABE\u0AA4\u0AC0": "gujarati", "\u0B13\u0B21\u0B3C\u0B3F\u0B06": "odia", "\u0BA4\u0BAE\u0BBF\u0BB4\u0BCD": "tamil", "\u0C24\u0C46\u0C32\u0C41\u0C17\u0C41": "telugu", "\u0C95\u0CA8\u0CCD\u0CA8\u0CA1": "kannada", "\u0D2E\u0D32\u0D2F\u0D3E\u0D33\u0D02": "malayalam", "\u0DC3\u0DD2\u0D82\u0DC4\u0DBD": "sinhala", "\u0E44\u0E17\u0E22": "thai", "\u0EA5\u0EB2\u0EA7": "lao", "\u0F56\u0F7C\u0F51\u0F0B\u0F66\u0F90\u0F51\u0F0B": "tibetan", "\u0F62\u0FAB\u0F7C\u0F44\u0F0B\u0F41": "dzongkha", "\u1019\u103C\u1014\u103A\u1019\u102C": "burmese", "\u10E5\u10D0\u10E0\u10D7\u10E3\u10DA\u10D8": "georgian", "\u1265\u120A\u1295": "blin", "\u1275\u130D\u1228": "tigre", "\u1275\u130D\u122D\u129B": "tigrinya", "\u12A0\u121B\u122D\u129B": "amharic", "\u12C8\u120B\u12ED\u1273\u1271": "wolaytta", "\u130D\u12D5\u12DD\u129B": "geez", "\u1403\u14C4\u1483\u144E\u1450\u1466": "inuktitut", "\u1781\u17D2\u1798\u17C2\u179A": "khmer", "\u1915\u1920\u1930\u190C\u1922\u1931 \u1910\u1920\u1934": "limbu-limbu", "\u1956\u196D\u1970 \u1958\u196B\u1974": "tainua", "\u1985\u19C4\u19BA\u1991\u199F\u19B9\u19C9": "lu", "\u1A05\u1A14 \u1A06\u1A00\u1A14\u1A11": "makasar-buginese", "\u1BC2\u1BD6 \u1BC5\u1BD6\u1BC2\u1BF2 \u1BD6\u1BEC\u1BC5": "bataktoba", "\u1C1B\u1C29\u1C35\u1C1B\u1C27\u1C35\u1C36": "lepcha", "\u1C65\u1C5F\u1C71\u1C5B\u1C5F\u1C72\u1C64": "santali", "\u1F10\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC": "greek", "\u2C44\u2C3E\u2C41\u2C32\u2C51\u2C40\u2C50\u2C44\u2C3D\u2C4F \u2C57\u2C38\u2C4F\u2C3A\u2C3D\u2C4F": "churchslavic-glagolitic", "\u2D5C\u2D30\u2D4E\u2D30\u2D63\u2D49\u2D56\u2D5C": "standardmoroccantamazight", "\u2D5C\u2D30\u2D5B\u2D4D\u2D43\u2D49\u2D5C": "tachelhit", "\u4E2D\u6587": "chinese", "\u4E2D\u6587-\u4E2D\u6587": "chinese", "\u65E5\u672C\u8A9E": "japanese", "\u7B80\u4F53\u4E2D\u6587": "chinese-simplified", "\u7CB5\u8A9E": "cantonese", "\u7CB5\u8A9E-\u7CB5\u8A9E": "cantonese", "\u7E41\u9AD4\u4E2D\u6587": "chinese-traditional", "\uA188\uA320\uA259": "sichuanyi", "\uA559\uA524": "vai", "\uABB3\uAB83\uAB79": "cherokee", "\uD55C\uAD6D\uC5B4": "korean-han", "\u{10332}\u{1033F}\u{10344}\u{10339}\u{10343}\u{1033A}": "gothic", "\u{10840}\u{10853}\u{1084C}\u{10849}\u{10840}": "aramaic", "\u{10903}\u{10901}\u{10913}\u{10909}\u{1090C} \u{1090A}\u{1090D}\u{1090F}\u{1090D}\u{10909}\u{1090C}": "phoenician", "\u{10B0E}\u{10B1E}\u{10B00}\u{10B2F}\u{10B19}\u{10B00}\u{10B0E}\u{10B0E}\u{10B00}\u{10B10}\u{10B00}\u{10B09}\u{10B25}\u{10B00}": "avestan", "\u{1110C}\u{1110B}\u{11134}\u{1111F}\u{11133}\u{11126}": "chakma", "\u{1201D}\u{12157}\u{1207A}\u{12311}": "akkadian", "\u{1308B}\u{133FA}\u{13216} \u{1318E}\u{13153}\u{133CF}\u{13296}": "ancientegyptian", "\u{17F07}\u{177F2}": "tangut", "\u{17F07}\u{177F2}-\u{17F07}\u{177F2}": "tangut", "\u{1E100}\u{1E104}\u{1E130}\u{1E129}\u{1E10D}\u{1E11C}\u{1E130}": "hmongnjua" };
    }
  });

  // node_modules/xregexp/tools/output/scripts.js
  var require_scripts = __commonJS({
    "node_modules/xregexp/tools/output/scripts.js"(exports, module) {
      module.exports = [
        {
          "name": "Adlam",
          "astral": "\uD83A[\uDD00-\uDD4B\uDD50-\uDD59\uDD5E\uDD5F]"
        },
        {
          "name": "Ahom",
          "astral": "\uD805[\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF46]"
        },
        {
          "name": "Anatolian_Hieroglyphs",
          "astral": "\uD811[\uDC00-\uDE46]"
        },
        {
          "name": "Arabic",
          "bmp": "\u0600-\u0604\u0606-\u060B\u060D-\u061A\u061C-\u061E\u0620-\u063F\u0641-\u064A\u0656-\u066F\u0671-\u06DC\u06DE-\u06FF\u0750-\u077F\u0870-\u088E\u0890\u0891\u0898-\u08E1\u08E3-\u08FF\uFB50-\uFBC2\uFBD3-\uFD3D\uFD40-\uFD8F\uFD92-\uFDC7\uFDCF\uFDF0-\uFDFF\uFE70-\uFE74\uFE76-\uFEFC",
          "astral": "\uD803[\uDE60-\uDE7E]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB\uDEF0\uDEF1]"
        },
        {
          "name": "Armenian",
          "bmp": "\u0531-\u0556\u0559-\u058A\u058D-\u058F\uFB13-\uFB17"
        },
        {
          "name": "Avestan",
          "astral": "\uD802[\uDF00-\uDF35\uDF39-\uDF3F]"
        },
        {
          "name": "Balinese",
          "bmp": "\u1B00-\u1B4C\u1B50-\u1B7E"
        },
        {
          "name": "Bamum",
          "bmp": "\uA6A0-\uA6F7",
          "astral": "\uD81A[\uDC00-\uDE38]"
        },
        {
          "name": "Bassa_Vah",
          "astral": "\uD81A[\uDED0-\uDEED\uDEF0-\uDEF5]"
        },
        {
          "name": "Batak",
          "bmp": "\u1BC0-\u1BF3\u1BFC-\u1BFF"
        },
        {
          "name": "Bengali",
          "bmp": "\u0980-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FE"
        },
        {
          "name": "Bhaiksuki",
          "astral": "\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC45\uDC50-\uDC6C]"
        },
        {
          "name": "Bopomofo",
          "bmp": "\u02EA\u02EB\u3105-\u312F\u31A0-\u31BF"
        },
        {
          "name": "Brahmi",
          "astral": "\uD804[\uDC00-\uDC4D\uDC52-\uDC75\uDC7F]"
        },
        {
          "name": "Braille",
          "bmp": "\u2800-\u28FF"
        },
        {
          "name": "Buginese",
          "bmp": "\u1A00-\u1A1B\u1A1E\u1A1F"
        },
        {
          "name": "Buhid",
          "bmp": "\u1740-\u1753"
        },
        {
          "name": "Canadian_Aboriginal",
          "bmp": "\u1400-\u167F\u18B0-\u18F5",
          "astral": "\uD806[\uDEB0-\uDEBF]"
        },
        {
          "name": "Carian",
          "astral": "\uD800[\uDEA0-\uDED0]"
        },
        {
          "name": "Caucasian_Albanian",
          "astral": "\uD801[\uDD30-\uDD63\uDD6F]"
        },
        {
          "name": "Chakma",
          "astral": "\uD804[\uDD00-\uDD34\uDD36-\uDD47]"
        },
        {
          "name": "Cham",
          "bmp": "\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAA5F"
        },
        {
          "name": "Cherokee",
          "bmp": "\u13A0-\u13F5\u13F8-\u13FD\uAB70-\uABBF"
        },
        {
          "name": "Chorasmian",
          "astral": "\uD803[\uDFB0-\uDFCB]"
        },
        {
          "name": "Common",
          "bmp": "\0-@\\[-`\\{-\xA9\xAB-\xB9\xBB-\xBF\xD7\xF7\u02B9-\u02DF\u02E5-\u02E9\u02EC-\u02FF\u0374\u037E\u0385\u0387\u0605\u060C\u061B\u061F\u0640\u06DD\u08E2\u0964\u0965\u0E3F\u0FD5-\u0FD8\u10FB\u16EB-\u16ED\u1735\u1736\u1802\u1803\u1805\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u2000-\u200B\u200E-\u2064\u2066-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20C0\u2100-\u2125\u2127-\u2129\u212C-\u2131\u2133-\u214D\u214F-\u215F\u2189-\u218B\u2190-\u2426\u2440-\u244A\u2460-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2E00-\u2E5D\u2FF0-\u2FFB\u3000-\u3004\u3006\u3008-\u3020\u3030-\u3037\u303C-\u303F\u309B\u309C\u30A0\u30FB\u30FC\u3190-\u319F\u31C0-\u31E3\u3220-\u325F\u327F-\u32CF\u32FF\u3358-\u33FF\u4DC0-\u4DFF\uA700-\uA721\uA788-\uA78A\uA830-\uA839\uA92E\uA9CF\uAB5B\uAB6A\uAB6B\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFF70\uFF9E\uFF9F\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD",
          "astral": "\uD800[\uDD00-\uDD02\uDD07-\uDD33\uDD37-\uDD3F\uDD90-\uDD9C\uDDD0-\uDDFC\uDEE1-\uDEFB]|\uD82F[\uDCA0-\uDCA3]|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD66\uDD6A-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDEE0-\uDEF3\uDF00-\uDF56\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDFCB\uDFCE-\uDFFF]|\uD83B[\uDC71-\uDCB4\uDD01-\uDD3D]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD00-\uDDAD\uDDE6-\uDDFF\uDE01\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDD-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6\uDF00-\uDF92\uDF94-\uDFCA\uDFF0-\uDFF9]|\uDB40[\uDC01\uDC20-\uDC7F]"
        },
        {
          "name": "Coptic",
          "bmp": "\u03E2-\u03EF\u2C80-\u2CF3\u2CF9-\u2CFF"
        },
        {
          "name": "Cuneiform",
          "astral": "\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC70-\uDC74\uDC80-\uDD43]"
        },
        {
          "name": "Cypriot",
          "astral": "\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F]"
        },
        {
          "name": "Cypro_Minoan",
          "astral": "\uD80B[\uDF90-\uDFF2]"
        },
        {
          "name": "Cyrillic",
          "bmp": "\u0400-\u0484\u0487-\u052F\u1C80-\u1C88\u1D2B\u1D78\u2DE0-\u2DFF\uA640-\uA69F\uFE2E\uFE2F"
        },
        {
          "name": "Deseret",
          "astral": "\uD801[\uDC00-\uDC4F]"
        },
        {
          "name": "Devanagari",
          "bmp": "\u0900-\u0950\u0955-\u0963\u0966-\u097F\uA8E0-\uA8FF"
        },
        {
          "name": "Dives_Akuru",
          "astral": "\uD806[\uDD00-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD35\uDD37\uDD38\uDD3B-\uDD46\uDD50-\uDD59]"
        },
        {
          "name": "Dogra",
          "astral": "\uD806[\uDC00-\uDC3B]"
        },
        {
          "name": "Duployan",
          "astral": "\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9C-\uDC9F]"
        },
        {
          "name": "Egyptian_Hieroglyphs",
          "astral": "\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E\uDC30-\uDC38]"
        },
        {
          "name": "Elbasan",
          "astral": "\uD801[\uDD00-\uDD27]"
        },
        {
          "name": "Elymaic",
          "astral": "\uD803[\uDFE0-\uDFF6]"
        },
        {
          "name": "Ethiopic",
          "bmp": "\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E",
          "astral": "\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]"
        },
        {
          "name": "Georgian",
          "bmp": "\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u10FF\u1C90-\u1CBA\u1CBD-\u1CBF\u2D00-\u2D25\u2D27\u2D2D"
        },
        {
          "name": "Glagolitic",
          "bmp": "\u2C00-\u2C5F",
          "astral": "\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]"
        },
        {
          "name": "Gothic",
          "astral": "\uD800[\uDF30-\uDF4A]"
        },
        {
          "name": "Grantha",
          "astral": "\uD804[\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]"
        },
        {
          "name": "Greek",
          "bmp": "\u0370-\u0373\u0375-\u0377\u037A-\u037D\u037F\u0384\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u1D6A\u1DBF\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u2126\uAB65",
          "astral": "\uD800[\uDD40-\uDD8E\uDDA0]|\uD834[\uDE00-\uDE45]"
        },
        {
          "name": "Gujarati",
          "bmp": "\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9-\u0AFF"
        },
        {
          "name": "Gunjala_Gondi",
          "astral": "\uD807[\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9]"
        },
        {
          "name": "Gurmukhi",
          "bmp": "\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A76"
        },
        {
          "name": "Han",
          "bmp": "\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u3005\u3007\u3021-\u3029\u3038-\u303B\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFA6D\uFA70-\uFAD9",
          "astral": "\uD81B[\uDFE2\uDFE3\uDFF0\uDFF1]|[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
        },
        {
          "name": "Hangul",
          "bmp": "\u1100-\u11FF\u302E\u302F\u3131-\u318E\u3200-\u321E\u3260-\u327E\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC"
        },
        {
          "name": "Hanifi_Rohingya",
          "astral": "\uD803[\uDD00-\uDD27\uDD30-\uDD39]"
        },
        {
          "name": "Hanunoo",
          "bmp": "\u1720-\u1734"
        },
        {
          "name": "Hatran",
          "astral": "\uD802[\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDCFF]"
        },
        {
          "name": "Hebrew",
          "bmp": "\u0591-\u05C7\u05D0-\u05EA\u05EF-\u05F4\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFB4F"
        },
        {
          "name": "Hiragana",
          "bmp": "\u3041-\u3096\u309D-\u309F",
          "astral": "\uD82C[\uDC01-\uDD1F\uDD50-\uDD52]|\u{1F200}"
        },
        {
          "name": "Imperial_Aramaic",
          "astral": "\uD802[\uDC40-\uDC55\uDC57-\uDC5F]"
        },
        {
          "name": "Inherited",
          "bmp": "\u0300-\u036F\u0485\u0486\u064B-\u0655\u0670\u0951-\u0954\u1AB0-\u1ACE\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u200D\u20D0-\u20F0\u302A-\u302D\u3099\u309A\uFE00-\uFE0F\uFE20-\uFE2D",
          "astral": "\uD800[\uDDFD\uDEE0]|\u{1133B}|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD]|\uDB40[\uDD00-\uDDEF]"
        },
        {
          "name": "Inscriptional_Pahlavi",
          "astral": "\uD802[\uDF60-\uDF72\uDF78-\uDF7F]"
        },
        {
          "name": "Inscriptional_Parthian",
          "astral": "\uD802[\uDF40-\uDF55\uDF58-\uDF5F]"
        },
        {
          "name": "Javanese",
          "bmp": "\uA980-\uA9CD\uA9D0-\uA9D9\uA9DE\uA9DF"
        },
        {
          "name": "Kaithi",
          "astral": "\uD804[\uDC80-\uDCC2\uDCCD]"
        },
        {
          "name": "Kannada",
          "bmp": "\u0C80-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2"
        },
        {
          "name": "Katakana",
          "bmp": "\u30A1-\u30FA\u30FD-\u30FF\u31F0-\u31FF\u32D0-\u32FE\u3300-\u3357\uFF66-\uFF6F\uFF71-\uFF9D",
          "astral": "\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00\uDD20-\uDD22\uDD64-\uDD67]"
        },
        {
          "name": "Kayah_Li",
          "bmp": "\uA900-\uA92D\uA92F"
        },
        {
          "name": "Kharoshthi",
          "astral": "\uD802[\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F-\uDE48\uDE50-\uDE58]"
        },
        {
          "name": "Khitan_Small_Script",
          "astral": "\u{16FE4}|\uD822[\uDF00-\uDFFF]|\uD823[\uDC00-\uDCD5]"
        },
        {
          "name": "Khmer",
          "bmp": "\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u19E0-\u19FF"
        },
        {
          "name": "Khojki",
          "astral": "\uD804[\uDE00-\uDE11\uDE13-\uDE3E]"
        },
        {
          "name": "Khudawadi",
          "astral": "\uD804[\uDEB0-\uDEEA\uDEF0-\uDEF9]"
        },
        {
          "name": "Lao",
          "bmp": "\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF"
        },
        {
          "name": "Latin",
          "bmp": "A-Za-z\xAA\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02E0-\u02E4\u1D00-\u1D25\u1D2C-\u1D5C\u1D62-\u1D65\u1D6B-\u1D77\u1D79-\u1DBE\u1E00-\u1EFF\u2071\u207F\u2090-\u209C\u212A\u212B\u2132\u214E\u2160-\u2188\u2C60-\u2C7F\uA722-\uA787\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA7FF\uAB30-\uAB5A\uAB5C-\uAB64\uAB66-\uAB69\uFB00-\uFB06\uFF21-\uFF3A\uFF41-\uFF5A",
          "astral": "\uD801[\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD837[\uDF00-\uDF1E]"
        },
        {
          "name": "Lepcha",
          "bmp": "\u1C00-\u1C37\u1C3B-\u1C49\u1C4D-\u1C4F"
        },
        {
          "name": "Limbu",
          "bmp": "\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u194F"
        },
        {
          "name": "Linear_A",
          "astral": "\uD801[\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]"
        },
        {
          "name": "Linear_B",
          "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA]"
        },
        {
          "name": "Lisu",
          "bmp": "\uA4D0-\uA4FF",
          "astral": "\u{11FB0}"
        },
        {
          "name": "Lycian",
          "astral": "\uD800[\uDE80-\uDE9C]"
        },
        {
          "name": "Lydian",
          "astral": "\uD802[\uDD20-\uDD39\uDD3F]"
        },
        {
          "name": "Mahajani",
          "astral": "\uD804[\uDD50-\uDD76]"
        },
        {
          "name": "Makasar",
          "astral": "\uD807[\uDEE0-\uDEF8]"
        },
        {
          "name": "Malayalam",
          "bmp": "\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F"
        },
        {
          "name": "Mandaic",
          "bmp": "\u0840-\u085B\u085E"
        },
        {
          "name": "Manichaean",
          "astral": "\uD802[\uDEC0-\uDEE6\uDEEB-\uDEF6]"
        },
        {
          "name": "Marchen",
          "astral": "\uD807[\uDC70-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]"
        },
        {
          "name": "Masaram_Gondi",
          "astral": "\uD807[\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]"
        },
        {
          "name": "Medefaidrin",
          "astral": "\uD81B[\uDE40-\uDE9A]"
        },
        {
          "name": "Meetei_Mayek",
          "bmp": "\uAAE0-\uAAF6\uABC0-\uABED\uABF0-\uABF9"
        },
        {
          "name": "Mende_Kikakui",
          "astral": "\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6]"
        },
        {
          "name": "Meroitic_Cursive",
          "astral": "\uD802[\uDDA0-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDDFF]"
        },
        {
          "name": "Meroitic_Hieroglyphs",
          "astral": "\uD802[\uDD80-\uDD9F]"
        },
        {
          "name": "Miao",
          "astral": "\uD81B[\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F]"
        },
        {
          "name": "Modi",
          "astral": "\uD805[\uDE00-\uDE44\uDE50-\uDE59]"
        },
        {
          "name": "Mongolian",
          "bmp": "\u1800\u1801\u1804\u1806-\u1819\u1820-\u1878\u1880-\u18AA",
          "astral": "\uD805[\uDE60-\uDE6C]"
        },
        {
          "name": "Mro",
          "astral": "\uD81A[\uDE40-\uDE5E\uDE60-\uDE69\uDE6E\uDE6F]"
        },
        {
          "name": "Multani",
          "astral": "\uD804[\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA9]"
        },
        {
          "name": "Myanmar",
          "bmp": "\u1000-\u109F\uA9E0-\uA9FE\uAA60-\uAA7F"
        },
        {
          "name": "Nabataean",
          "astral": "\uD802[\uDC80-\uDC9E\uDCA7-\uDCAF]"
        },
        {
          "name": "Nandinagari",
          "astral": "\uD806[\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE4]"
        },
        {
          "name": "New_Tai_Lue",
          "bmp": "\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE\u19DF"
        },
        {
          "name": "Newa",
          "astral": "\uD805[\uDC00-\uDC5B\uDC5D-\uDC61]"
        },
        {
          "name": "Nko",
          "bmp": "\u07C0-\u07FA\u07FD-\u07FF"
        },
        {
          "name": "Nushu",
          "astral": "\u{16FE1}|\uD82C[\uDD70-\uDEFB]"
        },
        {
          "name": "Nyiakeng_Puachue_Hmong",
          "astral": "\uD838[\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDD4F]"
        },
        {
          "name": "Ogham",
          "bmp": "\u1680-\u169C"
        },
        {
          "name": "Ol_Chiki",
          "bmp": "\u1C50-\u1C7F"
        },
        {
          "name": "Old_Hungarian",
          "astral": "\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDCFF]"
        },
        {
          "name": "Old_Italic",
          "astral": "\uD800[\uDF00-\uDF23\uDF2D-\uDF2F]"
        },
        {
          "name": "Old_North_Arabian",
          "astral": "\uD802[\uDE80-\uDE9F]"
        },
        {
          "name": "Old_Permic",
          "astral": "\uD800[\uDF50-\uDF7A]"
        },
        {
          "name": "Old_Persian",
          "astral": "\uD800[\uDFA0-\uDFC3\uDFC8-\uDFD5]"
        },
        {
          "name": "Old_Sogdian",
          "astral": "\uD803[\uDF00-\uDF27]"
        },
        {
          "name": "Old_South_Arabian",
          "astral": "\uD802[\uDE60-\uDE7F]"
        },
        {
          "name": "Old_Turkic",
          "astral": "\uD803[\uDC00-\uDC48]"
        },
        {
          "name": "Old_Uyghur",
          "astral": "\uD803[\uDF70-\uDF89]"
        },
        {
          "name": "Oriya",
          "bmp": "\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77"
        },
        {
          "name": "Osage",
          "astral": "\uD801[\uDCB0-\uDCD3\uDCD8-\uDCFB]"
        },
        {
          "name": "Osmanya",
          "astral": "\uD801[\uDC80-\uDC9D\uDCA0-\uDCA9]"
        },
        {
          "name": "Pahawh_Hmong",
          "astral": "\uD81A[\uDF00-\uDF45\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]"
        },
        {
          "name": "Palmyrene",
          "astral": "\uD802[\uDC60-\uDC7F]"
        },
        {
          "name": "Pau_Cin_Hau",
          "astral": "\uD806[\uDEC0-\uDEF8]"
        },
        {
          "name": "Phags_Pa",
          "bmp": "\uA840-\uA877"
        },
        {
          "name": "Phoenician",
          "astral": "\uD802[\uDD00-\uDD1B\uDD1F]"
        },
        {
          "name": "Psalter_Pahlavi",
          "astral": "\uD802[\uDF80-\uDF91\uDF99-\uDF9C\uDFA9-\uDFAF]"
        },
        {
          "name": "Rejang",
          "bmp": "\uA930-\uA953\uA95F"
        },
        {
          "name": "Runic",
          "bmp": "\u16A0-\u16EA\u16EE-\u16F8"
        },
        {
          "name": "Samaritan",
          "bmp": "\u0800-\u082D\u0830-\u083E"
        },
        {
          "name": "Saurashtra",
          "bmp": "\uA880-\uA8C5\uA8CE-\uA8D9"
        },
        {
          "name": "Sharada",
          "astral": "\uD804[\uDD80-\uDDDF]"
        },
        {
          "name": "Shavian",
          "astral": "\uD801[\uDC50-\uDC7F]"
        },
        {
          "name": "Siddham",
          "astral": "\uD805[\uDD80-\uDDB5\uDDB8-\uDDDD]"
        },
        {
          "name": "SignWriting",
          "astral": "\uD836[\uDC00-\uDE8B\uDE9B-\uDE9F\uDEA1-\uDEAF]"
        },
        {
          "name": "Sinhala",
          "bmp": "\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4",
          "astral": "\uD804[\uDDE1-\uDDF4]"
        },
        {
          "name": "Sogdian",
          "astral": "\uD803[\uDF30-\uDF59]"
        },
        {
          "name": "Sora_Sompeng",
          "astral": "\uD804[\uDCD0-\uDCE8\uDCF0-\uDCF9]"
        },
        {
          "name": "Soyombo",
          "astral": "\uD806[\uDE50-\uDEA2]"
        },
        {
          "name": "Sundanese",
          "bmp": "\u1B80-\u1BBF\u1CC0-\u1CC7"
        },
        {
          "name": "Syloti_Nagri",
          "bmp": "\uA800-\uA82C"
        },
        {
          "name": "Syriac",
          "bmp": "\u0700-\u070D\u070F-\u074A\u074D-\u074F\u0860-\u086A"
        },
        {
          "name": "Tagalog",
          "bmp": "\u1700-\u1715\u171F"
        },
        {
          "name": "Tagbanwa",
          "bmp": "\u1760-\u176C\u176E-\u1770\u1772\u1773"
        },
        {
          "name": "Tai_Le",
          "bmp": "\u1950-\u196D\u1970-\u1974"
        },
        {
          "name": "Tai_Tham",
          "bmp": "\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD"
        },
        {
          "name": "Tai_Viet",
          "bmp": "\uAA80-\uAAC2\uAADB-\uAADF"
        },
        {
          "name": "Takri",
          "astral": "\uD805[\uDE80-\uDEB9\uDEC0-\uDEC9]"
        },
        {
          "name": "Tamil",
          "bmp": "\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA",
          "astral": "\uD807[\uDFC0-\uDFF1\uDFFF]"
        },
        {
          "name": "Tangsa",
          "astral": "\uD81A[\uDE70-\uDEBE\uDEC0-\uDEC9]"
        },
        {
          "name": "Tangut",
          "astral": "\u{16FE0}|[\uD81C-\uD820][\uDC00-\uDFFF]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEFF]|\uD823[\uDD00-\uDD08]"
        },
        {
          "name": "Telugu",
          "bmp": "\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C77-\u0C7F"
        },
        {
          "name": "Thaana",
          "bmp": "\u0780-\u07B1"
        },
        {
          "name": "Thai",
          "bmp": "\u0E01-\u0E3A\u0E40-\u0E5B"
        },
        {
          "name": "Tibetan",
          "bmp": "\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FD4\u0FD9\u0FDA"
        },
        {
          "name": "Tifinagh",
          "bmp": "\u2D30-\u2D67\u2D6F\u2D70\u2D7F"
        },
        {
          "name": "Tirhuta",
          "astral": "\uD805[\uDC80-\uDCC7\uDCD0-\uDCD9]"
        },
        {
          "name": "Toto",
          "astral": "\uD838[\uDE90-\uDEAE]"
        },
        {
          "name": "Ugaritic",
          "astral": "\uD800[\uDF80-\uDF9D\uDF9F]"
        },
        {
          "name": "Vai",
          "bmp": "\uA500-\uA62B"
        },
        {
          "name": "Vithkuqi",
          "astral": "\uD801[\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC]"
        },
        {
          "name": "Wancho",
          "astral": "\uD838[\uDEC0-\uDEF9\uDEFF]"
        },
        {
          "name": "Warang_Citi",
          "astral": "\uD806[\uDCA0-\uDCF2\uDCFF]"
        },
        {
          "name": "Yezidi",
          "astral": "\uD803[\uDE80-\uDEA9\uDEAB-\uDEAD\uDEB0\uDEB1]"
        },
        {
          "name": "Yi",
          "bmp": "\uA000-\uA48C\uA490-\uA4C6"
        },
        {
          "name": "Zanabazar_Square",
          "astral": "\uD806[\uDE00-\uDE47]"
        }
      ];
    }
  });

  // gen/items/extra-fields.json
  var require_extra_fields = __commonJS({
    "gen/items/extra-fields.json"(exports, module) {
      module.exports = { "DOI": { "csl": ["DOI"], "type": "text", "zotero": ["DOI"] }, "ISBN": { "csl": ["ISBN"], "type": "text", "zotero": ["ISBN"] }, "ISSN": { "csl": ["ISSN"], "type": "text", "zotero": ["ISSN"] }, "PMCID": { "csl": ["PMCID"], "type": "text" }, "PMID": { "csl": ["PMID"], "type": "text" }, "URL": { "csl": ["URL"], "type": "text" }, "access date": { "csl": ["accessed"], "type": "date", "zotero": ["accessDate"] }, "accessDate": { "type": "date", "zotero": ["accessDate"] }, "accessed": { "csl": ["accessed"], "type": "date", "zotero": ["accessDate"] }, "admin flag": { "csl": ["admin-flag"], "type": "text", "zotero": ["adminFlag"] }, "admin-flag": { "csl": ["admin-flag"], "type": "text" }, "adminFlag": { "type": "text", "zotero": ["adminFlag"] }, "adoption date": { "type": "date", "zotero": ["adoptionDate"] }, "adoptionDate": { "type": "date", "zotero": ["adoptionDate"] }, "album": { "type": "text", "zotero": ["publicationTitle"] }, "application number": { "type": "text", "zotero": ["applicationNumber"] }, "applicationNumber": { "type": "text", "zotero": ["applicationNumber"] }, "archive": { "csl": ["archive"], "type": "text", "zotero": ["archive"] }, "archive collection": { "csl": ["archive_collection"], "type": "text", "zotero": ["archiveCollection"] }, "archive id": { "csl": ["number"], "type": "text", "zotero": ["number"] }, "archive location": { "csl": ["archive_location"], "type": "text", "zotero": ["archiveLocation"] }, "archive place": { "csl": ["archive-place"], "type": "text" }, "archive-place": { "csl": ["archive-place"], "type": "text" }, "archiveCollection": { "type": "text", "zotero": ["archiveCollection"] }, "archiveID": { "type": "text", "zotero": ["number"] }, "archiveLocation": { "type": "text", "zotero": ["archiveLocation"] }, "archive_collection": { "csl": ["archive_collection"], "type": "text" }, "archive_location": { "csl": ["archive_location"], "type": "text" }, "artist": { "csl": ["author"], "type": "name", "zotero": ["artist"] }, "artwork medium": { "type": "text", "zotero": ["medium"] }, "artwork size": { "type": "text", "zotero": ["artworkSize"] }, "artworkMedium": { "type": "text", "zotero": ["medium"] }, "artworkSize": { "type": "text", "zotero": ["artworkSize"] }, "assembly number": { "type": "text", "zotero": ["assemblyNumber", "seriesNumber"] }, "assemblyNumber": { "type": "text", "zotero": ["assemblyNumber", "seriesNumber"] }, "assignee": { "type": "text", "zotero": ["assignee"] }, "attorney agent": { "csl": ["attorneyAgent"], "type": "name", "zotero": ["attorneyAgent"] }, "attorneyAgent": { "csl": ["attorneyAgent"], "type": "name", "zotero": ["attorneyAgent"] }, "audio file type": { "type": "text", "zotero": ["medium"] }, "audio recording format": { "type": "text", "zotero": ["medium"] }, "audioFileType": { "type": "text", "zotero": ["medium"] }, "audioRecordingFormat": { "type": "text", "zotero": ["medium"] }, "author": { "csl": ["author"], "type": "name", "zotero": ["author"] }, "authority": { "csl": ["authority"], "type": "text", "zotero": ["authority"] }, "bill number": { "csl": ["number"], "type": "text", "zotero": ["number"] }, "billNumber": { "type": "text", "zotero": ["number"] }, "blog title": { "type": "text", "zotero": ["publicationTitle"] }, "blogTitle": { "type": "text", "zotero": ["publicationTitle"] }, "book abbreviation": { "csl": ["container-title-short"], "type": "text", "zotero": ["journalAbbreviation"] }, "book author": { "csl": ["container-author"], "type": "name", "zotero": ["bookAuthor"] }, "book title": { "type": "text", "zotero": ["publicationTitle"] }, "bookAbbreviation": { "type": "text", "zotero": ["journalAbbreviation"] }, "bookAuthor": { "type": "name", "zotero": ["bookAuthor"] }, "bookTitle": { "type": "text", "zotero": ["publicationTitle"] }, "call number": { "csl": ["call-number"], "type": "text", "zotero": ["callNumber"] }, "call-number": { "csl": ["call-number"], "type": "text" }, "callNumber": { "type": "text", "zotero": ["callNumber"] }, "cartographer": { "csl": ["author"], "type": "name", "zotero": ["cartographer"] }, "case name": { "csl": ["title"], "type": "text", "zotero": ["title"] }, "caseName": { "type": "text", "zotero": ["title"] }, "cast member": { "csl": ["castMember"], "type": "name", "zotero": ["castMember"] }, "castMember": { "csl": ["castMember"], "type": "name", "zotero": ["castMember"] }, "chapter number": { "csl": ["chapter-number"], "type": "text", "zotero": ["session"] }, "chapter-number": { "csl": ["chapter-number"], "type": "text" }, "citation key": { "type": "text", "zotero": ["citationKey"] }, "citationKey": { "type": "text", "zotero": ["citationKey"] }, "code": { "type": "text", "zotero": ["code"] }, "code number": { "type": "text", "zotero": ["codeNumber"] }, "code pages": { "csl": ["page"], "type": "text", "zotero": ["pages"] }, "code volume": { "type": "text", "zotero": ["volume"] }, "codeNumber": { "type": "text", "zotero": ["codeNumber"] }, "codePages": { "type": "text", "zotero": ["pages"] }, "codeVolume": { "type": "text", "zotero": ["volume"] }, "collection editor": { "csl": ["collection-editor"], "type": "name", "zotero": ["seriesEditor"] }, "collection number": { "csl": ["collection-number"], "type": "text", "zotero": ["seriesNumber", "assemblyNumber", "regnalYear", "yearAsVolume"] }, "collection title": { "csl": ["collection-title"], "type": "text", "zotero": ["seriesTitle", "series", "parentTreaty"] }, "collection-editor": { "csl": ["collection-editor"], "type": "name" }, "collection-number": { "csl": ["collection-number"], "type": "text" }, "collection-title": { "csl": ["collection-title"], "type": "text" }, "commenter": { "csl": ["commenter"], "type": "name", "zotero": ["commenter"] }, "committee": { "csl": ["committee"], "type": "text", "zotero": ["committee"] }, "company": { "csl": ["publisher"], "type": "text", "zotero": ["publisher"] }, "composer": { "csl": ["composer"], "type": "name", "zotero": ["composer"] }, "conference date": { "type": "date", "zotero": ["conferenceDate"] }, "conference name": { "type": "text", "zotero": ["conferenceName"] }, "conferenceDate": { "type": "date", "zotero": ["conferenceDate"] }, "conferenceName": { "type": "text", "zotero": ["conferenceName"] }, "container author": { "csl": ["container-author"], "type": "name", "zotero": ["bookAuthor"] }, "container title": { "csl": ["container-title"], "type": "text", "zotero": ["publicationTitle", "reporter", "code"] }, "container title short": { "csl": ["container-title-short"], "type": "text", "zotero": ["journalAbbreviation"] }, "container-author": { "csl": ["container-author"], "type": "name" }, "container-title": { "csl": ["container-title"], "type": "text" }, "container-title-short": { "csl": ["container-title-short"], "type": "text" }, "contributor": { "csl": ["contributor"], "type": "name", "zotero": ["contributor"] }, "cosponsor": { "csl": ["cosponsor"], "type": "name", "zotero": ["cosponsor"] }, "counsel": { "csl": ["counsel"], "type": "name", "zotero": ["counsel"] }, "country": { "type": "text", "zotero": ["country"] }, "court": { "type": "text", "zotero": ["court", "authority"] }, "csl type": { "csl": ["csl-type"], "type": "text" }, "csl-type": { "csl": ["csl-type"], "type": "text" }, "date": { "csl": ["issued"], "type": "date", "zotero": ["date"] }, "date amended": { "type": "date", "zotero": ["dateAmended"] }, "date decided": { "csl": ["issued"], "type": "date", "zotero": ["date"] }, "date enacted": { "csl": ["issued"], "type": "date", "zotero": ["date"] }, "dateAmended": { "type": "date", "zotero": ["dateAmended"] }, "dateDecided": { "type": "date", "zotero": ["date"] }, "dateEnacted": { "type": "date", "zotero": ["date"] }, "dictionary title": { "type": "text", "zotero": ["publicationTitle"] }, "dictionaryTitle": { "type": "text", "zotero": ["publicationTitle"] }, "dimensions": { "csl": ["dimensions"], "type": "text", "zotero": ["artworkSize", "runningTime"] }, "director": { "csl": ["director"], "type": "name", "zotero": ["director"] }, "distributor": { "csl": ["publisher"], "type": "text", "zotero": ["publisher"] }, "division": { "csl": ["division"], "type": "text", "zotero": ["division"] }, "docket number": { "csl": ["number"], "type": "text", "zotero": ["number"] }, "docketNumber": { "type": "text", "zotero": ["number"] }, "document name": { "csl": ["document-name"], "type": "text", "zotero": ["documentName"] }, "document number": { "csl": ["document-number"], "type": "text", "zotero": ["documentNumber", "number"] }, "document-name": { "csl": ["document-name"], "type": "text" }, "document-number": { "csl": ["document-number"], "type": "text" }, "documentName": { "type": "text", "zotero": ["documentName"] }, "documentNumber": { "type": "text", "zotero": ["documentNumber", "number"] }, "doi": { "csl": ["DOI"], "type": "text", "zotero": ["DOI"] }, "edition": { "csl": ["edition"], "type": "text", "zotero": ["edition"] }, "editor": { "csl": ["editor"], "type": "name", "zotero": ["editor"] }, "editorial director": { "csl": ["editorial-director"], "type": "name" }, "editorial-director": { "csl": ["editorial-director"], "type": "name" }, "encyclopedia title": { "type": "text", "zotero": ["publicationTitle"] }, "encyclopediaTitle": { "type": "text", "zotero": ["publicationTitle"] }, "episode number": { "csl": ["number"], "type": "text", "zotero": ["number"] }, "episodeNumber": { "type": "text", "zotero": ["number"] }, "event": { "csl": ["event"], "type": "text", "zotero": ["resolutionLabel"] }, "event date": { "csl": ["event-date"], "type": "date", "zotero": ["dateAmended", "signingDate", "conferenceDate"] }, "event place": { "csl": ["event-place"], "type": "text" }, "event title": { "csl": ["event-title"], "type": "text" }, "event-date": { "csl": ["event-date"], "type": "date" }, "event-place": { "csl": ["event-place"], "type": "text" }, "event-title": { "csl": ["event-title"], "type": "text" }, "filing date": { "csl": ["submitted"], "type": "date", "zotero": ["filingDate"] }, "filingDate": { "type": "date", "zotero": ["filingDate"] }, "first page": { "csl": ["page"], "type": "text", "zotero": ["pages"] }, "firstPage": { "type": "text", "zotero": ["pages"] }, "format": { "type": "text", "zotero": ["medium"] }, "forum title": { "type": "text", "zotero": ["publicationTitle"] }, "forumTitle": { "type": "text", "zotero": ["publicationTitle"] }, "gazette flag": { "csl": ["gazette-flag"], "type": "text", "zotero": ["gazetteFlag"] }, "gazette-flag": { "csl": ["gazette-flag"], "type": "text" }, "gazetteFlag": { "type": "text", "zotero": ["gazetteFlag"] }, "genre": { "csl": ["genre"], "type": "text", "zotero": ["genre", "type"] }, "guest": { "csl": ["guest"], "type": "name", "zotero": ["guest"] }, "history": { "type": "text", "zotero": ["history"] }, "identifier": { "csl": ["number"], "type": "text", "zotero": ["number"] }, "illustrator": { "csl": ["illustrator"], "type": "name" }, "institution": { "csl": ["publisher"], "type": "text", "zotero": ["institution", "publisher"] }, "interview medium": { "type": "text", "zotero": ["medium"] }, "interviewMedium": { "type": "text", "zotero": ["medium"] }, "interviewee": { "csl": ["author"], "type": "name", "zotero": ["interviewee"] }, "interviewer": { "csl": ["interviewer"], "type": "name", "zotero": ["interviewer"] }, "inventor": { "csl": ["author"], "type": "name", "zotero": ["inventor"] }, "isbn": { "csl": ["ISBN"], "type": "text", "zotero": ["ISBN"] }, "issn": { "csl": ["ISSN"], "type": "text", "zotero": ["ISSN"] }, "issue": { "csl": ["issue"], "type": "text", "zotero": ["issue"] }, "issue date": { "csl": ["issued"], "type": "date", "zotero": ["date"] }, "issueDate": { "type": "date", "zotero": ["date"] }, "issued": { "csl": ["issued"], "type": "date", "zotero": ["date"] }, "issuing authority": { "type": "text", "zotero": ["issuingAuthority", "authority"] }, "issuingAuthority": { "type": "text", "zotero": ["issuingAuthority", "authority"] }, "journal abbreviation": { "csl": ["container-title-short"], "type": "text", "zotero": ["journalAbbreviation"] }, "journalAbbreviation": { "type": "text", "zotero": ["journalAbbreviation"] }, "jurisdiction": { "csl": ["jurisdiction"], "type": "text", "zotero": ["jurisdiction"] }, "label": { "csl": ["publisher"], "type": "text", "zotero": ["publisher"] }, "language": { "csl": ["language"], "type": "text", "zotero": ["language"] }, "legal status": { "csl": ["status"], "type": "text", "zotero": ["legalStatus", "status"] }, "legalStatus": { "type": "text", "zotero": ["legalStatus", "status"] }, "legislative body": { "type": "text", "zotero": ["legislativeBody", "authority"] }, "legislativeBody": { "type": "text", "zotero": ["legislativeBody", "authority"] }, "letter type": { "type": "text", "zotero": ["type"] }, "letterType": { "type": "text", "zotero": ["type"] }, "library catalog": { "csl": ["source"], "type": "text", "zotero": ["libraryCatalog"] }, "libraryCatalog": { "type": "text", "zotero": ["libraryCatalog"] }, "license": { "csl": ["license"], "type": "text", "zotero": ["rights"] }, "manuscript type": { "type": "text", "zotero": ["type"] }, "manuscriptType": { "type": "text", "zotero": ["type"] }, "map type": { "type": "text", "zotero": ["type"] }, "mapType": { "type": "text", "zotero": ["type"] }, "medium": { "csl": ["medium"], "type": "text", "zotero": ["medium"] }, "meeting name": { "type": "text", "zotero": ["meetingName"] }, "meeting number": { "type": "text", "zotero": ["meetingNumber"] }, "meetingName": { "type": "text", "zotero": ["meetingName"] }, "meetingNumber": { "type": "text", "zotero": ["meetingNumber"] }, "name of act": { "csl": ["title"], "type": "text", "zotero": ["title"] }, "nameOfAct": { "type": "text", "zotero": ["title"] }, "network": { "csl": ["publisher"], "type": "text", "zotero": ["publisher"] }, "news case date": { "type": "date", "zotero": ["newsCaseDate"] }, "newsCaseDate": { "type": "date", "zotero": ["newsCaseDate"] }, "num pages": { "csl": ["number-of-pages"], "type": "text", "zotero": ["numPages"] }, "numPages": { "type": "text", "zotero": ["numPages"] }, "number": { "csl": ["number"], "type": "text", "zotero": ["number"] }, "number of pages": { "csl": ["number-of-pages"], "type": "text", "zotero": ["numPages"] }, "number of volumes": { "csl": ["number-of-volumes"], "type": "text", "zotero": ["numberOfVolumes"] }, "number-of-pages": { "csl": ["number-of-pages"], "type": "text" }, "number-of-volumes": { "csl": ["number-of-volumes"], "type": "text" }, "numberOfVolumes": { "type": "text", "zotero": ["numberOfVolumes"] }, "opening date": { "csl": ["opening-date"], "type": "date", "zotero": ["openingDate"] }, "opening-date": { "csl": ["opening-date"], "type": "date" }, "openingDate": { "type": "date", "zotero": ["openingDate"] }, "opus": { "type": "text", "zotero": ["opus"] }, "organization": { "type": "text", "zotero": ["authority"] }, "original author": { "csl": ["original-author"], "type": "name" }, "original date": { "csl": ["original-date"], "type": "date", "zotero": ["originalDate"] }, "original publisher": { "csl": ["original-publisher"], "type": "text" }, "original publisher place": { "csl": ["original-publisher-place"], "type": "text" }, "original title": { "csl": ["original-title"], "type": "text" }, "original-author": { "csl": ["original-author"], "type": "name" }, "original-date": { "csl": ["original-date"], "type": "date" }, "original-publisher": { "csl": ["original-publisher"], "type": "text" }, "original-publisher-place": { "csl": ["original-publisher-place"], "type": "text" }, "original-title": { "csl": ["original-title"], "type": "text" }, "originalDate": { "type": "date", "zotero": ["originalDate"] }, "page": { "csl": ["page"], "type": "text", "zotero": ["pages"] }, "pages": { "csl": ["page"], "type": "text", "zotero": ["pages"] }, "parent treaty": { "type": "text", "zotero": ["parentTreaty"] }, "parentTreaty": { "type": "text", "zotero": ["parentTreaty"] }, "patent number": { "csl": ["number"], "type": "text", "zotero": ["number"] }, "patentNumber": { "type": "text", "zotero": ["number"] }, "performer": { "csl": ["performer"], "type": "name", "zotero": ["performer"] }, "place": { "csl": ["event-place", "publisher-place"], "type": "text", "zotero": ["place"] }, "pmcid": { "csl": ["PMCID"], "type": "text" }, "pmid": { "csl": ["PMID"], "type": "text" }, "podcaster": { "csl": ["author"], "type": "name", "zotero": ["podcaster"] }, "post type": { "type": "text", "zotero": ["type"] }, "postType": { "type": "text", "zotero": ["type"] }, "presentation type": { "type": "text", "zotero": ["type"] }, "presentationType": { "type": "text", "zotero": ["type"] }, "presenter": { "csl": ["author"], "type": "name", "zotero": ["presenter"] }, "priority date": { "type": "date", "zotero": ["priorityDate"] }, "priority numbers": { "type": "text", "zotero": ["priorityNumbers"] }, "priorityDate": { "type": "date", "zotero": ["priorityDate"] }, "priorityNumbers": { "type": "text", "zotero": ["priorityNumbers"] }, "proceedings title": { "type": "text", "zotero": ["publicationTitle"] }, "proceedingsTitle": { "type": "text", "zotero": ["publicationTitle"] }, "producer": { "csl": ["producer"], "type": "name", "zotero": ["producer"] }, "program title": { "type": "text", "zotero": ["publicationTitle"] }, "programTitle": { "type": "text", "zotero": ["publicationTitle"] }, "programmer": { "csl": ["author"], "type": "name", "zotero": ["programmer"] }, "programming language": { "type": "text", "zotero": ["programmingLanguage"] }, "programmingLanguage": { "type": "text", "zotero": ["programmingLanguage"] }, "public law number": { "csl": ["number"], "type": "text", "zotero": ["number"] }, "publicLawNumber": { "type": "text", "zotero": ["number"] }, "publication date": { "csl": ["publication-date"], "type": "date", "zotero": ["publicationDate"] }, "publication number": { "csl": ["publication-number"], "type": "text", "zotero": ["publicationNumber"] }, "publication title": { "type": "text", "zotero": ["publicationTitle"] }, "publication-date": { "csl": ["publication-date"], "type": "date" }, "publication-number": { "csl": ["publication-number"], "type": "text" }, "publicationDate": { "type": "date", "zotero": ["publicationDate"] }, "publicationNumber": { "type": "text", "zotero": ["publicationNumber"] }, "publicationTitle": { "type": "text", "zotero": ["publicationTitle"] }, "publisher": { "csl": ["publisher"], "type": "text", "zotero": ["publisher"] }, "publisher place": { "csl": ["publisher-place"], "type": "text" }, "publisher-place": { "csl": ["publisher-place"], "type": "text" }, "recipient": { "csl": ["recipient"], "type": "name", "zotero": ["recipient"] }, "references": { "csl": ["references"], "type": "text", "zotero": ["references"] }, "regnal year": { "type": "text", "zotero": ["regnalYear"] }, "regnalYear": { "type": "text", "zotero": ["regnalYear"] }, "regulation type": { "type": "text", "zotero": ["regulationType", "type"] }, "regulationType": { "type": "text", "zotero": ["regulationType", "type"] }, "regulatory body": { "type": "text", "zotero": ["regulatoryBody", "legislativeBody"] }, "regulatoryBody": { "type": "text", "zotero": ["regulatoryBody", "legislativeBody"] }, "reign": { "type": "text", "zotero": ["reign"] }, "release": { "csl": ["edition"], "type": "text", "zotero": ["edition"] }, "report number": { "csl": ["number"], "type": "text", "zotero": ["number"] }, "report type": { "type": "text", "zotero": ["type"] }, "reportNumber": { "type": "text", "zotero": ["number"] }, "reportType": { "type": "text", "zotero": ["type"] }, "reporter": { "type": "text", "zotero": ["reporter", "publicationTitle"] }, "reporter volume": { "type": "text", "zotero": ["volume"] }, "reporterVolume": { "type": "text", "zotero": ["volume"] }, "repository": { "csl": ["publisher"], "type": "text", "zotero": ["publisher"] }, "repository location": { "csl": ["event-place", "publisher-place"], "type": "text", "zotero": ["place"] }, "repositoryLocation": { "type": "text", "zotero": ["place"] }, "resolution label": { "type": "text", "zotero": ["resolutionLabel"] }, "resolutionLabel": { "type": "text", "zotero": ["resolutionLabel"] }, "reviewed author": { "csl": ["reviewed-author"], "type": "name", "zotero": ["reviewedAuthor"] }, "reviewed title": { "csl": ["reviewed-title"], "type": "text" }, "reviewed-author": { "csl": ["reviewed-author"], "type": "name" }, "reviewed-title": { "csl": ["reviewed-title"], "type": "text" }, "reviewedAuthor": { "type": "name", "zotero": ["reviewedAuthor"] }, "rights": { "csl": ["rights"], "type": "text", "zotero": ["rights"] }, "running time": { "type": "text", "zotero": ["runningTime"] }, "runningTime": { "type": "text", "zotero": ["runningTime"] }, "scale": { "csl": ["scale"], "type": "text", "zotero": ["scale"] }, "script writer": { "csl": ["script-writer"], "type": "name", "zotero": ["scriptwriter"] }, "script-writer": { "csl": ["script-writer"], "type": "name" }, "scriptwriter": { "csl": ["scriptwriter"], "type": "name", "zotero": ["scriptwriter"] }, "section": { "csl": ["section"], "type": "text", "zotero": ["section"] }, "series": { "type": "text", "zotero": ["series"] }, "series editor": { "csl": ["collection-editor"], "type": "name", "zotero": ["seriesEditor"] }, "series number": { "type": "text", "zotero": ["seriesNumber"] }, "series text": { "type": "text", "zotero": ["seriesText"] }, "series title": { "type": "text", "zotero": ["seriesTitle"] }, "seriesEditor": { "type": "name", "zotero": ["seriesEditor"] }, "seriesNumber": { "type": "text", "zotero": ["seriesNumber"] }, "seriesText": { "type": "text", "zotero": ["seriesText"] }, "seriesTitle": { "type": "text", "zotero": ["seriesTitle"] }, "session": { "csl": ["chapter-number"], "type": "text", "zotero": ["session"] }, "session type": { "type": "text", "zotero": ["sessionType", "type"] }, "sessionType": { "type": "text", "zotero": ["sessionType", "type"] }, "short title": { "csl": ["title-short"], "type": "text", "zotero": ["shortTitle"] }, "shortTitle": { "type": "text", "zotero": ["shortTitle"] }, "signing date": { "type": "date", "zotero": ["signingDate"] }, "signingDate": { "type": "date", "zotero": ["signingDate"] }, "source": { "csl": ["source"], "type": "text", "zotero": ["libraryCatalog"] }, "sponsor": { "csl": ["author"], "type": "name", "zotero": ["sponsor"] }, "status": { "csl": ["status"], "type": "text", "zotero": ["status"] }, "studio": { "csl": ["publisher"], "type": "text", "zotero": ["publisher"] }, "subject": { "csl": ["title"], "type": "text", "zotero": ["title"] }, "submitted": { "csl": ["submitted"], "type": "date", "zotero": ["filingDate"] }, "supplement": { "csl": ["supplement"], "type": "text", "zotero": ["supplementName"] }, "supplement name": { "csl": ["supplement"], "type": "text", "zotero": ["supplementName"] }, "supplementName": { "type": "text", "zotero": ["supplementName"] }, "system": { "type": "text", "zotero": ["system"] }, "testimony by": { "csl": ["testimonyBy"], "type": "name", "zotero": ["testimonyBy"] }, "testimonyBy": { "csl": ["testimonyBy"], "type": "name", "zotero": ["testimonyBy"] }, "thesis type": { "type": "text", "zotero": ["type"] }, "thesisType": { "type": "text", "zotero": ["type"] }, "title": { "csl": ["title"], "type": "text", "zotero": ["title"] }, "title short": { "csl": ["title-short"], "type": "text", "zotero": ["shortTitle"] }, "title-short": { "csl": ["title-short"], "type": "text" }, "translator": { "csl": ["translator"], "type": "name", "zotero": ["translator"] }, "treaty number": { "csl": ["number"], "type": "text", "zotero": ["number"] }, "treatyNumber": { "type": "text", "zotero": ["number"] }, "type": { "type": "text", "zotero": ["type"] }, "university": { "csl": ["publisher"], "type": "text", "zotero": ["publisher"] }, "url": { "csl": ["URL"], "type": "text", "zotero": ["url"] }, "version": { "csl": ["version"], "type": "text", "zotero": ["versionNumber"] }, "version number": { "csl": ["version"], "type": "text", "zotero": ["versionNumber"] }, "versionNumber": { "type": "text", "zotero": ["versionNumber"] }, "video recording format": { "type": "text", "zotero": ["medium"] }, "videoRecordingFormat": { "type": "text", "zotero": ["medium"] }, "volume": { "csl": ["volume"], "type": "text", "zotero": ["volume"] }, "volume title": { "csl": ["volume-title"], "type": "text", "zotero": ["volumeTitle"] }, "volume-title": { "csl": ["volume-title"], "type": "text" }, "volumeTitle": { "type": "text", "zotero": ["volumeTitle"] }, "website title": { "type": "text", "zotero": ["publicationTitle"] }, "website type": { "type": "text", "zotero": ["type"] }, "websiteTitle": { "type": "text", "zotero": ["publicationTitle"] }, "websiteType": { "type": "text", "zotero": ["type"] }, "words by": { "csl": ["wordsBy"], "type": "name", "zotero": ["wordsBy"] }, "wordsBy": { "csl": ["wordsBy"], "type": "name", "zotero": ["wordsBy"] }, "year as volume": { "type": "text", "zotero": ["yearAsVolume"] }, "yearAsVolume": { "type": "text", "zotero": ["yearAsVolume"] } };
    }
  });

  // translators/Collected notes.ts
  var Collected_notes_exports = {};
  __export(Collected_notes_exports, {
    doExport: () => doExport
  });

  // content/client.ts
  var worker = typeof location !== "undefined" && location.search;
  var is7 = worker ? new URLSearchParams(location.search).get("is7") === "true" : Zotero.platformMajorVersion >= 102;
  function clientname() {
    var _a2;
    if (typeof location !== "undefined" && location.search) return new URLSearchParams(location.search).get("clientName");
    if (Zotero.clientName) return Zotero.clientName;
    if ((_a2 = Zotero.BetterBibTeX) == null ? void 0 : _a2.clientName) return Zotero.BetterBibTeX.clientName;
    throw new Error("Unable to detect clientName");
  }
  var platform = {
    name: "",
    windows: false,
    mac: false,
    linux: false
  };
  if (worker) {
    platform.name = new URLSearchParams(location.search).get("platform");
    platform.windows = platform.name === "win";
    platform.mac = platform.name === "mac";
    platform.linux = platform.name === "lin";
  } else {
    platform.name = Zotero.isWin ? "win" : Zotero.isMac ? "mac" : Zotero.isLinux ? "lin" : "unk";
    platform.windows = Zotero.isWin;
    platform.mac = Zotero.isMac;
    platform.linux = Zotero.isLinux;
  }
  var clientName = clientname();
  var client = clientName.toLowerCase().replace("-", "");

  // gen/osfile.js
  var OS2 = {
    Constants: {
      Path: {
        get homeDir() {
          return FileUtils.getDir("Home", []).path;
        },
        get libDir() {
          return FileUtils.getDir("GreBinD", []).path;
        },
        get profileDir() {
          return FileUtils.getDir("ProfD", []).path;
        },
        get tmpDir() {
          return FileUtils.getDir("TmpD", []).path;
        }
      }
    },
    File: {
      DirectoryIterator: function(path) {
        var initialized = false;
        var paths = [];
        async function init() {
          paths.push(...await IOUtils.getChildren(path));
          initialized = true;
        }
        async function getEntry(path2) {
          var info = await IOUtils.stat(path2);
          return {
            name: PathUtils.filename(path2),
            path: path2,
            isDir: info.type == "directory"
          };
        }
        this.nextBatch = async function(num) {
          if (!initialized) {
            await init();
          }
          var entries = [];
          while (paths.length && num > 0) {
            entries.push(await getEntry(paths.shift()));
            num--;
          }
          return entries;
        };
        this.forEach = async function(func) {
          if (!initialized) {
            await init();
          }
          var i = 0;
          while (paths.length) {
            let entry = await getEntry(paths.shift());
            await func(entry, i++, this);
          }
        };
        this.close = function() {
        };
      },
      Error: function(msg) {
        this.message = msg;
        this.stack = new Error().stack;
      },
      copy: wrapWrite(async function(src, dest) {
        return IOUtils.copy(src, dest);
      }),
      exists: async function(path) {
        try {
          return await IOUtils.exists(path);
        } catch (e) {
          if (e.message.includes("NS_ERROR_FILE_UNRECOGNIZED_PATH")) {
            dump(e.message + "\n\n" + e.stack + "\n\n");
            Components.utils.reportError(e);
            return false;
          }
        }
      },
      makeDir: wrapWrite(async function(path, options2 = {}) {
        try {
          return await IOUtils.makeDirectory(
            path,
            {
              ignoreExisting: options2.ignoreExisting !== false,
              createAncestors: !!options2.from,
              permissions: options2.unixMode
            }
          );
        } catch (e) {
          if (e.name == "InvalidAccessError") {
            if (/Could not create directory because the target file(.+) exists and is not a directory/.test(e.message)) {
              let osFileError = new OS2.File.Error(e.message);
              osFileError.becauseExists = true;
              throw osFileError;
            }
          }
        }
      }),
      move: wrapWrite(async function(src, dest, options2 = {}) {
        if (options2.noCopy) {
          throw new Error("noCopy is no longer supported");
        }
        var destFileInfo = null;
        try {
          destFileInfo = await IOUtils.stat(dest);
        } catch (e) {
          if (e.name != "NotFoundError") {
            throw e;
          }
        }
        if (destFileInfo) {
          if (destFileInfo.type == "directory") {
            throw new Error("OS.File.move() destination cannot be a directory -- use IOUtils.move()");
          }
          if (options2.noOverwrite) {
            let e = new OS2.File.Error();
            e.becauseExists = true;
            throw e;
          }
        }
        return IOUtils.move(src, dest, options2);
      }),
      read: async function(path, options2 = {}) {
        if (options2.encoding) {
          if (!/^utf\-?8$/i.test(options2.encoding)) {
            throw new Error("Can only read UTF-8");
          }
          return IOUtils.readUTF8(path);
        }
        return IOUtils.read(
          path,
          {
            maxBytes: options2.bytes
          }
        );
      },
      remove: async function(path, options2 = {}) {
        return IOUtils.remove(path, options2);
      },
      removeDir: async function(path, options2 = {}) {
        return IOUtils.remove(
          path,
          {
            recursive: true,
            // OS.File.removeDir defaulted to ignoreAbsent: true
            ignoreAbsent: options2.ignoreAbsent !== false
          }
        );
      },
      removeEmptyDir: async function(path) {
        return IOUtils.remove(path);
      },
      setDates: async function(path, atime, mtime) {
        if (atime) {
          await IOUtils.setAccessTime(path, atime.valueOf());
        }
        return await IOUtils.setModificationTime(path, mtime ? mtime.valueOf() : void 0);
      },
      setPermissions: async function(path, { unixMode, winAttributes } = {}) {
        await IOUtils.setPermissions(path, unixMode);
        if (winAttributes && Zotero.isWin) {
          let { readOnly, hidden, system } = winAttributes;
          await IOUtils.setWindowsAttributes(path, { readOnly, hidden, system });
        }
      },
      stat: async function stat(path) {
        var info;
        try {
          info = await IOUtils.stat(path);
        } catch (e) {
          if (e.name == "NotFoundError") {
            let osFileError = new this.Error("File not found");
            osFileError.becauseNoSuchFile = true;
            throw osFileError;
          }
          throw e;
        }
        return {
          isDir: info.type == "directory",
          isSymLink: true,
          // Supposedly was broken in Firefox
          size: info.size,
          lastAccessDate: new Date(info.lastAccessed),
          lastModificationDate: new Date(info.lastModified)
        };
      },
      unixSymLink: async function(pathTarget, pathCreate) {
        if (await IOUtils.exists(pathCreate)) {
          let osFileError = new this.Error(pathCreate + " already exists");
          osFileError.becauseExists = true;
          throw osFileError;
        }
        const { ctypes } = ChromeUtils.importESModule(
          "resource://gre/modules/ctypes.sys.mjs"
        );
        try {
          if (Services.appinfo.OS === "Darwin") {
            const libc = ctypes.open(
              Services.appinfo.OS === "Darwin" ? "libSystem.B.dylib" : "libc.so"
            );
            const symlink = libc.declare(
              "symlink",
              ctypes.default_abi,
              ctypes.int,
              // return value
              ctypes.char.ptr,
              // target
              ctypes.char.ptr
              //linkpath
            );
            if (symlink(pathTarget, pathCreate)) {
              throw new Error("Failed to create symlink at " + pathCreate);
            }
          } else {
            let ln = Cc["@mozilla.org/file/local;1"].createInstance(Ci.nsIFile);
            ln.initWithPath("/bin/ln");
            let process = Cc["@mozilla.org/process/util;1"].createInstance(Ci.nsIProcess);
            process.init(ln);
            let args = ["-s", pathTarget, pathCreate];
            process.run(true, args, args.length);
          }
        } catch (e) {
          dump(e.message + "\n\n");
          throw new Error("Failed to create symlink at " + pathCreate);
        }
      },
      writeAtomic: async function(path, bytes, options2 = {}) {
        if (options2.backupTo) {
          options2.backupFile = options2.backupTo;
        }
        if (options2.noOverwrite) {
          options2.mode = "create";
        }
        if (options2.encoding == "utf-8") {
          return IOUtils.writeUTF8(path, bytes, options2);
        }
        return IOUtils.write(path, bytes, options2);
      }
    },
    Path: {
      basename: function(path) {
        return PathUtils.filename(path);
      },
      dirname: function(path) {
        return PathUtils.parent(path);
      },
      fromFileURI: function(uri) {
        let url = new URL(uri);
        if (url.protocol != "file:") {
          throw new Error("fromFileURI expects a file URI");
        }
        let path = this.normalize(decodeURIComponent(url.pathname));
        return path;
      },
      join: function(path, ...args) {
        var platformSlash = Services.appinfo.OS == "WINNT" ? "\\" : "/";
        try {
          if (args.length == 0) {
            return path;
          }
          if (args.length == 1 && args[0].includes(platformSlash)) {
            return PathUtils.joinRelative(path, ...args);
          }
          return PathUtils.join(path, ...args);
        } catch (e) {
          if (e.message.includes("NS_ERROR_FILE_UNRECOGNIZED_PATH")) {
            Cu.reportError("WARNING: " + e.message + " -- update for IOUtils");
            return [path, ...args].join(platformSlash);
          }
          throw e;
        }
      },
      // From Firefox 102
      normalize: function(path) {
        let stack = [];
        let absolute;
        if (path.length >= 0 && path[0] == "/") {
          absolute = true;
        } else {
          absolute = false;
        }
        path.split("/").forEach(function(v) {
          switch (v) {
            case "":
            case ".":
              break;
            case "..":
              if (!stack.length) {
                if (absolute) {
                  throw new Error("Path is ill-formed: attempting to go past root");
                } else {
                  stack.push("..");
                }
              } else if (stack[stack.length - 1] == "..") {
                stack.push("..");
              } else {
                stack.pop();
              }
              break;
            default:
              stack.push(v);
          }
        });
        let string = stack.join("/");
        return absolute ? "/" + string : string;
      },
      split: function(path) {
        if (Services.appinfo.OS == "WINNT") {
          let index = path.indexOf(":");
          let absolute = path.length > index + 1 && path[index + 1] == "\\";
          return {
            absolute,
            winDrive: winGetDrive(path),
            components: path.split("\\")
          };
        }
        return {
          absolute: path.length && path[0] == "/",
          components: path.split("/")
        };
      },
      toFileURI: function(path) {
        return PathUtils.toFileURI(path);
      }
    }
  };
  var winGetDrive = function(path) {
    if (path == null) {
      throw new TypeError("path is invalid");
    }
    if (path.startsWith("\\\\")) {
      if (path.length == 2) {
        return null;
      }
      let index2 = path.indexOf("\\", 2);
      if (index2 == -1) {
        return path;
      }
      return path.slice(0, index2);
    }
    let index = path.indexOf(":");
    if (index <= 0) return null;
    return path.slice(0, index + 1);
  };
  function wrapWrite(func) {
    return async function() {
      try {
        return await func(...arguments);
      } catch (e) {
        if (DOMException.isInstance(e)) {
          if (e.name == "NoModificationAllowedError") {
            e.becauseExists = true;
          }
        }
        throw e;
      }
    };
  }

  // content/os.ts
  var Shim = is7 ? OS2 : void 0;
  if (Shim) {
    const Path = platform.windows ? { start: /.*\\/, end: /\\$/ } : { start: /.*\//, end: /\/$/ };
    Shim.Path.basename = (path) => path && Shim.Path.normalize(path).replace(Path.end, "").replace(Path.start, "");
  }

  // gen/preferences/meta.ts
  var defaults = {
    ascii: "",
    asciiBibLaTeX: false,
    asciiBibTeX: true,
    autoAbbrev: false,
    autoAbbrevStyle: "",
    autoExport: "immediate",
    autoExportDelay: 5,
    autoExportIdleWait: 10,
    autoExportPathReplaceDiacritics: false,
    autoExportPathReplaceDirSep: "-",
    autoExportPathReplaceSpace: " ",
    automaticTags: true,
    autoPinDelay: 0,
    auxImport: false,
    baseAttachmentPath: "",
    biblatexExtendedDateFormat: true,
    biblatexExtendedNameFormat: true,
    biblatexExtractEprint: true,
    bibtexEditionOrdinal: false,
    bibtexParticleNoOp: false,
    bibtexURL: "off",
    cache: true,
    cacheFlushInterval: 5,
    charmap: "",
    citeCommand: "cite",
    citekeyCaseInsensitive: true,
    citekeyFold: true,
    citekeyFormat: "auth.lower + shorttitle(3,3) + year",
    citekeyFormatEditing: "",
    citekeySearch: true,
    citekeyUnsafeChars: `\\"#%'(),={}~`,
    csquotes: "",
    DOIandURL: "both",
    exportBibTeXStrings: "off",
    exportBraceProtection: true,
    exportTitleCase: true,
    extraMergeCitekeys: false,
    extraMergeCSL: false,
    extraMergeTeX: false,
    git: "config",
    import: true,
    importBibTeXStrings: true,
    importCaseProtection: "as-needed",
    importCitationKey: true,
    importDetectURLs: true,
    importExtra: true,
    importJabRefAbbreviations: true,
    importJabRefStrings: true,
    importNoteToExtra: "",
    importSentenceCase: "on+guess",
    importSentenceCaseQuoted: true,
    importUnknownTexCommand: "ignore",
    itemObserverDelay: 5,
    jabrefFormat: 0,
    jieba: false,
    keyConflictPolicy: "keep",
    keyScope: "library",
    kuroshiro: false,
    language: "langid",
    logEvents: true,
    mapMath: "",
    mapText: "",
    packages: "",
    parseParticles: true,
    patchDates: "dateadded=dateAdded, date-added=dateAdded, datemodified=dateModified, date-modified=dateModified",
    platform: "",
    postscript: "",
    postscriptOverride: "",
    preferencesOverride: "",
    qualityReport: false,
    quickCopyEta: "",
    quickCopyMode: "latex",
    quickCopyOrgMode: "zotero",
    quickCopyPandocBrackets: false,
    quickCopySelectLink: "zotero",
    rawImports: false,
    rawLaTag: "#LaTeX",
    relativeFilePaths: false,
    retainCache: false,
    scrubDatabase: false,
    separatorList: "and",
    separatorNames: "and",
    skipFields: "",
    skipWords: "a,ab,aboard,about,above,across,after,against,al,along,amid,among,an,and,anti,around,as,at,before,behind,below,beneath,beside,besides,between,beyond,but,by,d,da,das,de,del,dell,dello,dei,degli,della,dell,delle,dem,den,der,des,despite,die,do,down,du,during,ein,eine,einem,einen,einer,eines,el,en,et,except,for,from,gli,i,il,in,inside,into,is,l,la,las,le,les,like,lo,los,near,nor,of,off,on,onto,or,over,past,per,plus,round,save,since,so,some,sur,than,the,through,to,toward,towards,un,una,unas,under,underneath,une,unlike,uno,unos,until,up,upon,versus,via,von,while,with,within,without,yet,zu,zum",
    startupProgress: "popup",
    strings: "",
    stringsOverride: "",
    testing: false,
    verbatimFields: "url,doi,file,pdf,ids,eprint,/^verb[a-z]$/,groups,/^citeulike-linkout-[0-9]+$/, /^bdsk-url-[0-9]+$/, keywords",
    warnBulkModify: 10,
    warnTitleCased: false
  };
  var affectedBy = {
    "BetterBibTeX JSON": [],
    "Better BibLaTeX": [
      "ascii",
      "asciiBibLaTeX",
      "autoAbbrev",
      "autoAbbrevStyle",
      "automaticTags",
      "baseAttachmentPath",
      "biblatexExtendedDateFormat",
      "biblatexExtendedNameFormat",
      "biblatexExtractEprint",
      "cache",
      "charmap",
      "csquotes",
      "DOIandURL",
      "exportBibTeXStrings",
      "exportBraceProtection",
      "exportTitleCase",
      "jabrefFormat",
      "language",
      "mapMath",
      "mapText",
      "packages",
      "parseParticles",
      "postscript",
      "qualityReport",
      "rawLaTag",
      "relativeFilePaths",
      "separatorList",
      "separatorNames",
      "skipFields",
      "skipWords",
      "strings",
      "verbatimFields"
    ],
    "Better BibTeX": [
      "ascii",
      "asciiBibTeX",
      "autoAbbrev",
      "autoAbbrevStyle",
      "automaticTags",
      "baseAttachmentPath",
      "biblatexExtractEprint",
      "bibtexEditionOrdinal",
      "bibtexParticleNoOp",
      "bibtexURL",
      "cache",
      "charmap",
      "csquotes",
      "DOIandURL",
      "exportBibTeXStrings",
      "exportBraceProtection",
      "exportTitleCase",
      "jabrefFormat",
      "language",
      "mapMath",
      "mapText",
      "packages",
      "parseParticles",
      "postscript",
      "qualityReport",
      "rawLaTag",
      "relativeFilePaths",
      "separatorList",
      "separatorNames",
      "skipFields",
      "skipWords",
      "strings",
      "verbatimFields"
    ],
    "Better CSL JSON": [
      "autoAbbrev",
      "autoAbbrevStyle",
      "automaticTags",
      "baseAttachmentPath",
      "cache",
      "parseParticles",
      "postscript",
      "skipFields"
    ],
    "Better CSL YAML": [
      "autoAbbrev",
      "autoAbbrevStyle",
      "automaticTags",
      "baseAttachmentPath",
      "cache",
      "parseParticles",
      "postscript",
      "skipFields"
    ]
  };
  var options = {
    "autoExport": {
      "immediate": "On Change",
      "idle": "When Idle",
      "off": "Paused"
    },
    "bibtexURL": {
      "off": "no",
      "note": "in the 'note' field",
      "note-url-ish": "in the 'note' field, but assuming the 'url' package is not loaded",
      "url": "in the 'url' field",
      "url-ish": "in the 'url' field, but assuming the 'url' package is not loaded"
    },
    "DOIandURL": {
      "both": "both",
      "doi": "DOI",
      "url": "URL"
    },
    "exportBibTeXStrings": {
      "off": "No",
      "detect": "Assume single-word fields to be @string vars",
      "match": "Match against the @string declarations below",
      "match+reverse": "Match against the @string declarations and their values below"
    },
    "importCaseProtection": {
      "as-needed": "minimal",
      "on": "yes",
      "off": "no"
    },
    "importSentenceCase": {
      "on+guess": "yes, but try to exclude already-sentence-cased titles",
      "on": "yes",
      "off": "no (import titles as-is)"
    },
    "jabrefFormat": {
      "0": "no",
      "3": "for JabRef 3",
      "4": "for JabRef 4",
      "5": "for JabRef 5"
    },
    "keyConflictPolicy": {
      "change": "postfixed (causes key changes)",
      "keep": "kept (causes key duplicates)"
    },
    "keyScope": {
      "global": "across all libraries",
      "library": "within each library"
    },
    "language": {
      "langid": "langid",
      "language": "language",
      "both": "both"
    },
    "quickCopyMode": {
      "latex": "LaTeX citation",
      "citekeys": "Cite Keys",
      "eta": "Eta template",
      "gitbook": "GitBook",
      "orgRef": "org-ref citation",
      "orgRef3": "org-ref v3 citation",
      "orgmode": "Org-mode select link",
      "pandoc": "Pandoc citation",
      "roamCiteKey": "Roam Cite Key",
      "rtfScan": "RTF Scan marker",
      "selectlink": "Zotero select link",
      "jupyter": "Jupyter notebook",
      "jekyll": "Jekyll cite"
    },
    "quickCopyOrgMode": {
      "zotero": "using Zotero item key",
      "citationkey": "using Better BibTeX citation key"
    },
    "quickCopySelectLink": {
      "zotero": "using Zotero item key",
      "citationkey": "using Better BibTeX citation key"
    }
  };

  // content/escape.ts
  var import_utils_escape_regexp_string = __toESM(require_lib12());
  var entity = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function html(str) {
    return str.replace(/[<>&"']/g, (c) => entity[c] || `&#${c.charCodeAt(0)};`);
  }
  function regex(text) {
    return (0, import_utils_escape_regexp_string.default)(text);
  }

  // translators/lib/translator.ts
  var $OS = is7 ? Shim : OS;
  var PrefNames = new Set(Object.keys(defaults));
  var cacheDisabler = new class {
    get(target, property) {
      if (property === "collections") {
        target.$cacheable = false;
      }
      return target[property];
    }
    /*
    set(target, property, value): boolean {
      if (property === '$cacheable' && target.$cacheable && !value) log.debug('cache-rate: not for', target, (new Error).stack)
      target[property] = value
      return true
    }
    */
  }();
  var Items = class {
    constructor(items) {
      this.items = [];
      this.map = {};
      if (items) {
        this.items = items.map((item) => this.map[item.itemID] = this.map[item.itemKey] = new Proxy(item, cacheDisabler));
      } else {
        let item;
        while (item = Zotero.nextItem()) {
          this.items.push(this.map[item.itemID] = this.map[item.itemKey] = new Proxy(item, cacheDisabler));
        }
      }
      this.items.sort((a, b) => {
        const ka = [a.citationKey || a.itemType, a.dateModified || a.dateAdded, a.itemID].join("	");
        const kb = [b.citationKey || b.itemType, b.dateModified || b.dateAdded, b.itemID].join("	");
        return ka.localeCompare(kb, void 0, { sensitivity: "base" });
      });
    }
    erase() {
      this.items = [];
      this.map = {};
      this.current = null;
    }
    cacheable(cacheable) {
      for (const item of this.items) {
        item.$cacheable = cacheable;
      }
    }
    *[Symbol.iterator]() {
      for (const item of this.items) {
        yield item;
      }
    }
    get regular() {
      return this._regular();
    }
    *_regular() {
      for (const item of this.items) {
        switch (item.itemType) {
          case "annotation":
          case "note":
          case "attachment":
            break;
          default:
            yield this.current = item;
        }
      }
    }
  };
  var Collections = class {
    constructor(items, collections) {
      this.items = items;
      this.byKey = {};
      if (collections) {
        this.byKey = collections;
      } else if (Zotero.nextCollection) {
        let collection;
        while (collection = Zotero.nextCollection()) {
          this.registerCollection(collection, "");
        }
      }
    }
    erase() {
      this.byKey = {};
    }
    registerCollection(collection, parent) {
      const key = (collection.primary ? collection.primary : collection).key;
      if (this.byKey[key]) return;
      this.byKey[key] = {
        key,
        parent,
        name: collection.name,
        collections: [],
        items: []
      };
      for (const child of collection.descendents || collection.children) {
        switch (child.type) {
          case "collection":
            this.byKey[key].collections.push(child.key);
            this.registerCollection(child, key);
            break;
          case "item":
            this.byKey[key].items.push(child.id);
            break;
        }
      }
    }
    get collectionTree() {
      return Object.values(this.byKey).filter((coll) => !coll.parent).map((coll) => this.nestedCollection(coll));
    }
    nestedCollection(collection) {
      const nested = {
        key: collection.key,
        name: collection.name,
        items: collection.items.map((itemID) => this.items.map[itemID]).filter((item) => item),
        collections: collection.collections.map((key) => this.nestedCollection(this.byKey[key])).filter((coll) => coll)
      };
      for (const coll of nested.collections) {
        coll.parent = nested;
      }
      return nested;
    }
  };
  function collect() {
    const items = new Items();
    return { items, collections: new Collections(items) };
  }
  var Override = class {
    constructor(preferences) {
      this.preferences = preferences;
      this.orig = { ...this.preferences };
      this.exportPath = Zotero.getOption("exportPath");
      this.exportDir = Zotero.getOption("exportDir");
    }
    override(preference, extension) {
      var _a2;
      const override = this.orig[`${preference}Override`];
      if (!this.exportPath || !override) {
        return false;
      }
      const candidates = [
        $OS.Path.basename(this.exportPath).replace(/\.[^.]+$/, "") + extension,
        override
      ].map((filename) => $OS.Path.join(this.exportDir, filename));
      for (const candidate of candidates) {
        Zotero.debug(`better-bibtex: looking for override ${preference} in ${candidate}`);
        try {
          const content = Zotero.BetterBibTeX.getContents(candidate);
          if (content === null) {
            Zotero.debug(`better-bibtex: override ${candidate} not found`);
            continue;
          }
          let prefs;
          if (preference === "preferences") {
            prefs = (_a2 = JSON.parse(content).override) == null ? void 0 : _a2.preferences;
            if (!prefs) continue;
          } else {
            prefs = { [preference]: content };
          }
          for (const [pref, value] of Object.entries(prefs)) {
            if (!PrefNames.has(pref)) {
              Zotero.debug(`better-bibtex: unexpected preference override for ${pref}`);
            } else if (typeof value !== typeof defaults[pref]) {
              Zotero.debug(`better-bibtex: preference override for ${pref}: expected ${typeof defaults[pref]}, got ${typeof value}`);
            } else if (options[pref] && !options[pref][value]) {
              Zotero.debug(`better-bibtex: preference override for ${pref}: expected ${Object.keys(options[pref]).join(" / ")}, got ${value}`);
            } else {
              this.preferences[pref] = value;
            }
          }
          Zotero.debug(`better-bibtex: override ${candidate} loaded`);
          return true;
        } catch (err) {
          Zotero.debug(`better-bibtex: failed to load override ${candidate}: ${err}`);
        }
      }
      return false;
    }
  };
  var Translation = class {
    constructor(translator, mode) {
      this.translator = translator;
      this.mode = mode;
      this.export = {
        dir: void 0,
        path: void 0
      };
      this.collections = {};
      // keep because it is being used in postscripts
      this.output = {
        body: "",
        attachments: []
      };
      this.cacheable = true;
      this[translator.label.replace(/[^a-z]/ig, "")] = true;
      this.BetterTeX = this.BetterBibTeX || this.BetterBibLaTeX;
      this.BetterCSL = this.BetterCSLJSON || this.BetterCSLYAML;
      this.options = { ...translator.displayOptions || {} };
      this.platform = Zotero.getHiddenPref("better-bibtex.platform");
      this.isJurisM = client === "jurism";
      this.isZotero = !this.isJurisM;
      this.paths = {
        caseSensitive: this.platform !== "mac" && this.platform !== "win",
        sep: this.platform === "win" ? "\\" : "/"
      };
      try {
        if (Zotero.getOption("cache") === false) this.cacheable = false;
      } catch (err) {
      }
      for (const key in this.options) {
        this.options[key] = !!Zotero.getOption(key);
      }
      this.options.custom = Zotero.getOption("custom");
      this.preferences = Object.entries(defaults).reduce((acc, [pref, dflt]) => {
        var _a2;
        acc[pref] = (_a2 = Zotero.getHiddenPref(`better-bibtex.${pref}`)) != null ? _a2 : dflt;
        return acc;
      }, {});
      const override = new Override(this.preferences);
      if (override.override("preferences", ".json")) this.cacheable = false;
      if (override.override("postscript", ".js")) this.cacheable = false;
      if (override.override("strings", ".bib")) this.cacheable = false;
      try {
        this.charmap = JSON.parse(this.preferences.charmap);
      } catch (err) {
        this.charmap = {};
      }
      this.importToExtra = {};
      this.preferences.importNoteToExtra.toLowerCase().split(/\s*,\s*/).filter((field) => field).forEach((field) => {
        this.importToExtra[field.replace(/\s*=.*/, "")] = field.match(/\s*=\s*force$/) ? "force" : "plain";
      });
      this.skipFields = this.preferences.skipFields.toLowerCase().split(",").map((field) => this.typefield(field)).filter((s) => s);
      let m;
      if (this.skipFields.length) {
        this.skipField = new RegExp("^(" + this.skipFields.map((field) => {
          if (m = field.match(/^(csl|tex|bibtex|biblatex)[.]([-a-z]+)[.]([-a-z]+)$/)) {
            return `(${m[1] === "tex" ? "bib(la)?" : ""}[.]${m[2]}[.]${m[3]})`;
          }
          if (m = field.match(/^(tex|bibtex|biblatex)[.]([-a-z]+)$/)) {
            return `(${m[1] === "tex" ? "bib(la)?" : ""}[.][-a-z]+[.]${m[2]})`;
          }
          if (m = field.match(/^([-a-z]+)[.]([-a-z]+)$/)) {
            return `(${this.BetterTeX ? "bib(la)?tex" : "csl"}[.]${m[1]}[.]${m[2]})`;
          }
          if (m = field.match(/^[-a-z]+$/)) {
            return `(${this.BetterTeX ? "bib(la)?tex" : "csl"}[.][-a-z]+[.]${field})`;
          }
          return "";
        }).filter((field) => field).join("|") + ")$");
      }
      this.verbatimFields = this.preferences.verbatimFields.toLowerCase().split(",").map((field) => (m = field.trim().match(/^[/](.+)[/]$/)) ? new RegExp(m[1], "i") : this.typefield(field)).filter((s) => s);
      if (!this.verbatimFields.length) this.verbatimFields = null;
      this.csquotes = this.preferences.csquotes ? { open: this.preferences.csquotes[0], close: this.preferences.csquotes[1] } : null;
      this.preferences.testing = Zotero.getHiddenPref("better-bibtex.testing");
    }
    get exportDir() {
      this.input.items.current.$cacheable = false;
      return this.export.dir;
    }
    get exportPath() {
      this.input.items.current.$cacheable = false;
      return this.export.path;
    }
    typefield(field) {
      field = field.trim();
      if (field.startsWith("bibtex.")) return this.BetterBibTeX ? field.replace(/^bibtex\./, "") : "";
      if (field.startsWith("biblatex.")) return this.mode === "import" || this.BetterBibLaTeX ? field.replace(/^biblatex\./, "") : "";
      return field;
    }
    static Import(translator) {
      return new this(translator, "import");
    }
    static Export(translator, input) {
      var _a2, _b, _c, _d;
      const translation = new this(translator, "export");
      translation.input = input;
      translation.export = {
        dir: Zotero.getOption("exportDir"),
        path: Zotero.getOption("exportPath")
      };
      if ((_a2 = translation.export.dir) == null ? void 0 : _a2.endsWith(translation.paths.sep)) translation.export.dir = translation.export.dir.slice(0, -1);
      translation.unicode = !translation.preferences[`ascii${translator.label.replace(/Better /, "")}`] || false;
      if (translation.preferences.baseAttachmentPath && (translation.export.dir === translation.preferences.baseAttachmentPath || ((_b = translation.export.dir) == null ? void 0 : _b.startsWith(translation.preferences.baseAttachmentPath + translation.paths.sep)))) {
        translation.preferences.relativeFilePaths = true;
      }
      translation.cacheable = translation.cacheable && translation.preferences.cache && !(translation.options.exportFileData || translation.preferences.relativeFilePaths || translation.preferences.baseAttachmentPath && ((_c = translation.export.dir) == null ? void 0 : _c.startsWith(translation.preferences.baseAttachmentPath)));
      if (translation.BetterTeX) {
        translation.preferences.separatorList = translation.preferences.separatorList.trim();
        translation.preferences.separatorNames = translation.preferences.separatorNames.trim();
        translation.and = {
          list: {
            re: new RegExp(regex(translation.preferences.separatorList), "g"),
            repl: ` {${translation.preferences.separatorList}} `
          },
          names: {
            re: new RegExp(` ${regex(translation.preferences.separatorNames)} `, "g"),
            repl: ` {${translation.preferences.separatorNames}} `
          }
        };
        translation.preferences.separatorList = ` ${translation.preferences.separatorList} `;
        translation.preferences.separatorNames = ` ${translation.preferences.separatorNames} `;
      }
      if (translation.preferences.testing && typeof __estrace === "undefined" && ((_d = translator.configOptions) == null ? void 0 : _d.cached)) {
        const allowedPreferences = (translator.label === "BetterBibTeX JSON" ? Object.keys(defaults) : affectedBy[translator.label]).concat(["testing"]).reduce((acc, pref) => {
          acc[pref] = translation.preferences[pref];
          return acc;
        }, {});
        translation.preferences = new Proxy(allowedPreferences, {
          set: (object, property, _value) => {
            throw new TypeError(`Unexpected set of preference ${String(property)}`);
          },
          get: (object, property) => {
            if (property === "toJSON") return object[property];
            if (!(property in allowedPreferences)) new TypeError(`Preference ${property} claims not to affect ${translator.label}`);
            return object[property];
          }
        });
      }
      translation.input.items.cacheable(translation.cacheable);
      translation.collections = translation.input.collections.byKey;
      return translation;
    }
    erase() {
      this.input.items.erase();
      this.input.collections.erase();
      this.output.body = "";
      this.output.attachments = [];
    }
    saveAttachments() {
      var _a2;
      if (!((_a2 = this.output) == null ? void 0 : _a2.attachments.length)) return;
      for (const attachment of this.output.attachments) {
        attachment.saveFile(attachment.defaultPath, true);
      }
    }
    isVerbatimField(field) {
      return !!this.verbatimFields.find((v) => typeof v === "string" ? v === field : field.match(v));
    }
  };

  // translators/Collected notes.ts
  var import_html_to_md = __toESM(require_dist());

  // content/stringify.ts
  var import_fast_safe_stringify = __toESM(require_fast_safe_stringify());

  // content/text.ts
  var import_bibtex_parser = __toESM(require_bibtex_parser());

  // content/csl-titlecase.ts
  var CSL = __toESM(require_citeproc_commonjs());
  function makeRegExp(lst) {
    lst = lst.slice();
    const ret = new RegExp("(?:(?:[?!:]*\\s+|-|^)(?:" + lst.join("|") + ")(?=[!?:]*\\s+|-|$))", "g");
    return ret;
  }
  var State = class {
    constructor() {
      this.opt = { lang: "en" };
      this.locale = {};
      this.locale[this.opt.lang] = { opts: {} };
      this.locale[this.opt.lang].opts["skip-words"] = CSL.SKIP_WORDS;
      this.locale[this.opt.lang].opts["skip-words-regexp"] = makeRegExp(this.locale[this.opt.lang].opts["skip-words"]);
      this.tmp = {};
    }
  };
  function titleCased(text) {
    return CSL.Output.Formatters.title(new State(), text);
  }

  // node_modules/parse5/dist/common/unicode.js
  var UNDEFINED_CODE_POINTS = /* @__PURE__ */ new Set([
    65534,
    65535,
    131070,
    131071,
    196606,
    196607,
    262142,
    262143,
    327678,
    327679,
    393214,
    393215,
    458750,
    458751,
    524286,
    524287,
    589822,
    589823,
    655358,
    655359,
    720894,
    720895,
    786430,
    786431,
    851966,
    851967,
    917502,
    917503,
    983038,
    983039,
    1048574,
    1048575,
    1114110,
    1114111
  ]);
  var REPLACEMENT_CHARACTER = "\uFFFD";
  var CODE_POINTS;
  (function(CODE_POINTS2) {
    CODE_POINTS2[CODE_POINTS2["EOF"] = -1] = "EOF";
    CODE_POINTS2[CODE_POINTS2["NULL"] = 0] = "NULL";
    CODE_POINTS2[CODE_POINTS2["TABULATION"] = 9] = "TABULATION";
    CODE_POINTS2[CODE_POINTS2["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
    CODE_POINTS2[CODE_POINTS2["LINE_FEED"] = 10] = "LINE_FEED";
    CODE_POINTS2[CODE_POINTS2["FORM_FEED"] = 12] = "FORM_FEED";
    CODE_POINTS2[CODE_POINTS2["SPACE"] = 32] = "SPACE";
    CODE_POINTS2[CODE_POINTS2["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
    CODE_POINTS2[CODE_POINTS2["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
    CODE_POINTS2[CODE_POINTS2["NUMBER_SIGN"] = 35] = "NUMBER_SIGN";
    CODE_POINTS2[CODE_POINTS2["AMPERSAND"] = 38] = "AMPERSAND";
    CODE_POINTS2[CODE_POINTS2["APOSTROPHE"] = 39] = "APOSTROPHE";
    CODE_POINTS2[CODE_POINTS2["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
    CODE_POINTS2[CODE_POINTS2["SOLIDUS"] = 47] = "SOLIDUS";
    CODE_POINTS2[CODE_POINTS2["DIGIT_0"] = 48] = "DIGIT_0";
    CODE_POINTS2[CODE_POINTS2["DIGIT_9"] = 57] = "DIGIT_9";
    CODE_POINTS2[CODE_POINTS2["SEMICOLON"] = 59] = "SEMICOLON";
    CODE_POINTS2[CODE_POINTS2["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
    CODE_POINTS2[CODE_POINTS2["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
    CODE_POINTS2[CODE_POINTS2["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
    CODE_POINTS2[CODE_POINTS2["QUESTION_MARK"] = 63] = "QUESTION_MARK";
    CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
    CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_F"] = 70] = "LATIN_CAPITAL_F";
    CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_X"] = 88] = "LATIN_CAPITAL_X";
    CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
    CODE_POINTS2[CODE_POINTS2["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
    CODE_POINTS2[CODE_POINTS2["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
    CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
    CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_F"] = 102] = "LATIN_SMALL_F";
    CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_X"] = 120] = "LATIN_SMALL_X";
    CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
    CODE_POINTS2[CODE_POINTS2["REPLACEMENT_CHARACTER"] = 65533] = "REPLACEMENT_CHARACTER";
  })(CODE_POINTS = CODE_POINTS || (CODE_POINTS = {}));
  var SEQUENCES = {
    DASH_DASH: "--",
    CDATA_START: "[CDATA[",
    DOCTYPE: "doctype",
    SCRIPT: "script",
    PUBLIC: "public",
    SYSTEM: "system"
  };
  function isSurrogate(cp) {
    return cp >= 55296 && cp <= 57343;
  }
  function isSurrogatePair(cp) {
    return cp >= 56320 && cp <= 57343;
  }
  function getSurrogatePairCodePoint(cp1, cp2) {
    return (cp1 - 55296) * 1024 + 9216 + cp2;
  }
  function isControlCodePoint(cp) {
    return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
  }
  function isUndefinedCodePoint(cp) {
    return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.has(cp);
  }

  // node_modules/parse5/dist/common/error-codes.js
  var ERR;
  (function(ERR2) {
    ERR2["controlCharacterInInputStream"] = "control-character-in-input-stream";
    ERR2["noncharacterInInputStream"] = "noncharacter-in-input-stream";
    ERR2["surrogateInInputStream"] = "surrogate-in-input-stream";
    ERR2["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
    ERR2["endTagWithAttributes"] = "end-tag-with-attributes";
    ERR2["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
    ERR2["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
    ERR2["unexpectedNullCharacter"] = "unexpected-null-character";
    ERR2["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
    ERR2["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
    ERR2["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
    ERR2["missingEndTagName"] = "missing-end-tag-name";
    ERR2["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
    ERR2["unknownNamedCharacterReference"] = "unknown-named-character-reference";
    ERR2["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
    ERR2["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
    ERR2["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
    ERR2["eofBeforeTagName"] = "eof-before-tag-name";
    ERR2["eofInTag"] = "eof-in-tag";
    ERR2["missingAttributeValue"] = "missing-attribute-value";
    ERR2["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
    ERR2["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
    ERR2["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
    ERR2["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
    ERR2["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
    ERR2["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
    ERR2["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
    ERR2["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
    ERR2["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
    ERR2["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
    ERR2["cdataInHtmlContent"] = "cdata-in-html-content";
    ERR2["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
    ERR2["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
    ERR2["eofInDoctype"] = "eof-in-doctype";
    ERR2["nestedComment"] = "nested-comment";
    ERR2["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
    ERR2["eofInComment"] = "eof-in-comment";
    ERR2["incorrectlyClosedComment"] = "incorrectly-closed-comment";
    ERR2["eofInCdata"] = "eof-in-cdata";
    ERR2["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
    ERR2["nullCharacterReference"] = "null-character-reference";
    ERR2["surrogateCharacterReference"] = "surrogate-character-reference";
    ERR2["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
    ERR2["controlCharacterReference"] = "control-character-reference";
    ERR2["noncharacterCharacterReference"] = "noncharacter-character-reference";
    ERR2["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
    ERR2["missingDoctypeName"] = "missing-doctype-name";
    ERR2["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
    ERR2["duplicateAttribute"] = "duplicate-attribute";
    ERR2["nonConformingDoctype"] = "non-conforming-doctype";
    ERR2["missingDoctype"] = "missing-doctype";
    ERR2["misplacedDoctype"] = "misplaced-doctype";
    ERR2["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
    ERR2["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
    ERR2["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
    ERR2["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
    ERR2["abandonedHeadElementChild"] = "abandoned-head-element-child";
    ERR2["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
    ERR2["nestedNoscriptInHead"] = "nested-noscript-in-head";
    ERR2["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
  })(ERR = ERR || (ERR = {}));

  // node_modules/parse5/dist/tokenizer/preprocessor.js
  var DEFAULT_BUFFER_WATERLINE = 1 << 16;
  var Preprocessor = class {
    constructor(handler) {
      this.handler = handler;
      this.html = "";
      this.pos = -1;
      this.lastGapPos = -2;
      this.gapStack = [];
      this.skipNextNewLine = false;
      this.lastChunkWritten = false;
      this.endOfChunkHit = false;
      this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
      this.isEol = false;
      this.lineStartPos = 0;
      this.droppedBufferSize = 0;
      this.line = 1;
      this.lastErrOffset = -1;
    }
    /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
    get col() {
      return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
    }
    get offset() {
      return this.droppedBufferSize + this.pos;
    }
    getError(code) {
      const { line, col, offset } = this;
      return {
        code,
        startLine: line,
        endLine: line,
        startCol: col,
        endCol: col,
        startOffset: offset,
        endOffset: offset
      };
    }
    _err(code) {
      if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
        this.lastErrOffset = this.offset;
        this.handler.onParseError(this.getError(code));
      }
    }
    _addGap() {
      this.gapStack.push(this.lastGapPos);
      this.lastGapPos = this.pos;
    }
    _processSurrogate(cp) {
      if (this.pos !== this.html.length - 1) {
        const nextCp = this.html.charCodeAt(this.pos + 1);
        if (isSurrogatePair(nextCp)) {
          this.pos++;
          this._addGap();
          return getSurrogatePairCodePoint(cp, nextCp);
        }
      } else if (!this.lastChunkWritten) {
        this.endOfChunkHit = true;
        return CODE_POINTS.EOF;
      }
      this._err(ERR.surrogateInInputStream);
      return cp;
    }
    willDropParsedChunk() {
      return this.pos > this.bufferWaterline;
    }
    dropParsedChunk() {
      if (this.willDropParsedChunk()) {
        this.html = this.html.substring(this.pos);
        this.lineStartPos -= this.pos;
        this.droppedBufferSize += this.pos;
        this.pos = 0;
        this.lastGapPos = -2;
        this.gapStack.length = 0;
      }
    }
    write(chunk, isLastChunk) {
      if (this.html.length > 0) {
        this.html += chunk;
      } else {
        this.html = chunk;
      }
      this.endOfChunkHit = false;
      this.lastChunkWritten = isLastChunk;
    }
    insertHtmlAtCurrentPos(chunk) {
      this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
      this.endOfChunkHit = false;
    }
    startsWith(pattern, caseSensitive) {
      if (this.pos + pattern.length > this.html.length) {
        this.endOfChunkHit = !this.lastChunkWritten;
        return false;
      }
      if (caseSensitive) {
        return this.html.startsWith(pattern, this.pos);
      }
      for (let i = 0; i < pattern.length; i++) {
        const cp = this.html.charCodeAt(this.pos + i) | 32;
        if (cp !== pattern.charCodeAt(i)) {
          return false;
        }
      }
      return true;
    }
    peek(offset) {
      const pos = this.pos + offset;
      if (pos >= this.html.length) {
        this.endOfChunkHit = !this.lastChunkWritten;
        return CODE_POINTS.EOF;
      }
      const code = this.html.charCodeAt(pos);
      return code === CODE_POINTS.CARRIAGE_RETURN ? CODE_POINTS.LINE_FEED : code;
    }
    advance() {
      this.pos++;
      if (this.isEol) {
        this.isEol = false;
        this.line++;
        this.lineStartPos = this.pos;
      }
      if (this.pos >= this.html.length) {
        this.endOfChunkHit = !this.lastChunkWritten;
        return CODE_POINTS.EOF;
      }
      let cp = this.html.charCodeAt(this.pos);
      if (cp === CODE_POINTS.CARRIAGE_RETURN) {
        this.isEol = true;
        this.skipNextNewLine = true;
        return CODE_POINTS.LINE_FEED;
      }
      if (cp === CODE_POINTS.LINE_FEED) {
        this.isEol = true;
        if (this.skipNextNewLine) {
          this.line--;
          this.skipNextNewLine = false;
          this._addGap();
          return this.advance();
        }
      }
      this.skipNextNewLine = false;
      if (isSurrogate(cp)) {
        cp = this._processSurrogate(cp);
      }
      const isCommonValidRange = this.handler.onParseError === null || cp > 31 && cp < 127 || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.CARRIAGE_RETURN || cp > 159 && cp < 64976;
      if (!isCommonValidRange) {
        this._checkForProblematicCharacters(cp);
      }
      return cp;
    }
    _checkForProblematicCharacters(cp) {
      if (isControlCodePoint(cp)) {
        this._err(ERR.controlCharacterInInputStream);
      } else if (isUndefinedCodePoint(cp)) {
        this._err(ERR.noncharacterInInputStream);
      }
    }
    retreat(count) {
      this.pos -= count;
      while (this.pos < this.lastGapPos) {
        this.lastGapPos = this.gapStack.pop();
        this.pos--;
      }
      this.isEol = false;
    }
  };

  // node_modules/parse5/dist/common/token.js
  var token_exports = {};
  __export(token_exports, {
    TokenType: () => TokenType,
    getTokenAttr: () => getTokenAttr
  });
  var TokenType;
  (function(TokenType2) {
    TokenType2[TokenType2["CHARACTER"] = 0] = "CHARACTER";
    TokenType2[TokenType2["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
    TokenType2[TokenType2["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
    TokenType2[TokenType2["START_TAG"] = 3] = "START_TAG";
    TokenType2[TokenType2["END_TAG"] = 4] = "END_TAG";
    TokenType2[TokenType2["COMMENT"] = 5] = "COMMENT";
    TokenType2[TokenType2["DOCTYPE"] = 6] = "DOCTYPE";
    TokenType2[TokenType2["EOF"] = 7] = "EOF";
    TokenType2[TokenType2["HIBERNATION"] = 8] = "HIBERNATION";
  })(TokenType = TokenType || (TokenType = {}));
  function getTokenAttr(token, attrName) {
    for (let i = token.attrs.length - 1; i >= 0; i--) {
      if (token.attrs[i].name === attrName) {
        return token.attrs[i].value;
      }
    }
    return null;
  }

  // node_modules/entities/lib/esm/generated/decode-data-html.js
  var decode_data_html_default = new Uint16Array(
    // prettier-ignore
    '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0))
  );

  // node_modules/entities/lib/esm/generated/decode-data-xml.js
  var decode_data_xml_default = new Uint16Array(
    // prettier-ignore
    "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c) => c.charCodeAt(0))
  );

  // node_modules/entities/lib/esm/decode_codepoint.js
  var _a;
  var decodeMap = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  var fromCodePoint = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
      let output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    }
  );
  function replaceCodePoint(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
  }

  // node_modules/entities/lib/esm/decode.js
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags || (BinTrieFlags = {}));
  function isNumber(code) {
    return code >= CharCodes.ZERO && code <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code) {
    return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
  }
  function isAsciiAlphaNumeric(code) {
    return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
  }
  function isEntityInAttributeInvalidEnd(code) {
    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
  }
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode || (DecodingMode = {}));
  var EntityDecoder = class {
    constructor(decodeTree, emitCodePoint, errors) {
      this.decodeTree = decodeTree;
      this.emitCodePoint = emitCodePoint;
      this.errors = errors;
      this.state = EntityDecoderState.EntityStart;
      this.consumed = 1;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.decodeMode = DecodingMode.Strict;
    }
    /** Resets the instance to make it reusable. */
    startEntity(decodeMode) {
      this.decodeMode = decodeMode;
      this.state = EntityDecoderState.EntityStart;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.consumed = 1;
    }
    /**
     * Write an entity to the decoder. This can be called multiple times with partial entities.
     * If the entity is incomplete, the decoder will return -1.
     *
     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
     * entity is incomplete, and resume when the next string is written.
     *
     * @param string The string containing the entity (or a continuation of the entity).
     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    write(str, offset) {
      switch (this.state) {
        case EntityDecoderState.EntityStart: {
          if (str.charCodeAt(offset) === CharCodes.NUM) {
            this.state = EntityDecoderState.NumericStart;
            this.consumed += 1;
            return this.stateNumericStart(str, offset + 1);
          }
          this.state = EntityDecoderState.NamedEntity;
          return this.stateNamedEntity(str, offset);
        }
        case EntityDecoderState.NumericStart: {
          return this.stateNumericStart(str, offset);
        }
        case EntityDecoderState.NumericDecimal: {
          return this.stateNumericDecimal(str, offset);
        }
        case EntityDecoderState.NumericHex: {
          return this.stateNumericHex(str, offset);
        }
        case EntityDecoderState.NamedEntity: {
          return this.stateNamedEntity(str, offset);
        }
      }
    }
    /**
     * Switches between the numeric decimal and hexadecimal states.
     *
     * Equivalent to the `Numeric character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericStart(str, offset) {
      if (offset >= str.length) {
        return -1;
      }
      if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
        this.state = EntityDecoderState.NumericHex;
        this.consumed += 1;
        return this.stateNumericHex(str, offset + 1);
      }
      this.state = EntityDecoderState.NumericDecimal;
      return this.stateNumericDecimal(str, offset);
    }
    addToNumericResult(str, start, end, base) {
      if (start !== end) {
        const digitCount = end - start;
        this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
        this.consumed += digitCount;
      }
    }
    /**
     * Parses a hexadecimal numeric entity.
     *
     * Equivalent to the `Hexademical character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericHex(str, offset) {
      const startIdx = offset;
      while (offset < str.length) {
        const char = str.charCodeAt(offset);
        if (isNumber(char) || isHexadecimalCharacter(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str, startIdx, offset, 16);
          return this.emitNumericEntity(char, 3);
        }
      }
      this.addToNumericResult(str, startIdx, offset, 16);
      return -1;
    }
    /**
     * Parses a decimal numeric entity.
     *
     * Equivalent to the `Decimal character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericDecimal(str, offset) {
      const startIdx = offset;
      while (offset < str.length) {
        const char = str.charCodeAt(offset);
        if (isNumber(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str, startIdx, offset, 10);
          return this.emitNumericEntity(char, 2);
        }
      }
      this.addToNumericResult(str, startIdx, offset, 10);
      return -1;
    }
    /**
     * Validate and emit a numeric entity.
     *
     * Implements the logic from the `Hexademical character reference start
     * state` and `Numeric character reference end state` in the HTML spec.
     *
     * @param lastCp The last code point of the entity. Used to see if the
     *               entity was terminated with a semicolon.
     * @param expectedLength The minimum number of characters that should be
     *                       consumed. Used to validate that at least one digit
     *                       was consumed.
     * @returns The number of characters that were consumed.
     */
    emitNumericEntity(lastCp, expectedLength) {
      var _a2;
      if (this.consumed <= expectedLength) {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      if (lastCp === CharCodes.SEMI) {
        this.consumed += 1;
      } else if (this.decodeMode === DecodingMode.Strict) {
        return 0;
      }
      this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
      if (this.errors) {
        if (lastCp !== CharCodes.SEMI) {
          this.errors.missingSemicolonAfterCharacterReference();
        }
        this.errors.validateNumericCharacterReference(this.result);
      }
      return this.consumed;
    }
    /**
     * Parses a named entity.
     *
     * Equivalent to the `Named character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNamedEntity(str, offset) {
      const { decodeTree } = this;
      let current = decodeTree[this.treeIndex];
      let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      for (; offset < str.length; offset++, this.excess++) {
        const char = str.charCodeAt(offset);
        this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
        if (this.treeIndex < 0) {
          return this.result === 0 || // If we are parsing an attribute
          this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
          (valueLength === 0 || // And there should be no invalid characters.
          isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
        }
        current = decodeTree[this.treeIndex];
        valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        if (valueLength !== 0) {
          if (char === CharCodes.SEMI) {
            return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
          }
          if (this.decodeMode !== DecodingMode.Strict) {
            this.result = this.treeIndex;
            this.consumed += this.excess;
            this.excess = 0;
          }
        }
      }
      return -1;
    }
    /**
     * Emit a named entity that was not terminated with a semicolon.
     *
     * @returns The number of characters consumed.
     */
    emitNotTerminatedNamedEntity() {
      var _a2;
      const { result, decodeTree } = this;
      const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
      this.emitNamedEntityData(result, valueLength, this.consumed);
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
      return this.consumed;
    }
    /**
     * Emit a named entity.
     *
     * @param result The index of the entity in the decode tree.
     * @param valueLength The number of bytes in the entity.
     * @param consumed The number of characters consumed.
     *
     * @returns The number of characters consumed.
     */
    emitNamedEntityData(result, valueLength, consumed) {
      const { decodeTree } = this;
      this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
      if (valueLength === 3) {
        this.emitCodePoint(decodeTree[result + 2], consumed);
      }
      return consumed;
    }
    /**
     * Signal to the parser that the end of the input was reached.
     *
     * Remaining data will be emitted and relevant errors will be produced.
     *
     * @returns The number of characters consumed.
     */
    end() {
      var _a2;
      switch (this.state) {
        case EntityDecoderState.NamedEntity: {
          return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
        }
        case EntityDecoderState.NumericDecimal: {
          return this.emitNumericEntity(0, 2);
        }
        case EntityDecoderState.NumericHex: {
          return this.emitNumericEntity(0, 3);
        }
        case EntityDecoderState.NumericStart: {
          (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        case EntityDecoderState.EntityStart: {
          return 0;
        }
      }
    }
  };
  function getDecoder(decodeTree) {
    let ret = "";
    const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
    return function decodeWithTrie(str, decodeMode) {
      let lastIndex = 0;
      let offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        const len = decoder.write(
          str,
          // Skip the "&"
          offset + 1
        );
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      const result = ret + str.slice(lastIndex);
      ret = "";
      return result;
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      const value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    let lo = nodeIdx;
    let hi = lo + branchCount - 1;
    while (lo <= hi) {
      const mid = lo + hi >>> 1;
      const midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  var htmlDecoder = getDecoder(decode_data_html_default);
  var xmlDecoder = getDecoder(decode_data_xml_default);

  // node_modules/parse5/dist/common/html.js
  var html_exports = {};
  __export(html_exports, {
    ATTRS: () => ATTRS,
    DOCUMENT_MODE: () => DOCUMENT_MODE,
    NS: () => NS,
    SPECIAL_ELEMENTS: () => SPECIAL_ELEMENTS,
    TAG_ID: () => TAG_ID,
    TAG_NAMES: () => TAG_NAMES,
    getTagID: () => getTagID,
    hasUnescapedText: () => hasUnescapedText,
    isNumberedHeader: () => isNumberedHeader
  });
  var NS;
  (function(NS2) {
    NS2["HTML"] = "http://www.w3.org/1999/xhtml";
    NS2["MATHML"] = "http://www.w3.org/1998/Math/MathML";
    NS2["SVG"] = "http://www.w3.org/2000/svg";
    NS2["XLINK"] = "http://www.w3.org/1999/xlink";
    NS2["XML"] = "http://www.w3.org/XML/1998/namespace";
    NS2["XMLNS"] = "http://www.w3.org/2000/xmlns/";
  })(NS = NS || (NS = {}));
  var ATTRS;
  (function(ATTRS2) {
    ATTRS2["TYPE"] = "type";
    ATTRS2["ACTION"] = "action";
    ATTRS2["ENCODING"] = "encoding";
    ATTRS2["PROMPT"] = "prompt";
    ATTRS2["NAME"] = "name";
    ATTRS2["COLOR"] = "color";
    ATTRS2["FACE"] = "face";
    ATTRS2["SIZE"] = "size";
  })(ATTRS = ATTRS || (ATTRS = {}));
  var DOCUMENT_MODE;
  (function(DOCUMENT_MODE2) {
    DOCUMENT_MODE2["NO_QUIRKS"] = "no-quirks";
    DOCUMENT_MODE2["QUIRKS"] = "quirks";
    DOCUMENT_MODE2["LIMITED_QUIRKS"] = "limited-quirks";
  })(DOCUMENT_MODE = DOCUMENT_MODE || (DOCUMENT_MODE = {}));
  var TAG_NAMES;
  (function(TAG_NAMES2) {
    TAG_NAMES2["A"] = "a";
    TAG_NAMES2["ADDRESS"] = "address";
    TAG_NAMES2["ANNOTATION_XML"] = "annotation-xml";
    TAG_NAMES2["APPLET"] = "applet";
    TAG_NAMES2["AREA"] = "area";
    TAG_NAMES2["ARTICLE"] = "article";
    TAG_NAMES2["ASIDE"] = "aside";
    TAG_NAMES2["B"] = "b";
    TAG_NAMES2["BASE"] = "base";
    TAG_NAMES2["BASEFONT"] = "basefont";
    TAG_NAMES2["BGSOUND"] = "bgsound";
    TAG_NAMES2["BIG"] = "big";
    TAG_NAMES2["BLOCKQUOTE"] = "blockquote";
    TAG_NAMES2["BODY"] = "body";
    TAG_NAMES2["BR"] = "br";
    TAG_NAMES2["BUTTON"] = "button";
    TAG_NAMES2["CAPTION"] = "caption";
    TAG_NAMES2["CENTER"] = "center";
    TAG_NAMES2["CODE"] = "code";
    TAG_NAMES2["COL"] = "col";
    TAG_NAMES2["COLGROUP"] = "colgroup";
    TAG_NAMES2["DD"] = "dd";
    TAG_NAMES2["DESC"] = "desc";
    TAG_NAMES2["DETAILS"] = "details";
    TAG_NAMES2["DIALOG"] = "dialog";
    TAG_NAMES2["DIR"] = "dir";
    TAG_NAMES2["DIV"] = "div";
    TAG_NAMES2["DL"] = "dl";
    TAG_NAMES2["DT"] = "dt";
    TAG_NAMES2["EM"] = "em";
    TAG_NAMES2["EMBED"] = "embed";
    TAG_NAMES2["FIELDSET"] = "fieldset";
    TAG_NAMES2["FIGCAPTION"] = "figcaption";
    TAG_NAMES2["FIGURE"] = "figure";
    TAG_NAMES2["FONT"] = "font";
    TAG_NAMES2["FOOTER"] = "footer";
    TAG_NAMES2["FOREIGN_OBJECT"] = "foreignObject";
    TAG_NAMES2["FORM"] = "form";
    TAG_NAMES2["FRAME"] = "frame";
    TAG_NAMES2["FRAMESET"] = "frameset";
    TAG_NAMES2["H1"] = "h1";
    TAG_NAMES2["H2"] = "h2";
    TAG_NAMES2["H3"] = "h3";
    TAG_NAMES2["H4"] = "h4";
    TAG_NAMES2["H5"] = "h5";
    TAG_NAMES2["H6"] = "h6";
    TAG_NAMES2["HEAD"] = "head";
    TAG_NAMES2["HEADER"] = "header";
    TAG_NAMES2["HGROUP"] = "hgroup";
    TAG_NAMES2["HR"] = "hr";
    TAG_NAMES2["HTML"] = "html";
    TAG_NAMES2["I"] = "i";
    TAG_NAMES2["IMG"] = "img";
    TAG_NAMES2["IMAGE"] = "image";
    TAG_NAMES2["INPUT"] = "input";
    TAG_NAMES2["IFRAME"] = "iframe";
    TAG_NAMES2["KEYGEN"] = "keygen";
    TAG_NAMES2["LABEL"] = "label";
    TAG_NAMES2["LI"] = "li";
    TAG_NAMES2["LINK"] = "link";
    TAG_NAMES2["LISTING"] = "listing";
    TAG_NAMES2["MAIN"] = "main";
    TAG_NAMES2["MALIGNMARK"] = "malignmark";
    TAG_NAMES2["MARQUEE"] = "marquee";
    TAG_NAMES2["MATH"] = "math";
    TAG_NAMES2["MENU"] = "menu";
    TAG_NAMES2["META"] = "meta";
    TAG_NAMES2["MGLYPH"] = "mglyph";
    TAG_NAMES2["MI"] = "mi";
    TAG_NAMES2["MO"] = "mo";
    TAG_NAMES2["MN"] = "mn";
    TAG_NAMES2["MS"] = "ms";
    TAG_NAMES2["MTEXT"] = "mtext";
    TAG_NAMES2["NAV"] = "nav";
    TAG_NAMES2["NOBR"] = "nobr";
    TAG_NAMES2["NOFRAMES"] = "noframes";
    TAG_NAMES2["NOEMBED"] = "noembed";
    TAG_NAMES2["NOSCRIPT"] = "noscript";
    TAG_NAMES2["OBJECT"] = "object";
    TAG_NAMES2["OL"] = "ol";
    TAG_NAMES2["OPTGROUP"] = "optgroup";
    TAG_NAMES2["OPTION"] = "option";
    TAG_NAMES2["P"] = "p";
    TAG_NAMES2["PARAM"] = "param";
    TAG_NAMES2["PLAINTEXT"] = "plaintext";
    TAG_NAMES2["PRE"] = "pre";
    TAG_NAMES2["RB"] = "rb";
    TAG_NAMES2["RP"] = "rp";
    TAG_NAMES2["RT"] = "rt";
    TAG_NAMES2["RTC"] = "rtc";
    TAG_NAMES2["RUBY"] = "ruby";
    TAG_NAMES2["S"] = "s";
    TAG_NAMES2["SCRIPT"] = "script";
    TAG_NAMES2["SECTION"] = "section";
    TAG_NAMES2["SELECT"] = "select";
    TAG_NAMES2["SOURCE"] = "source";
    TAG_NAMES2["SMALL"] = "small";
    TAG_NAMES2["SPAN"] = "span";
    TAG_NAMES2["STRIKE"] = "strike";
    TAG_NAMES2["STRONG"] = "strong";
    TAG_NAMES2["STYLE"] = "style";
    TAG_NAMES2["SUB"] = "sub";
    TAG_NAMES2["SUMMARY"] = "summary";
    TAG_NAMES2["SUP"] = "sup";
    TAG_NAMES2["TABLE"] = "table";
    TAG_NAMES2["TBODY"] = "tbody";
    TAG_NAMES2["TEMPLATE"] = "template";
    TAG_NAMES2["TEXTAREA"] = "textarea";
    TAG_NAMES2["TFOOT"] = "tfoot";
    TAG_NAMES2["TD"] = "td";
    TAG_NAMES2["TH"] = "th";
    TAG_NAMES2["THEAD"] = "thead";
    TAG_NAMES2["TITLE"] = "title";
    TAG_NAMES2["TR"] = "tr";
    TAG_NAMES2["TRACK"] = "track";
    TAG_NAMES2["TT"] = "tt";
    TAG_NAMES2["U"] = "u";
    TAG_NAMES2["UL"] = "ul";
    TAG_NAMES2["SVG"] = "svg";
    TAG_NAMES2["VAR"] = "var";
    TAG_NAMES2["WBR"] = "wbr";
    TAG_NAMES2["XMP"] = "xmp";
  })(TAG_NAMES = TAG_NAMES || (TAG_NAMES = {}));
  var TAG_ID;
  (function(TAG_ID2) {
    TAG_ID2[TAG_ID2["UNKNOWN"] = 0] = "UNKNOWN";
    TAG_ID2[TAG_ID2["A"] = 1] = "A";
    TAG_ID2[TAG_ID2["ADDRESS"] = 2] = "ADDRESS";
    TAG_ID2[TAG_ID2["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
    TAG_ID2[TAG_ID2["APPLET"] = 4] = "APPLET";
    TAG_ID2[TAG_ID2["AREA"] = 5] = "AREA";
    TAG_ID2[TAG_ID2["ARTICLE"] = 6] = "ARTICLE";
    TAG_ID2[TAG_ID2["ASIDE"] = 7] = "ASIDE";
    TAG_ID2[TAG_ID2["B"] = 8] = "B";
    TAG_ID2[TAG_ID2["BASE"] = 9] = "BASE";
    TAG_ID2[TAG_ID2["BASEFONT"] = 10] = "BASEFONT";
    TAG_ID2[TAG_ID2["BGSOUND"] = 11] = "BGSOUND";
    TAG_ID2[TAG_ID2["BIG"] = 12] = "BIG";
    TAG_ID2[TAG_ID2["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
    TAG_ID2[TAG_ID2["BODY"] = 14] = "BODY";
    TAG_ID2[TAG_ID2["BR"] = 15] = "BR";
    TAG_ID2[TAG_ID2["BUTTON"] = 16] = "BUTTON";
    TAG_ID2[TAG_ID2["CAPTION"] = 17] = "CAPTION";
    TAG_ID2[TAG_ID2["CENTER"] = 18] = "CENTER";
    TAG_ID2[TAG_ID2["CODE"] = 19] = "CODE";
    TAG_ID2[TAG_ID2["COL"] = 20] = "COL";
    TAG_ID2[TAG_ID2["COLGROUP"] = 21] = "COLGROUP";
    TAG_ID2[TAG_ID2["DD"] = 22] = "DD";
    TAG_ID2[TAG_ID2["DESC"] = 23] = "DESC";
    TAG_ID2[TAG_ID2["DETAILS"] = 24] = "DETAILS";
    TAG_ID2[TAG_ID2["DIALOG"] = 25] = "DIALOG";
    TAG_ID2[TAG_ID2["DIR"] = 26] = "DIR";
    TAG_ID2[TAG_ID2["DIV"] = 27] = "DIV";
    TAG_ID2[TAG_ID2["DL"] = 28] = "DL";
    TAG_ID2[TAG_ID2["DT"] = 29] = "DT";
    TAG_ID2[TAG_ID2["EM"] = 30] = "EM";
    TAG_ID2[TAG_ID2["EMBED"] = 31] = "EMBED";
    TAG_ID2[TAG_ID2["FIELDSET"] = 32] = "FIELDSET";
    TAG_ID2[TAG_ID2["FIGCAPTION"] = 33] = "FIGCAPTION";
    TAG_ID2[TAG_ID2["FIGURE"] = 34] = "FIGURE";
    TAG_ID2[TAG_ID2["FONT"] = 35] = "FONT";
    TAG_ID2[TAG_ID2["FOOTER"] = 36] = "FOOTER";
    TAG_ID2[TAG_ID2["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
    TAG_ID2[TAG_ID2["FORM"] = 38] = "FORM";
    TAG_ID2[TAG_ID2["FRAME"] = 39] = "FRAME";
    TAG_ID2[TAG_ID2["FRAMESET"] = 40] = "FRAMESET";
    TAG_ID2[TAG_ID2["H1"] = 41] = "H1";
    TAG_ID2[TAG_ID2["H2"] = 42] = "H2";
    TAG_ID2[TAG_ID2["H3"] = 43] = "H3";
    TAG_ID2[TAG_ID2["H4"] = 44] = "H4";
    TAG_ID2[TAG_ID2["H5"] = 45] = "H5";
    TAG_ID2[TAG_ID2["H6"] = 46] = "H6";
    TAG_ID2[TAG_ID2["HEAD"] = 47] = "HEAD";
    TAG_ID2[TAG_ID2["HEADER"] = 48] = "HEADER";
    TAG_ID2[TAG_ID2["HGROUP"] = 49] = "HGROUP";
    TAG_ID2[TAG_ID2["HR"] = 50] = "HR";
    TAG_ID2[TAG_ID2["HTML"] = 51] = "HTML";
    TAG_ID2[TAG_ID2["I"] = 52] = "I";
    TAG_ID2[TAG_ID2["IMG"] = 53] = "IMG";
    TAG_ID2[TAG_ID2["IMAGE"] = 54] = "IMAGE";
    TAG_ID2[TAG_ID2["INPUT"] = 55] = "INPUT";
    TAG_ID2[TAG_ID2["IFRAME"] = 56] = "IFRAME";
    TAG_ID2[TAG_ID2["KEYGEN"] = 57] = "KEYGEN";
    TAG_ID2[TAG_ID2["LABEL"] = 58] = "LABEL";
    TAG_ID2[TAG_ID2["LI"] = 59] = "LI";
    TAG_ID2[TAG_ID2["LINK"] = 60] = "LINK";
    TAG_ID2[TAG_ID2["LISTING"] = 61] = "LISTING";
    TAG_ID2[TAG_ID2["MAIN"] = 62] = "MAIN";
    TAG_ID2[TAG_ID2["MALIGNMARK"] = 63] = "MALIGNMARK";
    TAG_ID2[TAG_ID2["MARQUEE"] = 64] = "MARQUEE";
    TAG_ID2[TAG_ID2["MATH"] = 65] = "MATH";
    TAG_ID2[TAG_ID2["MENU"] = 66] = "MENU";
    TAG_ID2[TAG_ID2["META"] = 67] = "META";
    TAG_ID2[TAG_ID2["MGLYPH"] = 68] = "MGLYPH";
    TAG_ID2[TAG_ID2["MI"] = 69] = "MI";
    TAG_ID2[TAG_ID2["MO"] = 70] = "MO";
    TAG_ID2[TAG_ID2["MN"] = 71] = "MN";
    TAG_ID2[TAG_ID2["MS"] = 72] = "MS";
    TAG_ID2[TAG_ID2["MTEXT"] = 73] = "MTEXT";
    TAG_ID2[TAG_ID2["NAV"] = 74] = "NAV";
    TAG_ID2[TAG_ID2["NOBR"] = 75] = "NOBR";
    TAG_ID2[TAG_ID2["NOFRAMES"] = 76] = "NOFRAMES";
    TAG_ID2[TAG_ID2["NOEMBED"] = 77] = "NOEMBED";
    TAG_ID2[TAG_ID2["NOSCRIPT"] = 78] = "NOSCRIPT";
    TAG_ID2[TAG_ID2["OBJECT"] = 79] = "OBJECT";
    TAG_ID2[TAG_ID2["OL"] = 80] = "OL";
    TAG_ID2[TAG_ID2["OPTGROUP"] = 81] = "OPTGROUP";
    TAG_ID2[TAG_ID2["OPTION"] = 82] = "OPTION";
    TAG_ID2[TAG_ID2["P"] = 83] = "P";
    TAG_ID2[TAG_ID2["PARAM"] = 84] = "PARAM";
    TAG_ID2[TAG_ID2["PLAINTEXT"] = 85] = "PLAINTEXT";
    TAG_ID2[TAG_ID2["PRE"] = 86] = "PRE";
    TAG_ID2[TAG_ID2["RB"] = 87] = "RB";
    TAG_ID2[TAG_ID2["RP"] = 88] = "RP";
    TAG_ID2[TAG_ID2["RT"] = 89] = "RT";
    TAG_ID2[TAG_ID2["RTC"] = 90] = "RTC";
    TAG_ID2[TAG_ID2["RUBY"] = 91] = "RUBY";
    TAG_ID2[TAG_ID2["S"] = 92] = "S";
    TAG_ID2[TAG_ID2["SCRIPT"] = 93] = "SCRIPT";
    TAG_ID2[TAG_ID2["SECTION"] = 94] = "SECTION";
    TAG_ID2[TAG_ID2["SELECT"] = 95] = "SELECT";
    TAG_ID2[TAG_ID2["SOURCE"] = 96] = "SOURCE";
    TAG_ID2[TAG_ID2["SMALL"] = 97] = "SMALL";
    TAG_ID2[TAG_ID2["SPAN"] = 98] = "SPAN";
    TAG_ID2[TAG_ID2["STRIKE"] = 99] = "STRIKE";
    TAG_ID2[TAG_ID2["STRONG"] = 100] = "STRONG";
    TAG_ID2[TAG_ID2["STYLE"] = 101] = "STYLE";
    TAG_ID2[TAG_ID2["SUB"] = 102] = "SUB";
    TAG_ID2[TAG_ID2["SUMMARY"] = 103] = "SUMMARY";
    TAG_ID2[TAG_ID2["SUP"] = 104] = "SUP";
    TAG_ID2[TAG_ID2["TABLE"] = 105] = "TABLE";
    TAG_ID2[TAG_ID2["TBODY"] = 106] = "TBODY";
    TAG_ID2[TAG_ID2["TEMPLATE"] = 107] = "TEMPLATE";
    TAG_ID2[TAG_ID2["TEXTAREA"] = 108] = "TEXTAREA";
    TAG_ID2[TAG_ID2["TFOOT"] = 109] = "TFOOT";
    TAG_ID2[TAG_ID2["TD"] = 110] = "TD";
    TAG_ID2[TAG_ID2["TH"] = 111] = "TH";
    TAG_ID2[TAG_ID2["THEAD"] = 112] = "THEAD";
    TAG_ID2[TAG_ID2["TITLE"] = 113] = "TITLE";
    TAG_ID2[TAG_ID2["TR"] = 114] = "TR";
    TAG_ID2[TAG_ID2["TRACK"] = 115] = "TRACK";
    TAG_ID2[TAG_ID2["TT"] = 116] = "TT";
    TAG_ID2[TAG_ID2["U"] = 117] = "U";
    TAG_ID2[TAG_ID2["UL"] = 118] = "UL";
    TAG_ID2[TAG_ID2["SVG"] = 119] = "SVG";
    TAG_ID2[TAG_ID2["VAR"] = 120] = "VAR";
    TAG_ID2[TAG_ID2["WBR"] = 121] = "WBR";
    TAG_ID2[TAG_ID2["XMP"] = 122] = "XMP";
  })(TAG_ID = TAG_ID || (TAG_ID = {}));
  var TAG_NAME_TO_ID = /* @__PURE__ */ new Map([
    [TAG_NAMES.A, TAG_ID.A],
    [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
    [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
    [TAG_NAMES.APPLET, TAG_ID.APPLET],
    [TAG_NAMES.AREA, TAG_ID.AREA],
    [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
    [TAG_NAMES.ASIDE, TAG_ID.ASIDE],
    [TAG_NAMES.B, TAG_ID.B],
    [TAG_NAMES.BASE, TAG_ID.BASE],
    [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
    [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
    [TAG_NAMES.BIG, TAG_ID.BIG],
    [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
    [TAG_NAMES.BODY, TAG_ID.BODY],
    [TAG_NAMES.BR, TAG_ID.BR],
    [TAG_NAMES.BUTTON, TAG_ID.BUTTON],
    [TAG_NAMES.CAPTION, TAG_ID.CAPTION],
    [TAG_NAMES.CENTER, TAG_ID.CENTER],
    [TAG_NAMES.CODE, TAG_ID.CODE],
    [TAG_NAMES.COL, TAG_ID.COL],
    [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
    [TAG_NAMES.DD, TAG_ID.DD],
    [TAG_NAMES.DESC, TAG_ID.DESC],
    [TAG_NAMES.DETAILS, TAG_ID.DETAILS],
    [TAG_NAMES.DIALOG, TAG_ID.DIALOG],
    [TAG_NAMES.DIR, TAG_ID.DIR],
    [TAG_NAMES.DIV, TAG_ID.DIV],
    [TAG_NAMES.DL, TAG_ID.DL],
    [TAG_NAMES.DT, TAG_ID.DT],
    [TAG_NAMES.EM, TAG_ID.EM],
    [TAG_NAMES.EMBED, TAG_ID.EMBED],
    [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
    [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
    [TAG_NAMES.FIGURE, TAG_ID.FIGURE],
    [TAG_NAMES.FONT, TAG_ID.FONT],
    [TAG_NAMES.FOOTER, TAG_ID.FOOTER],
    [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
    [TAG_NAMES.FORM, TAG_ID.FORM],
    [TAG_NAMES.FRAME, TAG_ID.FRAME],
    [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
    [TAG_NAMES.H1, TAG_ID.H1],
    [TAG_NAMES.H2, TAG_ID.H2],
    [TAG_NAMES.H3, TAG_ID.H3],
    [TAG_NAMES.H4, TAG_ID.H4],
    [TAG_NAMES.H5, TAG_ID.H5],
    [TAG_NAMES.H6, TAG_ID.H6],
    [TAG_NAMES.HEAD, TAG_ID.HEAD],
    [TAG_NAMES.HEADER, TAG_ID.HEADER],
    [TAG_NAMES.HGROUP, TAG_ID.HGROUP],
    [TAG_NAMES.HR, TAG_ID.HR],
    [TAG_NAMES.HTML, TAG_ID.HTML],
    [TAG_NAMES.I, TAG_ID.I],
    [TAG_NAMES.IMG, TAG_ID.IMG],
    [TAG_NAMES.IMAGE, TAG_ID.IMAGE],
    [TAG_NAMES.INPUT, TAG_ID.INPUT],
    [TAG_NAMES.IFRAME, TAG_ID.IFRAME],
    [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
    [TAG_NAMES.LABEL, TAG_ID.LABEL],
    [TAG_NAMES.LI, TAG_ID.LI],
    [TAG_NAMES.LINK, TAG_ID.LINK],
    [TAG_NAMES.LISTING, TAG_ID.LISTING],
    [TAG_NAMES.MAIN, TAG_ID.MAIN],
    [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
    [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
    [TAG_NAMES.MATH, TAG_ID.MATH],
    [TAG_NAMES.MENU, TAG_ID.MENU],
    [TAG_NAMES.META, TAG_ID.META],
    [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
    [TAG_NAMES.MI, TAG_ID.MI],
    [TAG_NAMES.MO, TAG_ID.MO],
    [TAG_NAMES.MN, TAG_ID.MN],
    [TAG_NAMES.MS, TAG_ID.MS],
    [TAG_NAMES.MTEXT, TAG_ID.MTEXT],
    [TAG_NAMES.NAV, TAG_ID.NAV],
    [TAG_NAMES.NOBR, TAG_ID.NOBR],
    [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
    [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
    [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
    [TAG_NAMES.OBJECT, TAG_ID.OBJECT],
    [TAG_NAMES.OL, TAG_ID.OL],
    [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
    [TAG_NAMES.OPTION, TAG_ID.OPTION],
    [TAG_NAMES.P, TAG_ID.P],
    [TAG_NAMES.PARAM, TAG_ID.PARAM],
    [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
    [TAG_NAMES.PRE, TAG_ID.PRE],
    [TAG_NAMES.RB, TAG_ID.RB],
    [TAG_NAMES.RP, TAG_ID.RP],
    [TAG_NAMES.RT, TAG_ID.RT],
    [TAG_NAMES.RTC, TAG_ID.RTC],
    [TAG_NAMES.RUBY, TAG_ID.RUBY],
    [TAG_NAMES.S, TAG_ID.S],
    [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
    [TAG_NAMES.SECTION, TAG_ID.SECTION],
    [TAG_NAMES.SELECT, TAG_ID.SELECT],
    [TAG_NAMES.SOURCE, TAG_ID.SOURCE],
    [TAG_NAMES.SMALL, TAG_ID.SMALL],
    [TAG_NAMES.SPAN, TAG_ID.SPAN],
    [TAG_NAMES.STRIKE, TAG_ID.STRIKE],
    [TAG_NAMES.STRONG, TAG_ID.STRONG],
    [TAG_NAMES.STYLE, TAG_ID.STYLE],
    [TAG_NAMES.SUB, TAG_ID.SUB],
    [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
    [TAG_NAMES.SUP, TAG_ID.SUP],
    [TAG_NAMES.TABLE, TAG_ID.TABLE],
    [TAG_NAMES.TBODY, TAG_ID.TBODY],
    [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
    [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
    [TAG_NAMES.TFOOT, TAG_ID.TFOOT],
    [TAG_NAMES.TD, TAG_ID.TD],
    [TAG_NAMES.TH, TAG_ID.TH],
    [TAG_NAMES.THEAD, TAG_ID.THEAD],
    [TAG_NAMES.TITLE, TAG_ID.TITLE],
    [TAG_NAMES.TR, TAG_ID.TR],
    [TAG_NAMES.TRACK, TAG_ID.TRACK],
    [TAG_NAMES.TT, TAG_ID.TT],
    [TAG_NAMES.U, TAG_ID.U],
    [TAG_NAMES.UL, TAG_ID.UL],
    [TAG_NAMES.SVG, TAG_ID.SVG],
    [TAG_NAMES.VAR, TAG_ID.VAR],
    [TAG_NAMES.WBR, TAG_ID.WBR],
    [TAG_NAMES.XMP, TAG_ID.XMP]
  ]);
  function getTagID(tagName) {
    var _a2;
    return (_a2 = TAG_NAME_TO_ID.get(tagName)) !== null && _a2 !== void 0 ? _a2 : TAG_ID.UNKNOWN;
  }
  var $ = TAG_ID;
  var SPECIAL_ELEMENTS = {
    [NS.HTML]: /* @__PURE__ */ new Set([
      $.ADDRESS,
      $.APPLET,
      $.AREA,
      $.ARTICLE,
      $.ASIDE,
      $.BASE,
      $.BASEFONT,
      $.BGSOUND,
      $.BLOCKQUOTE,
      $.BODY,
      $.BR,
      $.BUTTON,
      $.CAPTION,
      $.CENTER,
      $.COL,
      $.COLGROUP,
      $.DD,
      $.DETAILS,
      $.DIR,
      $.DIV,
      $.DL,
      $.DT,
      $.EMBED,
      $.FIELDSET,
      $.FIGCAPTION,
      $.FIGURE,
      $.FOOTER,
      $.FORM,
      $.FRAME,
      $.FRAMESET,
      $.H1,
      $.H2,
      $.H3,
      $.H4,
      $.H5,
      $.H6,
      $.HEAD,
      $.HEADER,
      $.HGROUP,
      $.HR,
      $.HTML,
      $.IFRAME,
      $.IMG,
      $.INPUT,
      $.LI,
      $.LINK,
      $.LISTING,
      $.MAIN,
      $.MARQUEE,
      $.MENU,
      $.META,
      $.NAV,
      $.NOEMBED,
      $.NOFRAMES,
      $.NOSCRIPT,
      $.OBJECT,
      $.OL,
      $.P,
      $.PARAM,
      $.PLAINTEXT,
      $.PRE,
      $.SCRIPT,
      $.SECTION,
      $.SELECT,
      $.SOURCE,
      $.STYLE,
      $.SUMMARY,
      $.TABLE,
      $.TBODY,
      $.TD,
      $.TEMPLATE,
      $.TEXTAREA,
      $.TFOOT,
      $.TH,
      $.THEAD,
      $.TITLE,
      $.TR,
      $.TRACK,
      $.UL,
      $.WBR,
      $.XMP
    ]),
    [NS.MATHML]: /* @__PURE__ */ new Set([$.MI, $.MO, $.MN, $.MS, $.MTEXT, $.ANNOTATION_XML]),
    [NS.SVG]: /* @__PURE__ */ new Set([$.TITLE, $.FOREIGN_OBJECT, $.DESC]),
    [NS.XLINK]: /* @__PURE__ */ new Set(),
    [NS.XML]: /* @__PURE__ */ new Set(),
    [NS.XMLNS]: /* @__PURE__ */ new Set()
  };
  function isNumberedHeader(tn) {
    return tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6;
  }
  var UNESCAPED_TEXT = /* @__PURE__ */ new Set([
    TAG_NAMES.STYLE,
    TAG_NAMES.SCRIPT,
    TAG_NAMES.XMP,
    TAG_NAMES.IFRAME,
    TAG_NAMES.NOEMBED,
    TAG_NAMES.NOFRAMES,
    TAG_NAMES.PLAINTEXT
  ]);
  function hasUnescapedText(tn, scriptingEnabled) {
    return UNESCAPED_TEXT.has(tn) || scriptingEnabled && tn === TAG_NAMES.NOSCRIPT;
  }

  // node_modules/parse5/dist/tokenizer/index.js
  var C1_CONTROLS_REFERENCE_REPLACEMENTS = /* @__PURE__ */ new Map([
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  var State2;
  (function(State3) {
    State3[State3["DATA"] = 0] = "DATA";
    State3[State3["RCDATA"] = 1] = "RCDATA";
    State3[State3["RAWTEXT"] = 2] = "RAWTEXT";
    State3[State3["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
    State3[State3["PLAINTEXT"] = 4] = "PLAINTEXT";
    State3[State3["TAG_OPEN"] = 5] = "TAG_OPEN";
    State3[State3["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
    State3[State3["TAG_NAME"] = 7] = "TAG_NAME";
    State3[State3["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
    State3[State3["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
    State3[State3["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
    State3[State3["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
    State3[State3["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
    State3[State3["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
    State3[State3["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
    State3[State3["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
    State3[State3["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
    State3[State3["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
    State3[State3["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
    State3[State3["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
    State3[State3["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
    State3[State3["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
    State3[State3["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
    State3[State3["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
    State3[State3["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
    State3[State3["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
    State3[State3["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
    State3[State3["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
    State3[State3["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
    State3[State3["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
    State3[State3["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
    State3[State3["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
    State3[State3["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
    State3[State3["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
    State3[State3["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
    State3[State3["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
    State3[State3["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
    State3[State3["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
    State3[State3["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
    State3[State3["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
    State3[State3["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
    State3[State3["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
    State3[State3["COMMENT_START"] = 42] = "COMMENT_START";
    State3[State3["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
    State3[State3["COMMENT"] = 44] = "COMMENT";
    State3[State3["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
    State3[State3["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
    State3[State3["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
    State3[State3["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
    State3[State3["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
    State3[State3["COMMENT_END"] = 50] = "COMMENT_END";
    State3[State3["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
    State3[State3["DOCTYPE"] = 52] = "DOCTYPE";
    State3[State3["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
    State3[State3["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
    State3[State3["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
    State3[State3["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
    State3[State3["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
    State3[State3["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
    State3[State3["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
    State3[State3["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
    State3[State3["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
    State3[State3["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
    State3[State3["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
    State3[State3["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
    State3[State3["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
    State3[State3["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
    State3[State3["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
    State3[State3["CDATA_SECTION"] = 68] = "CDATA_SECTION";
    State3[State3["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
    State3[State3["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
    State3[State3["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
    State3[State3["NAMED_CHARACTER_REFERENCE"] = 72] = "NAMED_CHARACTER_REFERENCE";
    State3[State3["AMBIGUOUS_AMPERSAND"] = 73] = "AMBIGUOUS_AMPERSAND";
    State3[State3["NUMERIC_CHARACTER_REFERENCE"] = 74] = "NUMERIC_CHARACTER_REFERENCE";
    State3[State3["HEXADEMICAL_CHARACTER_REFERENCE_START"] = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START";
    State3[State3["HEXADEMICAL_CHARACTER_REFERENCE"] = 76] = "HEXADEMICAL_CHARACTER_REFERENCE";
    State3[State3["DECIMAL_CHARACTER_REFERENCE"] = 77] = "DECIMAL_CHARACTER_REFERENCE";
    State3[State3["NUMERIC_CHARACTER_REFERENCE_END"] = 78] = "NUMERIC_CHARACTER_REFERENCE_END";
  })(State2 || (State2 = {}));
  var TokenizerMode = {
    DATA: State2.DATA,
    RCDATA: State2.RCDATA,
    RAWTEXT: State2.RAWTEXT,
    SCRIPT_DATA: State2.SCRIPT_DATA,
    PLAINTEXT: State2.PLAINTEXT,
    CDATA_SECTION: State2.CDATA_SECTION
  };
  function isAsciiDigit(cp) {
    return cp >= CODE_POINTS.DIGIT_0 && cp <= CODE_POINTS.DIGIT_9;
  }
  function isAsciiUpper(cp) {
    return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_Z;
  }
  function isAsciiLower(cp) {
    return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_Z;
  }
  function isAsciiLetter(cp) {
    return isAsciiLower(cp) || isAsciiUpper(cp);
  }
  function isAsciiAlphaNumeric2(cp) {
    return isAsciiLetter(cp) || isAsciiDigit(cp);
  }
  function isAsciiUpperHexDigit(cp) {
    return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_F;
  }
  function isAsciiLowerHexDigit(cp) {
    return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_F;
  }
  function isAsciiHexDigit(cp) {
    return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
  }
  function toAsciiLower(cp) {
    return cp + 32;
  }
  function isWhitespace(cp) {
    return cp === CODE_POINTS.SPACE || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.TABULATION || cp === CODE_POINTS.FORM_FEED;
  }
  function isEntityInAttributeInvalidEnd2(nextCp) {
    return nextCp === CODE_POINTS.EQUALS_SIGN || isAsciiAlphaNumeric2(nextCp);
  }
  function isScriptDataDoubleEscapeSequenceEnd(cp) {
    return isWhitespace(cp) || cp === CODE_POINTS.SOLIDUS || cp === CODE_POINTS.GREATER_THAN_SIGN;
  }
  var Tokenizer = class {
    constructor(options2, handler) {
      this.options = options2;
      this.handler = handler;
      this.paused = false;
      this.inLoop = false;
      this.inForeignNode = false;
      this.lastStartTagName = "";
      this.active = false;
      this.state = State2.DATA;
      this.returnState = State2.DATA;
      this.charRefCode = -1;
      this.consumedAfterSnapshot = -1;
      this.currentCharacterToken = null;
      this.currentToken = null;
      this.currentAttr = { name: "", value: "" };
      this.preprocessor = new Preprocessor(handler);
      this.currentLocation = this.getCurrentLocation(-1);
    }
    //Errors
    _err(code) {
      var _a2, _b;
      (_b = (_a2 = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a2, this.preprocessor.getError(code));
    }
    // NOTE: `offset` may never run across line boundaries.
    getCurrentLocation(offset) {
      if (!this.options.sourceCodeLocationInfo) {
        return null;
      }
      return {
        startLine: this.preprocessor.line,
        startCol: this.preprocessor.col - offset,
        startOffset: this.preprocessor.offset - offset,
        endLine: -1,
        endCol: -1,
        endOffset: -1
      };
    }
    _runParsingLoop() {
      if (this.inLoop)
        return;
      this.inLoop = true;
      while (this.active && !this.paused) {
        this.consumedAfterSnapshot = 0;
        const cp = this._consume();
        if (!this._ensureHibernation()) {
          this._callState(cp);
        }
      }
      this.inLoop = false;
    }
    //API
    pause() {
      this.paused = true;
    }
    resume(writeCallback) {
      if (!this.paused) {
        throw new Error("Parser was already resumed");
      }
      this.paused = false;
      if (this.inLoop)
        return;
      this._runParsingLoop();
      if (!this.paused) {
        writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
      }
    }
    write(chunk, isLastChunk, writeCallback) {
      this.active = true;
      this.preprocessor.write(chunk, isLastChunk);
      this._runParsingLoop();
      if (!this.paused) {
        writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
      }
    }
    insertHtmlAtCurrentPos(chunk) {
      this.active = true;
      this.preprocessor.insertHtmlAtCurrentPos(chunk);
      this._runParsingLoop();
    }
    //Hibernation
    _ensureHibernation() {
      if (this.preprocessor.endOfChunkHit) {
        this._unconsume(this.consumedAfterSnapshot);
        this.active = false;
        return true;
      }
      return false;
    }
    //Consumption
    _consume() {
      this.consumedAfterSnapshot++;
      return this.preprocessor.advance();
    }
    _unconsume(count) {
      this.consumedAfterSnapshot -= count;
      this.preprocessor.retreat(count);
    }
    _reconsumeInState(state, cp) {
      this.state = state;
      this._callState(cp);
    }
    _advanceBy(count) {
      this.consumedAfterSnapshot += count;
      for (let i = 0; i < count; i++) {
        this.preprocessor.advance();
      }
    }
    _consumeSequenceIfMatch(pattern, caseSensitive) {
      if (this.preprocessor.startsWith(pattern, caseSensitive)) {
        this._advanceBy(pattern.length - 1);
        return true;
      }
      return false;
    }
    //Token creation
    _createStartTagToken() {
      this.currentToken = {
        type: TokenType.START_TAG,
        tagName: "",
        tagID: TAG_ID.UNKNOWN,
        selfClosing: false,
        ackSelfClosing: false,
        attrs: [],
        location: this.getCurrentLocation(1)
      };
    }
    _createEndTagToken() {
      this.currentToken = {
        type: TokenType.END_TAG,
        tagName: "",
        tagID: TAG_ID.UNKNOWN,
        selfClosing: false,
        ackSelfClosing: false,
        attrs: [],
        location: this.getCurrentLocation(2)
      };
    }
    _createCommentToken(offset) {
      this.currentToken = {
        type: TokenType.COMMENT,
        data: "",
        location: this.getCurrentLocation(offset)
      };
    }
    _createDoctypeToken(initialName) {
      this.currentToken = {
        type: TokenType.DOCTYPE,
        name: initialName,
        forceQuirks: false,
        publicId: null,
        systemId: null,
        location: this.currentLocation
      };
    }
    _createCharacterToken(type, chars) {
      this.currentCharacterToken = {
        type,
        chars,
        location: this.currentLocation
      };
    }
    //Tag attributes
    _createAttr(attrNameFirstCh) {
      this.currentAttr = {
        name: attrNameFirstCh,
        value: ""
      };
      this.currentLocation = this.getCurrentLocation(0);
    }
    _leaveAttrName() {
      var _a2;
      var _b;
      const token = this.currentToken;
      if (getTokenAttr(token, this.currentAttr.name) === null) {
        token.attrs.push(this.currentAttr);
        if (token.location && this.currentLocation) {
          const attrLocations = (_a2 = (_b = token.location).attrs) !== null && _a2 !== void 0 ? _a2 : _b.attrs = /* @__PURE__ */ Object.create(null);
          attrLocations[this.currentAttr.name] = this.currentLocation;
          this._leaveAttrValue();
        }
      } else {
        this._err(ERR.duplicateAttribute);
      }
    }
    _leaveAttrValue() {
      if (this.currentLocation) {
        this.currentLocation.endLine = this.preprocessor.line;
        this.currentLocation.endCol = this.preprocessor.col;
        this.currentLocation.endOffset = this.preprocessor.offset;
      }
    }
    //Token emission
    prepareToken(ct) {
      this._emitCurrentCharacterToken(ct.location);
      this.currentToken = null;
      if (ct.location) {
        ct.location.endLine = this.preprocessor.line;
        ct.location.endCol = this.preprocessor.col + 1;
        ct.location.endOffset = this.preprocessor.offset + 1;
      }
      this.currentLocation = this.getCurrentLocation(-1);
    }
    emitCurrentTagToken() {
      const ct = this.currentToken;
      this.prepareToken(ct);
      ct.tagID = getTagID(ct.tagName);
      if (ct.type === TokenType.START_TAG) {
        this.lastStartTagName = ct.tagName;
        this.handler.onStartTag(ct);
      } else {
        if (ct.attrs.length > 0) {
          this._err(ERR.endTagWithAttributes);
        }
        if (ct.selfClosing) {
          this._err(ERR.endTagWithTrailingSolidus);
        }
        this.handler.onEndTag(ct);
      }
      this.preprocessor.dropParsedChunk();
    }
    emitCurrentComment(ct) {
      this.prepareToken(ct);
      this.handler.onComment(ct);
      this.preprocessor.dropParsedChunk();
    }
    emitCurrentDoctype(ct) {
      this.prepareToken(ct);
      this.handler.onDoctype(ct);
      this.preprocessor.dropParsedChunk();
    }
    _emitCurrentCharacterToken(nextLocation) {
      if (this.currentCharacterToken) {
        if (nextLocation && this.currentCharacterToken.location) {
          this.currentCharacterToken.location.endLine = nextLocation.startLine;
          this.currentCharacterToken.location.endCol = nextLocation.startCol;
          this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
        }
        switch (this.currentCharacterToken.type) {
          case TokenType.CHARACTER: {
            this.handler.onCharacter(this.currentCharacterToken);
            break;
          }
          case TokenType.NULL_CHARACTER: {
            this.handler.onNullCharacter(this.currentCharacterToken);
            break;
          }
          case TokenType.WHITESPACE_CHARACTER: {
            this.handler.onWhitespaceCharacter(this.currentCharacterToken);
            break;
          }
        }
        this.currentCharacterToken = null;
      }
    }
    _emitEOFToken() {
      const location2 = this.getCurrentLocation(0);
      if (location2) {
        location2.endLine = location2.startLine;
        location2.endCol = location2.startCol;
        location2.endOffset = location2.startOffset;
      }
      this._emitCurrentCharacterToken(location2);
      this.handler.onEof({ type: TokenType.EOF, location: location2 });
      this.active = false;
    }
    //Characters emission
    //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
    //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
    //If we have a sequence of characters that belong to the same group, the parser can process it
    //as a single solid character token.
    //So, there are 3 types of character tokens in parse5:
    //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
    //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
    //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
    _appendCharToCurrentCharacterToken(type, ch) {
      if (this.currentCharacterToken) {
        if (this.currentCharacterToken.type !== type) {
          this.currentLocation = this.getCurrentLocation(0);
          this._emitCurrentCharacterToken(this.currentLocation);
          this.preprocessor.dropParsedChunk();
        } else {
          this.currentCharacterToken.chars += ch;
          return;
        }
      }
      this._createCharacterToken(type, ch);
    }
    _emitCodePoint(cp) {
      const type = isWhitespace(cp) ? TokenType.WHITESPACE_CHARACTER : cp === CODE_POINTS.NULL ? TokenType.NULL_CHARACTER : TokenType.CHARACTER;
      this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));
    }
    //NOTE: used when we emit characters explicitly.
    //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
    _emitChars(ch) {
      this._appendCharToCurrentCharacterToken(TokenType.CHARACTER, ch);
    }
    // Character reference helpers
    _matchNamedCharacterReference(cp) {
      let result = null;
      let excess = 0;
      let withoutSemicolon = false;
      for (let i = 0, current = decode_data_html_default[0]; i >= 0; cp = this._consume()) {
        i = determineBranch(decode_data_html_default, current, i + 1, cp);
        if (i < 0)
          break;
        excess += 1;
        current = decode_data_html_default[i];
        const masked = current & BinTrieFlags.VALUE_LENGTH;
        if (masked) {
          const valueLength = (masked >> 14) - 1;
          if (cp !== CODE_POINTS.SEMICOLON && this._isCharacterReferenceInAttribute() && isEntityInAttributeInvalidEnd2(this.preprocessor.peek(1))) {
            result = [CODE_POINTS.AMPERSAND];
            i += valueLength;
          } else {
            result = valueLength === 0 ? [decode_data_html_default[i] & ~BinTrieFlags.VALUE_LENGTH] : valueLength === 1 ? [decode_data_html_default[++i]] : [decode_data_html_default[++i], decode_data_html_default[++i]];
            excess = 0;
            withoutSemicolon = cp !== CODE_POINTS.SEMICOLON;
          }
          if (valueLength === 0) {
            this._consume();
            break;
          }
        }
      }
      this._unconsume(excess);
      if (withoutSemicolon && !this.preprocessor.endOfChunkHit) {
        this._err(ERR.missingSemicolonAfterCharacterReference);
      }
      this._unconsume(1);
      return result;
    }
    _isCharacterReferenceInAttribute() {
      return this.returnState === State2.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State2.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State2.ATTRIBUTE_VALUE_UNQUOTED;
    }
    _flushCodePointConsumedAsCharacterReference(cp) {
      if (this._isCharacterReferenceInAttribute()) {
        this.currentAttr.value += String.fromCodePoint(cp);
      } else {
        this._emitCodePoint(cp);
      }
    }
    // Calling states this way turns out to be much faster than any other approach.
    _callState(cp) {
      switch (this.state) {
        case State2.DATA: {
          this._stateData(cp);
          break;
        }
        case State2.RCDATA: {
          this._stateRcdata(cp);
          break;
        }
        case State2.RAWTEXT: {
          this._stateRawtext(cp);
          break;
        }
        case State2.SCRIPT_DATA: {
          this._stateScriptData(cp);
          break;
        }
        case State2.PLAINTEXT: {
          this._statePlaintext(cp);
          break;
        }
        case State2.TAG_OPEN: {
          this._stateTagOpen(cp);
          break;
        }
        case State2.END_TAG_OPEN: {
          this._stateEndTagOpen(cp);
          break;
        }
        case State2.TAG_NAME: {
          this._stateTagName(cp);
          break;
        }
        case State2.RCDATA_LESS_THAN_SIGN: {
          this._stateRcdataLessThanSign(cp);
          break;
        }
        case State2.RCDATA_END_TAG_OPEN: {
          this._stateRcdataEndTagOpen(cp);
          break;
        }
        case State2.RCDATA_END_TAG_NAME: {
          this._stateRcdataEndTagName(cp);
          break;
        }
        case State2.RAWTEXT_LESS_THAN_SIGN: {
          this._stateRawtextLessThanSign(cp);
          break;
        }
        case State2.RAWTEXT_END_TAG_OPEN: {
          this._stateRawtextEndTagOpen(cp);
          break;
        }
        case State2.RAWTEXT_END_TAG_NAME: {
          this._stateRawtextEndTagName(cp);
          break;
        }
        case State2.SCRIPT_DATA_LESS_THAN_SIGN: {
          this._stateScriptDataLessThanSign(cp);
          break;
        }
        case State2.SCRIPT_DATA_END_TAG_OPEN: {
          this._stateScriptDataEndTagOpen(cp);
          break;
        }
        case State2.SCRIPT_DATA_END_TAG_NAME: {
          this._stateScriptDataEndTagName(cp);
          break;
        }
        case State2.SCRIPT_DATA_ESCAPE_START: {
          this._stateScriptDataEscapeStart(cp);
          break;
        }
        case State2.SCRIPT_DATA_ESCAPE_START_DASH: {
          this._stateScriptDataEscapeStartDash(cp);
          break;
        }
        case State2.SCRIPT_DATA_ESCAPED: {
          this._stateScriptDataEscaped(cp);
          break;
        }
        case State2.SCRIPT_DATA_ESCAPED_DASH: {
          this._stateScriptDataEscapedDash(cp);
          break;
        }
        case State2.SCRIPT_DATA_ESCAPED_DASH_DASH: {
          this._stateScriptDataEscapedDashDash(cp);
          break;
        }
        case State2.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
          this._stateScriptDataEscapedLessThanSign(cp);
          break;
        }
        case State2.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
          this._stateScriptDataEscapedEndTagOpen(cp);
          break;
        }
        case State2.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
          this._stateScriptDataEscapedEndTagName(cp);
          break;
        }
        case State2.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
          this._stateScriptDataDoubleEscapeStart(cp);
          break;
        }
        case State2.SCRIPT_DATA_DOUBLE_ESCAPED: {
          this._stateScriptDataDoubleEscaped(cp);
          break;
        }
        case State2.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
          this._stateScriptDataDoubleEscapedDash(cp);
          break;
        }
        case State2.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
          this._stateScriptDataDoubleEscapedDashDash(cp);
          break;
        }
        case State2.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
          this._stateScriptDataDoubleEscapedLessThanSign(cp);
          break;
        }
        case State2.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
          this._stateScriptDataDoubleEscapeEnd(cp);
          break;
        }
        case State2.BEFORE_ATTRIBUTE_NAME: {
          this._stateBeforeAttributeName(cp);
          break;
        }
        case State2.ATTRIBUTE_NAME: {
          this._stateAttributeName(cp);
          break;
        }
        case State2.AFTER_ATTRIBUTE_NAME: {
          this._stateAfterAttributeName(cp);
          break;
        }
        case State2.BEFORE_ATTRIBUTE_VALUE: {
          this._stateBeforeAttributeValue(cp);
          break;
        }
        case State2.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
          this._stateAttributeValueDoubleQuoted(cp);
          break;
        }
        case State2.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
          this._stateAttributeValueSingleQuoted(cp);
          break;
        }
        case State2.ATTRIBUTE_VALUE_UNQUOTED: {
          this._stateAttributeValueUnquoted(cp);
          break;
        }
        case State2.AFTER_ATTRIBUTE_VALUE_QUOTED: {
          this._stateAfterAttributeValueQuoted(cp);
          break;
        }
        case State2.SELF_CLOSING_START_TAG: {
          this._stateSelfClosingStartTag(cp);
          break;
        }
        case State2.BOGUS_COMMENT: {
          this._stateBogusComment(cp);
          break;
        }
        case State2.MARKUP_DECLARATION_OPEN: {
          this._stateMarkupDeclarationOpen(cp);
          break;
        }
        case State2.COMMENT_START: {
          this._stateCommentStart(cp);
          break;
        }
        case State2.COMMENT_START_DASH: {
          this._stateCommentStartDash(cp);
          break;
        }
        case State2.COMMENT: {
          this._stateComment(cp);
          break;
        }
        case State2.COMMENT_LESS_THAN_SIGN: {
          this._stateCommentLessThanSign(cp);
          break;
        }
        case State2.COMMENT_LESS_THAN_SIGN_BANG: {
          this._stateCommentLessThanSignBang(cp);
          break;
        }
        case State2.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
          this._stateCommentLessThanSignBangDash(cp);
          break;
        }
        case State2.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
          this._stateCommentLessThanSignBangDashDash(cp);
          break;
        }
        case State2.COMMENT_END_DASH: {
          this._stateCommentEndDash(cp);
          break;
        }
        case State2.COMMENT_END: {
          this._stateCommentEnd(cp);
          break;
        }
        case State2.COMMENT_END_BANG: {
          this._stateCommentEndBang(cp);
          break;
        }
        case State2.DOCTYPE: {
          this._stateDoctype(cp);
          break;
        }
        case State2.BEFORE_DOCTYPE_NAME: {
          this._stateBeforeDoctypeName(cp);
          break;
        }
        case State2.DOCTYPE_NAME: {
          this._stateDoctypeName(cp);
          break;
        }
        case State2.AFTER_DOCTYPE_NAME: {
          this._stateAfterDoctypeName(cp);
          break;
        }
        case State2.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
          this._stateAfterDoctypePublicKeyword(cp);
          break;
        }
        case State2.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
          this._stateBeforeDoctypePublicIdentifier(cp);
          break;
        }
        case State2.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
          this._stateDoctypePublicIdentifierDoubleQuoted(cp);
          break;
        }
        case State2.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
          this._stateDoctypePublicIdentifierSingleQuoted(cp);
          break;
        }
        case State2.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
          this._stateAfterDoctypePublicIdentifier(cp);
          break;
        }
        case State2.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
          this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
          break;
        }
        case State2.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
          this._stateAfterDoctypeSystemKeyword(cp);
          break;
        }
        case State2.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
          this._stateBeforeDoctypeSystemIdentifier(cp);
          break;
        }
        case State2.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
          this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
          break;
        }
        case State2.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
          this._stateDoctypeSystemIdentifierSingleQuoted(cp);
          break;
        }
        case State2.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
          this._stateAfterDoctypeSystemIdentifier(cp);
          break;
        }
        case State2.BOGUS_DOCTYPE: {
          this._stateBogusDoctype(cp);
          break;
        }
        case State2.CDATA_SECTION: {
          this._stateCdataSection(cp);
          break;
        }
        case State2.CDATA_SECTION_BRACKET: {
          this._stateCdataSectionBracket(cp);
          break;
        }
        case State2.CDATA_SECTION_END: {
          this._stateCdataSectionEnd(cp);
          break;
        }
        case State2.CHARACTER_REFERENCE: {
          this._stateCharacterReference(cp);
          break;
        }
        case State2.NAMED_CHARACTER_REFERENCE: {
          this._stateNamedCharacterReference(cp);
          break;
        }
        case State2.AMBIGUOUS_AMPERSAND: {
          this._stateAmbiguousAmpersand(cp);
          break;
        }
        case State2.NUMERIC_CHARACTER_REFERENCE: {
          this._stateNumericCharacterReference(cp);
          break;
        }
        case State2.HEXADEMICAL_CHARACTER_REFERENCE_START: {
          this._stateHexademicalCharacterReferenceStart(cp);
          break;
        }
        case State2.HEXADEMICAL_CHARACTER_REFERENCE: {
          this._stateHexademicalCharacterReference(cp);
          break;
        }
        case State2.DECIMAL_CHARACTER_REFERENCE: {
          this._stateDecimalCharacterReference(cp);
          break;
        }
        case State2.NUMERIC_CHARACTER_REFERENCE_END: {
          this._stateNumericCharacterReferenceEnd(cp);
          break;
        }
        default: {
          throw new Error("Unknown state");
        }
      }
    }
    // State machine
    // Data state
    //------------------------------------------------------------------
    _stateData(cp) {
      switch (cp) {
        case CODE_POINTS.LESS_THAN_SIGN: {
          this.state = State2.TAG_OPEN;
          break;
        }
        case CODE_POINTS.AMPERSAND: {
          this.returnState = State2.DATA;
          this.state = State2.CHARACTER_REFERENCE;
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this._emitCodePoint(cp);
          break;
        }
        case CODE_POINTS.EOF: {
          this._emitEOFToken();
          break;
        }
        default: {
          this._emitCodePoint(cp);
        }
      }
    }
    //  RCDATA state
    //------------------------------------------------------------------
    _stateRcdata(cp) {
      switch (cp) {
        case CODE_POINTS.AMPERSAND: {
          this.returnState = State2.RCDATA;
          this.state = State2.CHARACTER_REFERENCE;
          break;
        }
        case CODE_POINTS.LESS_THAN_SIGN: {
          this.state = State2.RCDATA_LESS_THAN_SIGN;
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this._emitChars(REPLACEMENT_CHARACTER);
          break;
        }
        case CODE_POINTS.EOF: {
          this._emitEOFToken();
          break;
        }
        default: {
          this._emitCodePoint(cp);
        }
      }
    }
    // RAWTEXT state
    //------------------------------------------------------------------
    _stateRawtext(cp) {
      switch (cp) {
        case CODE_POINTS.LESS_THAN_SIGN: {
          this.state = State2.RAWTEXT_LESS_THAN_SIGN;
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this._emitChars(REPLACEMENT_CHARACTER);
          break;
        }
        case CODE_POINTS.EOF: {
          this._emitEOFToken();
          break;
        }
        default: {
          this._emitCodePoint(cp);
        }
      }
    }
    // Script data state
    //------------------------------------------------------------------
    _stateScriptData(cp) {
      switch (cp) {
        case CODE_POINTS.LESS_THAN_SIGN: {
          this.state = State2.SCRIPT_DATA_LESS_THAN_SIGN;
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this._emitChars(REPLACEMENT_CHARACTER);
          break;
        }
        case CODE_POINTS.EOF: {
          this._emitEOFToken();
          break;
        }
        default: {
          this._emitCodePoint(cp);
        }
      }
    }
    // PLAINTEXT state
    //------------------------------------------------------------------
    _statePlaintext(cp) {
      switch (cp) {
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this._emitChars(REPLACEMENT_CHARACTER);
          break;
        }
        case CODE_POINTS.EOF: {
          this._emitEOFToken();
          break;
        }
        default: {
          this._emitCodePoint(cp);
        }
      }
    }
    // Tag open state
    //------------------------------------------------------------------
    _stateTagOpen(cp) {
      if (isAsciiLetter(cp)) {
        this._createStartTagToken();
        this.state = State2.TAG_NAME;
        this._stateTagName(cp);
      } else
        switch (cp) {
          case CODE_POINTS.EXCLAMATION_MARK: {
            this.state = State2.MARKUP_DECLARATION_OPEN;
            break;
          }
          case CODE_POINTS.SOLIDUS: {
            this.state = State2.END_TAG_OPEN;
            break;
          }
          case CODE_POINTS.QUESTION_MARK: {
            this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
            this._createCommentToken(1);
            this.state = State2.BOGUS_COMMENT;
            this._stateBogusComment(cp);
            break;
          }
          case CODE_POINTS.EOF: {
            this._err(ERR.eofBeforeTagName);
            this._emitChars("<");
            this._emitEOFToken();
            break;
          }
          default: {
            this._err(ERR.invalidFirstCharacterOfTagName);
            this._emitChars("<");
            this.state = State2.DATA;
            this._stateData(cp);
          }
        }
    }
    // End tag open state
    //------------------------------------------------------------------
    _stateEndTagOpen(cp) {
      if (isAsciiLetter(cp)) {
        this._createEndTagToken();
        this.state = State2.TAG_NAME;
        this._stateTagName(cp);
      } else
        switch (cp) {
          case CODE_POINTS.GREATER_THAN_SIGN: {
            this._err(ERR.missingEndTagName);
            this.state = State2.DATA;
            break;
          }
          case CODE_POINTS.EOF: {
            this._err(ERR.eofBeforeTagName);
            this._emitChars("</");
            this._emitEOFToken();
            break;
          }
          default: {
            this._err(ERR.invalidFirstCharacterOfTagName);
            this._createCommentToken(2);
            this.state = State2.BOGUS_COMMENT;
            this._stateBogusComment(cp);
          }
        }
    }
    // Tag name state
    //------------------------------------------------------------------
    _stateTagName(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          this.state = State2.BEFORE_ATTRIBUTE_NAME;
          break;
        }
        case CODE_POINTS.SOLIDUS: {
          this.state = State2.SELF_CLOSING_START_TAG;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this.state = State2.DATA;
          this.emitCurrentTagToken();
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          token.tagName += REPLACEMENT_CHARACTER;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInTag);
          this._emitEOFToken();
          break;
        }
        default: {
          token.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
        }
      }
    }
    // RCDATA less-than sign state
    //------------------------------------------------------------------
    _stateRcdataLessThanSign(cp) {
      if (cp === CODE_POINTS.SOLIDUS) {
        this.state = State2.RCDATA_END_TAG_OPEN;
      } else {
        this._emitChars("<");
        this.state = State2.RCDATA;
        this._stateRcdata(cp);
      }
    }
    // RCDATA end tag open state
    //------------------------------------------------------------------
    _stateRcdataEndTagOpen(cp) {
      if (isAsciiLetter(cp)) {
        this.state = State2.RCDATA_END_TAG_NAME;
        this._stateRcdataEndTagName(cp);
      } else {
        this._emitChars("</");
        this.state = State2.RCDATA;
        this._stateRcdata(cp);
      }
    }
    handleSpecialEndTag(_cp) {
      if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
        return !this._ensureHibernation();
      }
      this._createEndTagToken();
      const token = this.currentToken;
      token.tagName = this.lastStartTagName;
      const cp = this.preprocessor.peek(this.lastStartTagName.length);
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          this._advanceBy(this.lastStartTagName.length);
          this.state = State2.BEFORE_ATTRIBUTE_NAME;
          return false;
        }
        case CODE_POINTS.SOLIDUS: {
          this._advanceBy(this.lastStartTagName.length);
          this.state = State2.SELF_CLOSING_START_TAG;
          return false;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._advanceBy(this.lastStartTagName.length);
          this.emitCurrentTagToken();
          this.state = State2.DATA;
          return false;
        }
        default: {
          return !this._ensureHibernation();
        }
      }
    }
    // RCDATA end tag name state
    //------------------------------------------------------------------
    _stateRcdataEndTagName(cp) {
      if (this.handleSpecialEndTag(cp)) {
        this._emitChars("</");
        this.state = State2.RCDATA;
        this._stateRcdata(cp);
      }
    }
    // RAWTEXT less-than sign state
    //------------------------------------------------------------------
    _stateRawtextLessThanSign(cp) {
      if (cp === CODE_POINTS.SOLIDUS) {
        this.state = State2.RAWTEXT_END_TAG_OPEN;
      } else {
        this._emitChars("<");
        this.state = State2.RAWTEXT;
        this._stateRawtext(cp);
      }
    }
    // RAWTEXT end tag open state
    //------------------------------------------------------------------
    _stateRawtextEndTagOpen(cp) {
      if (isAsciiLetter(cp)) {
        this.state = State2.RAWTEXT_END_TAG_NAME;
        this._stateRawtextEndTagName(cp);
      } else {
        this._emitChars("</");
        this.state = State2.RAWTEXT;
        this._stateRawtext(cp);
      }
    }
    // RAWTEXT end tag name state
    //------------------------------------------------------------------
    _stateRawtextEndTagName(cp) {
      if (this.handleSpecialEndTag(cp)) {
        this._emitChars("</");
        this.state = State2.RAWTEXT;
        this._stateRawtext(cp);
      }
    }
    // Script data less-than sign state
    //------------------------------------------------------------------
    _stateScriptDataLessThanSign(cp) {
      switch (cp) {
        case CODE_POINTS.SOLIDUS: {
          this.state = State2.SCRIPT_DATA_END_TAG_OPEN;
          break;
        }
        case CODE_POINTS.EXCLAMATION_MARK: {
          this.state = State2.SCRIPT_DATA_ESCAPE_START;
          this._emitChars("<!");
          break;
        }
        default: {
          this._emitChars("<");
          this.state = State2.SCRIPT_DATA;
          this._stateScriptData(cp);
        }
      }
    }
    // Script data end tag open state
    //------------------------------------------------------------------
    _stateScriptDataEndTagOpen(cp) {
      if (isAsciiLetter(cp)) {
        this.state = State2.SCRIPT_DATA_END_TAG_NAME;
        this._stateScriptDataEndTagName(cp);
      } else {
        this._emitChars("</");
        this.state = State2.SCRIPT_DATA;
        this._stateScriptData(cp);
      }
    }
    // Script data end tag name state
    //------------------------------------------------------------------
    _stateScriptDataEndTagName(cp) {
      if (this.handleSpecialEndTag(cp)) {
        this._emitChars("</");
        this.state = State2.SCRIPT_DATA;
        this._stateScriptData(cp);
      }
    }
    // Script data escape start state
    //------------------------------------------------------------------
    _stateScriptDataEscapeStart(cp) {
      if (cp === CODE_POINTS.HYPHEN_MINUS) {
        this.state = State2.SCRIPT_DATA_ESCAPE_START_DASH;
        this._emitChars("-");
      } else {
        this.state = State2.SCRIPT_DATA;
        this._stateScriptData(cp);
      }
    }
    // Script data escape start dash state
    //------------------------------------------------------------------
    _stateScriptDataEscapeStartDash(cp) {
      if (cp === CODE_POINTS.HYPHEN_MINUS) {
        this.state = State2.SCRIPT_DATA_ESCAPED_DASH_DASH;
        this._emitChars("-");
      } else {
        this.state = State2.SCRIPT_DATA;
        this._stateScriptData(cp);
      }
    }
    // Script data escaped state
    //------------------------------------------------------------------
    _stateScriptDataEscaped(cp) {
      switch (cp) {
        case CODE_POINTS.HYPHEN_MINUS: {
          this.state = State2.SCRIPT_DATA_ESCAPED_DASH;
          this._emitChars("-");
          break;
        }
        case CODE_POINTS.LESS_THAN_SIGN: {
          this.state = State2.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this._emitChars(REPLACEMENT_CHARACTER);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
          break;
        }
        default: {
          this._emitCodePoint(cp);
        }
      }
    }
    // Script data escaped dash state
    //------------------------------------------------------------------
    _stateScriptDataEscapedDash(cp) {
      switch (cp) {
        case CODE_POINTS.HYPHEN_MINUS: {
          this.state = State2.SCRIPT_DATA_ESCAPED_DASH_DASH;
          this._emitChars("-");
          break;
        }
        case CODE_POINTS.LESS_THAN_SIGN: {
          this.state = State2.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this.state = State2.SCRIPT_DATA_ESCAPED;
          this._emitChars(REPLACEMENT_CHARACTER);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
          break;
        }
        default: {
          this.state = State2.SCRIPT_DATA_ESCAPED;
          this._emitCodePoint(cp);
        }
      }
    }
    // Script data escaped dash dash state
    //------------------------------------------------------------------
    _stateScriptDataEscapedDashDash(cp) {
      switch (cp) {
        case CODE_POINTS.HYPHEN_MINUS: {
          this._emitChars("-");
          break;
        }
        case CODE_POINTS.LESS_THAN_SIGN: {
          this.state = State2.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this.state = State2.SCRIPT_DATA;
          this._emitChars(">");
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this.state = State2.SCRIPT_DATA_ESCAPED;
          this._emitChars(REPLACEMENT_CHARACTER);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
          break;
        }
        default: {
          this.state = State2.SCRIPT_DATA_ESCAPED;
          this._emitCodePoint(cp);
        }
      }
    }
    // Script data escaped less-than sign state
    //------------------------------------------------------------------
    _stateScriptDataEscapedLessThanSign(cp) {
      if (cp === CODE_POINTS.SOLIDUS) {
        this.state = State2.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
      } else if (isAsciiLetter(cp)) {
        this._emitChars("<");
        this.state = State2.SCRIPT_DATA_DOUBLE_ESCAPE_START;
        this._stateScriptDataDoubleEscapeStart(cp);
      } else {
        this._emitChars("<");
        this.state = State2.SCRIPT_DATA_ESCAPED;
        this._stateScriptDataEscaped(cp);
      }
    }
    // Script data escaped end tag open state
    //------------------------------------------------------------------
    _stateScriptDataEscapedEndTagOpen(cp) {
      if (isAsciiLetter(cp)) {
        this.state = State2.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
        this._stateScriptDataEscapedEndTagName(cp);
      } else {
        this._emitChars("</");
        this.state = State2.SCRIPT_DATA_ESCAPED;
        this._stateScriptDataEscaped(cp);
      }
    }
    // Script data escaped end tag name state
    //------------------------------------------------------------------
    _stateScriptDataEscapedEndTagName(cp) {
      if (this.handleSpecialEndTag(cp)) {
        this._emitChars("</");
        this.state = State2.SCRIPT_DATA_ESCAPED;
        this._stateScriptDataEscaped(cp);
      }
    }
    // Script data double escape start state
    //------------------------------------------------------------------
    _stateScriptDataDoubleEscapeStart(cp) {
      if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
        this._emitCodePoint(cp);
        for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
          this._emitCodePoint(this._consume());
        }
        this.state = State2.SCRIPT_DATA_DOUBLE_ESCAPED;
      } else if (!this._ensureHibernation()) {
        this.state = State2.SCRIPT_DATA_ESCAPED;
        this._stateScriptDataEscaped(cp);
      }
    }
    // Script data double escaped state
    //------------------------------------------------------------------
    _stateScriptDataDoubleEscaped(cp) {
      switch (cp) {
        case CODE_POINTS.HYPHEN_MINUS: {
          this.state = State2.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
          this._emitChars("-");
          break;
        }
        case CODE_POINTS.LESS_THAN_SIGN: {
          this.state = State2.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
          this._emitChars("<");
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this._emitChars(REPLACEMENT_CHARACTER);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
          break;
        }
        default: {
          this._emitCodePoint(cp);
        }
      }
    }
    // Script data double escaped dash state
    //------------------------------------------------------------------
    _stateScriptDataDoubleEscapedDash(cp) {
      switch (cp) {
        case CODE_POINTS.HYPHEN_MINUS: {
          this.state = State2.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
          this._emitChars("-");
          break;
        }
        case CODE_POINTS.LESS_THAN_SIGN: {
          this.state = State2.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
          this._emitChars("<");
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this.state = State2.SCRIPT_DATA_DOUBLE_ESCAPED;
          this._emitChars(REPLACEMENT_CHARACTER);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
          break;
        }
        default: {
          this.state = State2.SCRIPT_DATA_DOUBLE_ESCAPED;
          this._emitCodePoint(cp);
        }
      }
    }
    // Script data double escaped dash dash state
    //------------------------------------------------------------------
    _stateScriptDataDoubleEscapedDashDash(cp) {
      switch (cp) {
        case CODE_POINTS.HYPHEN_MINUS: {
          this._emitChars("-");
          break;
        }
        case CODE_POINTS.LESS_THAN_SIGN: {
          this.state = State2.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
          this._emitChars("<");
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this.state = State2.SCRIPT_DATA;
          this._emitChars(">");
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this.state = State2.SCRIPT_DATA_DOUBLE_ESCAPED;
          this._emitChars(REPLACEMENT_CHARACTER);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
          break;
        }
        default: {
          this.state = State2.SCRIPT_DATA_DOUBLE_ESCAPED;
          this._emitCodePoint(cp);
        }
      }
    }
    // Script data double escaped less-than sign state
    //------------------------------------------------------------------
    _stateScriptDataDoubleEscapedLessThanSign(cp) {
      if (cp === CODE_POINTS.SOLIDUS) {
        this.state = State2.SCRIPT_DATA_DOUBLE_ESCAPE_END;
        this._emitChars("/");
      } else {
        this.state = State2.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._stateScriptDataDoubleEscaped(cp);
      }
    }
    // Script data double escape end state
    //------------------------------------------------------------------
    _stateScriptDataDoubleEscapeEnd(cp) {
      if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
        this._emitCodePoint(cp);
        for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
          this._emitCodePoint(this._consume());
        }
        this.state = State2.SCRIPT_DATA_ESCAPED;
      } else if (!this._ensureHibernation()) {
        this.state = State2.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._stateScriptDataDoubleEscaped(cp);
      }
    }
    // Before attribute name state
    //------------------------------------------------------------------
    _stateBeforeAttributeName(cp) {
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          break;
        }
        case CODE_POINTS.SOLIDUS:
        case CODE_POINTS.GREATER_THAN_SIGN:
        case CODE_POINTS.EOF: {
          this.state = State2.AFTER_ATTRIBUTE_NAME;
          this._stateAfterAttributeName(cp);
          break;
        }
        case CODE_POINTS.EQUALS_SIGN: {
          this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
          this._createAttr("=");
          this.state = State2.ATTRIBUTE_NAME;
          break;
        }
        default: {
          this._createAttr("");
          this.state = State2.ATTRIBUTE_NAME;
          this._stateAttributeName(cp);
        }
      }
    }
    // Attribute name state
    //------------------------------------------------------------------
    _stateAttributeName(cp) {
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED:
        case CODE_POINTS.SOLIDUS:
        case CODE_POINTS.GREATER_THAN_SIGN:
        case CODE_POINTS.EOF: {
          this._leaveAttrName();
          this.state = State2.AFTER_ATTRIBUTE_NAME;
          this._stateAfterAttributeName(cp);
          break;
        }
        case CODE_POINTS.EQUALS_SIGN: {
          this._leaveAttrName();
          this.state = State2.BEFORE_ATTRIBUTE_VALUE;
          break;
        }
        case CODE_POINTS.QUOTATION_MARK:
        case CODE_POINTS.APOSTROPHE:
        case CODE_POINTS.LESS_THAN_SIGN: {
          this._err(ERR.unexpectedCharacterInAttributeName);
          this.currentAttr.name += String.fromCodePoint(cp);
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this.currentAttr.name += REPLACEMENT_CHARACTER;
          break;
        }
        default: {
          this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
        }
      }
    }
    // After attribute name state
    //------------------------------------------------------------------
    _stateAfterAttributeName(cp) {
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          break;
        }
        case CODE_POINTS.SOLIDUS: {
          this.state = State2.SELF_CLOSING_START_TAG;
          break;
        }
        case CODE_POINTS.EQUALS_SIGN: {
          this.state = State2.BEFORE_ATTRIBUTE_VALUE;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this.state = State2.DATA;
          this.emitCurrentTagToken();
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInTag);
          this._emitEOFToken();
          break;
        }
        default: {
          this._createAttr("");
          this.state = State2.ATTRIBUTE_NAME;
          this._stateAttributeName(cp);
        }
      }
    }
    // Before attribute value state
    //------------------------------------------------------------------
    _stateBeforeAttributeValue(cp) {
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          break;
        }
        case CODE_POINTS.QUOTATION_MARK: {
          this.state = State2.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
          break;
        }
        case CODE_POINTS.APOSTROPHE: {
          this.state = State2.ATTRIBUTE_VALUE_SINGLE_QUOTED;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingAttributeValue);
          this.state = State2.DATA;
          this.emitCurrentTagToken();
          break;
        }
        default: {
          this.state = State2.ATTRIBUTE_VALUE_UNQUOTED;
          this._stateAttributeValueUnquoted(cp);
        }
      }
    }
    // Attribute value (double-quoted) state
    //------------------------------------------------------------------
    _stateAttributeValueDoubleQuoted(cp) {
      switch (cp) {
        case CODE_POINTS.QUOTATION_MARK: {
          this.state = State2.AFTER_ATTRIBUTE_VALUE_QUOTED;
          break;
        }
        case CODE_POINTS.AMPERSAND: {
          this.returnState = State2.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
          this.state = State2.CHARACTER_REFERENCE;
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this.currentAttr.value += REPLACEMENT_CHARACTER;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInTag);
          this._emitEOFToken();
          break;
        }
        default: {
          this.currentAttr.value += String.fromCodePoint(cp);
        }
      }
    }
    // Attribute value (single-quoted) state
    //------------------------------------------------------------------
    _stateAttributeValueSingleQuoted(cp) {
      switch (cp) {
        case CODE_POINTS.APOSTROPHE: {
          this.state = State2.AFTER_ATTRIBUTE_VALUE_QUOTED;
          break;
        }
        case CODE_POINTS.AMPERSAND: {
          this.returnState = State2.ATTRIBUTE_VALUE_SINGLE_QUOTED;
          this.state = State2.CHARACTER_REFERENCE;
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this.currentAttr.value += REPLACEMENT_CHARACTER;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInTag);
          this._emitEOFToken();
          break;
        }
        default: {
          this.currentAttr.value += String.fromCodePoint(cp);
        }
      }
    }
    // Attribute value (unquoted) state
    //------------------------------------------------------------------
    _stateAttributeValueUnquoted(cp) {
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          this._leaveAttrValue();
          this.state = State2.BEFORE_ATTRIBUTE_NAME;
          break;
        }
        case CODE_POINTS.AMPERSAND: {
          this.returnState = State2.ATTRIBUTE_VALUE_UNQUOTED;
          this.state = State2.CHARACTER_REFERENCE;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._leaveAttrValue();
          this.state = State2.DATA;
          this.emitCurrentTagToken();
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this.currentAttr.value += REPLACEMENT_CHARACTER;
          break;
        }
        case CODE_POINTS.QUOTATION_MARK:
        case CODE_POINTS.APOSTROPHE:
        case CODE_POINTS.LESS_THAN_SIGN:
        case CODE_POINTS.EQUALS_SIGN:
        case CODE_POINTS.GRAVE_ACCENT: {
          this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
          this.currentAttr.value += String.fromCodePoint(cp);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInTag);
          this._emitEOFToken();
          break;
        }
        default: {
          this.currentAttr.value += String.fromCodePoint(cp);
        }
      }
    }
    // After attribute value (quoted) state
    //------------------------------------------------------------------
    _stateAfterAttributeValueQuoted(cp) {
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          this._leaveAttrValue();
          this.state = State2.BEFORE_ATTRIBUTE_NAME;
          break;
        }
        case CODE_POINTS.SOLIDUS: {
          this._leaveAttrValue();
          this.state = State2.SELF_CLOSING_START_TAG;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._leaveAttrValue();
          this.state = State2.DATA;
          this.emitCurrentTagToken();
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInTag);
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.missingWhitespaceBetweenAttributes);
          this.state = State2.BEFORE_ATTRIBUTE_NAME;
          this._stateBeforeAttributeName(cp);
        }
      }
    }
    // Self-closing start tag state
    //------------------------------------------------------------------
    _stateSelfClosingStartTag(cp) {
      switch (cp) {
        case CODE_POINTS.GREATER_THAN_SIGN: {
          const token = this.currentToken;
          token.selfClosing = true;
          this.state = State2.DATA;
          this.emitCurrentTagToken();
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInTag);
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.unexpectedSolidusInTag);
          this.state = State2.BEFORE_ATTRIBUTE_NAME;
          this._stateBeforeAttributeName(cp);
        }
      }
    }
    // Bogus comment state
    //------------------------------------------------------------------
    _stateBogusComment(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this.state = State2.DATA;
          this.emitCurrentComment(token);
          break;
        }
        case CODE_POINTS.EOF: {
          this.emitCurrentComment(token);
          this._emitEOFToken();
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          token.data += REPLACEMENT_CHARACTER;
          break;
        }
        default: {
          token.data += String.fromCodePoint(cp);
        }
      }
    }
    // Markup declaration open state
    //------------------------------------------------------------------
    _stateMarkupDeclarationOpen(cp) {
      if (this._consumeSequenceIfMatch(SEQUENCES.DASH_DASH, true)) {
        this._createCommentToken(SEQUENCES.DASH_DASH.length + 1);
        this.state = State2.COMMENT_START;
      } else if (this._consumeSequenceIfMatch(SEQUENCES.DOCTYPE, false)) {
        this.currentLocation = this.getCurrentLocation(SEQUENCES.DOCTYPE.length + 1);
        this.state = State2.DOCTYPE;
      } else if (this._consumeSequenceIfMatch(SEQUENCES.CDATA_START, true)) {
        if (this.inForeignNode) {
          this.state = State2.CDATA_SECTION;
        } else {
          this._err(ERR.cdataInHtmlContent);
          this._createCommentToken(SEQUENCES.CDATA_START.length + 1);
          this.currentToken.data = "[CDATA[";
          this.state = State2.BOGUS_COMMENT;
        }
      } else if (!this._ensureHibernation()) {
        this._err(ERR.incorrectlyOpenedComment);
        this._createCommentToken(2);
        this.state = State2.BOGUS_COMMENT;
        this._stateBogusComment(cp);
      }
    }
    // Comment start state
    //------------------------------------------------------------------
    _stateCommentStart(cp) {
      switch (cp) {
        case CODE_POINTS.HYPHEN_MINUS: {
          this.state = State2.COMMENT_START_DASH;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.abruptClosingOfEmptyComment);
          this.state = State2.DATA;
          const token = this.currentToken;
          this.emitCurrentComment(token);
          break;
        }
        default: {
          this.state = State2.COMMENT;
          this._stateComment(cp);
        }
      }
    }
    // Comment start dash state
    //------------------------------------------------------------------
    _stateCommentStartDash(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.HYPHEN_MINUS: {
          this.state = State2.COMMENT_END;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.abruptClosingOfEmptyComment);
          this.state = State2.DATA;
          this.emitCurrentComment(token);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInComment);
          this.emitCurrentComment(token);
          this._emitEOFToken();
          break;
        }
        default: {
          token.data += "-";
          this.state = State2.COMMENT;
          this._stateComment(cp);
        }
      }
    }
    // Comment state
    //------------------------------------------------------------------
    _stateComment(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.HYPHEN_MINUS: {
          this.state = State2.COMMENT_END_DASH;
          break;
        }
        case CODE_POINTS.LESS_THAN_SIGN: {
          token.data += "<";
          this.state = State2.COMMENT_LESS_THAN_SIGN;
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          token.data += REPLACEMENT_CHARACTER;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInComment);
          this.emitCurrentComment(token);
          this._emitEOFToken();
          break;
        }
        default: {
          token.data += String.fromCodePoint(cp);
        }
      }
    }
    // Comment less-than sign state
    //------------------------------------------------------------------
    _stateCommentLessThanSign(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.EXCLAMATION_MARK: {
          token.data += "!";
          this.state = State2.COMMENT_LESS_THAN_SIGN_BANG;
          break;
        }
        case CODE_POINTS.LESS_THAN_SIGN: {
          token.data += "<";
          break;
        }
        default: {
          this.state = State2.COMMENT;
          this._stateComment(cp);
        }
      }
    }
    // Comment less-than sign bang state
    //------------------------------------------------------------------
    _stateCommentLessThanSignBang(cp) {
      if (cp === CODE_POINTS.HYPHEN_MINUS) {
        this.state = State2.COMMENT_LESS_THAN_SIGN_BANG_DASH;
      } else {
        this.state = State2.COMMENT;
        this._stateComment(cp);
      }
    }
    // Comment less-than sign bang dash state
    //------------------------------------------------------------------
    _stateCommentLessThanSignBangDash(cp) {
      if (cp === CODE_POINTS.HYPHEN_MINUS) {
        this.state = State2.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
      } else {
        this.state = State2.COMMENT_END_DASH;
        this._stateCommentEndDash(cp);
      }
    }
    // Comment less-than sign bang dash dash state
    //------------------------------------------------------------------
    _stateCommentLessThanSignBangDashDash(cp) {
      if (cp !== CODE_POINTS.GREATER_THAN_SIGN && cp !== CODE_POINTS.EOF) {
        this._err(ERR.nestedComment);
      }
      this.state = State2.COMMENT_END;
      this._stateCommentEnd(cp);
    }
    // Comment end dash state
    //------------------------------------------------------------------
    _stateCommentEndDash(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.HYPHEN_MINUS: {
          this.state = State2.COMMENT_END;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInComment);
          this.emitCurrentComment(token);
          this._emitEOFToken();
          break;
        }
        default: {
          token.data += "-";
          this.state = State2.COMMENT;
          this._stateComment(cp);
        }
      }
    }
    // Comment end state
    //------------------------------------------------------------------
    _stateCommentEnd(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this.state = State2.DATA;
          this.emitCurrentComment(token);
          break;
        }
        case CODE_POINTS.EXCLAMATION_MARK: {
          this.state = State2.COMMENT_END_BANG;
          break;
        }
        case CODE_POINTS.HYPHEN_MINUS: {
          token.data += "-";
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInComment);
          this.emitCurrentComment(token);
          this._emitEOFToken();
          break;
        }
        default: {
          token.data += "--";
          this.state = State2.COMMENT;
          this._stateComment(cp);
        }
      }
    }
    // Comment end bang state
    //------------------------------------------------------------------
    _stateCommentEndBang(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.HYPHEN_MINUS: {
          token.data += "--!";
          this.state = State2.COMMENT_END_DASH;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.incorrectlyClosedComment);
          this.state = State2.DATA;
          this.emitCurrentComment(token);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInComment);
          this.emitCurrentComment(token);
          this._emitEOFToken();
          break;
        }
        default: {
          token.data += "--!";
          this.state = State2.COMMENT;
          this._stateComment(cp);
        }
      }
    }
    // DOCTYPE state
    //------------------------------------------------------------------
    _stateDoctype(cp) {
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          this.state = State2.BEFORE_DOCTYPE_NAME;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this.state = State2.BEFORE_DOCTYPE_NAME;
          this._stateBeforeDoctypeName(cp);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.missingWhitespaceBeforeDoctypeName);
          this.state = State2.BEFORE_DOCTYPE_NAME;
          this._stateBeforeDoctypeName(cp);
        }
      }
    }
    // Before DOCTYPE name state
    //------------------------------------------------------------------
    _stateBeforeDoctypeName(cp) {
      if (isAsciiUpper(cp)) {
        this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
        this.state = State2.DOCTYPE_NAME;
      } else
        switch (cp) {
          case CODE_POINTS.SPACE:
          case CODE_POINTS.LINE_FEED:
          case CODE_POINTS.TABULATION:
          case CODE_POINTS.FORM_FEED: {
            break;
          }
          case CODE_POINTS.NULL: {
            this._err(ERR.unexpectedNullCharacter);
            this._createDoctypeToken(REPLACEMENT_CHARACTER);
            this.state = State2.DOCTYPE_NAME;
            break;
          }
          case CODE_POINTS.GREATER_THAN_SIGN: {
            this._err(ERR.missingDoctypeName);
            this._createDoctypeToken(null);
            const token = this.currentToken;
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this.state = State2.DATA;
            break;
          }
          case CODE_POINTS.EOF: {
            this._err(ERR.eofInDoctype);
            this._createDoctypeToken(null);
            const token = this.currentToken;
            token.forceQuirks = true;
            this.emitCurrentDoctype(token);
            this._emitEOFToken();
            break;
          }
          default: {
            this._createDoctypeToken(String.fromCodePoint(cp));
            this.state = State2.DOCTYPE_NAME;
          }
        }
    }
    // DOCTYPE name state
    //------------------------------------------------------------------
    _stateDoctypeName(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          this.state = State2.AFTER_DOCTYPE_NAME;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this.state = State2.DATA;
          this.emitCurrentDoctype(token);
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          token.name += REPLACEMENT_CHARACTER;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          token.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
        }
      }
    }
    // After DOCTYPE name state
    //------------------------------------------------------------------
    _stateAfterDoctypeName(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this.state = State2.DATA;
          this.emitCurrentDoctype(token);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          if (this._consumeSequenceIfMatch(SEQUENCES.PUBLIC, false)) {
            this.state = State2.AFTER_DOCTYPE_PUBLIC_KEYWORD;
          } else if (this._consumeSequenceIfMatch(SEQUENCES.SYSTEM, false)) {
            this.state = State2.AFTER_DOCTYPE_SYSTEM_KEYWORD;
          } else if (!this._ensureHibernation()) {
            this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
            token.forceQuirks = true;
            this.state = State2.BOGUS_DOCTYPE;
            this._stateBogusDoctype(cp);
          }
        }
      }
    }
    // After DOCTYPE public keyword state
    //------------------------------------------------------------------
    _stateAfterDoctypePublicKeyword(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          this.state = State2.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
          break;
        }
        case CODE_POINTS.QUOTATION_MARK: {
          this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
          token.publicId = "";
          this.state = State2.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
          break;
        }
        case CODE_POINTS.APOSTROPHE: {
          this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
          token.publicId = "";
          this.state = State2.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingDoctypePublicIdentifier);
          token.forceQuirks = true;
          this.state = State2.DATA;
          this.emitCurrentDoctype(token);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
          token.forceQuirks = true;
          this.state = State2.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
    // Before DOCTYPE public identifier state
    //------------------------------------------------------------------
    _stateBeforeDoctypePublicIdentifier(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          break;
        }
        case CODE_POINTS.QUOTATION_MARK: {
          token.publicId = "";
          this.state = State2.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
          break;
        }
        case CODE_POINTS.APOSTROPHE: {
          token.publicId = "";
          this.state = State2.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingDoctypePublicIdentifier);
          token.forceQuirks = true;
          this.state = State2.DATA;
          this.emitCurrentDoctype(token);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
          token.forceQuirks = true;
          this.state = State2.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
    // DOCTYPE public identifier (double-quoted) state
    //------------------------------------------------------------------
    _stateDoctypePublicIdentifierDoubleQuoted(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.QUOTATION_MARK: {
          this.state = State2.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          token.publicId += REPLACEMENT_CHARACTER;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.abruptDoctypePublicIdentifier);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State2.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          token.publicId += String.fromCodePoint(cp);
        }
      }
    }
    // DOCTYPE public identifier (single-quoted) state
    //------------------------------------------------------------------
    _stateDoctypePublicIdentifierSingleQuoted(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.APOSTROPHE: {
          this.state = State2.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          token.publicId += REPLACEMENT_CHARACTER;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.abruptDoctypePublicIdentifier);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State2.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          token.publicId += String.fromCodePoint(cp);
        }
      }
    }
    // After DOCTYPE public identifier state
    //------------------------------------------------------------------
    _stateAfterDoctypePublicIdentifier(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          this.state = State2.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this.state = State2.DATA;
          this.emitCurrentDoctype(token);
          break;
        }
        case CODE_POINTS.QUOTATION_MARK: {
          this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
          token.systemId = "";
          this.state = State2.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
          break;
        }
        case CODE_POINTS.APOSTROPHE: {
          this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
          token.systemId = "";
          this.state = State2.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
          token.forceQuirks = true;
          this.state = State2.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
    // Between DOCTYPE public and system identifiers state
    //------------------------------------------------------------------
    _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this.emitCurrentDoctype(token);
          this.state = State2.DATA;
          break;
        }
        case CODE_POINTS.QUOTATION_MARK: {
          token.systemId = "";
          this.state = State2.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
          break;
        }
        case CODE_POINTS.APOSTROPHE: {
          token.systemId = "";
          this.state = State2.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
          token.forceQuirks = true;
          this.state = State2.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
    // After DOCTYPE system keyword state
    //------------------------------------------------------------------
    _stateAfterDoctypeSystemKeyword(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          this.state = State2.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
          break;
        }
        case CODE_POINTS.QUOTATION_MARK: {
          this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
          token.systemId = "";
          this.state = State2.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
          break;
        }
        case CODE_POINTS.APOSTROPHE: {
          this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
          token.systemId = "";
          this.state = State2.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingDoctypeSystemIdentifier);
          token.forceQuirks = true;
          this.state = State2.DATA;
          this.emitCurrentDoctype(token);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
          token.forceQuirks = true;
          this.state = State2.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
    // Before DOCTYPE system identifier state
    //------------------------------------------------------------------
    _stateBeforeDoctypeSystemIdentifier(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          break;
        }
        case CODE_POINTS.QUOTATION_MARK: {
          token.systemId = "";
          this.state = State2.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
          break;
        }
        case CODE_POINTS.APOSTROPHE: {
          token.systemId = "";
          this.state = State2.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingDoctypeSystemIdentifier);
          token.forceQuirks = true;
          this.state = State2.DATA;
          this.emitCurrentDoctype(token);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
          token.forceQuirks = true;
          this.state = State2.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
    // DOCTYPE system identifier (double-quoted) state
    //------------------------------------------------------------------
    _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.QUOTATION_MARK: {
          this.state = State2.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          token.systemId += REPLACEMENT_CHARACTER;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.abruptDoctypeSystemIdentifier);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State2.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          token.systemId += String.fromCodePoint(cp);
        }
      }
    }
    // DOCTYPE system identifier (single-quoted) state
    //------------------------------------------------------------------
    _stateDoctypeSystemIdentifierSingleQuoted(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.APOSTROPHE: {
          this.state = State2.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          token.systemId += REPLACEMENT_CHARACTER;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.abruptDoctypeSystemIdentifier);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State2.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          token.systemId += String.fromCodePoint(cp);
        }
      }
    }
    // After DOCTYPE system identifier state
    //------------------------------------------------------------------
    _stateAfterDoctypeSystemIdentifier(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this.emitCurrentDoctype(token);
          this.state = State2.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
          this.state = State2.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
    // Bogus DOCTYPE state
    //------------------------------------------------------------------
    _stateBogusDoctype(cp) {
      const token = this.currentToken;
      switch (cp) {
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this.emitCurrentDoctype(token);
          this.state = State2.DATA;
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          break;
        }
        case CODE_POINTS.EOF: {
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default:
      }
    }
    // CDATA section state
    //------------------------------------------------------------------
    _stateCdataSection(cp) {
      switch (cp) {
        case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
          this.state = State2.CDATA_SECTION_BRACKET;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInCdata);
          this._emitEOFToken();
          break;
        }
        default: {
          this._emitCodePoint(cp);
        }
      }
    }
    // CDATA section bracket state
    //------------------------------------------------------------------
    _stateCdataSectionBracket(cp) {
      if (cp === CODE_POINTS.RIGHT_SQUARE_BRACKET) {
        this.state = State2.CDATA_SECTION_END;
      } else {
        this._emitChars("]");
        this.state = State2.CDATA_SECTION;
        this._stateCdataSection(cp);
      }
    }
    // CDATA section end state
    //------------------------------------------------------------------
    _stateCdataSectionEnd(cp) {
      switch (cp) {
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this.state = State2.DATA;
          break;
        }
        case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
          this._emitChars("]");
          break;
        }
        default: {
          this._emitChars("]]");
          this.state = State2.CDATA_SECTION;
          this._stateCdataSection(cp);
        }
      }
    }
    // Character reference state
    //------------------------------------------------------------------
    _stateCharacterReference(cp) {
      if (cp === CODE_POINTS.NUMBER_SIGN) {
        this.state = State2.NUMERIC_CHARACTER_REFERENCE;
      } else if (isAsciiAlphaNumeric2(cp)) {
        this.state = State2.NAMED_CHARACTER_REFERENCE;
        this._stateNamedCharacterReference(cp);
      } else {
        this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
        this._reconsumeInState(this.returnState, cp);
      }
    }
    // Named character reference state
    //------------------------------------------------------------------
    _stateNamedCharacterReference(cp) {
      const matchResult = this._matchNamedCharacterReference(cp);
      if (this._ensureHibernation()) {
      } else if (matchResult) {
        for (let i = 0; i < matchResult.length; i++) {
          this._flushCodePointConsumedAsCharacterReference(matchResult[i]);
        }
        this.state = this.returnState;
      } else {
        this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
        this.state = State2.AMBIGUOUS_AMPERSAND;
      }
    }
    // Ambiguos ampersand state
    //------------------------------------------------------------------
    _stateAmbiguousAmpersand(cp) {
      if (isAsciiAlphaNumeric2(cp)) {
        this._flushCodePointConsumedAsCharacterReference(cp);
      } else {
        if (cp === CODE_POINTS.SEMICOLON) {
          this._err(ERR.unknownNamedCharacterReference);
        }
        this._reconsumeInState(this.returnState, cp);
      }
    }
    // Numeric character reference state
    //------------------------------------------------------------------
    _stateNumericCharacterReference(cp) {
      this.charRefCode = 0;
      if (cp === CODE_POINTS.LATIN_SMALL_X || cp === CODE_POINTS.LATIN_CAPITAL_X) {
        this.state = State2.HEXADEMICAL_CHARACTER_REFERENCE_START;
      } else if (isAsciiDigit(cp)) {
        this.state = State2.DECIMAL_CHARACTER_REFERENCE;
        this._stateDecimalCharacterReference(cp);
      } else {
        this._err(ERR.absenceOfDigitsInNumericCharacterReference);
        this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
        this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN);
        this._reconsumeInState(this.returnState, cp);
      }
    }
    // Hexademical character reference start state
    //------------------------------------------------------------------
    _stateHexademicalCharacterReferenceStart(cp) {
      if (isAsciiHexDigit(cp)) {
        this.state = State2.HEXADEMICAL_CHARACTER_REFERENCE;
        this._stateHexademicalCharacterReference(cp);
      } else {
        this._err(ERR.absenceOfDigitsInNumericCharacterReference);
        this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
        this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN);
        this._unconsume(2);
        this.state = this.returnState;
      }
    }
    // Hexademical character reference state
    //------------------------------------------------------------------
    _stateHexademicalCharacterReference(cp) {
      if (isAsciiUpperHexDigit(cp)) {
        this.charRefCode = this.charRefCode * 16 + cp - 55;
      } else if (isAsciiLowerHexDigit(cp)) {
        this.charRefCode = this.charRefCode * 16 + cp - 87;
      } else if (isAsciiDigit(cp)) {
        this.charRefCode = this.charRefCode * 16 + cp - 48;
      } else if (cp === CODE_POINTS.SEMICOLON) {
        this.state = State2.NUMERIC_CHARACTER_REFERENCE_END;
      } else {
        this._err(ERR.missingSemicolonAfterCharacterReference);
        this.state = State2.NUMERIC_CHARACTER_REFERENCE_END;
        this._stateNumericCharacterReferenceEnd(cp);
      }
    }
    // Decimal character reference state
    //------------------------------------------------------------------
    _stateDecimalCharacterReference(cp) {
      if (isAsciiDigit(cp)) {
        this.charRefCode = this.charRefCode * 10 + cp - 48;
      } else if (cp === CODE_POINTS.SEMICOLON) {
        this.state = State2.NUMERIC_CHARACTER_REFERENCE_END;
      } else {
        this._err(ERR.missingSemicolonAfterCharacterReference);
        this.state = State2.NUMERIC_CHARACTER_REFERENCE_END;
        this._stateNumericCharacterReferenceEnd(cp);
      }
    }
    // Numeric character reference end state
    //------------------------------------------------------------------
    _stateNumericCharacterReferenceEnd(cp) {
      if (this.charRefCode === CODE_POINTS.NULL) {
        this._err(ERR.nullCharacterReference);
        this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
      } else if (this.charRefCode > 1114111) {
        this._err(ERR.characterReferenceOutsideUnicodeRange);
        this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
      } else if (isSurrogate(this.charRefCode)) {
        this._err(ERR.surrogateCharacterReference);
        this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
      } else if (isUndefinedCodePoint(this.charRefCode)) {
        this._err(ERR.noncharacterCharacterReference);
      } else if (isControlCodePoint(this.charRefCode) || this.charRefCode === CODE_POINTS.CARRIAGE_RETURN) {
        this._err(ERR.controlCharacterReference);
        const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS.get(this.charRefCode);
        if (replacement !== void 0) {
          this.charRefCode = replacement;
        }
      }
      this._flushCodePointConsumedAsCharacterReference(this.charRefCode);
      this._reconsumeInState(this.returnState, cp);
    }
  };

  // node_modules/parse5/dist/parser/open-element-stack.js
  var IMPLICIT_END_TAG_REQUIRED = /* @__PURE__ */ new Set([TAG_ID.DD, TAG_ID.DT, TAG_ID.LI, TAG_ID.OPTGROUP, TAG_ID.OPTION, TAG_ID.P, TAG_ID.RB, TAG_ID.RP, TAG_ID.RT, TAG_ID.RTC]);
  var IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = /* @__PURE__ */ new Set([
    ...IMPLICIT_END_TAG_REQUIRED,
    TAG_ID.CAPTION,
    TAG_ID.COLGROUP,
    TAG_ID.TBODY,
    TAG_ID.TD,
    TAG_ID.TFOOT,
    TAG_ID.TH,
    TAG_ID.THEAD,
    TAG_ID.TR
  ]);
  var SCOPING_ELEMENT_NS = /* @__PURE__ */ new Map([
    [TAG_ID.APPLET, NS.HTML],
    [TAG_ID.CAPTION, NS.HTML],
    [TAG_ID.HTML, NS.HTML],
    [TAG_ID.MARQUEE, NS.HTML],
    [TAG_ID.OBJECT, NS.HTML],
    [TAG_ID.TABLE, NS.HTML],
    [TAG_ID.TD, NS.HTML],
    [TAG_ID.TEMPLATE, NS.HTML],
    [TAG_ID.TH, NS.HTML],
    [TAG_ID.ANNOTATION_XML, NS.MATHML],
    [TAG_ID.MI, NS.MATHML],
    [TAG_ID.MN, NS.MATHML],
    [TAG_ID.MO, NS.MATHML],
    [TAG_ID.MS, NS.MATHML],
    [TAG_ID.MTEXT, NS.MATHML],
    [TAG_ID.DESC, NS.SVG],
    [TAG_ID.FOREIGN_OBJECT, NS.SVG],
    [TAG_ID.TITLE, NS.SVG]
  ]);
  var NAMED_HEADERS = [TAG_ID.H1, TAG_ID.H2, TAG_ID.H3, TAG_ID.H4, TAG_ID.H5, TAG_ID.H6];
  var TABLE_ROW_CONTEXT = [TAG_ID.TR, TAG_ID.TEMPLATE, TAG_ID.HTML];
  var TABLE_BODY_CONTEXT = [TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TEMPLATE, TAG_ID.HTML];
  var TABLE_CONTEXT = [TAG_ID.TABLE, TAG_ID.TEMPLATE, TAG_ID.HTML];
  var TABLE_CELLS = [TAG_ID.TD, TAG_ID.TH];
  var OpenElementStack = class {
    get currentTmplContentOrNode() {
      return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
    }
    constructor(document, treeAdapter, handler) {
      this.treeAdapter = treeAdapter;
      this.handler = handler;
      this.items = [];
      this.tagIDs = [];
      this.stackTop = -1;
      this.tmplCount = 0;
      this.currentTagId = TAG_ID.UNKNOWN;
      this.current = document;
    }
    //Index of element
    _indexOf(element) {
      return this.items.lastIndexOf(element, this.stackTop);
    }
    //Update current element
    _isInTemplate() {
      return this.currentTagId === TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
    }
    _updateCurrentElement() {
      this.current = this.items[this.stackTop];
      this.currentTagId = this.tagIDs[this.stackTop];
    }
    //Mutations
    push(element, tagID) {
      this.stackTop++;
      this.items[this.stackTop] = element;
      this.current = element;
      this.tagIDs[this.stackTop] = tagID;
      this.currentTagId = tagID;
      if (this._isInTemplate()) {
        this.tmplCount++;
      }
      this.handler.onItemPush(element, tagID, true);
    }
    pop() {
      const popped = this.current;
      if (this.tmplCount > 0 && this._isInTemplate()) {
        this.tmplCount--;
      }
      this.stackTop--;
      this._updateCurrentElement();
      this.handler.onItemPop(popped, true);
    }
    replace(oldElement, newElement) {
      const idx = this._indexOf(oldElement);
      this.items[idx] = newElement;
      if (idx === this.stackTop) {
        this.current = newElement;
      }
    }
    insertAfter(referenceElement, newElement, newElementID) {
      const insertionIdx = this._indexOf(referenceElement) + 1;
      this.items.splice(insertionIdx, 0, newElement);
      this.tagIDs.splice(insertionIdx, 0, newElementID);
      this.stackTop++;
      if (insertionIdx === this.stackTop) {
        this._updateCurrentElement();
      }
      this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
    }
    popUntilTagNamePopped(tagName) {
      let targetIdx = this.stackTop + 1;
      do {
        targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
      } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== NS.HTML);
      this.shortenToLength(targetIdx < 0 ? 0 : targetIdx);
    }
    shortenToLength(idx) {
      while (this.stackTop >= idx) {
        const popped = this.current;
        if (this.tmplCount > 0 && this._isInTemplate()) {
          this.tmplCount -= 1;
        }
        this.stackTop--;
        this._updateCurrentElement();
        this.handler.onItemPop(popped, this.stackTop < idx);
      }
    }
    popUntilElementPopped(element) {
      const idx = this._indexOf(element);
      this.shortenToLength(idx < 0 ? 0 : idx);
    }
    popUntilPopped(tagNames, targetNS) {
      const idx = this._indexOfTagNames(tagNames, targetNS);
      this.shortenToLength(idx < 0 ? 0 : idx);
    }
    popUntilNumberedHeaderPopped() {
      this.popUntilPopped(NAMED_HEADERS, NS.HTML);
    }
    popUntilTableCellPopped() {
      this.popUntilPopped(TABLE_CELLS, NS.HTML);
    }
    popAllUpToHtmlElement() {
      this.tmplCount = 0;
      this.shortenToLength(1);
    }
    _indexOfTagNames(tagNames, namespace) {
      for (let i = this.stackTop; i >= 0; i--) {
        if (tagNames.includes(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === namespace) {
          return i;
        }
      }
      return -1;
    }
    clearBackTo(tagNames, targetNS) {
      const idx = this._indexOfTagNames(tagNames, targetNS);
      this.shortenToLength(idx + 1);
    }
    clearBackToTableContext() {
      this.clearBackTo(TABLE_CONTEXT, NS.HTML);
    }
    clearBackToTableBodyContext() {
      this.clearBackTo(TABLE_BODY_CONTEXT, NS.HTML);
    }
    clearBackToTableRowContext() {
      this.clearBackTo(TABLE_ROW_CONTEXT, NS.HTML);
    }
    remove(element) {
      const idx = this._indexOf(element);
      if (idx >= 0) {
        if (idx === this.stackTop) {
          this.pop();
        } else {
          this.items.splice(idx, 1);
          this.tagIDs.splice(idx, 1);
          this.stackTop--;
          this._updateCurrentElement();
          this.handler.onItemPop(element, false);
        }
      }
    }
    //Search
    tryPeekProperlyNestedBodyElement() {
      return this.stackTop >= 1 && this.tagIDs[1] === TAG_ID.BODY ? this.items[1] : null;
    }
    contains(element) {
      return this._indexOf(element) > -1;
    }
    getCommonAncestor(element) {
      const elementIdx = this._indexOf(element) - 1;
      return elementIdx >= 0 ? this.items[elementIdx] : null;
    }
    isRootHtmlElementCurrent() {
      return this.stackTop === 0 && this.tagIDs[0] === TAG_ID.HTML;
    }
    //Element in scope
    hasInScope(tagName) {
      for (let i = this.stackTop; i >= 0; i--) {
        const tn = this.tagIDs[i];
        const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
        if (tn === tagName && ns === NS.HTML) {
          return true;
        }
        if (SCOPING_ELEMENT_NS.get(tn) === ns) {
          return false;
        }
      }
      return true;
    }
    hasNumberedHeaderInScope() {
      for (let i = this.stackTop; i >= 0; i--) {
        const tn = this.tagIDs[i];
        const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
        if (isNumberedHeader(tn) && ns === NS.HTML) {
          return true;
        }
        if (SCOPING_ELEMENT_NS.get(tn) === ns) {
          return false;
        }
      }
      return true;
    }
    hasInListItemScope(tagName) {
      for (let i = this.stackTop; i >= 0; i--) {
        const tn = this.tagIDs[i];
        const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
        if (tn === tagName && ns === NS.HTML) {
          return true;
        }
        if ((tn === TAG_ID.UL || tn === TAG_ID.OL) && ns === NS.HTML || SCOPING_ELEMENT_NS.get(tn) === ns) {
          return false;
        }
      }
      return true;
    }
    hasInButtonScope(tagName) {
      for (let i = this.stackTop; i >= 0; i--) {
        const tn = this.tagIDs[i];
        const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
        if (tn === tagName && ns === NS.HTML) {
          return true;
        }
        if (tn === TAG_ID.BUTTON && ns === NS.HTML || SCOPING_ELEMENT_NS.get(tn) === ns) {
          return false;
        }
      }
      return true;
    }
    hasInTableScope(tagName) {
      for (let i = this.stackTop; i >= 0; i--) {
        const tn = this.tagIDs[i];
        const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
        if (ns !== NS.HTML) {
          continue;
        }
        if (tn === tagName) {
          return true;
        }
        if (tn === TAG_ID.TABLE || tn === TAG_ID.TEMPLATE || tn === TAG_ID.HTML) {
          return false;
        }
      }
      return true;
    }
    hasTableBodyContextInTableScope() {
      for (let i = this.stackTop; i >= 0; i--) {
        const tn = this.tagIDs[i];
        const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
        if (ns !== NS.HTML) {
          continue;
        }
        if (tn === TAG_ID.TBODY || tn === TAG_ID.THEAD || tn === TAG_ID.TFOOT) {
          return true;
        }
        if (tn === TAG_ID.TABLE || tn === TAG_ID.HTML) {
          return false;
        }
      }
      return true;
    }
    hasInSelectScope(tagName) {
      for (let i = this.stackTop; i >= 0; i--) {
        const tn = this.tagIDs[i];
        const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
        if (ns !== NS.HTML) {
          continue;
        }
        if (tn === tagName) {
          return true;
        }
        if (tn !== TAG_ID.OPTION && tn !== TAG_ID.OPTGROUP) {
          return false;
        }
      }
      return true;
    }
    //Implied end tags
    generateImpliedEndTags() {
      while (IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
        this.pop();
      }
    }
    generateImpliedEndTagsThoroughly() {
      while (IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
        this.pop();
      }
    }
    generateImpliedEndTagsWithExclusion(exclusionId) {
      while (this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
        this.pop();
      }
    }
  };

  // node_modules/parse5/dist/parser/formatting-element-list.js
  var NOAH_ARK_CAPACITY = 3;
  var EntryType;
  (function(EntryType2) {
    EntryType2[EntryType2["Marker"] = 0] = "Marker";
    EntryType2[EntryType2["Element"] = 1] = "Element";
  })(EntryType = EntryType || (EntryType = {}));
  var MARKER = { type: EntryType.Marker };
  var FormattingElementList = class {
    constructor(treeAdapter) {
      this.treeAdapter = treeAdapter;
      this.entries = [];
      this.bookmark = null;
    }
    //Noah Ark's condition
    //OPTIMIZATION: at first we try to find possible candidates for exclusion using
    //lightweight heuristics without thorough attributes check.
    _getNoahArkConditionCandidates(newElement, neAttrs) {
      const candidates = [];
      const neAttrsLength = neAttrs.length;
      const neTagName = this.treeAdapter.getTagName(newElement);
      const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        if (entry.type === EntryType.Marker) {
          break;
        }
        const { element } = entry;
        if (this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {
          const elementAttrs = this.treeAdapter.getAttrList(element);
          if (elementAttrs.length === neAttrsLength) {
            candidates.push({ idx: i, attrs: elementAttrs });
          }
        }
      }
      return candidates;
    }
    _ensureNoahArkCondition(newElement) {
      if (this.entries.length < NOAH_ARK_CAPACITY)
        return;
      const neAttrs = this.treeAdapter.getAttrList(newElement);
      const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
      if (candidates.length < NOAH_ARK_CAPACITY)
        return;
      const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));
      let validCandidates = 0;
      for (let i = 0; i < candidates.length; i++) {
        const candidate = candidates[i];
        if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {
          validCandidates += 1;
          if (validCandidates >= NOAH_ARK_CAPACITY) {
            this.entries.splice(candidate.idx, 1);
          }
        }
      }
    }
    //Mutations
    insertMarker() {
      this.entries.unshift(MARKER);
    }
    pushElement(element, token) {
      this._ensureNoahArkCondition(element);
      this.entries.unshift({
        type: EntryType.Element,
        element,
        token
      });
    }
    insertElementAfterBookmark(element, token) {
      const bookmarkIdx = this.entries.indexOf(this.bookmark);
      this.entries.splice(bookmarkIdx, 0, {
        type: EntryType.Element,
        element,
        token
      });
    }
    removeEntry(entry) {
      const entryIndex = this.entries.indexOf(entry);
      if (entryIndex >= 0) {
        this.entries.splice(entryIndex, 1);
      }
    }
    /**
     * Clears the list of formatting elements up to the last marker.
     *
     * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
     */
    clearToLastMarker() {
      const markerIdx = this.entries.indexOf(MARKER);
      if (markerIdx >= 0) {
        this.entries.splice(0, markerIdx + 1);
      } else {
        this.entries.length = 0;
      }
    }
    //Search
    getElementEntryInScopeWithTagName(tagName) {
      const entry = this.entries.find((entry2) => entry2.type === EntryType.Marker || this.treeAdapter.getTagName(entry2.element) === tagName);
      return entry && entry.type === EntryType.Element ? entry : null;
    }
    getElementEntry(element) {
      return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element);
    }
  };

  // node_modules/parse5/dist/tree-adapters/default.js
  function createTextNode(value) {
    return {
      nodeName: "#text",
      value,
      parentNode: null
    };
  }
  var defaultTreeAdapter = {
    //Node construction
    createDocument() {
      return {
        nodeName: "#document",
        mode: DOCUMENT_MODE.NO_QUIRKS,
        childNodes: []
      };
    },
    createDocumentFragment() {
      return {
        nodeName: "#document-fragment",
        childNodes: []
      };
    },
    createElement(tagName, namespaceURI, attrs) {
      return {
        nodeName: tagName,
        tagName,
        attrs,
        namespaceURI,
        childNodes: [],
        parentNode: null
      };
    },
    createCommentNode(data) {
      return {
        nodeName: "#comment",
        data,
        parentNode: null
      };
    },
    //Tree mutation
    appendChild(parentNode, newNode) {
      parentNode.childNodes.push(newNode);
      newNode.parentNode = parentNode;
    },
    insertBefore(parentNode, newNode, referenceNode) {
      const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
      parentNode.childNodes.splice(insertionIdx, 0, newNode);
      newNode.parentNode = parentNode;
    },
    setTemplateContent(templateElement, contentElement) {
      templateElement.content = contentElement;
    },
    getTemplateContent(templateElement) {
      return templateElement.content;
    },
    setDocumentType(document, name, publicId, systemId) {
      const doctypeNode = document.childNodes.find((node) => node.nodeName === "#documentType");
      if (doctypeNode) {
        doctypeNode.name = name;
        doctypeNode.publicId = publicId;
        doctypeNode.systemId = systemId;
      } else {
        const node = {
          nodeName: "#documentType",
          name,
          publicId,
          systemId,
          parentNode: null
        };
        defaultTreeAdapter.appendChild(document, node);
      }
    },
    setDocumentMode(document, mode) {
      document.mode = mode;
    },
    getDocumentMode(document) {
      return document.mode;
    },
    detachNode(node) {
      if (node.parentNode) {
        const idx = node.parentNode.childNodes.indexOf(node);
        node.parentNode.childNodes.splice(idx, 1);
        node.parentNode = null;
      }
    },
    insertText(parentNode, text) {
      if (parentNode.childNodes.length > 0) {
        const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
        if (defaultTreeAdapter.isTextNode(prevNode)) {
          prevNode.value += text;
          return;
        }
      }
      defaultTreeAdapter.appendChild(parentNode, createTextNode(text));
    },
    insertTextBefore(parentNode, text, referenceNode) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
      if (prevNode && defaultTreeAdapter.isTextNode(prevNode)) {
        prevNode.value += text;
      } else {
        defaultTreeAdapter.insertBefore(parentNode, createTextNode(text), referenceNode);
      }
    },
    adoptAttributes(recipient, attrs) {
      const recipientAttrsMap = new Set(recipient.attrs.map((attr) => attr.name));
      for (let j = 0; j < attrs.length; j++) {
        if (!recipientAttrsMap.has(attrs[j].name)) {
          recipient.attrs.push(attrs[j]);
        }
      }
    },
    //Tree traversing
    getFirstChild(node) {
      return node.childNodes[0];
    },
    getChildNodes(node) {
      return node.childNodes;
    },
    getParentNode(node) {
      return node.parentNode;
    },
    getAttrList(element) {
      return element.attrs;
    },
    //Node data
    getTagName(element) {
      return element.tagName;
    },
    getNamespaceURI(element) {
      return element.namespaceURI;
    },
    getTextNodeContent(textNode) {
      return textNode.value;
    },
    getCommentNodeContent(commentNode) {
      return commentNode.data;
    },
    getDocumentTypeNodeName(doctypeNode) {
      return doctypeNode.name;
    },
    getDocumentTypeNodePublicId(doctypeNode) {
      return doctypeNode.publicId;
    },
    getDocumentTypeNodeSystemId(doctypeNode) {
      return doctypeNode.systemId;
    },
    //Node types
    isTextNode(node) {
      return node.nodeName === "#text";
    },
    isCommentNode(node) {
      return node.nodeName === "#comment";
    },
    isDocumentTypeNode(node) {
      return node.nodeName === "#documentType";
    },
    isElementNode(node) {
      return Object.prototype.hasOwnProperty.call(node, "tagName");
    },
    // Source code location
    setNodeSourceCodeLocation(node, location2) {
      node.sourceCodeLocation = location2;
    },
    getNodeSourceCodeLocation(node) {
      return node.sourceCodeLocation;
    },
    updateNodeSourceCodeLocation(node, endLocation) {
      node.sourceCodeLocation = { ...node.sourceCodeLocation, ...endLocation };
    }
  };

  // node_modules/parse5/dist/common/doctype.js
  var VALID_DOCTYPE_NAME = "html";
  var VALID_SYSTEM_ID = "about:legacy-compat";
  var QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
  var QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
    "+//silmaril//dtd html pro v0r11 19970101//",
    "-//as//dtd html 3.0 aswedit + extensions//",
    "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
    "-//ietf//dtd html 2.0 level 1//",
    "-//ietf//dtd html 2.0 level 2//",
    "-//ietf//dtd html 2.0 strict level 1//",
    "-//ietf//dtd html 2.0 strict level 2//",
    "-//ietf//dtd html 2.0 strict//",
    "-//ietf//dtd html 2.0//",
    "-//ietf//dtd html 2.1e//",
    "-//ietf//dtd html 3.0//",
    "-//ietf//dtd html 3.2 final//",
    "-//ietf//dtd html 3.2//",
    "-//ietf//dtd html 3//",
    "-//ietf//dtd html level 0//",
    "-//ietf//dtd html level 1//",
    "-//ietf//dtd html level 2//",
    "-//ietf//dtd html level 3//",
    "-//ietf//dtd html strict level 0//",
    "-//ietf//dtd html strict level 1//",
    "-//ietf//dtd html strict level 2//",
    "-//ietf//dtd html strict level 3//",
    "-//ietf//dtd html strict//",
    "-//ietf//dtd html//",
    "-//metrius//dtd metrius presentational//",
    "-//microsoft//dtd internet explorer 2.0 html strict//",
    "-//microsoft//dtd internet explorer 2.0 html//",
    "-//microsoft//dtd internet explorer 2.0 tables//",
    "-//microsoft//dtd internet explorer 3.0 html strict//",
    "-//microsoft//dtd internet explorer 3.0 html//",
    "-//microsoft//dtd internet explorer 3.0 tables//",
    "-//netscape comm. corp.//dtd html//",
    "-//netscape comm. corp.//dtd strict html//",
    "-//o'reilly and associates//dtd html 2.0//",
    "-//o'reilly and associates//dtd html extended 1.0//",
    "-//o'reilly and associates//dtd html extended relaxed 1.0//",
    "-//sq//dtd html 2.0 hotmetal + extensions//",
    "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
    "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
    "-//spyglass//dtd html 2.0 extended//",
    "-//sun microsystems corp.//dtd hotjava html//",
    "-//sun microsystems corp.//dtd hotjava strict html//",
    "-//w3c//dtd html 3 1995-03-24//",
    "-//w3c//dtd html 3.2 draft//",
    "-//w3c//dtd html 3.2 final//",
    "-//w3c//dtd html 3.2//",
    "-//w3c//dtd html 3.2s draft//",
    "-//w3c//dtd html 4.0 frameset//",
    "-//w3c//dtd html 4.0 transitional//",
    "-//w3c//dtd html experimental 19960712//",
    "-//w3c//dtd html experimental 970421//",
    "-//w3c//dtd w3 html//",
    "-//w3o//dtd w3 html 3.0//",
    "-//webtechs//dtd mozilla html 2.0//",
    "-//webtechs//dtd mozilla html//"
  ];
  var QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
    ...QUIRKS_MODE_PUBLIC_ID_PREFIXES,
    "-//w3c//dtd html 4.01 frameset//",
    "-//w3c//dtd html 4.01 transitional//"
  ];
  var QUIRKS_MODE_PUBLIC_IDS = /* @__PURE__ */ new Set([
    "-//w3o//dtd w3 html strict 3.0//en//",
    "-/w3c/dtd html 4.0 transitional/en",
    "html"
  ]);
  var LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
  var LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
    ...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES,
    "-//w3c//dtd html 4.01 frameset//",
    "-//w3c//dtd html 4.01 transitional//"
  ];
  function hasPrefix(publicId, prefixes) {
    return prefixes.some((prefix) => publicId.startsWith(prefix));
  }
  function isConforming(token) {
    return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
  }
  function getDocumentMode(token) {
    if (token.name !== VALID_DOCTYPE_NAME) {
      return DOCUMENT_MODE.QUIRKS;
    }
    const { systemId } = token;
    if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
      return DOCUMENT_MODE.QUIRKS;
    }
    let { publicId } = token;
    if (publicId !== null) {
      publicId = publicId.toLowerCase();
      if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) {
        return DOCUMENT_MODE.QUIRKS;
      }
      let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
      if (hasPrefix(publicId, prefixes)) {
        return DOCUMENT_MODE.QUIRKS;
      }
      prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
      if (hasPrefix(publicId, prefixes)) {
        return DOCUMENT_MODE.LIMITED_QUIRKS;
      }
    }
    return DOCUMENT_MODE.NO_QUIRKS;
  }

  // node_modules/parse5/dist/common/foreign-content.js
  var foreign_content_exports = {};
  __export(foreign_content_exports, {
    SVG_TAG_NAMES_ADJUSTMENT_MAP: () => SVG_TAG_NAMES_ADJUSTMENT_MAP,
    adjustTokenMathMLAttrs: () => adjustTokenMathMLAttrs,
    adjustTokenSVGAttrs: () => adjustTokenSVGAttrs,
    adjustTokenSVGTagName: () => adjustTokenSVGTagName,
    adjustTokenXMLAttrs: () => adjustTokenXMLAttrs,
    causesExit: () => causesExit,
    isIntegrationPoint: () => isIntegrationPoint
  });
  var MIME_TYPES = {
    TEXT_HTML: "text/html",
    APPLICATION_XML: "application/xhtml+xml"
  };
  var DEFINITION_URL_ATTR = "definitionurl";
  var ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
  var SVG_ATTRS_ADJUSTMENT_MAP = new Map([
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan"
  ].map((attr) => [attr.toLowerCase(), attr]));
  var XML_ATTRS_ADJUSTMENT_MAP = /* @__PURE__ */ new Map([
    ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: NS.XLINK }],
    ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: NS.XLINK }],
    ["xlink:href", { prefix: "xlink", name: "href", namespace: NS.XLINK }],
    ["xlink:role", { prefix: "xlink", name: "role", namespace: NS.XLINK }],
    ["xlink:show", { prefix: "xlink", name: "show", namespace: NS.XLINK }],
    ["xlink:title", { prefix: "xlink", name: "title", namespace: NS.XLINK }],
    ["xlink:type", { prefix: "xlink", name: "type", namespace: NS.XLINK }],
    ["xml:base", { prefix: "xml", name: "base", namespace: NS.XML }],
    ["xml:lang", { prefix: "xml", name: "lang", namespace: NS.XML }],
    ["xml:space", { prefix: "xml", name: "space", namespace: NS.XML }],
    ["xmlns", { prefix: "", name: "xmlns", namespace: NS.XMLNS }],
    ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: NS.XMLNS }]
  ]);
  var SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
  ].map((tn) => [tn.toLowerCase(), tn]));
  var EXITS_FOREIGN_CONTENT = /* @__PURE__ */ new Set([
    TAG_ID.B,
    TAG_ID.BIG,
    TAG_ID.BLOCKQUOTE,
    TAG_ID.BODY,
    TAG_ID.BR,
    TAG_ID.CENTER,
    TAG_ID.CODE,
    TAG_ID.DD,
    TAG_ID.DIV,
    TAG_ID.DL,
    TAG_ID.DT,
    TAG_ID.EM,
    TAG_ID.EMBED,
    TAG_ID.H1,
    TAG_ID.H2,
    TAG_ID.H3,
    TAG_ID.H4,
    TAG_ID.H5,
    TAG_ID.H6,
    TAG_ID.HEAD,
    TAG_ID.HR,
    TAG_ID.I,
    TAG_ID.IMG,
    TAG_ID.LI,
    TAG_ID.LISTING,
    TAG_ID.MENU,
    TAG_ID.META,
    TAG_ID.NOBR,
    TAG_ID.OL,
    TAG_ID.P,
    TAG_ID.PRE,
    TAG_ID.RUBY,
    TAG_ID.S,
    TAG_ID.SMALL,
    TAG_ID.SPAN,
    TAG_ID.STRONG,
    TAG_ID.STRIKE,
    TAG_ID.SUB,
    TAG_ID.SUP,
    TAG_ID.TABLE,
    TAG_ID.TT,
    TAG_ID.U,
    TAG_ID.UL,
    TAG_ID.VAR
  ]);
  function causesExit(startTagToken) {
    const tn = startTagToken.tagID;
    const isFontWithAttrs = tn === TAG_ID.FONT && startTagToken.attrs.some(({ name }) => name === ATTRS.COLOR || name === ATTRS.SIZE || name === ATTRS.FACE);
    return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn);
  }
  function adjustTokenMathMLAttrs(token) {
    for (let i = 0; i < token.attrs.length; i++) {
      if (token.attrs[i].name === DEFINITION_URL_ATTR) {
        token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
        break;
      }
    }
  }
  function adjustTokenSVGAttrs(token) {
    for (let i = 0; i < token.attrs.length; i++) {
      const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
      if (adjustedAttrName != null) {
        token.attrs[i].name = adjustedAttrName;
      }
    }
  }
  function adjustTokenXMLAttrs(token) {
    for (let i = 0; i < token.attrs.length; i++) {
      const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
      if (adjustedAttrEntry) {
        token.attrs[i].prefix = adjustedAttrEntry.prefix;
        token.attrs[i].name = adjustedAttrEntry.name;
        token.attrs[i].namespace = adjustedAttrEntry.namespace;
      }
    }
  }
  function adjustTokenSVGTagName(token) {
    const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token.tagName);
    if (adjustedTagName != null) {
      token.tagName = adjustedTagName;
      token.tagID = getTagID(token.tagName);
    }
  }
  function isMathMLTextIntegrationPoint(tn, ns) {
    return ns === NS.MATHML && (tn === TAG_ID.MI || tn === TAG_ID.MO || tn === TAG_ID.MN || tn === TAG_ID.MS || tn === TAG_ID.MTEXT);
  }
  function isHtmlIntegrationPoint(tn, ns, attrs) {
    if (ns === NS.MATHML && tn === TAG_ID.ANNOTATION_XML) {
      for (let i = 0; i < attrs.length; i++) {
        if (attrs[i].name === ATTRS.ENCODING) {
          const value = attrs[i].value.toLowerCase();
          return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
        }
      }
    }
    return ns === NS.SVG && (tn === TAG_ID.FOREIGN_OBJECT || tn === TAG_ID.DESC || tn === TAG_ID.TITLE);
  }
  function isIntegrationPoint(tn, ns, attrs, foreignNS) {
    return (!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs) || (!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns);
  }

  // node_modules/parse5/dist/parser/index.js
  var HIDDEN_INPUT_TYPE = "hidden";
  var AA_OUTER_LOOP_ITER = 8;
  var AA_INNER_LOOP_ITER = 3;
  var InsertionMode;
  (function(InsertionMode2) {
    InsertionMode2[InsertionMode2["INITIAL"] = 0] = "INITIAL";
    InsertionMode2[InsertionMode2["BEFORE_HTML"] = 1] = "BEFORE_HTML";
    InsertionMode2[InsertionMode2["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
    InsertionMode2[InsertionMode2["IN_HEAD"] = 3] = "IN_HEAD";
    InsertionMode2[InsertionMode2["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
    InsertionMode2[InsertionMode2["AFTER_HEAD"] = 5] = "AFTER_HEAD";
    InsertionMode2[InsertionMode2["IN_BODY"] = 6] = "IN_BODY";
    InsertionMode2[InsertionMode2["TEXT"] = 7] = "TEXT";
    InsertionMode2[InsertionMode2["IN_TABLE"] = 8] = "IN_TABLE";
    InsertionMode2[InsertionMode2["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
    InsertionMode2[InsertionMode2["IN_CAPTION"] = 10] = "IN_CAPTION";
    InsertionMode2[InsertionMode2["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
    InsertionMode2[InsertionMode2["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
    InsertionMode2[InsertionMode2["IN_ROW"] = 13] = "IN_ROW";
    InsertionMode2[InsertionMode2["IN_CELL"] = 14] = "IN_CELL";
    InsertionMode2[InsertionMode2["IN_SELECT"] = 15] = "IN_SELECT";
    InsertionMode2[InsertionMode2["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
    InsertionMode2[InsertionMode2["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
    InsertionMode2[InsertionMode2["AFTER_BODY"] = 18] = "AFTER_BODY";
    InsertionMode2[InsertionMode2["IN_FRAMESET"] = 19] = "IN_FRAMESET";
    InsertionMode2[InsertionMode2["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
    InsertionMode2[InsertionMode2["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
    InsertionMode2[InsertionMode2["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
  })(InsertionMode || (InsertionMode = {}));
  var BASE_LOC = {
    startLine: -1,
    startCol: -1,
    startOffset: -1,
    endLine: -1,
    endCol: -1,
    endOffset: -1
  };
  var TABLE_STRUCTURE_TAGS = /* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TR]);
  var defaultParserOptions = {
    scriptingEnabled: true,
    sourceCodeLocationInfo: false,
    treeAdapter: defaultTreeAdapter,
    onParseError: null
  };
  var Parser = class {
    constructor(options2, document, fragmentContext = null, scriptHandler = null) {
      this.fragmentContext = fragmentContext;
      this.scriptHandler = scriptHandler;
      this.currentToken = null;
      this.stopped = false;
      this.insertionMode = InsertionMode.INITIAL;
      this.originalInsertionMode = InsertionMode.INITIAL;
      this.headElement = null;
      this.formElement = null;
      this.currentNotInHTML = false;
      this.tmplInsertionModeStack = [];
      this.pendingCharacterTokens = [];
      this.hasNonWhitespacePendingCharacterToken = false;
      this.framesetOk = true;
      this.skipNextNewLine = false;
      this.fosterParentingEnabled = false;
      this.options = {
        ...defaultParserOptions,
        ...options2
      };
      this.treeAdapter = this.options.treeAdapter;
      this.onParseError = this.options.onParseError;
      if (this.onParseError) {
        this.options.sourceCodeLocationInfo = true;
      }
      this.document = document !== null && document !== void 0 ? document : this.treeAdapter.createDocument();
      this.tokenizer = new Tokenizer(this.options, this);
      this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
      this.fragmentContextID = fragmentContext ? getTagID(this.treeAdapter.getTagName(fragmentContext)) : TAG_ID.UNKNOWN;
      this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
      this.openElements = new OpenElementStack(this.document, this.treeAdapter, this);
    }
    // API
    static parse(html2, options2) {
      const parser = new this(options2);
      parser.tokenizer.write(html2, true);
      return parser.document;
    }
    static getFragmentParser(fragmentContext, options2) {
      const opts = {
        ...defaultParserOptions,
        ...options2
      };
      fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : fragmentContext = opts.treeAdapter.createElement(TAG_NAMES.TEMPLATE, NS.HTML, []);
      const documentMock = opts.treeAdapter.createElement("documentmock", NS.HTML, []);
      const parser = new this(opts, documentMock, fragmentContext);
      if (parser.fragmentContextID === TAG_ID.TEMPLATE) {
        parser.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
      }
      parser._initTokenizerForFragmentParsing();
      parser._insertFakeRootElement();
      parser._resetInsertionMode();
      parser._findFormInFragmentContext();
      return parser;
    }
    getFragment() {
      const rootElement = this.treeAdapter.getFirstChild(this.document);
      const fragment = this.treeAdapter.createDocumentFragment();
      this._adoptNodes(rootElement, fragment);
      return fragment;
    }
    //Errors
    _err(token, code, beforeToken) {
      var _a2;
      if (!this.onParseError)
        return;
      const loc = (_a2 = token.location) !== null && _a2 !== void 0 ? _a2 : BASE_LOC;
      const err = {
        code,
        startLine: loc.startLine,
        startCol: loc.startCol,
        startOffset: loc.startOffset,
        endLine: beforeToken ? loc.startLine : loc.endLine,
        endCol: beforeToken ? loc.startCol : loc.endCol,
        endOffset: beforeToken ? loc.startOffset : loc.endOffset
      };
      this.onParseError(err);
    }
    //Stack events
    onItemPush(node, tid, isTop) {
      var _a2, _b;
      (_b = (_a2 = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a2, node);
      if (isTop && this.openElements.stackTop > 0)
        this._setContextModes(node, tid);
    }
    onItemPop(node, isTop) {
      var _a2, _b;
      if (this.options.sourceCodeLocationInfo) {
        this._setEndLocation(node, this.currentToken);
      }
      (_b = (_a2 = this.treeAdapter).onItemPop) === null || _b === void 0 ? void 0 : _b.call(_a2, node, this.openElements.current);
      if (isTop) {
        let current;
        let currentTagId;
        if (this.openElements.stackTop === 0 && this.fragmentContext) {
          current = this.fragmentContext;
          currentTagId = this.fragmentContextID;
        } else {
          ({ current, currentTagId } = this.openElements);
        }
        this._setContextModes(current, currentTagId);
      }
    }
    _setContextModes(current, tid) {
      const isHTML = current === this.document || this.treeAdapter.getNamespaceURI(current) === NS.HTML;
      this.currentNotInHTML = !isHTML;
      this.tokenizer.inForeignNode = !isHTML && !this._isIntegrationPoint(tid, current);
    }
    _switchToTextParsing(currentToken, nextTokenizerState) {
      this._insertElement(currentToken, NS.HTML);
      this.tokenizer.state = nextTokenizerState;
      this.originalInsertionMode = this.insertionMode;
      this.insertionMode = InsertionMode.TEXT;
    }
    switchToPlaintextParsing() {
      this.insertionMode = InsertionMode.TEXT;
      this.originalInsertionMode = InsertionMode.IN_BODY;
      this.tokenizer.state = TokenizerMode.PLAINTEXT;
    }
    //Fragment parsing
    _getAdjustedCurrentElement() {
      return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
    }
    _findFormInFragmentContext() {
      let node = this.fragmentContext;
      while (node) {
        if (this.treeAdapter.getTagName(node) === TAG_NAMES.FORM) {
          this.formElement = node;
          break;
        }
        node = this.treeAdapter.getParentNode(node);
      }
    }
    _initTokenizerForFragmentParsing() {
      if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== NS.HTML) {
        return;
      }
      switch (this.fragmentContextID) {
        case TAG_ID.TITLE:
        case TAG_ID.TEXTAREA: {
          this.tokenizer.state = TokenizerMode.RCDATA;
          break;
        }
        case TAG_ID.STYLE:
        case TAG_ID.XMP:
        case TAG_ID.IFRAME:
        case TAG_ID.NOEMBED:
        case TAG_ID.NOFRAMES:
        case TAG_ID.NOSCRIPT: {
          this.tokenizer.state = TokenizerMode.RAWTEXT;
          break;
        }
        case TAG_ID.SCRIPT: {
          this.tokenizer.state = TokenizerMode.SCRIPT_DATA;
          break;
        }
        case TAG_ID.PLAINTEXT: {
          this.tokenizer.state = TokenizerMode.PLAINTEXT;
          break;
        }
        default:
      }
    }
    //Tree mutation
    _setDocumentType(token) {
      const name = token.name || "";
      const publicId = token.publicId || "";
      const systemId = token.systemId || "";
      this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
      if (token.location) {
        const documentChildren = this.treeAdapter.getChildNodes(this.document);
        const docTypeNode = documentChildren.find((node) => this.treeAdapter.isDocumentTypeNode(node));
        if (docTypeNode) {
          this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
        }
      }
    }
    _attachElementToTree(element, location2) {
      if (this.options.sourceCodeLocationInfo) {
        const loc = location2 && {
          ...location2,
          startTag: location2
        };
        this.treeAdapter.setNodeSourceCodeLocation(element, loc);
      }
      if (this._shouldFosterParentOnInsertion()) {
        this._fosterParentElement(element);
      } else {
        const parent = this.openElements.currentTmplContentOrNode;
        this.treeAdapter.appendChild(parent, element);
      }
    }
    _appendElement(token, namespaceURI) {
      const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
      this._attachElementToTree(element, token.location);
    }
    _insertElement(token, namespaceURI) {
      const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
      this._attachElementToTree(element, token.location);
      this.openElements.push(element, token.tagID);
    }
    _insertFakeElement(tagName, tagID) {
      const element = this.treeAdapter.createElement(tagName, NS.HTML, []);
      this._attachElementToTree(element, null);
      this.openElements.push(element, tagID);
    }
    _insertTemplate(token) {
      const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
      const content = this.treeAdapter.createDocumentFragment();
      this.treeAdapter.setTemplateContent(tmpl, content);
      this._attachElementToTree(tmpl, token.location);
      this.openElements.push(tmpl, token.tagID);
      if (this.options.sourceCodeLocationInfo)
        this.treeAdapter.setNodeSourceCodeLocation(content, null);
    }
    _insertFakeRootElement() {
      const element = this.treeAdapter.createElement(TAG_NAMES.HTML, NS.HTML, []);
      if (this.options.sourceCodeLocationInfo)
        this.treeAdapter.setNodeSourceCodeLocation(element, null);
      this.treeAdapter.appendChild(this.openElements.current, element);
      this.openElements.push(element, TAG_ID.HTML);
    }
    _appendCommentNode(token, parent) {
      const commentNode = this.treeAdapter.createCommentNode(token.data);
      this.treeAdapter.appendChild(parent, commentNode);
      if (this.options.sourceCodeLocationInfo) {
        this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
      }
    }
    _insertCharacters(token) {
      let parent;
      let beforeElement;
      if (this._shouldFosterParentOnInsertion()) {
        ({ parent, beforeElement } = this._findFosterParentingLocation());
        if (beforeElement) {
          this.treeAdapter.insertTextBefore(parent, token.chars, beforeElement);
        } else {
          this.treeAdapter.insertText(parent, token.chars);
        }
      } else {
        parent = this.openElements.currentTmplContentOrNode;
        this.treeAdapter.insertText(parent, token.chars);
      }
      if (!token.location)
        return;
      const siblings = this.treeAdapter.getChildNodes(parent);
      const textNodeIdx = beforeElement ? siblings.lastIndexOf(beforeElement) : siblings.length;
      const textNode = siblings[textNodeIdx - 1];
      const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
      if (tnLoc) {
        const { endLine, endCol, endOffset } = token.location;
        this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
      } else if (this.options.sourceCodeLocationInfo) {
        this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
      }
    }
    _adoptNodes(donor, recipient) {
      for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
        this.treeAdapter.detachNode(child);
        this.treeAdapter.appendChild(recipient, child);
      }
    }
    _setEndLocation(element, closingToken) {
      if (this.treeAdapter.getNodeSourceCodeLocation(element) && closingToken.location) {
        const ctLoc = closingToken.location;
        const tn = this.treeAdapter.getTagName(element);
        const endLoc = (
          // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
          // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
          closingToken.type === TokenType.END_TAG && tn === closingToken.tagName ? {
            endTag: { ...ctLoc },
            endLine: ctLoc.endLine,
            endCol: ctLoc.endCol,
            endOffset: ctLoc.endOffset
          } : {
            endLine: ctLoc.startLine,
            endCol: ctLoc.startCol,
            endOffset: ctLoc.startOffset
          }
        );
        this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
      }
    }
    //Token processing
    shouldProcessStartTagTokenInForeignContent(token) {
      if (!this.currentNotInHTML)
        return false;
      let current;
      let currentTagId;
      if (this.openElements.stackTop === 0 && this.fragmentContext) {
        current = this.fragmentContext;
        currentTagId = this.fragmentContextID;
      } else {
        ({ current, currentTagId } = this.openElements);
      }
      if (token.tagID === TAG_ID.SVG && this.treeAdapter.getTagName(current) === TAG_NAMES.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(current) === NS.MATHML) {
        return false;
      }
      return (
        // Check that `current` is not an integration point for HTML or MathML elements.
        this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
        // integration point.
        (token.tagID === TAG_ID.MGLYPH || token.tagID === TAG_ID.MALIGNMARK) && !this._isIntegrationPoint(currentTagId, current, NS.HTML)
      );
    }
    _processToken(token) {
      switch (token.type) {
        case TokenType.CHARACTER: {
          this.onCharacter(token);
          break;
        }
        case TokenType.NULL_CHARACTER: {
          this.onNullCharacter(token);
          break;
        }
        case TokenType.COMMENT: {
          this.onComment(token);
          break;
        }
        case TokenType.DOCTYPE: {
          this.onDoctype(token);
          break;
        }
        case TokenType.START_TAG: {
          this._processStartTag(token);
          break;
        }
        case TokenType.END_TAG: {
          this.onEndTag(token);
          break;
        }
        case TokenType.EOF: {
          this.onEof(token);
          break;
        }
        case TokenType.WHITESPACE_CHARACTER: {
          this.onWhitespaceCharacter(token);
          break;
        }
      }
    }
    //Integration points
    _isIntegrationPoint(tid, element, foreignNS) {
      const ns = this.treeAdapter.getNamespaceURI(element);
      const attrs = this.treeAdapter.getAttrList(element);
      return isIntegrationPoint(tid, ns, attrs, foreignNS);
    }
    //Active formatting elements reconstruction
    _reconstructActiveFormattingElements() {
      const listLength = this.activeFormattingElements.entries.length;
      if (listLength) {
        const endIndex = this.activeFormattingElements.entries.findIndex((entry) => entry.type === EntryType.Marker || this.openElements.contains(entry.element));
        const unopenIdx = endIndex < 0 ? listLength - 1 : endIndex - 1;
        for (let i = unopenIdx; i >= 0; i--) {
          const entry = this.activeFormattingElements.entries[i];
          this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
          entry.element = this.openElements.current;
        }
      }
    }
    //Close elements
    _closeTableCell() {
      this.openElements.generateImpliedEndTags();
      this.openElements.popUntilTableCellPopped();
      this.activeFormattingElements.clearToLastMarker();
      this.insertionMode = InsertionMode.IN_ROW;
    }
    _closePElement() {
      this.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.P);
      this.openElements.popUntilTagNamePopped(TAG_ID.P);
    }
    //Insertion modes
    _resetInsertionMode() {
      for (let i = this.openElements.stackTop; i >= 0; i--) {
        switch (i === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i]) {
          case TAG_ID.TR: {
            this.insertionMode = InsertionMode.IN_ROW;
            return;
          }
          case TAG_ID.TBODY:
          case TAG_ID.THEAD:
          case TAG_ID.TFOOT: {
            this.insertionMode = InsertionMode.IN_TABLE_BODY;
            return;
          }
          case TAG_ID.CAPTION: {
            this.insertionMode = InsertionMode.IN_CAPTION;
            return;
          }
          case TAG_ID.COLGROUP: {
            this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
            return;
          }
          case TAG_ID.TABLE: {
            this.insertionMode = InsertionMode.IN_TABLE;
            return;
          }
          case TAG_ID.BODY: {
            this.insertionMode = InsertionMode.IN_BODY;
            return;
          }
          case TAG_ID.FRAMESET: {
            this.insertionMode = InsertionMode.IN_FRAMESET;
            return;
          }
          case TAG_ID.SELECT: {
            this._resetInsertionModeForSelect(i);
            return;
          }
          case TAG_ID.TEMPLATE: {
            this.insertionMode = this.tmplInsertionModeStack[0];
            return;
          }
          case TAG_ID.HTML: {
            this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
            return;
          }
          case TAG_ID.TD:
          case TAG_ID.TH: {
            if (i > 0) {
              this.insertionMode = InsertionMode.IN_CELL;
              return;
            }
            break;
          }
          case TAG_ID.HEAD: {
            if (i > 0) {
              this.insertionMode = InsertionMode.IN_HEAD;
              return;
            }
            break;
          }
        }
      }
      this.insertionMode = InsertionMode.IN_BODY;
    }
    _resetInsertionModeForSelect(selectIdx) {
      if (selectIdx > 0) {
        for (let i = selectIdx - 1; i > 0; i--) {
          const tn = this.openElements.tagIDs[i];
          if (tn === TAG_ID.TEMPLATE) {
            break;
          } else if (tn === TAG_ID.TABLE) {
            this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
            return;
          }
        }
      }
      this.insertionMode = InsertionMode.IN_SELECT;
    }
    //Foster parenting
    _isElementCausesFosterParenting(tn) {
      return TABLE_STRUCTURE_TAGS.has(tn);
    }
    _shouldFosterParentOnInsertion() {
      return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
    }
    _findFosterParentingLocation() {
      for (let i = this.openElements.stackTop; i >= 0; i--) {
        const openElement = this.openElements.items[i];
        switch (this.openElements.tagIDs[i]) {
          case TAG_ID.TEMPLATE: {
            if (this.treeAdapter.getNamespaceURI(openElement) === NS.HTML) {
              return { parent: this.treeAdapter.getTemplateContent(openElement), beforeElement: null };
            }
            break;
          }
          case TAG_ID.TABLE: {
            const parent = this.treeAdapter.getParentNode(openElement);
            if (parent) {
              return { parent, beforeElement: openElement };
            }
            return { parent: this.openElements.items[i - 1], beforeElement: null };
          }
          default:
        }
      }
      return { parent: this.openElements.items[0], beforeElement: null };
    }
    _fosterParentElement(element) {
      const location2 = this._findFosterParentingLocation();
      if (location2.beforeElement) {
        this.treeAdapter.insertBefore(location2.parent, element, location2.beforeElement);
      } else {
        this.treeAdapter.appendChild(location2.parent, element);
      }
    }
    //Special elements
    _isSpecialElement(element, id) {
      const ns = this.treeAdapter.getNamespaceURI(element);
      return SPECIAL_ELEMENTS[ns].has(id);
    }
    onCharacter(token) {
      this.skipNextNewLine = false;
      if (this.tokenizer.inForeignNode) {
        characterInForeignContent(this, token);
        return;
      }
      switch (this.insertionMode) {
        case InsertionMode.INITIAL: {
          tokenInInitialMode(this, token);
          break;
        }
        case InsertionMode.BEFORE_HTML: {
          tokenBeforeHtml(this, token);
          break;
        }
        case InsertionMode.BEFORE_HEAD: {
          tokenBeforeHead(this, token);
          break;
        }
        case InsertionMode.IN_HEAD: {
          tokenInHead(this, token);
          break;
        }
        case InsertionMode.IN_HEAD_NO_SCRIPT: {
          tokenInHeadNoScript(this, token);
          break;
        }
        case InsertionMode.AFTER_HEAD: {
          tokenAfterHead(this, token);
          break;
        }
        case InsertionMode.IN_BODY:
        case InsertionMode.IN_CAPTION:
        case InsertionMode.IN_CELL:
        case InsertionMode.IN_TEMPLATE: {
          characterInBody(this, token);
          break;
        }
        case InsertionMode.TEXT:
        case InsertionMode.IN_SELECT:
        case InsertionMode.IN_SELECT_IN_TABLE: {
          this._insertCharacters(token);
          break;
        }
        case InsertionMode.IN_TABLE:
        case InsertionMode.IN_TABLE_BODY:
        case InsertionMode.IN_ROW: {
          characterInTable(this, token);
          break;
        }
        case InsertionMode.IN_TABLE_TEXT: {
          characterInTableText(this, token);
          break;
        }
        case InsertionMode.IN_COLUMN_GROUP: {
          tokenInColumnGroup(this, token);
          break;
        }
        case InsertionMode.AFTER_BODY: {
          tokenAfterBody(this, token);
          break;
        }
        case InsertionMode.AFTER_AFTER_BODY: {
          tokenAfterAfterBody(this, token);
          break;
        }
        default:
      }
    }
    onNullCharacter(token) {
      this.skipNextNewLine = false;
      if (this.tokenizer.inForeignNode) {
        nullCharacterInForeignContent(this, token);
        return;
      }
      switch (this.insertionMode) {
        case InsertionMode.INITIAL: {
          tokenInInitialMode(this, token);
          break;
        }
        case InsertionMode.BEFORE_HTML: {
          tokenBeforeHtml(this, token);
          break;
        }
        case InsertionMode.BEFORE_HEAD: {
          tokenBeforeHead(this, token);
          break;
        }
        case InsertionMode.IN_HEAD: {
          tokenInHead(this, token);
          break;
        }
        case InsertionMode.IN_HEAD_NO_SCRIPT: {
          tokenInHeadNoScript(this, token);
          break;
        }
        case InsertionMode.AFTER_HEAD: {
          tokenAfterHead(this, token);
          break;
        }
        case InsertionMode.TEXT: {
          this._insertCharacters(token);
          break;
        }
        case InsertionMode.IN_TABLE:
        case InsertionMode.IN_TABLE_BODY:
        case InsertionMode.IN_ROW: {
          characterInTable(this, token);
          break;
        }
        case InsertionMode.IN_COLUMN_GROUP: {
          tokenInColumnGroup(this, token);
          break;
        }
        case InsertionMode.AFTER_BODY: {
          tokenAfterBody(this, token);
          break;
        }
        case InsertionMode.AFTER_AFTER_BODY: {
          tokenAfterAfterBody(this, token);
          break;
        }
        default:
      }
    }
    onComment(token) {
      this.skipNextNewLine = false;
      if (this.currentNotInHTML) {
        appendComment(this, token);
        return;
      }
      switch (this.insertionMode) {
        case InsertionMode.INITIAL:
        case InsertionMode.BEFORE_HTML:
        case InsertionMode.BEFORE_HEAD:
        case InsertionMode.IN_HEAD:
        case InsertionMode.IN_HEAD_NO_SCRIPT:
        case InsertionMode.AFTER_HEAD:
        case InsertionMode.IN_BODY:
        case InsertionMode.IN_TABLE:
        case InsertionMode.IN_CAPTION:
        case InsertionMode.IN_COLUMN_GROUP:
        case InsertionMode.IN_TABLE_BODY:
        case InsertionMode.IN_ROW:
        case InsertionMode.IN_CELL:
        case InsertionMode.IN_SELECT:
        case InsertionMode.IN_SELECT_IN_TABLE:
        case InsertionMode.IN_TEMPLATE:
        case InsertionMode.IN_FRAMESET:
        case InsertionMode.AFTER_FRAMESET: {
          appendComment(this, token);
          break;
        }
        case InsertionMode.IN_TABLE_TEXT: {
          tokenInTableText(this, token);
          break;
        }
        case InsertionMode.AFTER_BODY: {
          appendCommentToRootHtmlElement(this, token);
          break;
        }
        case InsertionMode.AFTER_AFTER_BODY:
        case InsertionMode.AFTER_AFTER_FRAMESET: {
          appendCommentToDocument(this, token);
          break;
        }
        default:
      }
    }
    onDoctype(token) {
      this.skipNextNewLine = false;
      switch (this.insertionMode) {
        case InsertionMode.INITIAL: {
          doctypeInInitialMode(this, token);
          break;
        }
        case InsertionMode.BEFORE_HEAD:
        case InsertionMode.IN_HEAD:
        case InsertionMode.IN_HEAD_NO_SCRIPT:
        case InsertionMode.AFTER_HEAD: {
          this._err(token, ERR.misplacedDoctype);
          break;
        }
        case InsertionMode.IN_TABLE_TEXT: {
          tokenInTableText(this, token);
          break;
        }
        default:
      }
    }
    onStartTag(token) {
      this.skipNextNewLine = false;
      this.currentToken = token;
      this._processStartTag(token);
      if (token.selfClosing && !token.ackSelfClosing) {
        this._err(token, ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
      }
    }
    /**
     * Processes a given start tag.
     *
     * `onStartTag` checks if a self-closing tag was recognized. When a token
     * is moved inbetween multiple insertion modes, this check for self-closing
     * could lead to false positives. To avoid this, `_processStartTag` is used
     * for nested calls.
     *
     * @param token The token to process.
     */
    _processStartTag(token) {
      if (this.shouldProcessStartTagTokenInForeignContent(token)) {
        startTagInForeignContent(this, token);
      } else {
        this._startTagOutsideForeignContent(token);
      }
    }
    _startTagOutsideForeignContent(token) {
      switch (this.insertionMode) {
        case InsertionMode.INITIAL: {
          tokenInInitialMode(this, token);
          break;
        }
        case InsertionMode.BEFORE_HTML: {
          startTagBeforeHtml(this, token);
          break;
        }
        case InsertionMode.BEFORE_HEAD: {
          startTagBeforeHead(this, token);
          break;
        }
        case InsertionMode.IN_HEAD: {
          startTagInHead(this, token);
          break;
        }
        case InsertionMode.IN_HEAD_NO_SCRIPT: {
          startTagInHeadNoScript(this, token);
          break;
        }
        case InsertionMode.AFTER_HEAD: {
          startTagAfterHead(this, token);
          break;
        }
        case InsertionMode.IN_BODY: {
          startTagInBody(this, token);
          break;
        }
        case InsertionMode.IN_TABLE: {
          startTagInTable(this, token);
          break;
        }
        case InsertionMode.IN_TABLE_TEXT: {
          tokenInTableText(this, token);
          break;
        }
        case InsertionMode.IN_CAPTION: {
          startTagInCaption(this, token);
          break;
        }
        case InsertionMode.IN_COLUMN_GROUP: {
          startTagInColumnGroup(this, token);
          break;
        }
        case InsertionMode.IN_TABLE_BODY: {
          startTagInTableBody(this, token);
          break;
        }
        case InsertionMode.IN_ROW: {
          startTagInRow(this, token);
          break;
        }
        case InsertionMode.IN_CELL: {
          startTagInCell(this, token);
          break;
        }
        case InsertionMode.IN_SELECT: {
          startTagInSelect(this, token);
          break;
        }
        case InsertionMode.IN_SELECT_IN_TABLE: {
          startTagInSelectInTable(this, token);
          break;
        }
        case InsertionMode.IN_TEMPLATE: {
          startTagInTemplate(this, token);
          break;
        }
        case InsertionMode.AFTER_BODY: {
          startTagAfterBody(this, token);
          break;
        }
        case InsertionMode.IN_FRAMESET: {
          startTagInFrameset(this, token);
          break;
        }
        case InsertionMode.AFTER_FRAMESET: {
          startTagAfterFrameset(this, token);
          break;
        }
        case InsertionMode.AFTER_AFTER_BODY: {
          startTagAfterAfterBody(this, token);
          break;
        }
        case InsertionMode.AFTER_AFTER_FRAMESET: {
          startTagAfterAfterFrameset(this, token);
          break;
        }
        default:
      }
    }
    onEndTag(token) {
      this.skipNextNewLine = false;
      this.currentToken = token;
      if (this.currentNotInHTML) {
        endTagInForeignContent(this, token);
      } else {
        this._endTagOutsideForeignContent(token);
      }
    }
    _endTagOutsideForeignContent(token) {
      switch (this.insertionMode) {
        case InsertionMode.INITIAL: {
          tokenInInitialMode(this, token);
          break;
        }
        case InsertionMode.BEFORE_HTML: {
          endTagBeforeHtml(this, token);
          break;
        }
        case InsertionMode.BEFORE_HEAD: {
          endTagBeforeHead(this, token);
          break;
        }
        case InsertionMode.IN_HEAD: {
          endTagInHead(this, token);
          break;
        }
        case InsertionMode.IN_HEAD_NO_SCRIPT: {
          endTagInHeadNoScript(this, token);
          break;
        }
        case InsertionMode.AFTER_HEAD: {
          endTagAfterHead(this, token);
          break;
        }
        case InsertionMode.IN_BODY: {
          endTagInBody(this, token);
          break;
        }
        case InsertionMode.TEXT: {
          endTagInText(this, token);
          break;
        }
        case InsertionMode.IN_TABLE: {
          endTagInTable(this, token);
          break;
        }
        case InsertionMode.IN_TABLE_TEXT: {
          tokenInTableText(this, token);
          break;
        }
        case InsertionMode.IN_CAPTION: {
          endTagInCaption(this, token);
          break;
        }
        case InsertionMode.IN_COLUMN_GROUP: {
          endTagInColumnGroup(this, token);
          break;
        }
        case InsertionMode.IN_TABLE_BODY: {
          endTagInTableBody(this, token);
          break;
        }
        case InsertionMode.IN_ROW: {
          endTagInRow(this, token);
          break;
        }
        case InsertionMode.IN_CELL: {
          endTagInCell(this, token);
          break;
        }
        case InsertionMode.IN_SELECT: {
          endTagInSelect(this, token);
          break;
        }
        case InsertionMode.IN_SELECT_IN_TABLE: {
          endTagInSelectInTable(this, token);
          break;
        }
        case InsertionMode.IN_TEMPLATE: {
          endTagInTemplate(this, token);
          break;
        }
        case InsertionMode.AFTER_BODY: {
          endTagAfterBody(this, token);
          break;
        }
        case InsertionMode.IN_FRAMESET: {
          endTagInFrameset(this, token);
          break;
        }
        case InsertionMode.AFTER_FRAMESET: {
          endTagAfterFrameset(this, token);
          break;
        }
        case InsertionMode.AFTER_AFTER_BODY: {
          tokenAfterAfterBody(this, token);
          break;
        }
        default:
      }
    }
    onEof(token) {
      switch (this.insertionMode) {
        case InsertionMode.INITIAL: {
          tokenInInitialMode(this, token);
          break;
        }
        case InsertionMode.BEFORE_HTML: {
          tokenBeforeHtml(this, token);
          break;
        }
        case InsertionMode.BEFORE_HEAD: {
          tokenBeforeHead(this, token);
          break;
        }
        case InsertionMode.IN_HEAD: {
          tokenInHead(this, token);
          break;
        }
        case InsertionMode.IN_HEAD_NO_SCRIPT: {
          tokenInHeadNoScript(this, token);
          break;
        }
        case InsertionMode.AFTER_HEAD: {
          tokenAfterHead(this, token);
          break;
        }
        case InsertionMode.IN_BODY:
        case InsertionMode.IN_TABLE:
        case InsertionMode.IN_CAPTION:
        case InsertionMode.IN_COLUMN_GROUP:
        case InsertionMode.IN_TABLE_BODY:
        case InsertionMode.IN_ROW:
        case InsertionMode.IN_CELL:
        case InsertionMode.IN_SELECT:
        case InsertionMode.IN_SELECT_IN_TABLE: {
          eofInBody(this, token);
          break;
        }
        case InsertionMode.TEXT: {
          eofInText(this, token);
          break;
        }
        case InsertionMode.IN_TABLE_TEXT: {
          tokenInTableText(this, token);
          break;
        }
        case InsertionMode.IN_TEMPLATE: {
          eofInTemplate(this, token);
          break;
        }
        case InsertionMode.AFTER_BODY:
        case InsertionMode.IN_FRAMESET:
        case InsertionMode.AFTER_FRAMESET:
        case InsertionMode.AFTER_AFTER_BODY:
        case InsertionMode.AFTER_AFTER_FRAMESET: {
          stopParsing(this, token);
          break;
        }
        default:
      }
    }
    onWhitespaceCharacter(token) {
      if (this.skipNextNewLine) {
        this.skipNextNewLine = false;
        if (token.chars.charCodeAt(0) === CODE_POINTS.LINE_FEED) {
          if (token.chars.length === 1) {
            return;
          }
          token.chars = token.chars.substr(1);
        }
      }
      if (this.tokenizer.inForeignNode) {
        this._insertCharacters(token);
        return;
      }
      switch (this.insertionMode) {
        case InsertionMode.IN_HEAD:
        case InsertionMode.IN_HEAD_NO_SCRIPT:
        case InsertionMode.AFTER_HEAD:
        case InsertionMode.TEXT:
        case InsertionMode.IN_COLUMN_GROUP:
        case InsertionMode.IN_SELECT:
        case InsertionMode.IN_SELECT_IN_TABLE:
        case InsertionMode.IN_FRAMESET:
        case InsertionMode.AFTER_FRAMESET: {
          this._insertCharacters(token);
          break;
        }
        case InsertionMode.IN_BODY:
        case InsertionMode.IN_CAPTION:
        case InsertionMode.IN_CELL:
        case InsertionMode.IN_TEMPLATE:
        case InsertionMode.AFTER_BODY:
        case InsertionMode.AFTER_AFTER_BODY:
        case InsertionMode.AFTER_AFTER_FRAMESET: {
          whitespaceCharacterInBody(this, token);
          break;
        }
        case InsertionMode.IN_TABLE:
        case InsertionMode.IN_TABLE_BODY:
        case InsertionMode.IN_ROW: {
          characterInTable(this, token);
          break;
        }
        case InsertionMode.IN_TABLE_TEXT: {
          whitespaceCharacterInTableText(this, token);
          break;
        }
        default:
      }
    }
  };
  function aaObtainFormattingElementEntry(p, token) {
    let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
    if (formattingElementEntry) {
      if (!p.openElements.contains(formattingElementEntry.element)) {
        p.activeFormattingElements.removeEntry(formattingElementEntry);
        formattingElementEntry = null;
      } else if (!p.openElements.hasInScope(token.tagID)) {
        formattingElementEntry = null;
      }
    } else {
      genericEndTagInBody(p, token);
    }
    return formattingElementEntry;
  }
  function aaObtainFurthestBlock(p, formattingElementEntry) {
    let furthestBlock = null;
    let idx = p.openElements.stackTop;
    for (; idx >= 0; idx--) {
      const element = p.openElements.items[idx];
      if (element === formattingElementEntry.element) {
        break;
      }
      if (p._isSpecialElement(element, p.openElements.tagIDs[idx])) {
        furthestBlock = element;
      }
    }
    if (!furthestBlock) {
      p.openElements.shortenToLength(idx < 0 ? 0 : idx);
      p.activeFormattingElements.removeEntry(formattingElementEntry);
    }
    return furthestBlock;
  }
  function aaInnerLoop(p, furthestBlock, formattingElement) {
    let lastElement = furthestBlock;
    let nextElement = p.openElements.getCommonAncestor(furthestBlock);
    for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
      nextElement = p.openElements.getCommonAncestor(element);
      const elementEntry = p.activeFormattingElements.getElementEntry(element);
      const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
      const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
      if (shouldRemoveFromOpenElements) {
        if (counterOverflow) {
          p.activeFormattingElements.removeEntry(elementEntry);
        }
        p.openElements.remove(element);
      } else {
        element = aaRecreateElementFromEntry(p, elementEntry);
        if (lastElement === furthestBlock) {
          p.activeFormattingElements.bookmark = elementEntry;
        }
        p.treeAdapter.detachNode(lastElement);
        p.treeAdapter.appendChild(element, lastElement);
        lastElement = element;
      }
    }
    return lastElement;
  }
  function aaRecreateElementFromEntry(p, elementEntry) {
    const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
    const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
    p.openElements.replace(elementEntry.element, newElement);
    elementEntry.element = newElement;
    return newElement;
  }
  function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
    const tn = p.treeAdapter.getTagName(commonAncestor);
    const tid = getTagID(tn);
    if (p._isElementCausesFosterParenting(tid)) {
      p._fosterParentElement(lastElement);
    } else {
      const ns = p.treeAdapter.getNamespaceURI(commonAncestor);
      if (tid === TAG_ID.TEMPLATE && ns === NS.HTML) {
        commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
      }
      p.treeAdapter.appendChild(commonAncestor, lastElement);
    }
  }
  function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
    const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
    const { token } = formattingElementEntry;
    const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);
    p._adoptNodes(furthestBlock, newElement);
    p.treeAdapter.appendChild(furthestBlock, newElement);
    p.activeFormattingElements.insertElementAfterBookmark(newElement, token);
    p.activeFormattingElements.removeEntry(formattingElementEntry);
    p.openElements.remove(formattingElementEntry.element);
    p.openElements.insertAfter(furthestBlock, newElement, token.tagID);
  }
  function callAdoptionAgency(p, token) {
    for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
      const formattingElementEntry = aaObtainFormattingElementEntry(p, token);
      if (!formattingElementEntry) {
        break;
      }
      const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);
      if (!furthestBlock) {
        break;
      }
      p.activeFormattingElements.bookmark = formattingElementEntry;
      const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);
      const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);
      p.treeAdapter.detachNode(lastElement);
      if (commonAncestor)
        aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
      aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
    }
  }
  function appendComment(p, token) {
    p._appendCommentNode(token, p.openElements.currentTmplContentOrNode);
  }
  function appendCommentToRootHtmlElement(p, token) {
    p._appendCommentNode(token, p.openElements.items[0]);
  }
  function appendCommentToDocument(p, token) {
    p._appendCommentNode(token, p.document);
  }
  function stopParsing(p, token) {
    p.stopped = true;
    if (token.location) {
      const target = p.fragmentContext ? 0 : 2;
      for (let i = p.openElements.stackTop; i >= target; i--) {
        p._setEndLocation(p.openElements.items[i], token);
      }
      if (!p.fragmentContext && p.openElements.stackTop >= 0) {
        const htmlElement = p.openElements.items[0];
        const htmlLocation = p.treeAdapter.getNodeSourceCodeLocation(htmlElement);
        if (htmlLocation && !htmlLocation.endTag) {
          p._setEndLocation(htmlElement, token);
          if (p.openElements.stackTop >= 1) {
            const bodyElement = p.openElements.items[1];
            const bodyLocation = p.treeAdapter.getNodeSourceCodeLocation(bodyElement);
            if (bodyLocation && !bodyLocation.endTag) {
              p._setEndLocation(bodyElement, token);
            }
          }
        }
      }
    }
  }
  function doctypeInInitialMode(p, token) {
    p._setDocumentType(token);
    const mode = token.forceQuirks ? DOCUMENT_MODE.QUIRKS : getDocumentMode(token);
    if (!isConforming(token)) {
      p._err(token, ERR.nonConformingDoctype);
    }
    p.treeAdapter.setDocumentMode(p.document, mode);
    p.insertionMode = InsertionMode.BEFORE_HTML;
  }
  function tokenInInitialMode(p, token) {
    p._err(token, ERR.missingDoctype, true);
    p.treeAdapter.setDocumentMode(p.document, DOCUMENT_MODE.QUIRKS);
    p.insertionMode = InsertionMode.BEFORE_HTML;
    p._processToken(token);
  }
  function startTagBeforeHtml(p, token) {
    if (token.tagID === TAG_ID.HTML) {
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.BEFORE_HEAD;
    } else {
      tokenBeforeHtml(p, token);
    }
  }
  function endTagBeforeHtml(p, token) {
    const tn = token.tagID;
    if (tn === TAG_ID.HTML || tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.BR) {
      tokenBeforeHtml(p, token);
    }
  }
  function tokenBeforeHtml(p, token) {
    p._insertFakeRootElement();
    p.insertionMode = InsertionMode.BEFORE_HEAD;
    p._processToken(token);
  }
  function startTagBeforeHead(p, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p, token);
        break;
      }
      case TAG_ID.HEAD: {
        p._insertElement(token, NS.HTML);
        p.headElement = p.openElements.current;
        p.insertionMode = InsertionMode.IN_HEAD;
        break;
      }
      default: {
        tokenBeforeHead(p, token);
      }
    }
  }
  function endTagBeforeHead(p, token) {
    const tn = token.tagID;
    if (tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.HTML || tn === TAG_ID.BR) {
      tokenBeforeHead(p, token);
    } else {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
  function tokenBeforeHead(p, token) {
    p._insertFakeElement(TAG_NAMES.HEAD, TAG_ID.HEAD);
    p.headElement = p.openElements.current;
    p.insertionMode = InsertionMode.IN_HEAD;
    p._processToken(token);
  }
  function startTagInHead(p, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p, token);
        break;
      }
      case TAG_ID.BASE:
      case TAG_ID.BASEFONT:
      case TAG_ID.BGSOUND:
      case TAG_ID.LINK:
      case TAG_ID.META: {
        p._appendElement(token, NS.HTML);
        token.ackSelfClosing = true;
        break;
      }
      case TAG_ID.TITLE: {
        p._switchToTextParsing(token, TokenizerMode.RCDATA);
        break;
      }
      case TAG_ID.NOSCRIPT: {
        if (p.options.scriptingEnabled) {
          p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
        } else {
          p._insertElement(token, NS.HTML);
          p.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
        }
        break;
      }
      case TAG_ID.NOFRAMES:
      case TAG_ID.STYLE: {
        p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
        break;
      }
      case TAG_ID.SCRIPT: {
        p._switchToTextParsing(token, TokenizerMode.SCRIPT_DATA);
        break;
      }
      case TAG_ID.TEMPLATE: {
        p._insertTemplate(token);
        p.activeFormattingElements.insertMarker();
        p.framesetOk = false;
        p.insertionMode = InsertionMode.IN_TEMPLATE;
        p.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
        break;
      }
      case TAG_ID.HEAD: {
        p._err(token, ERR.misplacedStartTagForHeadElement);
        break;
      }
      default: {
        tokenInHead(p, token);
      }
    }
  }
  function endTagInHead(p, token) {
    switch (token.tagID) {
      case TAG_ID.HEAD: {
        p.openElements.pop();
        p.insertionMode = InsertionMode.AFTER_HEAD;
        break;
      }
      case TAG_ID.BODY:
      case TAG_ID.BR:
      case TAG_ID.HTML: {
        tokenInHead(p, token);
        break;
      }
      case TAG_ID.TEMPLATE: {
        templateEndTagInHead(p, token);
        break;
      }
      default: {
        p._err(token, ERR.endTagWithoutMatchingOpenElement);
      }
    }
  }
  function templateEndTagInHead(p, token) {
    if (p.openElements.tmplCount > 0) {
      p.openElements.generateImpliedEndTagsThoroughly();
      if (p.openElements.currentTagId !== TAG_ID.TEMPLATE) {
        p._err(token, ERR.closingOfElementWithOpenChildElements);
      }
      p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
      p.activeFormattingElements.clearToLastMarker();
      p.tmplInsertionModeStack.shift();
      p._resetInsertionMode();
    } else {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
  function tokenInHead(p, token) {
    p.openElements.pop();
    p.insertionMode = InsertionMode.AFTER_HEAD;
    p._processToken(token);
  }
  function startTagInHeadNoScript(p, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p, token);
        break;
      }
      case TAG_ID.BASEFONT:
      case TAG_ID.BGSOUND:
      case TAG_ID.HEAD:
      case TAG_ID.LINK:
      case TAG_ID.META:
      case TAG_ID.NOFRAMES:
      case TAG_ID.STYLE: {
        startTagInHead(p, token);
        break;
      }
      case TAG_ID.NOSCRIPT: {
        p._err(token, ERR.nestedNoscriptInHead);
        break;
      }
      default: {
        tokenInHeadNoScript(p, token);
      }
    }
  }
  function endTagInHeadNoScript(p, token) {
    switch (token.tagID) {
      case TAG_ID.NOSCRIPT: {
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_HEAD;
        break;
      }
      case TAG_ID.BR: {
        tokenInHeadNoScript(p, token);
        break;
      }
      default: {
        p._err(token, ERR.endTagWithoutMatchingOpenElement);
      }
    }
  }
  function tokenInHeadNoScript(p, token) {
    const errCode = token.type === TokenType.EOF ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
    p._err(token, errCode);
    p.openElements.pop();
    p.insertionMode = InsertionMode.IN_HEAD;
    p._processToken(token);
  }
  function startTagAfterHead(p, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p, token);
        break;
      }
      case TAG_ID.BODY: {
        p._insertElement(token, NS.HTML);
        p.framesetOk = false;
        p.insertionMode = InsertionMode.IN_BODY;
        break;
      }
      case TAG_ID.FRAMESET: {
        p._insertElement(token, NS.HTML);
        p.insertionMode = InsertionMode.IN_FRAMESET;
        break;
      }
      case TAG_ID.BASE:
      case TAG_ID.BASEFONT:
      case TAG_ID.BGSOUND:
      case TAG_ID.LINK:
      case TAG_ID.META:
      case TAG_ID.NOFRAMES:
      case TAG_ID.SCRIPT:
      case TAG_ID.STYLE:
      case TAG_ID.TEMPLATE:
      case TAG_ID.TITLE: {
        p._err(token, ERR.abandonedHeadElementChild);
        p.openElements.push(p.headElement, TAG_ID.HEAD);
        startTagInHead(p, token);
        p.openElements.remove(p.headElement);
        break;
      }
      case TAG_ID.HEAD: {
        p._err(token, ERR.misplacedStartTagForHeadElement);
        break;
      }
      default: {
        tokenAfterHead(p, token);
      }
    }
  }
  function endTagAfterHead(p, token) {
    switch (token.tagID) {
      case TAG_ID.BODY:
      case TAG_ID.HTML:
      case TAG_ID.BR: {
        tokenAfterHead(p, token);
        break;
      }
      case TAG_ID.TEMPLATE: {
        templateEndTagInHead(p, token);
        break;
      }
      default: {
        p._err(token, ERR.endTagWithoutMatchingOpenElement);
      }
    }
  }
  function tokenAfterHead(p, token) {
    p._insertFakeElement(TAG_NAMES.BODY, TAG_ID.BODY);
    p.insertionMode = InsertionMode.IN_BODY;
    modeInBody(p, token);
  }
  function modeInBody(p, token) {
    switch (token.type) {
      case TokenType.CHARACTER: {
        characterInBody(p, token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        whitespaceCharacterInBody(p, token);
        break;
      }
      case TokenType.COMMENT: {
        appendComment(p, token);
        break;
      }
      case TokenType.START_TAG: {
        startTagInBody(p, token);
        break;
      }
      case TokenType.END_TAG: {
        endTagInBody(p, token);
        break;
      }
      case TokenType.EOF: {
        eofInBody(p, token);
        break;
      }
      default:
    }
  }
  function whitespaceCharacterInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertCharacters(token);
  }
  function characterInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertCharacters(token);
    p.framesetOk = false;
  }
  function htmlStartTagInBody(p, token) {
    if (p.openElements.tmplCount === 0) {
      p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
    }
  }
  function bodyStartTagInBody(p, token) {
    const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
    if (bodyElement && p.openElements.tmplCount === 0) {
      p.framesetOk = false;
      p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
    }
  }
  function framesetStartTagInBody(p, token) {
    const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
    if (p.framesetOk && bodyElement) {
      p.treeAdapter.detachNode(bodyElement);
      p.openElements.popAllUpToHtmlElement();
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.IN_FRAMESET;
    }
  }
  function addressStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope(TAG_ID.P)) {
      p._closePElement();
    }
    p._insertElement(token, NS.HTML);
  }
  function numberedHeaderStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope(TAG_ID.P)) {
      p._closePElement();
    }
    if (isNumberedHeader(p.openElements.currentTagId)) {
      p.openElements.pop();
    }
    p._insertElement(token, NS.HTML);
  }
  function preStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope(TAG_ID.P)) {
      p._closePElement();
    }
    p._insertElement(token, NS.HTML);
    p.skipNextNewLine = true;
    p.framesetOk = false;
  }
  function formStartTagInBody(p, token) {
    const inTemplate = p.openElements.tmplCount > 0;
    if (!p.formElement || inTemplate) {
      if (p.openElements.hasInButtonScope(TAG_ID.P)) {
        p._closePElement();
      }
      p._insertElement(token, NS.HTML);
      if (!inTemplate) {
        p.formElement = p.openElements.current;
      }
    }
  }
  function listItemStartTagInBody(p, token) {
    p.framesetOk = false;
    const tn = token.tagID;
    for (let i = p.openElements.stackTop; i >= 0; i--) {
      const elementId = p.openElements.tagIDs[i];
      if (tn === TAG_ID.LI && elementId === TAG_ID.LI || (tn === TAG_ID.DD || tn === TAG_ID.DT) && (elementId === TAG_ID.DD || elementId === TAG_ID.DT)) {
        p.openElements.generateImpliedEndTagsWithExclusion(elementId);
        p.openElements.popUntilTagNamePopped(elementId);
        break;
      }
      if (elementId !== TAG_ID.ADDRESS && elementId !== TAG_ID.DIV && elementId !== TAG_ID.P && p._isSpecialElement(p.openElements.items[i], elementId)) {
        break;
      }
    }
    if (p.openElements.hasInButtonScope(TAG_ID.P)) {
      p._closePElement();
    }
    p._insertElement(token, NS.HTML);
  }
  function plaintextStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope(TAG_ID.P)) {
      p._closePElement();
    }
    p._insertElement(token, NS.HTML);
    p.tokenizer.state = TokenizerMode.PLAINTEXT;
  }
  function buttonStartTagInBody(p, token) {
    if (p.openElements.hasInScope(TAG_ID.BUTTON)) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilTagNamePopped(TAG_ID.BUTTON);
    }
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
    p.framesetOk = false;
  }
  function aStartTagInBody(p, token) {
    const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(TAG_NAMES.A);
    if (activeElementEntry) {
      callAdoptionAgency(p, token);
      p.openElements.remove(activeElementEntry.element);
      p.activeFormattingElements.removeEntry(activeElementEntry);
    }
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
    p.activeFormattingElements.pushElement(p.openElements.current, token);
  }
  function bStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
    p.activeFormattingElements.pushElement(p.openElements.current, token);
  }
  function nobrStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    if (p.openElements.hasInScope(TAG_ID.NOBR)) {
      callAdoptionAgency(p, token);
      p._reconstructActiveFormattingElements();
    }
    p._insertElement(token, NS.HTML);
    p.activeFormattingElements.pushElement(p.openElements.current, token);
  }
  function appletStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
    p.activeFormattingElements.insertMarker();
    p.framesetOk = false;
  }
  function tableStartTagInBody(p, token) {
    if (p.treeAdapter.getDocumentMode(p.document) !== DOCUMENT_MODE.QUIRKS && p.openElements.hasInButtonScope(TAG_ID.P)) {
      p._closePElement();
    }
    p._insertElement(token, NS.HTML);
    p.framesetOk = false;
    p.insertionMode = InsertionMode.IN_TABLE;
  }
  function areaStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._appendElement(token, NS.HTML);
    p.framesetOk = false;
    token.ackSelfClosing = true;
  }
  function isHiddenInput(token) {
    const inputType = getTokenAttr(token, ATTRS.TYPE);
    return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
  }
  function inputStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._appendElement(token, NS.HTML);
    if (!isHiddenInput(token)) {
      p.framesetOk = false;
    }
    token.ackSelfClosing = true;
  }
  function paramStartTagInBody(p, token) {
    p._appendElement(token, NS.HTML);
    token.ackSelfClosing = true;
  }
  function hrStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope(TAG_ID.P)) {
      p._closePElement();
    }
    p._appendElement(token, NS.HTML);
    p.framesetOk = false;
    token.ackSelfClosing = true;
  }
  function imageStartTagInBody(p, token) {
    token.tagName = TAG_NAMES.IMG;
    token.tagID = TAG_ID.IMG;
    areaStartTagInBody(p, token);
  }
  function textareaStartTagInBody(p, token) {
    p._insertElement(token, NS.HTML);
    p.skipNextNewLine = true;
    p.tokenizer.state = TokenizerMode.RCDATA;
    p.originalInsertionMode = p.insertionMode;
    p.framesetOk = false;
    p.insertionMode = InsertionMode.TEXT;
  }
  function xmpStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope(TAG_ID.P)) {
      p._closePElement();
    }
    p._reconstructActiveFormattingElements();
    p.framesetOk = false;
    p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
  }
  function iframeStartTagInBody(p, token) {
    p.framesetOk = false;
    p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
  }
  function noembedStartTagInBody(p, token) {
    p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
  }
  function selectStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
    p.framesetOk = false;
    p.insertionMode = p.insertionMode === InsertionMode.IN_TABLE || p.insertionMode === InsertionMode.IN_CAPTION || p.insertionMode === InsertionMode.IN_TABLE_BODY || p.insertionMode === InsertionMode.IN_ROW || p.insertionMode === InsertionMode.IN_CELL ? InsertionMode.IN_SELECT_IN_TABLE : InsertionMode.IN_SELECT;
  }
  function optgroupStartTagInBody(p, token) {
    if (p.openElements.currentTagId === TAG_ID.OPTION) {
      p.openElements.pop();
    }
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
  }
  function rbStartTagInBody(p, token) {
    if (p.openElements.hasInScope(TAG_ID.RUBY)) {
      p.openElements.generateImpliedEndTags();
    }
    p._insertElement(token, NS.HTML);
  }
  function rtStartTagInBody(p, token) {
    if (p.openElements.hasInScope(TAG_ID.RUBY)) {
      p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.RTC);
    }
    p._insertElement(token, NS.HTML);
  }
  function mathStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    adjustTokenMathMLAttrs(token);
    adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p._appendElement(token, NS.MATHML);
    } else {
      p._insertElement(token, NS.MATHML);
    }
    token.ackSelfClosing = true;
  }
  function svgStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    adjustTokenSVGAttrs(token);
    adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p._appendElement(token, NS.SVG);
    } else {
      p._insertElement(token, NS.SVG);
    }
    token.ackSelfClosing = true;
  }
  function genericStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
  }
  function startTagInBody(p, token) {
    switch (token.tagID) {
      case TAG_ID.I:
      case TAG_ID.S:
      case TAG_ID.B:
      case TAG_ID.U:
      case TAG_ID.EM:
      case TAG_ID.TT:
      case TAG_ID.BIG:
      case TAG_ID.CODE:
      case TAG_ID.FONT:
      case TAG_ID.SMALL:
      case TAG_ID.STRIKE:
      case TAG_ID.STRONG: {
        bStartTagInBody(p, token);
        break;
      }
      case TAG_ID.A: {
        aStartTagInBody(p, token);
        break;
      }
      case TAG_ID.H1:
      case TAG_ID.H2:
      case TAG_ID.H3:
      case TAG_ID.H4:
      case TAG_ID.H5:
      case TAG_ID.H6: {
        numberedHeaderStartTagInBody(p, token);
        break;
      }
      case TAG_ID.P:
      case TAG_ID.DL:
      case TAG_ID.OL:
      case TAG_ID.UL:
      case TAG_ID.DIV:
      case TAG_ID.DIR:
      case TAG_ID.NAV:
      case TAG_ID.MAIN:
      case TAG_ID.MENU:
      case TAG_ID.ASIDE:
      case TAG_ID.CENTER:
      case TAG_ID.FIGURE:
      case TAG_ID.FOOTER:
      case TAG_ID.HEADER:
      case TAG_ID.HGROUP:
      case TAG_ID.DIALOG:
      case TAG_ID.DETAILS:
      case TAG_ID.ADDRESS:
      case TAG_ID.ARTICLE:
      case TAG_ID.SECTION:
      case TAG_ID.SUMMARY:
      case TAG_ID.FIELDSET:
      case TAG_ID.BLOCKQUOTE:
      case TAG_ID.FIGCAPTION: {
        addressStartTagInBody(p, token);
        break;
      }
      case TAG_ID.LI:
      case TAG_ID.DD:
      case TAG_ID.DT: {
        listItemStartTagInBody(p, token);
        break;
      }
      case TAG_ID.BR:
      case TAG_ID.IMG:
      case TAG_ID.WBR:
      case TAG_ID.AREA:
      case TAG_ID.EMBED:
      case TAG_ID.KEYGEN: {
        areaStartTagInBody(p, token);
        break;
      }
      case TAG_ID.HR: {
        hrStartTagInBody(p, token);
        break;
      }
      case TAG_ID.RB:
      case TAG_ID.RTC: {
        rbStartTagInBody(p, token);
        break;
      }
      case TAG_ID.RT:
      case TAG_ID.RP: {
        rtStartTagInBody(p, token);
        break;
      }
      case TAG_ID.PRE:
      case TAG_ID.LISTING: {
        preStartTagInBody(p, token);
        break;
      }
      case TAG_ID.XMP: {
        xmpStartTagInBody(p, token);
        break;
      }
      case TAG_ID.SVG: {
        svgStartTagInBody(p, token);
        break;
      }
      case TAG_ID.HTML: {
        htmlStartTagInBody(p, token);
        break;
      }
      case TAG_ID.BASE:
      case TAG_ID.LINK:
      case TAG_ID.META:
      case TAG_ID.STYLE:
      case TAG_ID.TITLE:
      case TAG_ID.SCRIPT:
      case TAG_ID.BGSOUND:
      case TAG_ID.BASEFONT:
      case TAG_ID.TEMPLATE: {
        startTagInHead(p, token);
        break;
      }
      case TAG_ID.BODY: {
        bodyStartTagInBody(p, token);
        break;
      }
      case TAG_ID.FORM: {
        formStartTagInBody(p, token);
        break;
      }
      case TAG_ID.NOBR: {
        nobrStartTagInBody(p, token);
        break;
      }
      case TAG_ID.MATH: {
        mathStartTagInBody(p, token);
        break;
      }
      case TAG_ID.TABLE: {
        tableStartTagInBody(p, token);
        break;
      }
      case TAG_ID.INPUT: {
        inputStartTagInBody(p, token);
        break;
      }
      case TAG_ID.PARAM:
      case TAG_ID.TRACK:
      case TAG_ID.SOURCE: {
        paramStartTagInBody(p, token);
        break;
      }
      case TAG_ID.IMAGE: {
        imageStartTagInBody(p, token);
        break;
      }
      case TAG_ID.BUTTON: {
        buttonStartTagInBody(p, token);
        break;
      }
      case TAG_ID.APPLET:
      case TAG_ID.OBJECT:
      case TAG_ID.MARQUEE: {
        appletStartTagInBody(p, token);
        break;
      }
      case TAG_ID.IFRAME: {
        iframeStartTagInBody(p, token);
        break;
      }
      case TAG_ID.SELECT: {
        selectStartTagInBody(p, token);
        break;
      }
      case TAG_ID.OPTION:
      case TAG_ID.OPTGROUP: {
        optgroupStartTagInBody(p, token);
        break;
      }
      case TAG_ID.NOEMBED: {
        noembedStartTagInBody(p, token);
        break;
      }
      case TAG_ID.FRAMESET: {
        framesetStartTagInBody(p, token);
        break;
      }
      case TAG_ID.TEXTAREA: {
        textareaStartTagInBody(p, token);
        break;
      }
      case TAG_ID.NOSCRIPT: {
        if (p.options.scriptingEnabled) {
          noembedStartTagInBody(p, token);
        } else {
          genericStartTagInBody(p, token);
        }
        break;
      }
      case TAG_ID.PLAINTEXT: {
        plaintextStartTagInBody(p, token);
        break;
      }
      case TAG_ID.COL:
      case TAG_ID.TH:
      case TAG_ID.TD:
      case TAG_ID.TR:
      case TAG_ID.HEAD:
      case TAG_ID.FRAME:
      case TAG_ID.TBODY:
      case TAG_ID.TFOOT:
      case TAG_ID.THEAD:
      case TAG_ID.CAPTION:
      case TAG_ID.COLGROUP: {
        break;
      }
      default: {
        genericStartTagInBody(p, token);
      }
    }
  }
  function bodyEndTagInBody(p, token) {
    if (p.openElements.hasInScope(TAG_ID.BODY)) {
      p.insertionMode = InsertionMode.AFTER_BODY;
      if (p.options.sourceCodeLocationInfo) {
        const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
        if (bodyElement) {
          p._setEndLocation(bodyElement, token);
        }
      }
    }
  }
  function htmlEndTagInBody(p, token) {
    if (p.openElements.hasInScope(TAG_ID.BODY)) {
      p.insertionMode = InsertionMode.AFTER_BODY;
      endTagAfterBody(p, token);
    }
  }
  function addressEndTagInBody(p, token) {
    const tn = token.tagID;
    if (p.openElements.hasInScope(tn)) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilTagNamePopped(tn);
    }
  }
  function formEndTagInBody(p) {
    const inTemplate = p.openElements.tmplCount > 0;
    const { formElement } = p;
    if (!inTemplate) {
      p.formElement = null;
    }
    if ((formElement || inTemplate) && p.openElements.hasInScope(TAG_ID.FORM)) {
      p.openElements.generateImpliedEndTags();
      if (inTemplate) {
        p.openElements.popUntilTagNamePopped(TAG_ID.FORM);
      } else if (formElement) {
        p.openElements.remove(formElement);
      }
    }
  }
  function pEndTagInBody(p) {
    if (!p.openElements.hasInButtonScope(TAG_ID.P)) {
      p._insertFakeElement(TAG_NAMES.P, TAG_ID.P);
    }
    p._closePElement();
  }
  function liEndTagInBody(p) {
    if (p.openElements.hasInListItemScope(TAG_ID.LI)) {
      p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.LI);
      p.openElements.popUntilTagNamePopped(TAG_ID.LI);
    }
  }
  function ddEndTagInBody(p, token) {
    const tn = token.tagID;
    if (p.openElements.hasInScope(tn)) {
      p.openElements.generateImpliedEndTagsWithExclusion(tn);
      p.openElements.popUntilTagNamePopped(tn);
    }
  }
  function numberedHeaderEndTagInBody(p) {
    if (p.openElements.hasNumberedHeaderInScope()) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilNumberedHeaderPopped();
    }
  }
  function appletEndTagInBody(p, token) {
    const tn = token.tagID;
    if (p.openElements.hasInScope(tn)) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilTagNamePopped(tn);
      p.activeFormattingElements.clearToLastMarker();
    }
  }
  function brEndTagInBody(p) {
    p._reconstructActiveFormattingElements();
    p._insertFakeElement(TAG_NAMES.BR, TAG_ID.BR);
    p.openElements.pop();
    p.framesetOk = false;
  }
  function genericEndTagInBody(p, token) {
    const tn = token.tagName;
    const tid = token.tagID;
    for (let i = p.openElements.stackTop; i > 0; i--) {
      const element = p.openElements.items[i];
      const elementId = p.openElements.tagIDs[i];
      if (tid === elementId && (tid !== TAG_ID.UNKNOWN || p.treeAdapter.getTagName(element) === tn)) {
        p.openElements.generateImpliedEndTagsWithExclusion(tid);
        if (p.openElements.stackTop >= i)
          p.openElements.shortenToLength(i);
        break;
      }
      if (p._isSpecialElement(element, elementId)) {
        break;
      }
    }
  }
  function endTagInBody(p, token) {
    switch (token.tagID) {
      case TAG_ID.A:
      case TAG_ID.B:
      case TAG_ID.I:
      case TAG_ID.S:
      case TAG_ID.U:
      case TAG_ID.EM:
      case TAG_ID.TT:
      case TAG_ID.BIG:
      case TAG_ID.CODE:
      case TAG_ID.FONT:
      case TAG_ID.NOBR:
      case TAG_ID.SMALL:
      case TAG_ID.STRIKE:
      case TAG_ID.STRONG: {
        callAdoptionAgency(p, token);
        break;
      }
      case TAG_ID.P: {
        pEndTagInBody(p);
        break;
      }
      case TAG_ID.DL:
      case TAG_ID.UL:
      case TAG_ID.OL:
      case TAG_ID.DIR:
      case TAG_ID.DIV:
      case TAG_ID.NAV:
      case TAG_ID.PRE:
      case TAG_ID.MAIN:
      case TAG_ID.MENU:
      case TAG_ID.ASIDE:
      case TAG_ID.BUTTON:
      case TAG_ID.CENTER:
      case TAG_ID.FIGURE:
      case TAG_ID.FOOTER:
      case TAG_ID.HEADER:
      case TAG_ID.HGROUP:
      case TAG_ID.DIALOG:
      case TAG_ID.ADDRESS:
      case TAG_ID.ARTICLE:
      case TAG_ID.DETAILS:
      case TAG_ID.SECTION:
      case TAG_ID.SUMMARY:
      case TAG_ID.LISTING:
      case TAG_ID.FIELDSET:
      case TAG_ID.BLOCKQUOTE:
      case TAG_ID.FIGCAPTION: {
        addressEndTagInBody(p, token);
        break;
      }
      case TAG_ID.LI: {
        liEndTagInBody(p);
        break;
      }
      case TAG_ID.DD:
      case TAG_ID.DT: {
        ddEndTagInBody(p, token);
        break;
      }
      case TAG_ID.H1:
      case TAG_ID.H2:
      case TAG_ID.H3:
      case TAG_ID.H4:
      case TAG_ID.H5:
      case TAG_ID.H6: {
        numberedHeaderEndTagInBody(p);
        break;
      }
      case TAG_ID.BR: {
        brEndTagInBody(p);
        break;
      }
      case TAG_ID.BODY: {
        bodyEndTagInBody(p, token);
        break;
      }
      case TAG_ID.HTML: {
        htmlEndTagInBody(p, token);
        break;
      }
      case TAG_ID.FORM: {
        formEndTagInBody(p);
        break;
      }
      case TAG_ID.APPLET:
      case TAG_ID.OBJECT:
      case TAG_ID.MARQUEE: {
        appletEndTagInBody(p, token);
        break;
      }
      case TAG_ID.TEMPLATE: {
        templateEndTagInHead(p, token);
        break;
      }
      default: {
        genericEndTagInBody(p, token);
      }
    }
  }
  function eofInBody(p, token) {
    if (p.tmplInsertionModeStack.length > 0) {
      eofInTemplate(p, token);
    } else {
      stopParsing(p, token);
    }
  }
  function endTagInText(p, token) {
    var _a2;
    if (token.tagID === TAG_ID.SCRIPT) {
      (_a2 = p.scriptHandler) === null || _a2 === void 0 ? void 0 : _a2.call(p, p.openElements.current);
    }
    p.openElements.pop();
    p.insertionMode = p.originalInsertionMode;
  }
  function eofInText(p, token) {
    p._err(token, ERR.eofInElementThatCanContainOnlyText);
    p.openElements.pop();
    p.insertionMode = p.originalInsertionMode;
    p.onEof(token);
  }
  function characterInTable(p, token) {
    if (TABLE_STRUCTURE_TAGS.has(p.openElements.currentTagId)) {
      p.pendingCharacterTokens.length = 0;
      p.hasNonWhitespacePendingCharacterToken = false;
      p.originalInsertionMode = p.insertionMode;
      p.insertionMode = InsertionMode.IN_TABLE_TEXT;
      switch (token.type) {
        case TokenType.CHARACTER: {
          characterInTableText(p, token);
          break;
        }
        case TokenType.WHITESPACE_CHARACTER: {
          whitespaceCharacterInTableText(p, token);
          break;
        }
      }
    } else {
      tokenInTable(p, token);
    }
  }
  function captionStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p.activeFormattingElements.insertMarker();
    p._insertElement(token, NS.HTML);
    p.insertionMode = InsertionMode.IN_CAPTION;
  }
  function colgroupStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertElement(token, NS.HTML);
    p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
  }
  function colStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertFakeElement(TAG_NAMES.COLGROUP, TAG_ID.COLGROUP);
    p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
    startTagInColumnGroup(p, token);
  }
  function tbodyStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertElement(token, NS.HTML);
    p.insertionMode = InsertionMode.IN_TABLE_BODY;
  }
  function tdStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertFakeElement(TAG_NAMES.TBODY, TAG_ID.TBODY);
    p.insertionMode = InsertionMode.IN_TABLE_BODY;
    startTagInTableBody(p, token);
  }
  function tableStartTagInTable(p, token) {
    if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
      p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
      p._resetInsertionMode();
      p._processStartTag(token);
    }
  }
  function inputStartTagInTable(p, token) {
    if (isHiddenInput(token)) {
      p._appendElement(token, NS.HTML);
    } else {
      tokenInTable(p, token);
    }
    token.ackSelfClosing = true;
  }
  function formStartTagInTable(p, token) {
    if (!p.formElement && p.openElements.tmplCount === 0) {
      p._insertElement(token, NS.HTML);
      p.formElement = p.openElements.current;
      p.openElements.pop();
    }
  }
  function startTagInTable(p, token) {
    switch (token.tagID) {
      case TAG_ID.TD:
      case TAG_ID.TH:
      case TAG_ID.TR: {
        tdStartTagInTable(p, token);
        break;
      }
      case TAG_ID.STYLE:
      case TAG_ID.SCRIPT:
      case TAG_ID.TEMPLATE: {
        startTagInHead(p, token);
        break;
      }
      case TAG_ID.COL: {
        colStartTagInTable(p, token);
        break;
      }
      case TAG_ID.FORM: {
        formStartTagInTable(p, token);
        break;
      }
      case TAG_ID.TABLE: {
        tableStartTagInTable(p, token);
        break;
      }
      case TAG_ID.TBODY:
      case TAG_ID.TFOOT:
      case TAG_ID.THEAD: {
        tbodyStartTagInTable(p, token);
        break;
      }
      case TAG_ID.INPUT: {
        inputStartTagInTable(p, token);
        break;
      }
      case TAG_ID.CAPTION: {
        captionStartTagInTable(p, token);
        break;
      }
      case TAG_ID.COLGROUP: {
        colgroupStartTagInTable(p, token);
        break;
      }
      default: {
        tokenInTable(p, token);
      }
    }
  }
  function endTagInTable(p, token) {
    switch (token.tagID) {
      case TAG_ID.TABLE: {
        if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
          p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
          p._resetInsertionMode();
        }
        break;
      }
      case TAG_ID.TEMPLATE: {
        templateEndTagInHead(p, token);
        break;
      }
      case TAG_ID.BODY:
      case TAG_ID.CAPTION:
      case TAG_ID.COL:
      case TAG_ID.COLGROUP:
      case TAG_ID.HTML:
      case TAG_ID.TBODY:
      case TAG_ID.TD:
      case TAG_ID.TFOOT:
      case TAG_ID.TH:
      case TAG_ID.THEAD:
      case TAG_ID.TR: {
        break;
      }
      default: {
        tokenInTable(p, token);
      }
    }
  }
  function tokenInTable(p, token) {
    const savedFosterParentingState = p.fosterParentingEnabled;
    p.fosterParentingEnabled = true;
    modeInBody(p, token);
    p.fosterParentingEnabled = savedFosterParentingState;
  }
  function whitespaceCharacterInTableText(p, token) {
    p.pendingCharacterTokens.push(token);
  }
  function characterInTableText(p, token) {
    p.pendingCharacterTokens.push(token);
    p.hasNonWhitespacePendingCharacterToken = true;
  }
  function tokenInTableText(p, token) {
    let i = 0;
    if (p.hasNonWhitespacePendingCharacterToken) {
      for (; i < p.pendingCharacterTokens.length; i++) {
        tokenInTable(p, p.pendingCharacterTokens[i]);
      }
    } else {
      for (; i < p.pendingCharacterTokens.length; i++) {
        p._insertCharacters(p.pendingCharacterTokens[i]);
      }
    }
    p.insertionMode = p.originalInsertionMode;
    p._processToken(token);
  }
  var TABLE_VOID_ELEMENTS = /* @__PURE__ */ new Set([TAG_ID.CAPTION, TAG_ID.COL, TAG_ID.COLGROUP, TAG_ID.TBODY, TAG_ID.TD, TAG_ID.TFOOT, TAG_ID.TH, TAG_ID.THEAD, TAG_ID.TR]);
  function startTagInCaption(p, token) {
    const tn = token.tagID;
    if (TABLE_VOID_ELEMENTS.has(tn)) {
      if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
        p.activeFormattingElements.clearToLastMarker();
        p.insertionMode = InsertionMode.IN_TABLE;
        startTagInTable(p, token);
      }
    } else {
      startTagInBody(p, token);
    }
  }
  function endTagInCaption(p, token) {
    const tn = token.tagID;
    switch (tn) {
      case TAG_ID.CAPTION:
      case TAG_ID.TABLE: {
        if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
          p.openElements.generateImpliedEndTags();
          p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
          p.activeFormattingElements.clearToLastMarker();
          p.insertionMode = InsertionMode.IN_TABLE;
          if (tn === TAG_ID.TABLE) {
            endTagInTable(p, token);
          }
        }
        break;
      }
      case TAG_ID.BODY:
      case TAG_ID.COL:
      case TAG_ID.COLGROUP:
      case TAG_ID.HTML:
      case TAG_ID.TBODY:
      case TAG_ID.TD:
      case TAG_ID.TFOOT:
      case TAG_ID.TH:
      case TAG_ID.THEAD:
      case TAG_ID.TR: {
        break;
      }
      default: {
        endTagInBody(p, token);
      }
    }
  }
  function startTagInColumnGroup(p, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p, token);
        break;
      }
      case TAG_ID.COL: {
        p._appendElement(token, NS.HTML);
        token.ackSelfClosing = true;
        break;
      }
      case TAG_ID.TEMPLATE: {
        startTagInHead(p, token);
        break;
      }
      default: {
        tokenInColumnGroup(p, token);
      }
    }
  }
  function endTagInColumnGroup(p, token) {
    switch (token.tagID) {
      case TAG_ID.COLGROUP: {
        if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE;
        }
        break;
      }
      case TAG_ID.TEMPLATE: {
        templateEndTagInHead(p, token);
        break;
      }
      case TAG_ID.COL: {
        break;
      }
      default: {
        tokenInColumnGroup(p, token);
      }
    }
  }
  function tokenInColumnGroup(p, token) {
    if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
      p.openElements.pop();
      p.insertionMode = InsertionMode.IN_TABLE;
      p._processToken(token);
    }
  }
  function startTagInTableBody(p, token) {
    switch (token.tagID) {
      case TAG_ID.TR: {
        p.openElements.clearBackToTableBodyContext();
        p._insertElement(token, NS.HTML);
        p.insertionMode = InsertionMode.IN_ROW;
        break;
      }
      case TAG_ID.TH:
      case TAG_ID.TD: {
        p.openElements.clearBackToTableBodyContext();
        p._insertFakeElement(TAG_NAMES.TR, TAG_ID.TR);
        p.insertionMode = InsertionMode.IN_ROW;
        startTagInRow(p, token);
        break;
      }
      case TAG_ID.CAPTION:
      case TAG_ID.COL:
      case TAG_ID.COLGROUP:
      case TAG_ID.TBODY:
      case TAG_ID.TFOOT:
      case TAG_ID.THEAD: {
        if (p.openElements.hasTableBodyContextInTableScope()) {
          p.openElements.clearBackToTableBodyContext();
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE;
          startTagInTable(p, token);
        }
        break;
      }
      default: {
        startTagInTable(p, token);
      }
    }
  }
  function endTagInTableBody(p, token) {
    const tn = token.tagID;
    switch (token.tagID) {
      case TAG_ID.TBODY:
      case TAG_ID.TFOOT:
      case TAG_ID.THEAD: {
        if (p.openElements.hasInTableScope(tn)) {
          p.openElements.clearBackToTableBodyContext();
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE;
        }
        break;
      }
      case TAG_ID.TABLE: {
        if (p.openElements.hasTableBodyContextInTableScope()) {
          p.openElements.clearBackToTableBodyContext();
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE;
          endTagInTable(p, token);
        }
        break;
      }
      case TAG_ID.BODY:
      case TAG_ID.CAPTION:
      case TAG_ID.COL:
      case TAG_ID.COLGROUP:
      case TAG_ID.HTML:
      case TAG_ID.TD:
      case TAG_ID.TH:
      case TAG_ID.TR: {
        break;
      }
      default: {
        endTagInTable(p, token);
      }
    }
  }
  function startTagInRow(p, token) {
    switch (token.tagID) {
      case TAG_ID.TH:
      case TAG_ID.TD: {
        p.openElements.clearBackToTableRowContext();
        p._insertElement(token, NS.HTML);
        p.insertionMode = InsertionMode.IN_CELL;
        p.activeFormattingElements.insertMarker();
        break;
      }
      case TAG_ID.CAPTION:
      case TAG_ID.COL:
      case TAG_ID.COLGROUP:
      case TAG_ID.TBODY:
      case TAG_ID.TFOOT:
      case TAG_ID.THEAD:
      case TAG_ID.TR: {
        if (p.openElements.hasInTableScope(TAG_ID.TR)) {
          p.openElements.clearBackToTableRowContext();
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE_BODY;
          startTagInTableBody(p, token);
        }
        break;
      }
      default: {
        startTagInTable(p, token);
      }
    }
  }
  function endTagInRow(p, token) {
    switch (token.tagID) {
      case TAG_ID.TR: {
        if (p.openElements.hasInTableScope(TAG_ID.TR)) {
          p.openElements.clearBackToTableRowContext();
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE_BODY;
        }
        break;
      }
      case TAG_ID.TABLE: {
        if (p.openElements.hasInTableScope(TAG_ID.TR)) {
          p.openElements.clearBackToTableRowContext();
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE_BODY;
          endTagInTableBody(p, token);
        }
        break;
      }
      case TAG_ID.TBODY:
      case TAG_ID.TFOOT:
      case TAG_ID.THEAD: {
        if (p.openElements.hasInTableScope(token.tagID) || p.openElements.hasInTableScope(TAG_ID.TR)) {
          p.openElements.clearBackToTableRowContext();
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE_BODY;
          endTagInTableBody(p, token);
        }
        break;
      }
      case TAG_ID.BODY:
      case TAG_ID.CAPTION:
      case TAG_ID.COL:
      case TAG_ID.COLGROUP:
      case TAG_ID.HTML:
      case TAG_ID.TD:
      case TAG_ID.TH: {
        break;
      }
      default: {
        endTagInTable(p, token);
      }
    }
  }
  function startTagInCell(p, token) {
    const tn = token.tagID;
    if (TABLE_VOID_ELEMENTS.has(tn)) {
      if (p.openElements.hasInTableScope(TAG_ID.TD) || p.openElements.hasInTableScope(TAG_ID.TH)) {
        p._closeTableCell();
        startTagInRow(p, token);
      }
    } else {
      startTagInBody(p, token);
    }
  }
  function endTagInCell(p, token) {
    const tn = token.tagID;
    switch (tn) {
      case TAG_ID.TD:
      case TAG_ID.TH: {
        if (p.openElements.hasInTableScope(tn)) {
          p.openElements.generateImpliedEndTags();
          p.openElements.popUntilTagNamePopped(tn);
          p.activeFormattingElements.clearToLastMarker();
          p.insertionMode = InsertionMode.IN_ROW;
        }
        break;
      }
      case TAG_ID.TABLE:
      case TAG_ID.TBODY:
      case TAG_ID.TFOOT:
      case TAG_ID.THEAD:
      case TAG_ID.TR: {
        if (p.openElements.hasInTableScope(tn)) {
          p._closeTableCell();
          endTagInRow(p, token);
        }
        break;
      }
      case TAG_ID.BODY:
      case TAG_ID.CAPTION:
      case TAG_ID.COL:
      case TAG_ID.COLGROUP:
      case TAG_ID.HTML: {
        break;
      }
      default: {
        endTagInBody(p, token);
      }
    }
  }
  function startTagInSelect(p, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p, token);
        break;
      }
      case TAG_ID.OPTION: {
        if (p.openElements.currentTagId === TAG_ID.OPTION) {
          p.openElements.pop();
        }
        p._insertElement(token, NS.HTML);
        break;
      }
      case TAG_ID.OPTGROUP: {
        if (p.openElements.currentTagId === TAG_ID.OPTION) {
          p.openElements.pop();
        }
        if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
          p.openElements.pop();
        }
        p._insertElement(token, NS.HTML);
        break;
      }
      case TAG_ID.INPUT:
      case TAG_ID.KEYGEN:
      case TAG_ID.TEXTAREA:
      case TAG_ID.SELECT: {
        if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
          p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
          p._resetInsertionMode();
          if (token.tagID !== TAG_ID.SELECT) {
            p._processStartTag(token);
          }
        }
        break;
      }
      case TAG_ID.SCRIPT:
      case TAG_ID.TEMPLATE: {
        startTagInHead(p, token);
        break;
      }
      default:
    }
  }
  function endTagInSelect(p, token) {
    switch (token.tagID) {
      case TAG_ID.OPTGROUP: {
        if (p.openElements.stackTop > 0 && p.openElements.currentTagId === TAG_ID.OPTION && p.openElements.tagIDs[p.openElements.stackTop - 1] === TAG_ID.OPTGROUP) {
          p.openElements.pop();
        }
        if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
          p.openElements.pop();
        }
        break;
      }
      case TAG_ID.OPTION: {
        if (p.openElements.currentTagId === TAG_ID.OPTION) {
          p.openElements.pop();
        }
        break;
      }
      case TAG_ID.SELECT: {
        if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
          p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
          p._resetInsertionMode();
        }
        break;
      }
      case TAG_ID.TEMPLATE: {
        templateEndTagInHead(p, token);
        break;
      }
      default:
    }
  }
  function startTagInSelectInTable(p, token) {
    const tn = token.tagID;
    if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
      p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
      p._resetInsertionMode();
      p._processStartTag(token);
    } else {
      startTagInSelect(p, token);
    }
  }
  function endTagInSelectInTable(p, token) {
    const tn = token.tagID;
    if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
      if (p.openElements.hasInTableScope(tn)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p._resetInsertionMode();
        p.onEndTag(token);
      }
    } else {
      endTagInSelect(p, token);
    }
  }
  function startTagInTemplate(p, token) {
    switch (token.tagID) {
      case TAG_ID.BASE:
      case TAG_ID.BASEFONT:
      case TAG_ID.BGSOUND:
      case TAG_ID.LINK:
      case TAG_ID.META:
      case TAG_ID.NOFRAMES:
      case TAG_ID.SCRIPT:
      case TAG_ID.STYLE:
      case TAG_ID.TEMPLATE:
      case TAG_ID.TITLE: {
        startTagInHead(p, token);
        break;
      }
      case TAG_ID.CAPTION:
      case TAG_ID.COLGROUP:
      case TAG_ID.TBODY:
      case TAG_ID.TFOOT:
      case TAG_ID.THEAD: {
        p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
        p.insertionMode = InsertionMode.IN_TABLE;
        startTagInTable(p, token);
        break;
      }
      case TAG_ID.COL: {
        p.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
        p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
        startTagInColumnGroup(p, token);
        break;
      }
      case TAG_ID.TR: {
        p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        startTagInTableBody(p, token);
        break;
      }
      case TAG_ID.TD:
      case TAG_ID.TH: {
        p.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
        p.insertionMode = InsertionMode.IN_ROW;
        startTagInRow(p, token);
        break;
      }
      default: {
        p.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
        p.insertionMode = InsertionMode.IN_BODY;
        startTagInBody(p, token);
      }
    }
  }
  function endTagInTemplate(p, token) {
    if (token.tagID === TAG_ID.TEMPLATE) {
      templateEndTagInHead(p, token);
    }
  }
  function eofInTemplate(p, token) {
    if (p.openElements.tmplCount > 0) {
      p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
      p.activeFormattingElements.clearToLastMarker();
      p.tmplInsertionModeStack.shift();
      p._resetInsertionMode();
      p.onEof(token);
    } else {
      stopParsing(p, token);
    }
  }
  function startTagAfterBody(p, token) {
    if (token.tagID === TAG_ID.HTML) {
      startTagInBody(p, token);
    } else {
      tokenAfterBody(p, token);
    }
  }
  function endTagAfterBody(p, token) {
    var _a2;
    if (token.tagID === TAG_ID.HTML) {
      if (!p.fragmentContext) {
        p.insertionMode = InsertionMode.AFTER_AFTER_BODY;
      }
      if (p.options.sourceCodeLocationInfo && p.openElements.tagIDs[0] === TAG_ID.HTML) {
        p._setEndLocation(p.openElements.items[0], token);
        const bodyElement = p.openElements.items[1];
        if (bodyElement && !((_a2 = p.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a2 === void 0 ? void 0 : _a2.endTag)) {
          p._setEndLocation(bodyElement, token);
        }
      }
    } else {
      tokenAfterBody(p, token);
    }
  }
  function tokenAfterBody(p, token) {
    p.insertionMode = InsertionMode.IN_BODY;
    modeInBody(p, token);
  }
  function startTagInFrameset(p, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p, token);
        break;
      }
      case TAG_ID.FRAMESET: {
        p._insertElement(token, NS.HTML);
        break;
      }
      case TAG_ID.FRAME: {
        p._appendElement(token, NS.HTML);
        token.ackSelfClosing = true;
        break;
      }
      case TAG_ID.NOFRAMES: {
        startTagInHead(p, token);
        break;
      }
      default:
    }
  }
  function endTagInFrameset(p, token) {
    if (token.tagID === TAG_ID.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
      p.openElements.pop();
      if (!p.fragmentContext && p.openElements.currentTagId !== TAG_ID.FRAMESET) {
        p.insertionMode = InsertionMode.AFTER_FRAMESET;
      }
    }
  }
  function startTagAfterFrameset(p, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p, token);
        break;
      }
      case TAG_ID.NOFRAMES: {
        startTagInHead(p, token);
        break;
      }
      default:
    }
  }
  function endTagAfterFrameset(p, token) {
    if (token.tagID === TAG_ID.HTML) {
      p.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
    }
  }
  function startTagAfterAfterBody(p, token) {
    if (token.tagID === TAG_ID.HTML) {
      startTagInBody(p, token);
    } else {
      tokenAfterAfterBody(p, token);
    }
  }
  function tokenAfterAfterBody(p, token) {
    p.insertionMode = InsertionMode.IN_BODY;
    modeInBody(p, token);
  }
  function startTagAfterAfterFrameset(p, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p, token);
        break;
      }
      case TAG_ID.NOFRAMES: {
        startTagInHead(p, token);
        break;
      }
      default:
    }
  }
  function nullCharacterInForeignContent(p, token) {
    token.chars = REPLACEMENT_CHARACTER;
    p._insertCharacters(token);
  }
  function characterInForeignContent(p, token) {
    p._insertCharacters(token);
    p.framesetOk = false;
  }
  function popUntilHtmlOrIntegrationPoint(p) {
    while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML && !p._isIntegrationPoint(p.openElements.currentTagId, p.openElements.current)) {
      p.openElements.pop();
    }
  }
  function startTagInForeignContent(p, token) {
    if (causesExit(token)) {
      popUntilHtmlOrIntegrationPoint(p);
      p._startTagOutsideForeignContent(token);
    } else {
      const current = p._getAdjustedCurrentElement();
      const currentNs = p.treeAdapter.getNamespaceURI(current);
      if (currentNs === NS.MATHML) {
        adjustTokenMathMLAttrs(token);
      } else if (currentNs === NS.SVG) {
        adjustTokenSVGTagName(token);
        adjustTokenSVGAttrs(token);
      }
      adjustTokenXMLAttrs(token);
      if (token.selfClosing) {
        p._appendElement(token, currentNs);
      } else {
        p._insertElement(token, currentNs);
      }
      token.ackSelfClosing = true;
    }
  }
  function endTagInForeignContent(p, token) {
    if (token.tagID === TAG_ID.P || token.tagID === TAG_ID.BR) {
      popUntilHtmlOrIntegrationPoint(p);
      p._endTagOutsideForeignContent(token);
      return;
    }
    for (let i = p.openElements.stackTop; i > 0; i--) {
      const element = p.openElements.items[i];
      if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {
        p._endTagOutsideForeignContent(token);
        break;
      }
      const tagName = p.treeAdapter.getTagName(element);
      if (tagName.toLowerCase() === token.tagName) {
        token.tagName = tagName;
        p.openElements.shortenToLength(i);
        break;
      }
    }
  }

  // node_modules/entities/lib/esm/escape.js
  var xmlCodeMap = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  var getCodePoint = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      (c, index) => (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index)
    )
  );
  function getEscaper(regex2, map) {
    return function escape(data) {
      let match;
      let lastIdx = 0;
      let result = "";
      while (match = regex2.exec(data)) {
        if (lastIdx !== match.index) {
          result += data.substring(lastIdx, match.index);
        }
        result += map.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result + data.substring(lastIdx);
    };
  }
  var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));

  // node_modules/parse5/dist/serializer/index.js
  var VOID_ELEMENTS = /* @__PURE__ */ new Set([
    TAG_NAMES.AREA,
    TAG_NAMES.BASE,
    TAG_NAMES.BASEFONT,
    TAG_NAMES.BGSOUND,
    TAG_NAMES.BR,
    TAG_NAMES.COL,
    TAG_NAMES.EMBED,
    TAG_NAMES.FRAME,
    TAG_NAMES.HR,
    TAG_NAMES.IMG,
    TAG_NAMES.INPUT,
    TAG_NAMES.KEYGEN,
    TAG_NAMES.LINK,
    TAG_NAMES.META,
    TAG_NAMES.PARAM,
    TAG_NAMES.SOURCE,
    TAG_NAMES.TRACK,
    TAG_NAMES.WBR
  ]);

  // node_modules/parse5/dist/index.js
  function parseFragment(fragmentContext, html2, options2) {
    if (typeof fragmentContext === "string") {
      options2 = html2;
      html2 = fragmentContext;
      fragmentContext = null;
    }
    const parser = Parser.getFragmentParser(fragmentContext, options2);
    parser.tokenizer.write(html2, true);
    return parser.getFragment();
  }

  // content/text.ts
  var import_langmap = __toESM(require_langmap());
  var LanguagePrefixes = Object.keys(import_langmap.default).sort().reverse().filter((prefix) => prefix.length > 3);
  var charCategories = require_categories();
  var scripts = require_scripts();
  var re = {
    Nl: charCategories.find((cat) => cat.alias === "Letter_Number").bmp,
    Nd: charCategories.find((cat) => cat.alias === "Decimal_Number").bmp,
    Mn: charCategories.find((cat) => cat.alias === "Nonspacing_Mark").bmp,
    Mc: charCategories.find((cat) => cat.alias === "Spacing_Mark").bmp,
    Lu: charCategories.find((cat) => cat.alias === "Uppercase_Letter").bmp,
    Lt: charCategories.find((cat) => cat.alias === "Titlecase_Letter").bmp,
    Ll: charCategories.find((cat) => cat.alias === "Lowercase_Letter").bmp,
    Lm: charCategories.find((cat) => cat.alias === "Modifier_Letter").bmp,
    Lo: charCategories.find((cat) => cat.alias === "Other_Letter").bmp,
    // punctuation
    P: /\.\u002D\u2000-\u206F\u2E00-\u2E7F\\'!"#\$%&\(\)\*\+,\/:;<=>\?@\[\]^_`{\|}~/.source,
    // P: charCategories.find(cat => cat.alias === 'Punctuation').bmp,
    Whitespace: / \t\n\r\u00A0/.source,
    // calculated below
    lcChar: null,
    char: null,
    L: null,
    protectedWord: null,
    leadingUnprotectedWord: null,
    protectedWords: null,
    unprotectedWord: null,
    url: null,
    whitespace: null,
    sentenceEnd: /^[:?]/
  };
  re.lcChar = re.Ll + re.Lt + re.Lm + re.Lo + re.Mn + re.Mc + re.Nd + re.Nl;
  re.char = re.Lu + re.lcChar;
  re.L = `${re.Lu}${re.Ll}${re.Lt}${re.Lm}${re.Lo}`;
  re.protectedWord = `[${re.lcChar}]*[${re.Lu}][-${re.char}]*`;
  re.leadingUnprotectedWord = new RegExp(`^([${re.Lu}][${re.lcChar}]*)[${re.Whitespace}${re.P}]`);
  re.protectedWords = new RegExp(`^(${re.protectedWord})(([${re.Whitespace}])(${re.protectedWord}))*`);
  re.unprotectedWord = new RegExp(`^[${re.char}]+`);
  re.url = /^(https?|mailto):\/\/[^\s]+/;
  re.whitespace = new RegExp(`^[${re.Whitespace}]+`);
  var ligatures = {
    // '\u01F1': 'DZ',
    // '\u01F2': 'Dz',
    "\u01F3": "dz",
    // '\u01C4': 'D\u017D',
    // '\u01C5': 'D\u017E',
    // '\u01C6': 'd\u017E',
    "\uFB00": "ff",
    "\uFB01": "fi",
    "\uFB02": "fl",
    "\uFB03": "ffi",
    "\uFB04": "ffl",
    // '\uFB05': '\u017Ft',
    "\uFB06": "st",
    // '\u0132': 'IJ',
    "\u0133": "ij",
    // '\u01C7': 'LJ',
    // '\u01C8': 'Lj',
    "\u01C9": "lj",
    // '\u01CA': 'NJ',
    // '\u01CB': 'Nj',
    "\u01CC": "nj"
  };
  var titleCaseKeep = new RegExp(`(?:(?:[>:?]?[${re.Whitespace}]+)[${re.L}][${re.P}]?(?:[${re.Whitespace}]|$))|(?:(?:<span class="nocase">.*?</span>)|(?:<nc>.*?</nc>))`, "gi");
  var singleLetter = new RegExp(`^([>:?])?[${re.Whitespace}]+(.)`);
  function titleCase(text) {
    let titlecased = titleCased(text);
    text.replace(titleCaseKeep, (match, offset) => {
      if (match[0] !== "<") {
        const [, punc, l] = match.match(singleLetter);
        if (punc && (l === "a" || l === "A")) {
          match = match.toUpperCase();
        }
      }
      titlecased = titlecased.substr(0, offset) + match + titlecased.substr(offset + match.length);
      return match;
    });
    return titlecased;
  }
  var HTMLParser = new class {
    constructor() {
      this.spuriousNode = /* @__PURE__ */ new Set(["#document-fragment", "#document", "div", "span"]);
      this.ligatures = new RegExp(`[${Object.keys(ligatures).join("")}]`, "g");
    }
    parse(html2, options2) {
      this.html = html2;
      let doc;
      this.options = { ...options2, exportBraceProtection: options2.caseConversion && options2.exportBraceProtection };
      this.sentenceStart = true;
      const csquotes = this.options.csquotes;
      if (csquotes) {
        const space = "\\s*";
        for (const close of [0, 1]) {
          const chars = csquotes.replace(/./g, (c, i) => [c, ""][i + close & 1]).replace(/[-[\]/{}()*+?.\\^$|]\s*/g, "\\$&");
          this.html = this.html.replace(new RegExp(`${close ? space : ""}[${chars}]${close ? "" : space}`, "g"), close ? "</span>" : '<span class="enquote">');
        }
      }
      if (!this.options.html) {
        this.html = this.html.replace(/&/g, "&amp;");
        this.html = this.html.replace(/<(\/?)([^<>]*)>/g, (match, close, body) => {
          if (body.match(/^(emphasis|span|nc|sc|i|b|sup|sub|script)($|\n|\s)/i)) return match;
          if (body.match(/^pre$/i)) return `<${close || ""}script>`;
          return match.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        });
      }
      doc = this.walk(parseFragment(this.html, { sourceCodeLocationInfo: true }));
      if (this.options.caseConversion) {
        if (this.options.exportTitleCase) {
          this.titleCased = "";
          this.collectText(doc);
          this.titleCased = titleCase(this.titleCased);
          this.titleCase(doc);
        }
        const unwrapped = this.unwrapNocase(doc);
        if (unwrapped.length === 1) {
          doc = unwrapped[0];
        } else {
          doc = { nodeName: "span", attr: {}, class: {}, childNodes: unwrapped };
        }
        this.cleanupNocase(doc);
      }
      doc = this.unwrapSpurious(doc);
      doc.source = this.html;
      return doc;
    }
    titleCase(node) {
      if (node.nodeName === "#text") {
        node.value = this.titleCased.substr(node.titleCased, node.value.length);
        return;
      }
      for (const child of node.childNodes) {
        if (child.nocase || child.nodeName === "sup" || child.nodeName === "sub") continue;
        this.titleCase(child);
      }
    }
    unwrapSpurious(node) {
      if (node.nodeName === "#text") return node;
      node.childNodes = node.childNodes.map((child) => this.unwrapSpurious(child));
      while (this.spuriousNode.has(node.nodeName) && Object.keys(node.attr).length === 0 && !node.nocase && node.childNodes.length === 1) node = node.childNodes[0];
      return node;
    }
    // BibLaTeX is beyond insane https://github.com/retorquere/zotero-better-bibtex/issues/541#issuecomment-240999396
    unwrapNocase(node) {
      if (node.nodeName === "#text") return [node];
      node.childNodes = [].concat(...node.childNodes.map((child) => this.unwrapNocase(child)));
      if (node.nocase || !node.childNodes.find((child) => child.nocase)) return [node];
      return node.childNodes.map((child) => {
        if (child.nocase) {
          return {
            ...child,
            childNodes: [{ ...node, childNodes: child.childNodes }]
          };
        }
        return {
          ...node,
          childNodes: [child]
        };
      });
    }
    cleanupNocase(node, nocased = false) {
      if (node.nodeName === "#text") return null;
      if (nocased) delete node.nocase;
      for (const child of node.childNodes) {
        this.cleanupNocase(child, node.nocase || nocased);
      }
    }
    collectText(node) {
      switch (node.nodeName) {
        case "#text":
          node.titleCased = this.titleCased.length;
          this.titleCased += node.value;
          break;
        case "script":
          this.titleCased += "".padStart(node.value.length, "latex");
          break;
        default:
          for (const child of node.childNodes) {
            this.collectText(child);
          }
      }
    }
    plaintext(childNodes, text, offset) {
      text = text.replace(this.ligatures, (ligature) => ligatures[ligature]);
      const l = childNodes.length;
      if (l === 0 || childNodes[l - 1].nodeName !== "#text") {
        childNodes.push({ nodeName: "#text", offset, value: text, attr: {}, class: {} });
      } else {
        childNodes[l - 1].value += text;
      }
    }
    nocase(childNodes, text, offset) {
      childNodes.push({
        nodeName: "span",
        nocase: true,
        attr: {},
        class: {},
        childNodes: [{
          nodeName: "#text",
          offset,
          value: text,
          attr: {},
          class: {}
        }]
      });
    }
    walk(node, isNocased = false) {
      var _a2;
      const normalized_node = { nodeName: node.nodeName, childNodes: [], attr: {}, class: {} };
      for (const { name, value } of node.attrs || []) {
        normalized_node.attr[name] = value;
      }
      for (const cls of (normalized_node.attr.class || "").trim().split(/\s+/)) {
        if (cls) normalized_node.class[cls] = true;
      }
      switch ((_a2 = node.type) == null ? void 0 : _a2.toLowerCase()) {
        case "smallcaps":
          normalized_node.attr.smallcaps = "smallcaps";
          break;
      }
      if (node.type) normalized_node.class[node.type] = true;
      switch (node.nodeName) {
        case "#document":
        case "#document-fragment":
        case "pre":
          normalized_node.nodeName = "span";
          break;
        case "nc":
          normalized_node.nodeName = "span";
          normalized_node.attr.nocase = "nocase";
          break;
        case "emphasis":
          normalized_node.nodeName = "i";
          break;
        case "sc":
          normalized_node.nodeName = "span";
          normalized_node.attr.smallcaps = "smallcaps";
          break;
      }
      if (normalized_node.attr.nocase || normalized_node.class.nocase) normalized_node.nocase = !isNocased;
      if (normalized_node.attr.relax || normalized_node.class.relax) normalized_node.relax = true;
      if (normalized_node.class.enquote || normalized_node.attr.enquote) normalized_node.enquote = true;
      if (!normalized_node.attr.smallcaps && (normalized_node.attr.style || "").match(/small-caps/i)) normalized_node.attr.smallcaps = "smallcaps";
      if (normalized_node.class.smallcaps || normalized_node.attr.smallcaps) normalized_node.smallcaps = true;
      if (normalized_node.nodeName === "script") {
        if (!node.childNodes || node.childNodes.length === 0) {
          normalized_node.value = "";
          normalized_node.childNodes = [];
        } else if (node.childNodes.length === 1 && node.childNodes[0].nodeName === "#text") {
          normalized_node.value = node.childNodes[0].value;
          normalized_node.childNodes = [];
        } else {
          throw new Error(`Unexpected script body ${JSON.stringify(node)}`);
        }
      } else if (node.childNodes) {
        let m;
        for (const child of node.childNodes) {
          if (child.nodeName !== "#text") {
            normalized_node.childNodes.push(this.walk(child, isNocased || normalized_node.nocase));
            continue;
          }
          if (!this.options.caseConversion || isNocased) {
            this.plaintext(normalized_node.childNodes, child.value, child.sourceCodeLocation.startOffset);
            continue;
          }
          let text = child.value;
          const length = text.length;
          while (text) {
            if (m = re.whitespace.exec(text)) {
              this.plaintext(normalized_node.childNodes, m[0], child.sourceCodeLocation.startOffset + (length - text.length));
              text = text.substring(m[0].length);
              continue;
            }
            if (m = re.sentenceEnd.exec(text)) {
              this.plaintext(normalized_node.childNodes, m[0], child.sourceCodeLocation.startOffset + (length - text.length));
              text = text.substring(m[0].length);
              continue;
            }
            if (this.sentenceStart && (m = re.leadingUnprotectedWord.exec(`${text} `))) {
              this.sentenceStart = false;
              this.plaintext(normalized_node.childNodes, m[1], child.sourceCodeLocation.startOffset + (length - text.length));
              text = text.substring(m[1].length);
              continue;
            }
            this.sentenceStart = false;
            if (!isNocased && this.options.exportBraceProtection && (m = re.protectedWords.exec(text))) {
              this.nocase(normalized_node.childNodes, m[0], child.sourceCodeLocation.startOffset + (length - text.length));
              text = text.substring(m[0].length);
            } else if (m = re.url.exec(text)) {
              this.nocase(normalized_node.childNodes, m[0], child.sourceCodeLocation.startOffset + (length - text.length));
              text = text.substring(m[0].length);
            } else if (m = re.unprotectedWord.exec(text)) {
              this.plaintext(normalized_node.childNodes, m[0], child.sourceCodeLocation.startOffset + (length - text.length));
              text = text.substring(m[0].length);
            } else {
              this.plaintext(normalized_node.childNodes, text[0], child.sourceCodeLocation.startOffset + (length - text.length));
              text = text.substring(1);
            }
          }
        }
      }
      return normalized_node;
    }
  }();
  var notAlphaNum = new RegExp(`[^${re.L}${re.Nd}${re.Nl}]`);
  var CJK = new RegExp(`([${scripts.map((s) => {
    switch (s.name) {
      case "Katakana":
      case "Hiragana":
      case "Han":
        return s.bmp;
      default:
        return "";
    }
  }).join("")}])`, "g");
  function asciify(str) {
    return str.replace(/[\u007F-\uFFFF]/g, (chr) => `\\u${`0000${chr.charCodeAt(0).toString(16)}`.substr(-4)}`);
  }

  // content/stringify.ts
  function stringifyXPCOM(obj) {
    if (!obj.QueryInterface) return "";
    if (obj.message) return `[XPCOM error ${obj.message}]`;
    if (obj.name) return `[XPCOM object ${obj.name}]`;
    return "[XPCOM object]";
  }
  function stringifyError(obj) {
    if (obj instanceof Error) return `[error: ${obj.message || "<unspecified error>"}
${obj.stack}]`;
    if (obj.error instanceof Error && obj.message) return `[errorevent: ${obj.message} ${stringifyError(obj.error)}]`;
    if (typeof ErrorEvent !== "undefined" && obj instanceof ErrorEvent) return `[errorevent: ${obj.message || "<unspecified errorevent>"}]`;
    return "";
  }
  function $stringify(key, value, cache) {
    switch (typeof value) {
      case "number":
      case "string":
      case "boolean":
      case "undefined":
        return value;
      case "function":
        return `[function ${key}]`;
    }
    if (value === null) return value;
    if (value.openDialog || value.querySelector) return value.toString();
    if (cache.includes(value)) return "[circular]";
    let replacement;
    if (value instanceof RegExp) {
      value = value.source;
    } else if (replacement = stringifyXPCOM(value)) {
      value = replacement;
    } else if (replacement = stringifyError(value)) {
      value = replacement;
    } else {
      replacement = "";
    }
    if (!replacement) cache.push(value);
    return replacement || value;
  }
  function stringify(obj, indent = 0, ucode) {
    let cache = [];
    const stringified = JSON.stringify(
      obj,
      (key, value) => {
        try {
          return $stringify(key, value, cache);
        } catch (err) {
          return `[stringify error: ${err}
${err.stack}]`;
        }
      },
      indent
    );
    cache = null;
    return ucode ? asciify(stringified) : stringified;
  }

  // content/logger.ts
  function print(msg) {
    dump(`better-bibtex::${msg}
`);
  }
  function toString(obj) {
    try {
      if (typeof obj === "string") return obj;
      return stringify(obj, 0);
    } catch (err) {
      return stringify(err, 0);
    }
  }
  var Logger = class {
    constructor() {
      this.prefix = "";
    }
    format({ error = false }, msg) {
      let diff = null;
      const now = Date.now();
      if (this.timestamp) diff = now - this.timestamp;
      this.timestamp = now;
      if (Array.isArray(msg)) msg = msg.map(toString).join(" ");
      let prefix = "";
      if (typeof workerEnvironment !== "undefined") {
        prefix += " worker";
        if (typeof workerJob !== "undefined") prefix += `:${workerJob.translator}`;
      }
      if (error) prefix += " error:";
      return `{better-bibtex${this.prefix}${prefix}} +${diff} ${asciify(msg)}`;
    }
    get enabled() {
      var _a2, _b;
      return typeof workerJob !== "undefined" && workerJob.debugEnabled || !Zotero || ((_a2 = Zotero.Debug) == null ? void 0 : _a2.enabled) || ((_b = Zotero.Prefs) == null ? void 0 : _b.get("debug.store"));
    }
    print(msg) {
      if (!this.enabled) return;
      if (typeof Zotero !== "undefined") {
        Zotero.debug(msg);
      } else {
        print(msg);
      }
    }
    log(...msg) {
      this.print(this.format({}, msg));
    }
    debug(...msg) {
      this.print(this.format({}, msg));
    }
    warn(...msg) {
      this.print(this.format({}, msg));
    }
    info(...msg) {
      this.print(this.format({}, msg));
    }
    error(...msg) {
      this.print(this.format({ error: true }, msg));
    }
    dump(...msg) {
      if (this.enabled) print(this.format({}, msg));
    }
    status({ error = false }, ...msg) {
      if (error || this.enabled) Zotero.debug(this.format({ error }, msg));
    }
  };
  var log = new Logger();

  // content/extra.ts
  var mapping = __toESM(require_extra_fields());
  var CSL2 = __toESM(require_citeproc_commonjs());
  var re2 = {
    // fetch fields as per https://forums.zotero.org/discussion/3673/2/original-date-of-publication/. Spurious 'tex.' so I can do a single match
    old: /^{:((?:bib(?:la)?)?tex\.)?([^:]+)(:)\s*([^}]+)}$/i,
    new: /^((?:bib(?:la)?)?tex\.)?([^:=]+)\s*([:=])\s*([\S\s]*)/i,
    quoted: /^((?:bib(?:la)?)?tex\.)"([^"]+)"\s*([:=])\s*([\S\s]*)/i
  };
  var otherFields = ["lccn", "mr", "zbl", "arxiv", "jstor", "hdl", "googlebooksid"];
  function get(extra, mode, options2) {
    let defaults2 = false;
    if (!options2) {
      options2 = { citationKey: true, aliases: true, kv: true, tex: true };
      defaults2 = true;
    }
    const other = { zotero: "csl", csl: "zotero" }[mode];
    extra = extra || "";
    const extraFields = {
      kv: options2.kv || defaults2 ? {} : void 0,
      creator: {},
      creators: [],
      tex: options2.tex || defaults2 ? {} : void 0,
      citationKey: "",
      aliases: options2.aliases || defaults2 ? [] : void 0
    };
    let ef;
    extra = extra.split("\n").filter((line, i) => {
      const m = line.match(re2.old) || line.match(re2.quoted) || line.match(re2.new);
      if (!m) return true;
      let [, tex, key, assign, value] = m;
      const texmode = assign === "=" ? "raw" : tex && (tex.includes("T") || tex.match(/^[A-Z]/)) ? "cased" : void 0;
      tex = tex && tex.toLowerCase();
      if (!tex && texmode) return true;
      if (tex) {
        key = key.trim().toLowerCase();
      } else {
        key = key.trim().replace(/(?!^)[-_]/g, " ").replace(/([a-z])([A-Z])/g, "$1 $2").toLowerCase();
      }
      value = value.trim();
      if (options2.citationKey && !tex && ["citation key", "bibtex"].includes(key)) {
        extraFields.citationKey = value;
        return false;
      }
      if (options2.aliases && !tex && key === "citation key alias") {
        extraFields.aliases = [...extraFields.aliases, ...value.split(/s*,\s*/).filter((alias) => alias)];
        return false;
      }
      if (options2.aliases && tex && key === "ids") {
        extraFields.aliases = [...extraFields.aliases, ...value.split(/s*,\s*/).filter((alias) => alias)];
        return false;
      }
      if (options2.kv && key === "_eprint") {
        extraFields.kv[key] = value;
        return false;
      }
      if (options2.kv && key !== "citation key" && (ef = mapping[key]) && !tex) {
        for (const field of ef[mode] || ef[other]) {
          switch (ef.type) {
            case "name":
              extraFields.creator[field] = extraFields.creator[field] || [];
              extraFields.creator[field].push(value);
              extraFields.creators.push({ name: value, type: field });
              break;
            case "text":
            case "date":
              extraFields.kv[field] = value;
              break;
            default:
              throw new Error(`Unexpected extra field type ${ef.type}`);
          }
        }
        return false;
      }
      if (options2.tex && tex && !key.includes(" ")) {
        extraFields.tex[tex + key] = { value, mode: texmode, line: i };
        return false;
      }
      if (options2.tex && !tex && otherFields.includes(key.replace(/[- ]/g, ""))) {
        extraFields.tex[`tex.${key.replace(/[- ]/g, "")}`] = { value, line: i };
        return false;
      }
      return true;
    }).join("\n").trim();
    extraFields.aliases = Array.from(new Set(extraFields.aliases)).filter((key) => key !== extraFields.citationKey);
    return { extra, extraFields };
  }

  // translators/Collected notes.ts
  function clean(item) {
    switch (item.itemType) {
      case "note":
      case "annotation":
      case "attachment":
        return item;
    }
    const cleaned = { ...item, extra: get(item.extra, "zotero").extra };
    cleaned.extra = cleaned.extra.split("\n").filter((line) => !line.match(/^OCLC:/i)).join("\n");
    return cleaned;
  }
  function sorted(collections) {
    return collections.sort((a, b) => a.name.localeCompare(b.name, void 0, { sensitivity: "base" }));
  }
  var Exporter = class {
    constructor(translation) {
      this.levels = 0;
      this.body = "";
      this.html = "";
      this.markdown = "";
      this.translation = translation;
      const items = {};
      const filed = /* @__PURE__ */ new Set();
      const collections = {};
      for (const item of this.translation.input.items) {
        const cleaned = clean(item);
        if (this.keep(cleaned)) items[item.itemID] = cleaned;
      }
      for (const [key, collection] of Object.entries(this.translation.collections)) {
        for (const itemID of collection.items) filed.add(itemID);
        collections[key] = {
          name: collection.name,
          // resolve item IDs to items
          items: (collection.items || []).map((itemID) => items[itemID]).filter((item) => item),
          // resolve collection IDs to collections
          collections: [],
          root: !this.translation.collections[collection.parent]
        };
      }
      for (const [key, collection] of Object.entries(this.translation.collections)) {
        collections[key].collections = (collection.collections || []).map((coll) => collections[coll]).filter((coll) => coll);
      }
      const unfiled = { name: "Unfiled", items: Object.values(items).filter((item) => !filed.has(item.itemID)), collections: [], root: true };
      if (!this.prune(unfiled)) this.write_collection(unfiled);
      for (const collection of sorted(Object.values(collections))) {
        if (collection.root && !this.prune(collection)) this.write_collection(collection);
      }
      let style = "\n  body {\n    counter-reset: h1;\n  }\n\n";
      for (let level = 1; level <= this.levels; level++) {
        if (level !== this.levels) style += `  h${level} {
    counter-reset: h${level + 1};
  }
`;
        style += `  h${level}:before {
`;
        const label = Array.from({ length: level }, (_x, i) => `counter(h${i + 1}, decimal)`).join(' "." ');
        style += `    content: ${label} ".\\0000a0\\0000a0";
`;
        style += `    counter-increment: h${level};
`;
        style += "  }\n\n";
      }
      style += "  blockquote { border-left: 1px solid gray; }\n";
      this.html = `<html><head><style>${style}</style></head><body>${this.body}</body></html>`;
      if (this.translation.options.markdown) this.markdown = (0, import_html_to_md.default)(this.html);
    }
    show(context, args) {
      log.debug(`collectednotes.${context}: ${JSON.stringify(Array.from(args))}`);
    }
    write_collection(collection, level = 1) {
      this.levels = Math.max(this.levels, level);
      this.body += `<h${level}>${html(collection.name)}</h${level}>
`;
      for (const item of collection.items) {
        this.write_item(item);
      }
      for (const coll of sorted(collection.collections)) {
        this.write_collection(coll, level + 1);
      }
    }
    write_item(item) {
      switch (item.itemType) {
        case "note":
          this.note(item.note, "note");
          break;
        case "attachment":
          this.item(item);
          break;
        default:
          this.item(item);
          break;
      }
    }
    prune(collection) {
      if (!collection) return true;
      collection.collections = collection.collections.filter((sub) => !this.prune(sub));
      return !collection.items.length && !collection.collections.length;
    }
    note(note, type) {
      switch (type) {
        case "extra":
          if (!note) return;
          this.body += `<blockquote><pre>${html(note)}</pre></blockquote>
`;
          break;
        case "attachment":
          if (!note.note) return;
          this.body += `<blockquote><div><samp>${note.title}</samp></div>${note.note}</blockquote>
`;
          break;
        default:
          if (!note.note) return;
          this.body += `<blockquote>${note.note}</blockquote>
`;
          break;
      }
    }
    creator(cr) {
      return [cr.lastName, cr.name, cr.firstName].find((v) => v) || "";
    }
    creators(cr) {
      switch (cr.length) {
        case 0:
        case 1:
          return cr[0];
        case 2:
          return cr.join(" and ");
        default:
          return `${cr.slice(0, cr.length - 1).join(", ")}, and ${cr[cr.length - 1]}`;
      }
    }
    item(item) {
      let notes = [];
      let title = "";
      if (item.itemType === "attachment") {
        if (item.note) notes = [{ note: item.note }];
        if (item.title) title = `<samp>${html(item.title)}</samp>`;
      } else {
        notes = (item.notes || []).filter((note) => note.note);
        const creators = this.creators(item.creators.map((creator) => this.creator(creator)).filter((v) => v));
        let date = null;
        if (item.date) {
          date = Zotero.BetterBibTeX.parseDate(item.date);
          if (date.from) date = date.from;
          date = typeof date.year === "number" ? date.year : item.date;
        }
        const author = [creators, date].filter((v) => v).join(", ");
        if (item.title) title += `<i>${html(item.title)}</i>`;
        if (author) title += ` (${html(author)})`;
        title = title.trim();
      }
      this.body += `<div>${title}</div>
`;
      this.note(item.extra, "extra");
      for (const note of notes) {
        this.note(note, "note");
      }
      for (const att of item.attachments || []) {
        this.note(att, "attachment");
      }
    }
    keep(item) {
      var _a2, _b, _c;
      if (!item) return false;
      switch (item.itemType) {
        case "note":
        case "annotation":
          return item.note;
        case "attachment":
          return (_a2 = item.notes) == null ? void 0 : _a2.find((note) => note.note);
        default:
          return item.extra || ((_b = item.notes) == null ? void 0 : _b.find((note) => note.note)) || ((_c = item.attachments) == null ? void 0 : _c.find((att) => att.note));
      }
    }
  };
  function doExport() {
    const translation = Translation.Export(ZOTERO_TRANSLATOR_INFO, collect());
    const exporter = new Exporter(translation);
    translation.output.body += exporter[translation.options.markdown ? "markdown" : "html"];
    Zotero.write(translation.output.body);
    translation.erase();
  }
  return __toCommonJS(Collected_notes_exports);
})();
/*! Bundled license information:

@stdlib/utils-define-property/lib/define_property.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2021 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/utils-define-property/lib/has_define_property_support.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2021 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/utils-define-property/lib/builtin.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/string-base-format-interpolate/lib/is_number.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2022 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/string-base-format-interpolate/lib/zero_pad.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2022 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/string-base-format-interpolate/lib/format_integer.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2022 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/string-base-format-interpolate/lib/is_string.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2022 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/string-base-format-interpolate/lib/format_double.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2022 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/string-base-format-interpolate/lib/space_pad.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2022 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/string-base-format-interpolate/lib/main.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2022 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/string-base-format-interpolate/lib/index.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2022 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/string-base-format-tokenize/lib/main.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2022 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/string-base-format-tokenize/lib/index.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2022 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/string-format/lib/is_string.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2022 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/string-format/lib/main.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2022 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/string-format/lib/index.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2022 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/utils-define-property/lib/polyfill.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/utils-define-property/lib/index.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/utils-define-nonenumerable-read-only-property/lib/main.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/utils-define-nonenumerable-read-only-property/lib/index.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/assert-is-string/lib/primitive.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/assert-has-symbol-support/lib/main.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/assert-has-symbol-support/lib/index.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/assert-has-tostringtag-support/lib/main.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/assert-has-tostringtag-support/lib/index.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/utils-native-class/lib/tostring.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/utils-native-class/lib/main.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/assert-has-own-property/lib/main.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/assert-has-own-property/lib/index.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/symbol-ctor/lib/main.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/symbol-ctor/lib/index.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/utils-native-class/lib/tostringtag.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/utils-native-class/lib/polyfill.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/utils-native-class/lib/index.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/assert-is-string/lib/valueof.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/assert-is-string/lib/try2valueof.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/assert-is-string/lib/object.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/assert-is-string/lib/main.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/assert-is-string/lib/index.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/utils-escape-regexp-string/lib/main.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)

@stdlib/utils-escape-regexp-string/lib/index.js:
  (**
  * @license Apache-2.0
  *
  * Copyright (c) 2018 The Stdlib Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)
*/
